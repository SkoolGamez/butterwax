// -------------------------------------------------------
//     ____        __  __
//    / __ )__  __/ /_/ /____  _________ ___  ____ __  __
//   / __  / / / / __/ __/ _  / ___/ __ `__  / __ `/ |/_/
//  / /_/ / /_/ / /_/ /_/  __/ /  / / / / / / /_/ />  <
// /_____/ __,_/ __/ __/ ___/_/  /_/ /_/ /_/ __,_/_/|_|
// https://buttermax.net
//
// -------------------------------------------------------
//   12/14/23 5:31a
// -------------------------------------------------------
"undefined" == typeof console &&
  ((window.console = {}),
  (console.log =
    console.error =
    console.info =
    console.debug =
    console.warn =
    console.trace =
      function () {})),
  (window.performance =
    window.performance && window.performance.now ? window.performance : Date),
  (Date.now =
    Date.now ||
    function () {
      return +new Date();
    }),
  window.requestAnimationFrame ||
    (window.requestAnimationFrame =
      window.webkitRequestAnimationFrame ||
      window.mozRequestAnimationFrame ||
      window.oRequestAnimationFrame ||
      window.msRequestAnimationFrame ||
      (function () {
        const start = Date.now();
        return function (callback) {
          window.setTimeout(() => callback(Date.now() - start), 1e3 / 60);
        };
      })()),
  (window.defer = window.requestAnimationFrame),
  (window.clearTimeout = (function () {
    const _clearTimeout = window.clearTimeout;
    return function (ref) {
      return (window.Timer && Timer.__clearTimeout(ref)) || _clearTimeout(ref);
    };
  })()),
  (window.requestIdleCallback = (function () {
    const _requestIdleCallback = window.requestIdleCallback;
    return function (callback, max) {
      return _requestIdleCallback
        ? _requestIdleCallback(callback, max ? { timeout: max } : null)
        : defer(() => {
            callback({ didTimeout: !1 });
          }, 0);
    };
  })()),
  (window.onIdle = window.requestIdleCallback),
  "undefined" == typeof Float32Array && (Float32Array = Array),
  (Math.sign = function (x) {
    return 0 === (x = +x) || isNaN(x) ? Number(x) : x > 0 ? 1 : -1;
  }),
  (Math._round = Math.round),
  (Math.round = function (value, precision = 0) {
    let p = Math.pow(10, precision);
    return Math._round(value * p) / p;
  }),
  (Math._random = Math.random),
  (Math.rand = Math.random =
    function (min, max, precision = 0) {
      return void 0 === min
        ? Math._random()
        : min === max
        ? min
        : ((min = min || 0),
          (max = max || 1),
          0 == precision
            ? Math.floor(Math._random() * (max + 1 - min) + min)
            : Math.round(min + Math._random() * (max - min), precision));
    }),
  (Math.degrees = function (radians) {
    return radians * (180 / Math.PI);
  }),
  (Math.radians = function (degrees) {
    return degrees * (Math.PI / 180);
  }),
  (Math.clamp = function (value, min = 0, max = 1) {
    return Math.min(Math.max(value, Math.min(min, max)), Math.max(min, max));
  }),
  (Math.map = Math.range =
    function (value, oldMin = -1, oldMax = 1, newMin = 0, newMax = 1, isClamp) {
      const newValue =
        ((value - oldMin) * (newMax - newMin)) / (oldMax - oldMin) + newMin;
      return isClamp
        ? Math.clamp(
            newValue,
            Math.min(newMin, newMax),
            Math.max(newMin, newMax)
          )
        : newValue;
    }),
  (Math.mix = function (a, b, alpha) {
    return a * (1 - alpha) + b * alpha;
  }),
  (Math.step = function (edge, value) {
    return value < edge ? 0 : 1;
  }),
  (Math.smoothStep = function (min, max, value) {
    const x = Math.max(0, Math.min(1, (value - min) / (max - min)));
    return x * x * (3 - 2 * x);
  }),
  (Math.fract = function (value) {
    return value - Math.floor(value);
  }),
  (Math.lerp = function (target, value, alpha, calcHz = !0) {
    return (
      value +
      (target - value) *
        (alpha = calcHz
          ? Math.framerateNormalizeLerpAlpha(alpha)
          : Math.clamp(alpha))
    );
  });
{
  const mainThread = !!window.document;
  Math.framerateNormalizeLerpAlpha = function (t) {
    return (
      (t = Math.clamp(t)),
      mainThread
        ? 1 - Math.exp(Math.log(1 - t) * Render.FRAME_HZ_MULTIPLIER)
        : t
    );
  };
}
(Math.mod = function (value, n) {
  return ((value % n) + n) % n;
}),
  Object.defineProperty(Array.prototype, "shuffle", {
    writable: !0,
    value() {
      let randomIndex,
        currentIndex = this.length;
      for (; 0 != currentIndex; )
        (randomIndex = Math.floor(Math.random() * currentIndex)),
          currentIndex--,
          ([this[currentIndex], this[randomIndex]] = [
            this[randomIndex],
            this[currentIndex],
          ]);
      return this;
    },
  }),
  (Array.storeRandom = function (arr) {
    arr.randomStore = [];
  }),
  Object.defineProperty(Array.prototype, "random", {
    writable: !0,
    value(range) {
      let value = Math.random(0, this.length - 1);
      if (
        (arguments.length && !this.randomStore && Array.storeRandom(this),
        !this.randomStore)
      )
        return this[value];
      if ((range > this.length - 1 && (range = this.length), range > 1)) {
        for (; ~this.randomStore.indexOf(value); )
          (value += 1) > this.length - 1 && (value = 0);
        this.randomStore.push(value),
          this.randomStore.length >= range && this.randomStore.shift();
      }
      return this[value];
    },
  }),
  Object.defineProperty(Array.prototype, "remove", {
    writable: !0,
    value(element) {
      if (!this.indexOf) return;
      const index = this.indexOf(element);
      return ~index ? this.splice(index, 1) : void 0;
    },
  }),
  Object.defineProperty(Array.prototype, "last", {
    writable: !0,
    value() {
      return this[this.length - 1];
    },
  }),
  (window.Promise = window.Promise || {}),
  Array.prototype.flat ||
    Object.defineProperty(Array.prototype, "flat", {
      configurable: !0,
      value: function flat() {
        var depth = isNaN(arguments[0]) ? 1 : Number(arguments[0]);
        return depth
          ? Array.prototype.reduce.call(
              this,
              function (acc, cur) {
                return (
                  Array.isArray(cur)
                    ? acc.push.apply(acc, flat.call(cur, depth - 1))
                    : acc.push(cur),
                  acc
                );
              },
              []
            )
          : Array.prototype.slice.call(this);
      },
      writable: !0,
    }),
  (Promise.create = function () {
    const promise = new Promise((resolve, reject) => {
      (this.temp_resolve = resolve), (this.temp_reject = reject);
    });
    return (
      (promise.resolve = this.temp_resolve),
      (promise.reject = this.temp_reject),
      delete this.temp_resolve,
      delete this.temp_reject,
      promise
    );
  }),
  (Promise.catchAll = function (array) {
    return Promise.all(
      array.map((promise) =>
        promise && "function" == typeof promise.catch
          ? promise.catch((error) => {
              Promise.reject(error);
            })
          : promise
      )
    );
  }),
  (Promise.timeout = function (promise, timeout) {
    Array.isArray(promise) && (promise = Promise.all(promise));
    var timeoutPromise = Promise.create(),
      ref = Timer.create(timeoutPromise.resolve, timeout);
    return Promise.race([promise, timeoutPromise]).finally(function () {
      Timer.__clearTimeout(ref);
    });
  }),
  (function () {
    function notRegExp(it) {
      if (
        (function isRegExp(it) {
          if (!("object" == typeof it ? null !== it : "function" == typeof it))
            return !1;
          var match = it["undefined" != typeof Symbol ? Symbol.match : "match"];
          return void 0 !== match
            ? !!match
            : "RegExp" === Object.prototype.toString.call(it).slice(8, -1);
        })(it)
      )
        throw new Error(
          "First argument to String.prototype.includes must not be a regular expression"
        );
      return it;
    }
    Object.defineProperty(String.prototype, "includes", {
      writable: !0,
      value(str) {
        if (!Array.isArray(str)) return !!~this.indexOf(notRegExp(str));
        for (let i = str.length - 1; i >= 0; i--)
          if (~this.indexOf(notRegExp(str[i]))) return !0;
        return !1;
      },
    });
  })(),
  Object.defineProperty(String.prototype, "equals", {
    writable: !0,
    value(str) {
      let compare = String(this);
      if (!Array.isArray(str)) return str === compare;
      for (let i = str.length - 1; i >= 0; i--)
        if (str[i] === compare) return !0;
      return !1;
    },
  }),
  Object.defineProperty(String.prototype, "strpos", {
    writable: !0,
    value(str) {
      return (
        console.warn("strpos deprecated: use .includes()"), this.includes(str)
      );
    },
  }),
  Object.defineProperty(String.prototype, "clip", {
    writable: !0,
    value(num, end = "") {
      return this.length > num
        ? this.slice(0, Math.max(0, num - end.length)).trim() + end
        : this.slice();
    },
  }),
  Object.defineProperty(String.prototype, "capitalize", {
    writable: !0,
    value() {
      return this.charAt(0).toUpperCase() + this.slice(1);
    },
  }),
  Object.defineProperty(String.prototype, "replaceAll", {
    writable: !0,
    value(find, replace) {
      return this.split(find).join(replace);
    },
  }),
  Object.defineProperty(String.prototype, "replaceAt", {
    writable: !0,
    value(index, replacement) {
      return (
        this.substr(0, index) +
        replacement +
        this.substr(index + replacement.length)
      );
    },
  }),
  (!window.fetch || (!window.AURA && location.protocol.includes("file"))) &&
    (window.fetch = function (url, options) {
      options = options || {};
      const promise = Promise.create(),
        request = new XMLHttpRequest();
      request.open(options.method || "get", url),
        url.includes(".ktx") && (request.responseType = "arraybuffer");
      for (let i in options.headers)
        request.setRequestHeader(i, options.headers[i]);
      function response() {
        let header,
          keys = [],
          all = [],
          headers = {};
        return (
          request
            .getAllResponseHeaders()
            .replace(/^(.*?):\s*([\s\S]*?)$/gm, (m, key, value) => {
              keys.push((key = key.toLowerCase())),
                all.push([key, value]),
                (header = headers[key]),
                (headers[key] = header ? `${header},${value}` : value);
            }),
          {
            ok: 1 == ((request.status / 200) | 0),
            status: request.status,
            statusText: request.statusText,
            url: request.responseURL,
            clone: response,
            text: () => Promise.resolve(request.responseText),
            json: () => Promise.resolve(request.responseText).then(JSON.parse),
            xml: () => Promise.resolve(request.responseXML),
            blob: () => Promise.resolve(new Blob([request.response])),
            arrayBuffer: () => Promise.resolve(request.response),
            headers: {
              keys: () => keys,
              entries: () => all,
              get: (n) => headers[n.toLowerCase()],
              has: (n) => n.toLowerCase() in headers,
            },
          }
        );
      }
      return (
        (request.onload = () => {
          promise.resolve(response());
        }),
        (request.onerror = promise.reject),
        request.send(options.body),
        promise
      );
    }),
  (window.get = function (url, options = { credentials: "same-origin" }) {
    let promise = Promise.create();
    return (
      (options.method = "GET"),
      fetch(url, options)
        .then(function handleResponse(e) {
          if (!e.ok) return promise.reject(e);
          e.text().then((text) => {
            if (text.charAt(0).includes(["[", "{"]))
              try {
                promise.resolve(JSON.parse(text));
              } catch (err) {
                promise.resolve(text);
              }
            else promise.resolve(text);
          });
        })
        .catch(promise.reject),
      promise
    );
  }),
  (window.post = function (url, body = {}, options = {}) {
    let promise = Promise.create();
    return (
      (options.method = "POST"),
      body &&
        (options.body =
          "object" == typeof body || Array.isArray(body)
            ? JSON.stringify(body)
            : body),
      options.headers ||
        (options.headers = { "content-type": "application/json" }),
      fetch(url, options)
        .then(function handleResponse(e) {
          if (!e.ok) return promise.reject(e);
          e.text().then((text) => {
            if (text.charAt(0).includes("[") || text.charAt(0).includes("{"))
              try {
                promise.resolve(JSON.parse(text));
              } catch (err) {
                promise.resolve(text);
              }
            else promise.resolve(text);
          });
        })
        .catch(promise.reject),
      promise
    );
  }),
  (window.put = function (url, body, options = {}) {
    let promise = Promise.create();
    return (
      (options.method = "PUT"),
      body &&
        (options.body =
          "object" == typeof body || Array.isArray(body)
            ? JSON.stringify(body)
            : body),
      fetch(url, options)
        .then(function handleResponse(e) {
          if (!e.ok) return promise.reject(e);
          e.text().then((text) => {
            if (text.charAt(0).includes(["[", "{"]))
              try {
                promise.resolve(JSON.parse(text));
              } catch (err) {
                promise.resolve(text);
              }
            else promise.resolve(text);
          });
        })
        .catch(promise.reject),
      promise
    );
  }),
  "undefined" == typeof WeakRef &&
    (function () {
      var targetProp =
        "undefined" != typeof Symbol
          ? Symbol("WeakRefTarget")
          : "@@WeakRefTarget";
      function WeakRef(target) {
        this[targetProp] = target;
      }
      (WeakRef.prototype.deref = function () {
        return this[targetProp];
      }),
        (window.WeakRef = WeakRef);
    })(),
  (window.Class = function (_class, _type, _static) {
    const _this = this || window,
      _name = _class.name || _class.toString().match(/function ?([^\(]+)/)[1];
    "function" == typeof _type && ((_static = _type), (_type = null)),
      (_type = (_type || "").toLowerCase())
        ? "static" == _type
          ? (_this[_name] = new _class())
          : "singleton" == _type &&
            ((_this[_name] = _class),
            (function () {
              let _instance;
              _this[_name].instance = function () {
                return (
                  _instance || (_instance = new _class(...arguments)), _instance
                );
              };
            })(),
            _static && _static())
        : ((_this[_name] = _class), _static && _static()),
      this && this !== window && (this[_name]._namespace = this.__namespace);
  }),
  (window.Inherit = function (child, parent) {
    const args = [].slice.call(arguments, 2);
    parent.apply(child, args);
    const save = {};
    for (let method in child) save[method] = child[method];
    const addSuperMethods = () => {
      for (let method in save)
        if (child[method] && child[method] !== save[method]) {
          if ("destroy" == method && !child.__element)
            throw `Do not override destroy directly, use onDestroy :: ${child.constructor.toString()}`;
          let name = method;
          do {
            name = `_${name}`;
          } while (child[name]);
          child[name] = save[method];
        }
    };
    child.__afterInitClass
      ? child.__afterInitClass.push(addSuperMethods)
      : defer(addSuperMethods);
  }),
  (window.Namespace = function (obj) {
    "string" == typeof obj
      ? window[obj] || (window[obj] = { Class: Class, __namespace: obj })
      : ((obj.Class = Class),
        (obj.__namespace =
          obj.constructor.name ||
          obj.constructor.toString().match(/function ([^\(]+)/)[1]));
  }),
  (window.Global = {}),
  (window.THREAD = !1),
  Class(function Hydra() {
    const _this = this,
      _readyPromise = Promise.create();
    var _base,
      _callbacks = [];
    function initLoad() {
      return document && window
        ? window._NODE_
          ? setTimeout(loaded, 1)
          : window._AURA_
          ? window.Main
            ? setTimeout(loaded, 1)
            : setTimeout(initLoad, 1)
          : void ("complete" === document.readyState
              ? setTimeout(loaded, 1)
              : window.addEventListener("load", loaded, !1))
        : setTimeout(initLoad, 1);
    }
    function loaded() {
      if (
        (window.removeEventListener("load", loaded, !1),
        window._HYDRA_BEFORE_READY)
      ) {
        let promise = window._HYDRA_BEFORE_READY;
        return delete window._HYDRA_BEFORE_READY, promise.then(loaded);
      }
      (_this.LOCAL =
        (!window._BUILT_ ||
          location.pathname.toLowerCase().includes("platform")) &&
        (location.hostname.indexOf("local") > -1 ||
          "10" == location.hostname.split(".")[0] ||
          "192" == location.hostname.split(".")[0] ||
          /atdev.online$/.test(location.hostname)) &&
        ("" == location.port || "3000" === location.port)),
        _callbacks.forEach((cb) => cb()),
        (_callbacks = null),
        _readyPromise.resolve(),
        window.Main &&
          _readyPromise.then(() => (Hydra.Main = new window.Main()));
    }
    (this.HASH = window.location.hash.slice(1)),
      (this.LOCAL =
        !window._BUILT_ &&
        (location.hostname.indexOf("local") > -1 ||
          "10" == location.hostname.split(".")[0] ||
          "192" == location.hostname.split(".")[0] ||
          /atdev.online$/.test(location.hostname)) &&
        ("" == location.port || "3000" === location.port)),
      initLoad(),
      (this.__triggerReady = function () {
        _callbacks || loaded();
      }),
      (this.ready = function (callback) {
        if (!callback) return _readyPromise;
        _callbacks ? _callbacks.push(callback) : callback();
      }),
      (this.absolutePath = function (path) {
        if (window.AURA) return path;
        let base = window.HYDRA_BASE_PATH ?? _base;
        if (void 0 === base)
          try {
            if (document.getElementsByTagName("base").length > 0) {
              var a = document.createElement("a");
              (a.href = document.getElementsByTagName("base")[0].href),
                (base = a.pathname),
                (_base = base);
            }
          } catch (e) {
            _base = null;
          }
        let pathname = base ?? location.pathname;
        pathname.includes("/index.html") &&
          (pathname = pathname.replace("/index.html", ""));
        let port = Number(location.port) > 1e3 ? `:${location.port}` : "";
        return path.includes("http")
          ? path
          : (location.protocol.length ? `${location.protocol}//` : "") +
              `${location.hostname + port + pathname}/${path}`.replace(
                "//",
                "/"
              );
      });
  }, "Static"),
  Class(function Utils() {
    var _queries = {},
      _searchParams = new URLSearchParams(window.location.search);
    (this.query = this.queryParams =
      function (key, value) {
        if (
          (void 0 !== value && (_queries[key] = value),
          void 0 !== _queries[key])
        )
          return _queries[key];
        if (_searchParams)
          "0" === (value = _searchParams.get(key))
            ? (value = 0)
            : "false" === value || null === value
            ? (value = !1)
            : "" === value && (value = !0);
        else {
          let escapedKey = encodeURIComponent(key).replace(/[\.\+\*]/g, "\\$&");
          "0" ==
          (value = decodeURIComponent(
            window.location.search.replace(
              new RegExp(`^(?:.*?[&?]${escapedKey}(?:=([^&]*)|[&$]))?.*$`, "i"),
              "$1"
            )
          ))
            ? (value = 0)
            : "false" == value
            ? (value = !1)
            : value.length ||
              (value = new RegExp(`[&?]${escapedKey}(?:[&=]|$)`, "i").test(
                window.location.search
              ));
        }
        return (_queries[key] = value), value;
      }),
      (this.addQuery = function (query, value) {
        if (_queries[query] === value) return _queries[query];
        let url = new URL(location.href);
        return (
          url.searchParams.set(query, value),
          (_searchParams = url.searchParams),
          window.history.replaceState({}, document.title, url.toString()),
          (_queries[query] = value)
        );
      }),
      (this.removeQuery = function (query) {
        let url = new URL(location.href);
        return (
          url.searchParams.delete(query),
          (_searchParams = url.searchParams),
          window.history.replaceState({}, document.title, url.toString()),
          delete _queries[query]
        );
      }),
      (this.addQueryToPath = function (path, hash) {
        return [
          [path, _searchParams.toString()].filter(Boolean).join("?"),
          hash,
        ]
          .filter(Boolean)
          .join("#");
      }),
      (this.addParam = function (url, param, value) {
        let index = url.indexOf("?"),
          prefix = url.substring(0, index + 1),
          suffix = url.substring(index + 1),
          searchParams = new URLSearchParams(suffix);
        return (
          searchParams.append(param, value), prefix + searchParams.toString()
        );
      }),
      (this.removeParam = function (url, param) {
        let index = url.indexOf("?"),
          prefix = url.substring(0, index + 1),
          suffix = url.substring(index + 1),
          searchParams = new URLSearchParams(suffix);
        return searchParams.delete(param), prefix + searchParams.toString();
      }),
      (this.getConstructorName = function (obj) {
        return obj
          ? (obj.___constructorName ||
              (obj.___constructorName =
                "function" == typeof obj
                  ? obj.toString().match(/function ([^\(]+)/)[1]
                  : obj.constructor.name ||
                    obj.constructor.toString().match(/function ([^\(]+)/)[1]),
            obj.___constructorName)
          : obj;
      }),
      (this.nullObject = function (object) {
        if (object && (object.destroy || object.div))
          for (var key in object)
            void 0 !== object[key] && (object[key] = null);
        return null;
      }),
      (this.cloneObject = function (obj) {
        return JSON.parse(JSON.stringify(obj));
      }),
      (this.headsTails = function (n0, n1) {
        return Math.random(0, 1) ? n1 : n0;
      }),
      (this.mergeObject = function () {
        for (var obj = {}, i = 0; i < arguments.length; i++) {
          var o = arguments[i];
          for (var key in o) obj[key] = o[key];
        }
        return obj;
      }),
      (this.timestamp = this.uuid =
        function () {
          return (
            Date.now() +
            "xx-4xx-yxx-xxx".replace(/[xy]/g, function (c) {
              let r = (16 * Math.random()) | 0;
              return ("x" == c ? r : (3 & r) | 8).toString(16);
            })
          );
        }),
      (this.randomColor = function () {
        var color = `#${Math.floor(16777215 * Math.random()).toString(16)}`;
        return color.length < 7 && (color = this.randomColor()), color;
      }),
      (this.numberWithCommas = function (num) {
        return num.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ",");
      }),
      (this.padInt = function (num, digits, isLimit) {
        isLimit && (num = Math.min(num, Math.pow(10, digits) - 1));
        let str = Math.floor(num).toString();
        return (
          Math.pow(10, Math.max(0, digits - str.length))
            .toString()
            .slice(1) + str
        );
      }),
      (this.copyToClipboard = function (string) {
        try {
          var el = document.createElement("textarea"),
            range = document.createRange();
          (el.contentEditable = !0),
            (el.readOnly = !0),
            (el.value = string),
            document.body.appendChild(el),
            el.select(),
            range.selectNodeContents(el);
          var s = window.getSelection();
          return (
            s.removeAllRanges(),
            s.addRange(range),
            el.setSelectionRange(0, string.length),
            document.execCommand("copy"),
            document.body.removeChild(el),
            !0
          );
        } catch (e) {
          return !1;
        }
      }),
      (this.stringList = function (items = [], limit = 0, options = {}) {
        if (0 === items.length) return "";
        let output = "",
          printed = 0;
        "object" == typeof limit && ((options = limit), (limit = 0)),
          (options.oxford = !0 === options.oxford),
          (options.more =
            !1 !== options.more && (options.more ? options.more : "more")),
          (options.and = options.and ? options.and : "&"),
          (options.comma = options.comma ? options.comma : ","),
          isNaN(options.limit) || (limit = options.limit),
          0 === limit && (limit = items.length);
        do {
          (output = `${output}${items.shift()}${options.comma} `), printed++;
        } while (items.length > 1 && printed + 1 < limit);
        if (
          ((output = output.trim()),
          (output = output.slice(0, output.length - 1)),
          1 === items.length)
        )
          output = `${output}${
            options.oxford && printed > 1 ? options.comma : ""
          } ${options.and} ${items.shift()}`;
        else if (items.length > 1 && options.more) {
          let more = `${items.length} ${options.more}`;
          output = `${output}${
            options.oxford && printed > 1 ? options.comma : ""
          } ${options.and} ${more}`;
        }
        return output;
      }),
      (this.debounce = function (callback, time = 100) {
        clearTimeout(callback.__interval),
          (callback.__interval = Timer.create(callback, time));
      });
  }, "Static"),
  Class(function Render() {
    const _this = this,
      _render = [],
      _native = [],
      _drawFrame = [],
      _multipliers = [];
    let _renderIndex = null,
      _nativeIndex = null;
    var _last = performance.now(),
      _localTSL = 0,
      _elapsed = 0,
      _capLast = 0,
      _sampleRefreshRate = [],
      _firstSample = !1,
      _saveRefreshRate = 60,
      rAF = requestAnimationFrame,
      _refreshScale = 1,
      _canCap = 0,
      _screenHash = getScreenHash();
    function render(tsl) {
      if (_last >= tsl) return void (THREAD || _this.isPaused || rAF(render));
      if (_native.length) {
        let multiplier = 60 / _saveRefreshRate;
        for (
          _nativeIndex = _native.length - 1;
          _nativeIndex > -1;
          _nativeIndex--
        ) {
          let callback = _native[_nativeIndex];
          try {
            callback(multiplier);
          } catch (error) {
            handleRenderCallbackError(callback, error);
          }
        }
        _nativeIndex = null;
      }
      if (_this.capFPS > 0 && ++_canCap > 31) {
        let delta = tsl - _capLast;
        if (((_capLast = tsl), (_elapsed += delta) < 1e3 / _this.capFPS))
          return void (THREAD || _this.isPaused || rAF(render));
        (_this.REFRESH_RATE = _this.capFPS),
          (_this.HZ_MULTIPLIER = (60 / _this.REFRESH_RATE) * _refreshScale),
          (_elapsed = 0);
      }
      if (((_this.timeScaleUniform.value = 1), _multipliers.length))
        for (let i = 0; i < _multipliers.length; i++) {
          let obj = _multipliers[i];
          _this.timeScaleUniform.value *= obj.value;
        }
      (_this.DT = tsl - _last), (_last = tsl);
      let delta = _this.DT * _this.timeScaleUniform.value;
      if (
        ((delta = Math.min(200, delta)), _sampleRefreshRate && !_this.capFPS)
      ) {
        let fps = 1e3 / _this.DT;
        if ((_sampleRefreshRate.push(fps), _sampleRefreshRate.length > 30)) {
          _sampleRefreshRate.sort((a, b) => a - b);
          let rate =
            _sampleRefreshRate[Math.round(_sampleRefreshRate.length / 2)];
          (rate = _this.REFRESH_TABLE.reduce((prev, curr) =>
            Math.abs(curr - rate) < Math.abs(prev - rate) ? curr : prev
          )),
            (_this.REFRESH_RATE = _saveRefreshRate =
              _firstSample ? Math.max(_this.REFRESH_RATE, rate) : rate),
            (_this.HZ_MULTIPLIER = (60 / _this.REFRESH_RATE) * _refreshScale),
            (_sampleRefreshRate = null),
            (_firstSample = !0);
        }
      }
      for (
        _this.TIME = tsl,
          _this.DELTA = delta,
          _this.startFrame && _this.startFrame(tsl, delta),
          _localTSL += delta,
          _renderIndex = _render.length - 1;
        _renderIndex >= 0;
        _renderIndex--
      ) {
        var callback = _render[_renderIndex];
        if (callback)
          try {
            if (callback.fps) {
              if (tsl - callback.last < 1e3 / callback.fps) continue;
              callback(++callback.frame), (callback.last = tsl);
              continue;
            }
            callback(tsl, delta);
          } catch (error) {
            handleRenderCallbackError(callback, error);
          }
        else _render.splice(_renderIndex, 1);
      }
      _renderIndex = null;
      for (let i = _drawFrame.length - 1; i > -1; i--)
        _drawFrame[i](tsl, delta);
      _this.drawFrame && _this.drawFrame(tsl, delta),
        _this.endFrame && _this.endFrame(tsl, delta),
        THREAD || _this.isPaused || rAF(render);
    }
    function handleRenderCallbackError(callback, error) {
      let evt = { callback: callback, error: error, preventStopRender: !1 };
      Events.emitter._fireEvent(_this.RENDER_CALLBACK_ERROR, evt),
        evt.preventStopRender || _this.stop(callback);
    }
    function getScreenHash() {
      return window.screen
        ? `${window.screen.width}x${window.screen.height}.${window.screen.pixelDepth}`
        : "none";
    }
    function checkMoveScreen() {
      var newScreen = getScreenHash();
      _screenHash !== newScreen &&
        ((_screenHash = newScreen),
        (_sampleRefreshRate = null),
        (_firstSample = !1));
    }
    (this.timeScaleUniform = { value: 1, type: "f", ignoreUIL: !0 }),
      (this.REFRESH_TABLE = [30, 60, 72, 90, 100, 120, 144, 240]),
      (this.REFRESH_RATE = 60),
      (this.HZ_MULTIPLIER = 1),
      (this.RENDER_CALLBACK_ERROR = "render_callback_error"),
      (this.capFPS = null),
      THREAD ||
        (rAF(render),
        setInterval((_) => (_sampleRefreshRate = []), 3e3),
        setInterval(checkMoveScreen, 5e3)),
      (this.now = function () {
        return _localTSL;
      }),
      (this.setRefreshScale = function (scale) {
        (_refreshScale = scale), (_sampleRefreshRate = []);
      }),
      (this.start = function (callback, fps, native) {
        fps &&
          ((callback.fps = fps),
          (callback.last = -1 / 0),
          (callback.frame = -1)),
          native
            ? ~_native.indexOf(callback) ||
              (_native.unshift(callback),
              null !== _nativeIndex && (_nativeIndex += 1))
            : ~_render.indexOf(callback) ||
              (_render.unshift(callback),
              null !== _renderIndex && (_renderIndex += 1));
      }),
      (this.stop = function (callback) {
        let i = _render.indexOf(callback);
        i >= 0 &&
          (_render.splice(i, 1),
          null !== _renderIndex && i < _renderIndex && (_renderIndex -= 1)),
          (i = _native.indexOf(callback)),
          i >= 0 &&
            (_native.splice(i, 1),
            null !== _nativeIndex && i < _nativeIndex && (_nativeIndex -= 1));
      }),
      (this.tick = function () {
        THREAD && ((this.TIME = performance.now()), render(this.TIME));
      }),
      (this.forceRender = function (time) {
        (this.TIME = time), render(this.TIME);
      }),
      (this.Worker = function (_callback, _budget = 4) {
        Inherit(this, Component);
        let _scope = this,
          _elapsed = 0;
        function loop() {
          if (!_scope.dead) {
            for (; _elapsed < _budget; ) {
              if (_scope.dead || _scope.paused) return;
              const start = performance.now();
              _callback && _callback(), (_elapsed += performance.now() - start);
            }
            _elapsed = 0;
          }
        }
        this.startRender(loop),
          (this.stop = function () {
            (this.dead = !0), this.stopRender(loop);
          }),
          (this.pause = function () {
            (this.paused = !0), this.stopRender(loop);
          }),
          (this.resume = function () {
            (this.paused = !1), this.startRender(loop);
          }),
          (this.setCallback = function (cb) {
            _callback = cb;
          });
      }),
      (this.pause = function () {
        _this.isPaused = !0;
      }),
      (this.resume = function () {
        _this.isPaused && ((_this.isPaused = !1), rAF(render));
      }),
      (this.useRAF = function (raf) {
        (_firstSample = null), (_last = performance.now()), (rAF = raf)(render);
      }),
      (this.onDrawFrame = function (cb) {
        _drawFrame.push(cb);
      }),
      (this.setTimeScale = function (v) {
        _this.timeScaleUniform.value = v;
      }),
      (this.getTimeScale = function () {
        return _this.timeScaleUniform.value;
      }),
      (this.createTimeMultiplier = function () {
        let obj = { value: 1 };
        return _multipliers.push(obj), obj;
      }),
      (this.destroyTimeMultiplier = function (obj) {
        _multipliers.remove(obj);
      }),
      (this.tweenTimeScale = function (value, time, ease, delay) {
        return tween(
          _this.timeScaleUniform,
          { value: value },
          time,
          ease,
          delay,
          null,
          null,
          !0
        );
      }),
      Object.defineProperty(_this, "FRAME_HZ_MULTIPLIER", {
        get: () => (60 / (1e3 / _this.DELTA)) * _refreshScale,
        enumerable: !0,
      });
  }, "Static"),
  Class(function Timer() {
    const _this = this,
      _callbacks = [],
      _discard = [],
      _deferA = [],
      _deferB = [];
    var _defer = _deferA;
    function loop(t, delta) {
      for (let i = _discard.length - 1; i >= 0; i--) {
        let obj = _discard[i];
        (obj.callback = null), _callbacks.remove(obj);
      }
      _discard.length && (_discard.length = 0);
      for (let i = _callbacks.length - 1; i >= 0; i--) {
        let obj = _callbacks[i];
        obj
          ? (obj.scaledTime
              ? (obj.current += delta)
              : (obj.current += Render.DT),
            obj.current >= obj.time &&
              (obj.callback && obj.callback(), _discard.push(obj)))
          : _callbacks.remove(obj);
      }
      for (let i = _defer.length - 1; i > -1; i--) _defer[i]();
      (_defer.length = 0), (_defer = _defer == _deferA ? _deferB : _deferA);
    }
    Render.start(loop),
      (this.__clearTimeout = function (ref) {
        const obj = (function find(ref) {
          for (let i = _callbacks.length - 1; i > -1; i--)
            if (_callbacks[i].ref == ref) return _callbacks[i];
        })(ref);
        return !!obj && ((obj.callback = null), _callbacks.remove(obj), !0);
      }),
      (this.create = function (callback, time, scaledTime) {
        if (window._NODE_) return setTimeout(callback, time);
        const obj = {
          time: Math.max(1, time || 1),
          current: 0,
          ref: Utils.timestamp(),
          callback: callback,
          scaledTime: scaledTime,
        };
        return _callbacks.unshift(obj), obj.ref;
      }),
      (this.delayedCall = function (time) {
        let promise = Promise.create();
        return _this.create(promise.resolve, time), promise;
      }),
      (window.defer = this.defer =
        function (callback) {
          let promise;
          return (
            callback ||
              ((promise = Promise.create()), (callback = promise.resolve)),
            (_defer == _deferA ? _deferB : _deferA).unshift(callback),
            promise
          );
        });
  }, "static"),
  Class(
    function Events() {
      const _this = this;
      this.events = {};
      const _e = {},
        _linked = [];
      let _emitter;
      (this.events.sub = function (obj, evt, callback) {
        if (
          ("object" != typeof obj &&
            ((callback = evt), (evt = obj), (obj = null)),
          !obj)
        )
          return (
            Events.emitter._addEvent(
              evt,
              callback.resolve ? callback.resolve : callback,
              this
            ),
            callback
          );
        let emitter = obj.events.emitter();
        return (
          emitter._addEvent(
            evt,
            callback.resolve ? callback.resolve : callback,
            this
          ),
          emitter._saveLink(this),
          _linked.push(emitter),
          callback
        );
      }),
        (this.events.wait = async function (obj, evt) {
          const promise = Promise.create(),
            args = [
              obj,
              evt,
              (e) => {
                _this.events.unsub(...args), promise.resolve(e);
              },
            ];
          return (
            "object" != typeof obj && args.splice(1, 1),
            _this.events.sub(...args),
            promise
          );
        }),
        (this.events.unsub = function (obj, evt, callback) {
          if (
            ("object" != typeof obj &&
              ((callback = evt), (evt = obj), (obj = null)),
            !obj)
          )
            return Events.emitter._removeEvent(
              evt,
              callback.resolve ? callback.resolve : callback
            );
          obj.events
            .emitter()
            ._removeEvent(evt, callback.resolve ? callback.resolve : callback);
        }),
        (this.events.fire = function (evt, obj, isLocalOnly) {
          ((obj = obj || _e).target = this),
            Events.emitter._check(evt),
            (_emitter && _emitter._fireEvent(evt, obj)) ||
              isLocalOnly ||
              Events.emitter._fireEvent(evt, obj);
        }),
        (this.events.bubble = function (obj, evt) {
          _this.events.sub(obj, evt, (e) => _this.events.fire(evt, e));
        }),
        (this.events.destroy = function () {
          return (
            Events.emitter._destroyEvents(this),
            _linked &&
              _linked.forEach((emitter) => emitter._destroyEvents(this)),
            _emitter &&
              _emitter.links &&
              _emitter.links.forEach(
                (obj) => obj.events && obj.events._unlink(_emitter)
              ),
            null
          );
        }),
        (this.events.emitter = function () {
          return (
            _emitter || (_emitter = Events.emitter.createLocalEmitter()),
            _emitter
          );
        }),
        (this.events._unlink = function (emitter) {
          _linked.remove(emitter);
        });
    },
    () => {
      (Events.emitter = new (function Emitter() {
        const prototype = Emitter.prototype;
        if (((this.events = []), void 0 !== prototype._check)) return;
        (prototype._check = function (evt) {
          if (void 0 === evt) throw "Undefined event";
        }),
          (prototype._addEvent = function (evt, callback, object) {
            this._check(evt),
              this.events.push({
                evt: evt,
                object: object,
                callback: callback,
              });
          }),
          (prototype._removeEvent = function (eventString, callback) {
            this._check(eventString);
            for (let i = this.events.length - 1; i >= 0; i--)
              this.events[i].evt === eventString &&
                this.events[i].callback === callback &&
                this._markForDeletion(i);
          }),
          (prototype._sweepEvents = function () {
            for (let i = 0; i < this.events.length; i++)
              this.events[i].markedForDeletion &&
                (delete this.events[i].markedForDeletion,
                this.events.splice(i, 1),
                --i);
          }),
          (prototype._markForDeletion = function (i) {
            (this.events[i].markedForDeletion = !0),
              this._sweepScheduled ||
                ((this._sweepScheduled = !0),
                defer(() => {
                  (this._sweepScheduled = !1), this._sweepEvents();
                }));
          }),
          (prototype._fireEvent = function (eventString, obj) {
            this._check && this._check(eventString), (obj = obj || _e);
            let called = !1;
            for (let i = 0; i < this.events.length; i++) {
              let evt = this.events[i];
              evt.evt != eventString ||
                evt.markedForDeletion ||
                (evt.callback(obj), (called = !0));
            }
            return called;
          }),
          (prototype._destroyEvents = function (object) {
            for (var i = this.events.length - 1; i >= 0; i--)
              this.events[i].object === object && this._markForDeletion(i);
          }),
          (prototype._saveLink = function (obj) {
            this.links || (this.links = []),
              ~this.links.indexOf(obj) || this.links.push(obj);
          }),
          (prototype.createLocalEmitter = function () {
            return new Emitter();
          });
      })()),
        (Events.broadcast = Events.emitter._fireEvent),
        (Events.VISIBILITY = "hydra_visibility"),
        (Events.HASH_UPDATE = "hydra_hash_update"),
        (Events.COMPLETE = "hydra_complete"),
        (Events.PROGRESS = "hydra_progress"),
        (Events.CONNECTIVITY = "hydra_connectivity"),
        (Events.UPDATE = "hydra_update"),
        (Events.LOADED = "hydra_loaded"),
        (Events.END = "hydra_end"),
        (Events.FAIL = "hydra_fail"),
        (Events.SELECT = "hydra_select"),
        (Events.ERROR = "hydra_error"),
        (Events.READY = "hydra_ready"),
        (Events.RESIZE = "hydra_resize"),
        (Events.CLICK = "hydra_click"),
        (Events.HOVER = "hydra_hover"),
        (Events.MESSAGE = "hydra_message"),
        (Events.ORIENTATION = "orientation"),
        (Events.BACKGROUND = "background"),
        (Events.BACK = "hydra_back"),
        (Events.PREVIOUS = "hydra_previous"),
        (Events.NEXT = "hydra_next"),
        (Events.RELOAD = "hydra_reload"),
        (Events.UNLOAD = "hydra_unload"),
        (Events.FULLSCREEN = "hydra_fullscreen");
      const _e = {};
      Hydra.ready(() => {
        let box;
        !(function () {
          let _last,
            _lastTime = performance.now();
          function onfocus() {
            (Render.blurTime = -1),
              "focus" != _last &&
                Events.emitter._fireEvent(Events.VISIBILITY, { type: "focus" }),
              (_last = "focus");
          }
          function onblur() {
            (Render.blurTime = Date.now()),
              "blur" != _last &&
                Events.emitter._fireEvent(Events.VISIBILITY, { type: "blur" }),
              (_last = "blur");
          }
          Timer.create(function addVisibilityHandler() {
            let hidden, eventName;
            if (
              ([
                ["msHidden", "msvisibilitychange"],
                ["webkitHidden", "webkitvisibilitychange"],
                ["hidden", "visibilitychange"],
              ].forEach((d) => {
                void 0 !== document[d[0]] &&
                  ((hidden = d[0]), (eventName = d[1]));
              }),
              !eventName)
            ) {
              const root = "ie" == Device.browser ? document : window;
              return (root.onfocus = onfocus), void (root.onblur = onblur);
            }
            document.addEventListener(eventName, () => {
              const time = performance.now();
              time - _lastTime > 10 &&
                (!1 === document[hidden] ? onfocus() : onblur()),
                (_lastTime = time);
            });
          }, 250),
            window.addEventListener("online", (_) =>
              Events.emitter._fireEvent(Events.CONNECTIVITY, { online: !0 })
            ),
            window.addEventListener("offline", (_) =>
              Events.emitter._fireEvent(Events.CONNECTIVITY, { online: !1 })
            ),
            (window.onbeforeunload = (_) => (
              Events.emitter._fireEvent(Events.UNLOAD), null
            ));
        })(),
          (window.Stage = window.Stage || {}),
          "social" == Device.system.browser &&
            "ios" == Device.system.os &&
            ((box = document.createElement("div")),
            (box.style.position = "fixed"),
            (box.style.top =
              box.style.left =
              box.style.right =
              box.style.bottom =
                "0px"),
            (box.style.zIndex = "-1"),
            (box.style.opacity = "0"),
            (box.style.pointerEvents = "none"),
            document.body.appendChild(box)),
          updateStage();
        let timer,
          iosResize = "ios" === Device.system.os,
          html = !!iosResize && document.querySelector("html"),
          delay = iosResize ? 500 : 16;
        function updateStage() {
          if (box) {
            let bbox = box.getBoundingClientRect();
            (Stage.width =
              bbox.width ||
              window.innerWidth ||
              document.body.clientWidth ||
              document.documentElement.offsetWidth),
              (Stage.height =
                bbox.height ||
                window.innerHeight ||
                document.body.clientHeight ||
                document.documentElement.offsetHeight),
              (document.body.parentElement.scrollTop = document.body.scrollTop =
                0),
              (document.documentElement.style.width =
                document.body.style.width =
                  `${Stage.width}px`),
              (document.documentElement.style.height =
                document.body.style.height =
                  `${Stage.height}px`),
              Events.emitter._fireEvent(Events.RESIZE);
          } else
            (Stage.width =
              window.innerWidth ||
              document.body.clientWidth ||
              document.documentElement.offsetWidth),
              (Stage.height =
                window.innerHeight ||
                document.body.clientHeight ||
                document.documentElement.offsetHeight);
        }
        window.addEventListener("resize", function handleResize() {
          clearTimeout(timer),
            (timer = setTimeout((_) => {
              updateStage(),
                html &&
                  Math.min(window.screen.width, window.screen.height) !==
                    Stage.height &&
                  !Mobile.isAllowNativeScroll &&
                  (html.scrollTop = -1),
                Events.emitter._fireEvent(Events.RESIZE);
            }, delay));
        }),
          (window.onorientationchange = window.onresize),
          "social" == Device.system.browser &&
            (Stage.height >= screen.height || Stage.width >= screen.width) &&
            setTimeout(updateStage, 1e3),
          defer(window.onresize);
      });
    }
  ),
  Class(function Device() {
    var vid,
      _this = this;
    (this.agent = navigator.userAgent.toLowerCase()),
      (this.detect = function (match) {
        return this.agent.includes(match);
      }),
      (this.touchCapable = !!navigator.maxTouchPoints),
      (this.pixelRatio = window.devicePixelRatio),
      (this.system = {}),
      (this.system.retina = window.devicePixelRatio > 1),
      (this.system.webworker = void 0 !== window.Worker),
      window._NODE_ ||
        (this.system.geolocation = void 0 !== navigator.geolocation),
      window._NODE_ ||
        (this.system.pushstate = void 0 !== window.history.pushState),
      (this.system.webcam = !!(
        navigator.getUserMedia ||
        navigator.webkitGetUserMedia ||
        navigator.mozGetUserMedia ||
        navigator.mediaDevices
      )),
      (this.system.language =
        window.navigator.userLanguage || window.navigator.language),
      (this.system.webaudio = void 0 !== window.AudioContext),
      (this.system.xr = {}),
      (this.system.detectXR = async function () {
        if (window.AURA)
          return (_this.system.xr.vr = !0), void (_this.system.xr.ar = !0);
        if (!navigator.xr)
          return (_this.system.xr.vr = !1), void (_this.system.xr.ar = !1);
        try {
          [_this.system.xr.vr, _this.system.xr.ar] = await Promise.all([
            navigator.xr.isSessionSupported("immersive-vr"),
            navigator.xr.isSessionSupported("immersive-ar"),
          ]);
        } catch (e) {}
        "android" == _this.system.os &&
          (_this.detect("oculus") || (_this.system.xr.vr = !1));
      });
    try {
      this.system.localStorage = void 0 !== window.localStorage;
    } catch (e) {
      this.system.localStorage = !1;
    }
    (this.system.fullscreen =
      document.fullscreenEnabled ||
      document.webkitFullscreenEnabled ||
      document.mozFullScreenEnabled ||
      document.msFullscreenEnabled),
      (this.system.os =
        _this.detect(["ipad", "iphone", "ios"]) ||
        (function detectIpad() {
          let aspect =
            Math.max(screen.width, screen.height) /
            Math.min(screen.width, screen.height);
          return (
            _this.detect("mac") &&
            _this.touchCapable &&
            Math.abs(aspect - 4 / 3) < Math.abs(aspect - 1.6)
          );
        })()
          ? "ios"
          : _this.detect(["android", "kindle"])
          ? "android"
          : _this.detect(["blackberry"])
          ? "blackberry"
          : _this.detect(["mac os"])
          ? "mac"
          : _this.detect(["windows", "iemobile"])
          ? "windows"
          : _this.detect(["linux"])
          ? "linux"
          : "unknown"),
      (this.system.version = (function () {
        try {
          if ("ios" == _this.system.os) {
            if (_this.agent.includes("intel mac")) {
              let split = _this.agent
                .split("version/")[1]
                .split(" ")[0]
                .split(".");
              return Number(`${split[0]}.${split[1]}`);
            }
            var num = _this.agent.split("os ")[1].split("_"),
              main = num[0],
              sub = num[1].split(" ")[0];
            return Number(`${main}.${sub}`);
          }
          if ("android" == _this.system.os) {
            var version = _this.agent.split("android ")[1].split(";")[0];
            return (
              version.length > 3 && (version = version.slice(0, -2)),
              "." == version.charAt(version.length - 1) &&
                (version = version.slice(0, -1)),
              Number(version)
            );
          }
          if ("windows" == _this.system.os)
            return _this.agent.includes("rv:11")
              ? 11
              : Number(_this.agent.split("windows phone ")[1].split(";")[0]);
        } catch (e) {}
        return -1;
      })()),
      (this.system.browser =
        "ios" == _this.system.os
          ? _this.detect(["twitter", "fbios", "instagram"])
            ? "social"
            : _this.detect(["crios"])
            ? "chrome"
            : _this.detect(["fxios"])
            ? "firefox"
            : _this.detect(["safari"])
            ? "safari"
            : "unknown"
          : "android" == _this.system.os
          ? _this.detect(["twitter", "fb", "facebook", "instagram"])
            ? "social"
            : _this.detect(["chrome"])
            ? "chrome"
            : _this.detect(["firefox"])
            ? "firefox"
            : "browser"
          : _this.detect(["msie"]) ||
            (_this.detect(["trident"]) && _this.detect(["rv:"])) ||
            (_this.detect(["windows"]) && _this.detect(["edge"]))
          ? "ie"
          : _this.detect(["chrome"])
          ? "chrome"
          : _this.detect(["safari"])
          ? "safari"
          : _this.detect(["firefox"])
          ? "firefox"
          : "unknown"),
      (this.system.browserVersion = (function () {
        try {
          if ("chrome" == _this.system.browser)
            return _this.detect("crios")
              ? Number(_this.agent.split("crios/")[1].split(".")[0])
              : Number(_this.agent.split("chrome/")[1].split(".")[0]);
          if ("firefox" == _this.system.browser)
            return Number(_this.agent.split("firefox/")[1].split(".")[0]);
          if ("safari" == _this.system.browser)
            return Number(
              _this.agent.split("version/")[1].split(".")[0].split(".")[0]
            );
          if ("ie" == _this.system.browser)
            return _this.detect(["msie"])
              ? Number(_this.agent.split("msie ")[1].split(".")[0])
              : _this.detect(["rv:"])
              ? Number(_this.agent.split("rv:")[1].split(".")[0])
              : Number(_this.agent.split("edge/")[1].split(".")[0]);
        } catch (e) {
          return -1;
        }
      })()),
      (this.mobile =
        !(
          window._NODE_ ||
          (!("ontouchstart" in window) && !("onpointerdown" in window)) ||
          !_this.system.os.includes(["ios", "android", "magicleap"])
        ) && {}),
      _this.detect("oculusbrowser") && (this.mobile = !0),
      _this.detect("quest") && (this.mobile = !0),
      this.mobile &&
        this.detect(["windows"]) &&
        !this.detect(["touch"]) &&
        (this.mobile = !1),
      this.mobile &&
        ((this.mobile.tablet =
          Math.max(
            window.screen ? screen.width : window.innerWidth,
            window.screen ? screen.height : window.innerHeight
          ) > 1e3),
        (this.mobile.phone = !this.mobile.tablet),
        (this.mobile.pwa =
          !(
            !window.matchMedia ||
            !window.matchMedia("(display-mode: standalone)").matches
          ) || !!window.navigator.standalone),
        Hydra.ready(() => {
          _this.mobile.native =
            !(!Mobile.NativeCore || !Mobile.NativeCore.active) ||
            !!window._AURA_;
        })),
      (this.media = {}),
      (this.media.audio =
        !!document.createElement("audio").canPlayType &&
        (_this.detect(["firefox", "opera"]) ? "ogg" : "mp3")),
      (this.media.video =
        ((vid = document.createElement("video")).setAttribute("muted", !0),
        vid.setAttribute("loop", !0),
        vid.setAttribute("autoplay", !0),
        vid.setAttribute("preload", !0),
        vid.setAttribute("playsinline", !0),
        vid.setAttribute("webkit-playsinline", !0),
        (vid.autoplay = !0),
        (vid.muted = !0),
        (vid.src =
          "data:video/mp4;base64,AAAAIGZ0eXBtcDQyAAACAG1wNDJpc28yYXZjMW1wNDEAAANObW9vdgAAAGxtdmhkAAAAAOA5QnjgOUJ4AAAD6AAAAEMAAQAAAQAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgAAAmt0cmFrAAAAXHRraGQAAAAD4DlCeOA5QngAAAABAAAAAAAAAEMAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAABAAAAAACAAAAAgAAAAAAAkZWR0cwAAABxlbHN0AAAAAAAAAAEAAABDAAAAAAABAAAAAAHjbWRpYQAAACBtZGhkAAAAAOA5QnjgOUJ4AAFfkAAAF3BVxAAAAAAALWhkbHIAAAAAAAAAAHZpZGUAAAAAAAAAAAAAAABWaWRlb0hhbmRsZXIAAAABjm1pbmYAAAAUdm1oZAAAAAEAAAAAAAAAAAAAACRkaW5mAAAAHGRyZWYAAAAAAAAAAQAAAAx1cmwgAAAAAQAAAU5zdGJsAAAAznN0c2QAAAAAAAAAAQAAAL5hdmMxAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAACAAIABIAAAASAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAGP//AAAAMWF2Y0MBTUAo/+EAGWdNQCjspLYC1BgYGQAAAwABAAK/IA8YMZYBAAVo6uEyyAAAABNjb2xybmNseAAGAAYABgAAAAAQcGFzcAAAAAEAAAABAAAAFGJ0cnQAAAAAAAF1IAABdSAAAAAYc3R0cwAAAAAAAAABAAAAAgAAC7gAAAAUc3RzcwAAAAAAAAABAAAAAQAAABxzdHNjAAAAAAAAAAEAAAABAAAAAgAAAAEAAAAcc3RzegAAAAAAAAAAAAAAAgAAAxAAAAAMAAAAFHN0Y28AAAAAAAAAAQAAA34AAABvdWR0YQAAAGdtZXRhAAAAAAAAACFoZGxyAAAAAAAAAABtZGlyYXBwbAAAAAAAAAAAAAAAADppbHN0AAAAMql0b28AAAAqZGF0YQAAAAEAAAAASGFuZEJyYWtlIDEuNi4xIDIwMjMwMTIyMDAAAAAIZnJlZQAAAyRtZGF0AAAC9AYF///w3EXpvebZSLeWLNgg2SPu73gyNjQgLSBjb3JlIDE2NCByMzEwMCBlZDBmN2E2IC0gSC4yNjQvTVBFRy00IEFWQyBjb2RlYyAtIENvcHlsZWZ0IDIwMDMtMjAyMiAtIGh0dHA6Ly93d3cudmlkZW9sYW4ub3JnL3gyNjQuaHRtbCAtIG9wdGlvbnM6IGNhYmFjPTEgcmVmPTIgZGVibG9jaz0xOjA6MCBhbmFseXNlPTB4MToweDExMSBtZT1oZXggc3VibWU9NiBwc3k9MSBwc3lfcmQ9MS4wMDowLjAwIG1peGVkX3JlZj0xIG1lX3JhbmdlPTE2IGNocm9tYV9tZT0xIHRyZWxsaXM9MSA4eDhkY3Q9MCBjcW09MCBkZWFkem9uZT0yMSwxMSBmYXN0X3Bza2lwPTEgY2hyb21hX3FwX29mZnNldD0tMiB0aHJlYWRzPTEgbG9va2FoZWFkX3RocmVhZHM9MSBzbGljZWRfdGhyZWFkcz0wIG5yPTAgZGVjaW1hdGU9MSBpbnRlcmxhY2VkPTAgYmx1cmF5X2NvbXBhdD0wIGNvbnN0cmFpbmVkX2ludHJhPTAgYmZyYW1lcz0zIGJfcHlyYW1pZD0yIGJfYWRhcHQ9MSBiX2JpYXM9MCBkaXJlY3Q9MSB3ZWlnaHRiPTEgb3Blbl9nb3A9MCB3ZWlnaHRwPTEga2V5aW50PTMwMCBrZXlpbnRfbWluPTMwIHNjZW5lY3V0PTQwIGludHJhX3JlZnJlc2g9MCByY19sb29rYWhlYWQ9MzAgcmM9Y3JmIG1idHJlZT0xIGNyZj0yMi4wIHFjb21wPTAuNjAgcXBtaW49MCBxcG1heD02OSBxcHN0ZXA9NCB2YnZfbWF4cmF0ZT0yMDAwMCB2YnZfYnVmc2l6ZT0yNTAwMCBjcmZfbWF4PTAuMCBuYWxfaHJkPW5vbmUgZmlsbGVyPTAgaXBfcmF0aW89MS40MCBhcT0xOjEuMDAAgAAAABRliIQAK//+9q78yyt0fpUs1YVPgQAAAAhBmiFsQn/+Vg=="),
        vid.play(),
        vid.addEventListener("canplaythrough", (_) => {
          vid.paused && _this.mobile && (_this.mobile.lowPowerMode = !0),
            setTimeout((_) => vid.pause(), 500);
        }),
        !!vid.canPlayType &&
          (vid.canPlayType("video/webm;") ? "webm" : "mp4"))),
      (this.media.webrtc = !!(
        window.webkitRTCPeerConnection ||
        window.mozRTCPeerConnection ||
        window.msRTCPeerConnection ||
        window.oRTCPeerConnection ||
        window.RTCPeerConnection
      )),
      (this.graphics = {}),
      (this.graphics.webgl = (function () {
        let DISABLED = !1;
        Object.defineProperty(_this.graphics, "webgl", {
          get: () => {
            if (DISABLED) return !1;
            if (_this.graphics._webglContext)
              return _this.graphics._webglContext;
            try {
              const names = ["webgl2", "webgl", "experimental-webgl"],
                canvas = document.createElement("canvas");
              let gl;
              for (
                let i = 0;
                i < names.length &&
                (("webgl2" === names[i] && Utils.query("compat")) ||
                  ((gl = canvas.getContext(names[i])), !gl));
                i++
              );
              let output = { gpu: "unknown" };
              if (
                ((output.renderer = gl.getParameter(gl.RENDERER).toLowerCase()),
                (output.version = gl.getParameter(gl.VERSION).toLowerCase()),
                (output.glsl = gl
                  .getParameter(gl.SHADING_LANGUAGE_VERSION)
                  .toLowerCase()),
                (output.extensions = gl.getSupportedExtensions()),
                (output.webgl2 = output.version.includes([
                  "webgl 2",
                  "webgl2",
                ])),
                (output.canvas = canvas),
                (output.context = gl),
                "firefox" === _this.system.browser &&
                  _this.system.browserVersion >= 92)
              )
                output.gpu = output.renderer;
              else {
                let info = gl.getExtension("WEBGL_debug_renderer_info");
                if (info) {
                  let gpu = info.UNMASKED_RENDERER_WEBGL;
                  output.gpu = gl.getParameter(gpu).toLowerCase();
                }
              }
              return (
                (output.detect = function (matches) {
                  if (output.gpu && output.gpu.toLowerCase().includes(matches))
                    return !0;
                  if (
                    output.version &&
                    output.version.toLowerCase().includes(matches)
                  )
                    return !0;
                  for (let i = 0; i < output.extensions.length; i++)
                    if (output.extensions[i].toLowerCase().includes(matches))
                      return !0;
                  return !1;
                }),
                output.webgl2 ||
                  output.detect("instance") ||
                  window.AURA ||
                  (DISABLED = !0),
                (_this.graphics._webglContext = output),
                output
              );
            } catch (e) {
              return !1;
            }
          },
          set: (v) => {
            !1 === v && (DISABLED = !0);
          },
        });
      })()),
      (this.graphics.metal = (function () {
        if (!window.Metal) return !1;
        let output = {};
        return (
          (output.gpu = Metal.device.getName().toLowerCase()),
          (output.detect = function (matches) {
            return output.gpu.includes(matches);
          }),
          output
        );
      })()),
      (this.graphics.gpu = (function () {
        if (!_this.graphics.webgl && !_this.graphics.metal) return !1;
        let output = {};
        return (
          ["metal", "webgl"].forEach((name) => {
            _this.graphics[name] &&
              !output.identifier &&
              ((output.detect = _this.graphics[name].detect),
              (output.identifier = _this.graphics[name].gpu));
          }),
          output
        );
      })()),
      (this.graphics.canvas = !!document.createElement("canvas").getContext);
    const checkForStyle = (function () {
      let _tagDiv;
      return function (prop) {
        _tagDiv = _tagDiv || document.createElement("div");
        const vendors = ["Khtml", "ms", "O", "Moz", "Webkit"];
        if (prop in _tagDiv.style) return !0;
        prop = prop.replace(/^[a-z]/, (val) => val.toUpperCase());
        for (let i = vendors.length - 1; i >= 0; i--)
          if (vendors[i] + prop in _tagDiv.style) return !0;
        return !1;
      };
    })();
    (this.styles = {}),
      (this.styles.filter = checkForStyle("filter")),
      (this.styles.blendMode = checkForStyle("mix-blend-mode")),
      (this.tween = {}),
      (this.tween.transition = checkForStyle("transition")),
      (this.tween.css2d = checkForStyle("transform")),
      (this.tween.css3d = checkForStyle("perspective")),
      (this.social = _this.agent.includes("instagram")
        ? "instagram"
        : _this.agent.includes("fban") ||
          _this.agent.includes("fbav") ||
          _this.agent.includes("fbios")
        ? "facebook"
        : (_this.agent.includes("twitter") ||
            !(!document.referrer || !document.referrer.includes("//t.co/"))) &&
          "twitter");
  }, "Static"),
  Class(function Component() {
    Inherit(this, Events);
    const _this = this,
      _setters = {},
      _flags = {},
      _timers = [],
      _loops = [];
    var _onDestroy, _appStateBindings;
    function defineSetter(_this, prop) {
      (_setters[prop] = {}),
        Object.defineProperty(_this, prop, {
          set(v) {
            _setters[prop] &&
              _setters[prop].s &&
              _setters[prop].s.call(_this, v),
              (v = null);
          },
          get() {
            if (_setters[prop] && _setters[prop].g)
              return _setters[prop].g.apply(_this);
          },
        });
    }
    (this.classes = {}),
      (this.findParent = function (type) {
        let p = _this.parent;
        for (; p; ) {
          if (
            (p._cachedName || (p._cachedName = Utils.getConstructorName(p)),
            p._cachedName == type)
          )
            return p;
          p = p.parent;
        }
      }),
      (this.set = function (prop, callback) {
        _setters[prop] || defineSetter(this, prop),
          (_setters[prop].s = callback);
      }),
      (this.get = function (prop, callback) {
        _setters[prop] || defineSetter(this, prop),
          (_setters[prop].g = callback);
      }),
      (this.isPlayground = function (name) {
        return (
          Global.PLAYGROUND &&
          Global.PLAYGROUND == (name || Utils.getConstructorName(_this))
        );
      }),
      (this.initClass = function (clss) {
        if (!clss) throw (console.trace(), "unable to locate class");
        const args = [].slice.call(arguments, 1),
          child = Object.create(clss.prototype);
        if (
          ((child.parent = this),
          (child.__afterInitClass = []),
          clss.apply(child, args),
          child.destroy)
        ) {
          const id = Utils.timestamp();
          (this.classes[id] = child), (this.classes[id].__id = id);
        }
        if (child.element) {
          const last = arguments[arguments.length - 1];
          Array.isArray(last) &&
          1 == last.length &&
          last[0] instanceof HydraObject
            ? last[0].add(child.element)
            : this.element &&
              this.element.add &&
              null !== last &&
              this.element.add(child.element);
        }
        if (child.group) {
          const last = arguments[arguments.length - 1];
          this.group && null !== last && this.group.add(child.group);
        }
        return (
          child.__afterInitClass.forEach((callback) => {
            callback();
          }),
          delete child.__afterInitClass,
          child
        );
      }),
      (this.delayedCall = function (callback, time, scaledTime) {
        const timer = Timer.create(
          () => {
            _this && _this.destroy && callback && callback();
          },
          time,
          scaledTime
        );
        return (
          _timers.push(timer), _timers.length > 50 && _timers.shift(), timer
        );
      }),
      (this.clearTimers = function () {
        for (let i = _timers.length - 1; i >= 0; i--) clearTimeout(_timers[i]);
        _timers.length = 0;
      }),
      (this.startRender = function (callback, fps, obj) {
        "number" != typeof fps && ((obj = fps), (fps = void 0));
        for (let i = 0; i < _loops.length; i++)
          if (_loops[i].callback == callback) return;
        let flagInvisible = (_) => {
            _this._invisible ||
              ((_this._invisible = !0),
              _this.onInvisible && _this.onInvisible());
          },
          loop = (a, b, c, d) => {
            if (!_this.startRender) return !1;
            let p = _this;
            for (; p; ) {
              if (!1 === p.visible) return flagInvisible();
              if (p.group && !1 === p.group.visible) return flagInvisible();
              p = p.parent;
            }
            !1 !== _this._invisible &&
              ((_this._invisible = !1), _this.onVisible && _this.onVisible());
            try {
              callback(a, b, c, d);
            } catch (error) {
              let evt = {
                callback: callback,
                error: error,
                component: _this,
                preventStopRender: !1,
              };
              Events.emitter._fireEvent(Render.RENDER_CALLBACK_ERROR, evt),
                evt.preventStopRender || _this.stopRender(callback, obj);
            }
            return !0;
          };
        _loops.push({ callback: callback, loop: loop }),
          obj
            ? obj == RenderManager.NATIVE_FRAMERATE
              ? Render.start(loop, null, !0)
              : RenderManager.schedule(loop, obj)
            : Render.start(loop, fps);
      }),
      (this.onResize = function (callback, callInitial = !0) {
        callInitial && callback(), this.events.sub(Events.RESIZE, callback);
      }),
      (this.stopRender = function (callback, obj) {
        for (let i = 0; i < _loops.length; i++)
          if (_loops[i].callback == callback) {
            let loop = _loops[i].loop;
            obj && RenderManager.unschedule(loop, obj),
              Render.stop(loop),
              _loops.splice(i, 1);
          }
      }),
      (this.clearRenders = function () {
        for (let i = 0; i < _loops.length; i++) Render.stop(_loops[i].loop);
        _loops.length = 0;
      }),
      (this.wait = function (object, key, callback) {
        const promise = Promise.create();
        let condition;
        if (
          ("string" == typeof object &&
            ((callback = key), (key = object), (object = _this)),
          "number" == typeof object && 1 === arguments.length)
        )
          return _this.delayedCall(promise.resolve, object), promise;
        if (
          ("function" == typeof object &&
            1 === arguments.length &&
            ((condition = object), (object = _this)),
          "function" == typeof object && "string" == typeof callback)
        ) {
          let _object = object;
          (object = key), (key = callback), (callback = _object);
        }
        if (
          ((callback = callback || promise.resolve),
          condition ||
            ("!" === key?.charAt?.(0)
              ? ((key = key.slice(1)),
                (condition = () =>
                  !(
                    object[key] ||
                    ("function" == typeof object.flag && object.flag(key))
                  )))
              : (condition = () =>
                  !!object[key] ||
                  !("function" != typeof object.flag || !object.flag(key)))),
          condition())
        )
          callback();
        else {
          Render.start(function test() {
            if (!object || !_this.flag || null === object.destroy)
              return Render.stop(test);
            condition() && (callback(), Render.stop(test));
          });
        }
        return promise;
      }),
      (this.bindState = function (appState, key, ...rest) {
        if (appState.then)
          return (async () => _this.bindState(await appState, key, ...rest))();
        "object" != typeof appState ||
          appState.constructor !== Object ||
          appState.isAppState ||
          (appState = AppState.createLocal(appState)),
          _appStateBindings || (_appStateBindings = []);
        let binding = (appState._bind || appState.bind).bind(appState)(
          key,
          ...rest
        );
        return (
          _appStateBindings.push(binding),
          binding._bindOnDestroy(() => {
            _appStateBindings.remove(binding);
          }),
          binding
        );
      }),
      (this.flag = function (name, value, time) {
        if (void 0 === value) return _flags[name];
        (_flags[name] = value),
          time &&
            (clearTimeout(_flags[`${name}_timer`]),
            (_flags[`${name}_timer`] = this.delayedCall(() => {
              _flags[name] = !_flags[name];
            }, time)));
      }),
      (this.destroy = function () {
        this.removeDispatch && this.removeDispatch(),
          this.onDestroy && this.onDestroy(),
          this.fxDestroy && this.fxDestroy(),
          _onDestroy && _onDestroy.forEach((cb) => cb());
        for (let id in this.classes) {
          var clss = this.classes[id];
          clss && clss.destroy && clss.destroy();
        }
        if (
          ((this.classes = null),
          this.clearRenders && this.clearRenders(),
          this.clearTimers && this.clearTimers(),
          this.element &&
            window.GLUI &&
            this.element instanceof GLUIObject &&
            this.element.remove(),
          this.events && (this.events = this.events.destroy()),
          this.parent &&
            this.parent.__destroyChild &&
            this.parent.__destroyChild(this.__id),
          _appStateBindings)
        )
          for (; _appStateBindings.length > 0; )
            _appStateBindings[_appStateBindings.length - 1].destroy?.();
        return Utils.nullObject(this);
      }),
      (this._bindOnDestroy = function (cb) {
        _onDestroy || (_onDestroy = []), _onDestroy.push(cb);
      }),
      (this.__destroyChild = function (name) {
        delete this.classes[name];
      }),
      (this.navigate = function (route) {
        let p = _this.parent;
        for (; p; ) p.navigate && p.navigate(route), (p = p.parent);
      });
  }),
  Class(function Model() {
    Inherit(this, Component), Namespace(this);
    const _this = this,
      _storage = {},
      _requests = {};
    let _data = 0,
      _triggered = 0;
    (this.push = function (name, val) {
      _storage[name] = val;
    }),
      (this.pull = function (name) {
        return _storage[name];
      }),
      (this.waitForData = this.promiseData =
        function (num = 1) {
          _data += num;
        }),
      (this.fulfillData = this.resolveData =
        function () {
          _triggered++, _triggered == _data && (_this.dataReady = !0);
        }),
      (this.ready = function (callback) {
        let promise = Promise.create();
        return (
          callback && promise.then(callback),
          _this.wait(_this, "dataReady").then(promise.resolve),
          promise
        );
      }),
      (this.initWithData = function (data) {
        for (var key in ((_this.STATIC_DATA = data), _this)) {
          var model = _this[key],
            init = !1;
          for (var i in data)
            i.toLowerCase().replace(/-/g, "") == key.toLowerCase() &&
              ((init = !0), model.init && model.init(data[i]));
          !init && model.init && model.init();
        }
        _this.init && _this.init(data);
      }),
      (this.loadData = function (url, callback) {
        let promise = Promise.create();
        callback || (callback = promise.resolve);
        var _this = this;
        return (
          get(`${url}?${Utils.timestamp()}`).then((d) => {
            defer(() => {
              _this.initWithData(d), callback(d);
            });
          }),
          promise
        );
      }),
      (this.handleRequest = function (type, callback) {
        _requests[type] = callback;
      }),
      (this.makeRequest = async function (type, data, mockData = {}) {
        if (!_requests[type])
          return (
            console.warn(
              `Missing data handler for ${type} with mockData`,
              mockData
            ),
            Array.isArray(mockData)
              ? new StateArray(mockData)
              : AppState.createLocal(mockData)
          );
        let result = await _requests[type](data, mockData);
        if (!(result instanceof StateArray || result.createLocal))
          throw `makeRequest ${type} must return either an AppState or StateArray`;
        return result;
      }),
      (this.request = async function (type, data, mockData) {
        if (
          ("function" == typeof data && ((mockData = data), (data = null)),
          mockData && (mockData = mockData()),
          !_requests[type])
        )
          return Array.isArray(mockData)
            ? new StateArray(mockData)
            : AppState.createLocal(mockData);
        let result = await _requests[type](data, mockData);
        if (
          (Array.isArray(result)
            ? (result = new StateArray(result))
            : "object" == typeof result &&
              (result = AppState.createLocal(result)),
          !(result instanceof StateArray || result.createLocal))
        )
          throw `makeRequest ${type} must return either an AppState or StateArray`;
        return result;
      });
  }),
  Class(function Data() {
    Inherit(this, Model);
  }, "static"),
  Class(function Modules() {
    const _modules = {},
      _constructors = {};
    function exec() {
      for (let m in _modules)
        for (let key in _modules[m]) {
          let module = _modules[m][key];
          module._ready || ((module._ready = !0), module.exec && module.exec());
        }
    }
    defer(exec),
      (this.Module = function (module) {
        let m = new module(),
          name = module
            .toString()
            .slice(0, 100)
            .match(/function ([^\(]+)/);
        name
          ? ((m._ready = !0),
            (name = name[1]),
            (_modules[name] = { index: m }),
            (_constructors[name] = module))
          : (_modules[m.module] || (_modules[m.module] = {}),
            (_modules[m.module][m.path] = m));
      }),
      (this.require = function (path) {
        let root;
        return (
          path.includes("/")
            ? ((root = path.split("/")[0]),
              (path = path.replace(`${root}/`, "")))
            : ((root = path), (path = "index")),
          (function requireModule(root, path) {
            let module = _modules[root];
            if (!module) throw `Module ${root} not found`;
            return (
              (module = module[path]),
              module._ready ||
                ((module._ready = !0), module.exec && module.exec()),
              module
            );
          })(root, path).exports
        );
      }),
      (this.getConstructor = function (name) {
        return _constructors[name];
      }),
      (this.modulesReady = async function () {
        let modules = [...arguments].flat();
        await Promise.all(modules.map((name) => Modules.moduleReady(name)));
      }),
      (this.moduleReady = function (name) {
        let promise = Promise.create(),
          check = function () {
            _modules[name] && (Render.stop(check), promise.resolve());
          };
        return Render.start(check), promise;
      }),
      (window.Module = this.Module),
      window._NODE_ ||
        ((window.requireNative = window.require),
        (window.require = this.require));
  }, "Static"),
  Class(function StateWrapper(_array) {
    const _this = this;
    Inherit(this, Component),
      (this.bind = this.listen =
        function (key, callback) {
          _array.forEach(async (obj) => {
            await obj.wait("__ready"),
              _this.bindState(obj.state, key, (data) => {
                callback({ target: obj, data: data });
              });
          });
        });
  }),
  Class(function StateInitializer(Class, _ref, _params, _stateRef) {
    Inherit(this, Component);
    const _this = this;
    function onInit(bool) {
      _this.parent[_ref] = bool
        ? _this.parent.initClass(Class, _params)
        : _this.parent[_ref].destroy();
    }
    async function onInit3D() {
      let ref = _this.parent[_ref];
      await _this.wait((_) => ref);
      let next = await Initializer3D.queue();
      await Initializer3D.uploadAllAsync(ref.layout || ref.scene || ref.group),
        next();
    }
    (this.ref = _ref),
      (function () {
        if (!_stateRef.init) throw "StateInitializer required init parameter";
        _stateRef.init && _this.bindState(AppState, _stateRef.init, onInit),
          _stateRef.init3d &&
            _this.bindState(AppState, _stateRef.init3d, onInit3D);
      })(),
      (this.force = function () {
        AppState.set(_stateRef.init, !0);
      });
  }),
  Class(function FragUIHelper(_obj, _root) {
    Inherit(this, Component);
    const _this = this;
    function isLowerCase(str) {
      return str == str.toLowerCase();
    }
    function findStateObject(text) {
      return text.match(/\$(.*)\./)[1];
    }
    function getPropByString(obj, propString) {
      if (!propString) return obj;
      for (
        var props = propString.split("."), i = 0, iLen = props.length - 1;
        i < iLen;
        i++
      ) {
        var candidate = obj[props[i]];
        if (void 0 === candidate) break;
        obj = candidate;
      }
      return obj[props[i]];
    }
    function parseTextBindings(text) {
      let binds = [];
      for (; text.match(/\$(.*)\./); ) {
        let match = text.match(/\$(.*)\./),
          split = text.split(match[0]);
        (split[0] = `${split[0]}@[`), (split[1] = split[1].split(" "));
        let name = split[1][0];
        (split[1][0] += "]"),
          (split[1] = split[1].join(" ")),
          (text = split.join("")),
          binds.push(name);
      }
      return [binds, text];
    }
    function parseTextGlobalBindings(text) {
      let binds = [];
      for (; text.match(/\$(\w*)\/(\w*)/); ) {
        let match = text.match(/\$(\w*)\/(\w*)/),
          split = text.split(match[0]);
        (split[0] = `${split[0]}@[`), (split[1] = split[1].split(" "));
        let name = match[0].slice(1).trim();
        (split[1][0] = name),
          (split[1][0] += "]"),
          (split[1] = split[1].join(" ")),
          (text = split.join("")),
          binds.push(name);
      }
      return [binds, text];
    }
    function parseCSSTransformStr(obj) {
      let data = {};
      return (
        obj.split(",").forEach((param) => {
          let [a, b] = param.split(":");
          (a = a.trim()),
            (b = b.trim()),
            isNaN(b) || (b = Number(b)),
            (data[a] = b);
        }),
        data
      );
    }
    function doConstructor(obj) {
      switch (obj._type) {
        case "UI":
          return _this.parent.element || _this.parent.getDOMElement?.();
        case "GLObject":
        case "glObject":
        case "glObj":
          if (obj.width && obj.height && obj.bg) {
            let tempObj = $gl(Number(obj.width), Number(obj.height), obj.bg);
            return delete obj.bg, tempObj;
          }
          return $gl();
        case "GLText":
        case "glText":
          if (obj._innerText.match?.(/\$(.*)\./)) {
            let $text = $glText(
                obj._innerText,
                obj.font,
                Number(obj.fontSize),
                { color: obj.fontColor, width: obj.width }
              ),
              state = findStateObject(obj._innerText),
              ref = state;
            if (ref.includes(".")) {
              let split = state.split(".");
              (ref = split[0]), split.shift(), (state = split.join("."));
            }
            return (
              _this.wait(_this.parent, ref).then((_) => {
                let [binds, text] = parseTextBindings(obj._innerText);
                $obj.html(text),
                  _this.parent.bindState(
                    ref == state
                      ? _this.parent[ref]
                      : getPropByString(_this.parent[ref], state),
                    binds,
                    $obj
                  );
              }),
              $text
            );
          }
          if (obj._innerText.match?.(/\$(\w*)\/(\w*)/)) {
            let [binds, text] = parseTextGlobalBindings(obj._innerText),
              $text = $glText(text, obj.font, Number(obj.fontSize), {
                color: obj.fontColor,
                width: obj.width,
              });
            return _this.parent.bindState(AppState, binds, $text), $text;
          }
          return $glText(obj._innerText, obj.font, Number(obj.fontSize), {
            color: obj.fontColor,
            width: obj.width,
          });
        default:
          let $obj = $(
            obj.className || obj.refName || "h",
            "HydraObject" != obj._type ? obj._type : "div"
          );
          if (
            (obj.width && obj.height && $obj.size(obj.width, obj.height),
            obj.font &&
              $obj.fontStyle(obj.font, Number(obj.fontSize), obj.fontColor),
            obj._innerText)
          )
            if (obj._innerText.match?.(/\$(.*)\./)) {
              let state = findStateObject(obj._innerText),
                ref = state;
              if (ref.includes(".")) {
                let split = state.split(".");
                (ref = split[0]), split.shift(), (state = split.join("."));
              }
              _this.wait(_this.parent, ref).then((_) => {
                let [binds, text] = parseTextBindings(obj._innerText);
                $obj.html(text),
                  _this.parent.bindState(
                    ref == state
                      ? _this.parent[ref]
                      : getPropByString(_this.parent[ref], state),
                    binds,
                    $obj
                  );
              });
            } else if (obj._innerText.match?.(/\$(\w*)\/(\w*)/)) {
              let [binds, text] = parseTextGlobalBindings(obj._innerText);
              $obj.html(text), _this.parent.bindState(AppState, binds, $obj);
            } else $obj.html(obj._innerText);
          return $obj;
      }
    }
    function applyValues(obj, $obj) {
      const invalidDomAttrs = ["refname", "refname", "_innertext", "_type"],
        callObjKeyVal = (key) =>
          new Promise((resolve) => {
            const applyValue = (val) => {
                "function" == typeof $obj[key]
                  ? $obj[key](val)
                  : ($obj instanceof HydraObject &&
                      (invalidDomAttrs.includes(key.toLowerCase()) ||
                        $obj.attr(key, val)),
                    ($obj[key] = val));
              },
              callFn = async () => {
                let val = isNaN(obj[key]) ? obj[key] : Number(obj[key]);
                if ("string" == typeof val) {
                  if (val.match(/\$(.*)\./)) {
                    let stateStr = findStateObject(val),
                      state = _this.parent[stateStr];
                    state ||
                      (await _this.wait(_this.parent, stateStr),
                      (state = _this.parent[stateStr])),
                      state.then && (state = await state);
                    let [binds] = parseTextBindings(val);
                    return _this.parent.bindState(state, binds, (dataVal) =>
                      applyValue(dataVal)
                    );
                  }
                  if (val.match(/\$(\w*)\/(\w*)/)) {
                    let [binds] = parseTextGlobalBindings(val);
                    return _this.parent.bindState(AppState, binds, (dataVal) =>
                      applyValue(dataVal)
                    );
                  }
                  if (val.startsWith("$") && "$element" != val)
                    return applyValue(_this.parent[val.slice(1)]);
                }
                applyValue(val);
              };
            if (_this.parent.__afterInitClass)
              return _this.parent.__afterInitClass.push(() =>
                resolve(callFn())
              );
            resolve(callFn());
          });
      for (let key in obj) {
        if ("shader" == key) {
          let shader = _this.initClass(Shader, obj[key], {
            tMap: { value: null },
          });
          window[shader.vsName] && window[shader.vsName]({}, shader),
            $obj.useShader(shader);
        }
        if (
          (obj.width &&
            obj.height &&
            $obj.size &&
            $obj.size(
              isNaN(obj.width) ? obj.width : Number(obj.width),
              isNaN(obj.height) ? obj.height : Number(obj.height)
            ),
          "css" == key || "transform" == key)
        )
          $obj[key](parseCSSTransformStr(obj[key]));
        else if ("onClick" == key || "onHover" == key)
          _this
            .wait((_) => !!_this.parent[obj[key].slice(1)])
            .then((_) => {
              const interactHandle = _this.parent[obj[key].slice(1)];
              let hoverFn = "onHover" === key ? interactHandle : null,
                clickFn = "onClick" === key ? interactHandle : null;
              $obj.interact(hoverFn, clickFn, obj.seoLink, obj.seoText);
            });
        else if ("function" == typeof $obj[key]) {
          if ("size" == key) {
            let size = obj.size.split(",");
            size.map((x) => Number(x)), $obj.size(size[0], size[1]);
            continue;
          }
          1 === obj[key] && (obj[key] = void 0), callObjKeyVal(key);
        } else callObjKeyVal(key);
      }
    }
    function convertToUsableRef(str) {
      str.startsWith("$") && (str = str.slice(1));
      let ref = str,
        state = str;
      if (str.includes(".")) {
        let split = str.split(".");
        (state = split[0]), split.shift(), (ref = split.join("."));
      }
      return [state, ref];
    }
    async function create(obj, parent) {
      if (
        !isLowerCase(obj._type) &&
        "GLObject" != obj._type &&
        "HydraObject" != obj._type &&
        "GLText" != obj._type &&
        "UI" != obj._type &&
        "glText" != obj._type &&
        "glObject" != obj._type &&
        "glObj" != obj._type
      ) {
        let params = {};
        for (let key in obj)
          if (
            "_type" != key &&
            "refName" != key &&
            "children" != key &&
            "display" != key
          )
            if (((params[key] = obj[key]), params[key].match?.(/\$(.*)\./))) {
              await defer();
              let [state, ref] = convertToUsableRef(params[key]);
              params[key] =
                state == ref
                  ? _this.parent[state]
                  : _this.parent[ref]
                  ? _this.parent[ref]
                  : getPropByString(_this.parent[state], ref);
            } else
              params[key].startsWith("$") &&
                (await defer(),
                (params[key] = _this.parent[params[key].slice(1)]));
        return (
          "ViewState" == obj._type && (params.__parent = parent),
          (_this.parent[obj.refName] = _this.parent.initClass(
            window[obj._type],
            AppState.createLocal(params, !0),
            [parent.element || parent]
          )),
          obj.children.forEach((o) => create(o, _this.parent[obj.refName])),
          void (
            params.css &&
            _this.parent[obj.refName].element.css(
              parseCSSTransformStr(params.css)
            )
          )
        );
      }
      let $obj = doConstructor(obj);
      if (obj.addTo) {
        let addTo = obj.addTo.includes(".")
          ? eval(obj.addTo)
          : _this.parent.element;
        addTo.add($obj);
      } else parent && parent.add($obj);
      applyValues(obj, $obj),
        $obj.transform?.(),
        obj.refName && (_this.parent[obj.refName] = $obj),
        obj.children.forEach((o) => create(o, $obj));
    }
    _obj.addTo || "UI" == _obj._type || (_obj.addTo = "$element"),
      _root && applyValues(_root, _this.parent.element),
      create(_obj);
  }),
  Class(function XComponent() {
    const _this = this;
    (_this.fragName = "overwritten in descendent"),
      (_this.contexts = "overwritten in descendent"),
      (async function () {})(),
      (_this.help = function () {
        console.groupCollapsed(`Fragment ${_this.fragName} Overview`),
          console.log(`Your context(s) are: ${_this.contexts}`),
          console.log("You have access to the following $ methods:");
        for (let key in _this)
          "_" != key.charAt(0) &&
            (key.includes([
              "flag",
              "initClass",
              "classes",
              "events",
              "parent",
              "findParent",
              "bindState",
            ]) ||
              console.log(`$${key}`));
        console.groupEnd();
      }),
      (_this.set = function (key, value) {
        void 0 === value && (value = Utils.uuid()),
          key.includes("/") || (key = `${_this.fragName}/${key}`),
          AppState.set(key, value);
      }),
      (_this.fire = function (key, value) {
        key.includes("/") || (key = `${_this.fragName}/${key}`),
          AppState.set(key, value, !0);
      }),
      (_this.bind = _this.listen =
        function (key, callback, ref) {
          if ("function" == typeof ref && "string" == typeof callback) {
            let rref = key;
            (key = callback), (callback = ref), (ref = rref);
          }
          ref
            ? ref.isAppState
              ? _this.bindState(ref, key, callback)
              : _this.events.sub(ref, key, callback)
            : (key.includes("/") || (key = `${_this.fragName}/${key}`),
              _this.bindState(AppState, key, callback));
        }),
      (_this.get = function (key) {
        return (
          key.includes("/") || (key = `${_this.fragName}/${key}`),
          AppState.get(key)
        );
      }),
      (_this.createState = function () {
        _this.state ||
          ((_this.state = AppState.createLocal()),
          (_this.state._bind = _this.state.bind),
          (_this.state.bind = function (key, callback) {
            _this.bindState(state, key, callback);
          }),
          (_this.state.fire = function (key, value) {
            _this.state.set(key, value, !0);
          }),
          AppState.set(`${_this.fragName}/state`, _this.state),
          _this._bindOnDestroy((_) => {
            AppState.set(`${_this.fragName}/state`, null);
          }));
      });
  }),
  Class(function LinkedList() {
    var prototype = LinkedList.prototype;
    (this.length = 0),
      (this.first = null),
      (this.last = null),
      (this.current = null),
      (this.prev = null),
      void 0 === prototype.push &&
        ((prototype.push = function (obj) {
          this.first
            ? ((obj.__next = this.first),
              (obj.__prev = this.last),
              (this.last.__next = obj),
              (this.last = obj))
            : ((this.first = obj),
              (this.last = obj),
              (obj.__prev = obj),
              (obj.__next = obj)),
            this.length++;
        }),
        (prototype.remove = function (obj) {
          obj &&
            obj.__next &&
            (this.length <= 1
              ? this.empty()
              : (obj == this.first
                  ? ((this.first = obj.__next),
                    (this.last.__next = this.first),
                    (this.first.__prev = this.last))
                  : obj == this.last
                  ? ((this.last = obj.__prev),
                    (this.last.__next = this.first),
                    (this.first.__prev = this.last))
                  : ((obj.__prev.__next = obj.__next),
                    (obj.__next.__prev = obj.__prev)),
                this.length--),
            (obj.__prev = null),
            (obj.__next = null));
        }),
        (prototype.empty = function () {
          (this.first = null),
            (this.last = null),
            (this.current = null),
            (this.prev = null),
            (this.length = 0);
        }),
        (prototype.start = function () {
          return (
            (this.current = this.first),
            (this.prev = this.current),
            this.current
          );
        }),
        (prototype.next = function () {
          if (
            this.current &&
            ((this.current = this.current.__next),
            1 != this.length && this.prev.__next != this.first)
          )
            return (this.prev = this.current), this.current;
        }),
        (prototype.destroy = function () {
          return Utils.nullObject(this), null;
        }));
  }),
  Class(function ObjectPool(_type, _number = 10) {
    var _pool = [];
    (this.array = _pool),
      (function () {
        if (_type) for (var i = 0; i < _number; i++) _pool.push(new _type());
      })(),
      (this.get = function () {
        return _pool.shift() || (_type ? new _type() : null);
      }),
      (this.empty = function () {
        _pool.length = 0;
      }),
      (this.put = function (obj) {
        obj && !_pool.includes(obj) && _pool.push(obj);
      }),
      (this.insert = function (array) {
        void 0 === array.push && (array = [array]);
        for (var i = 0; i < array.length; i++) this.put(array[i]);
      }),
      (this.length = function () {
        return _pool.length;
      }),
      (this.randomize = function () {
        let array = _pool;
        for (let i = array.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          [array[i], array[j]] = [array[j], array[i]];
        }
      }),
      (this.destroy = function () {
        for (let i = _pool.length - 1; i >= 0; i--)
          _pool[i].destroy && _pool[i].destroy();
        return (_pool = null);
      });
  }),
  Class(function Gate() {
    var _list = [],
      _map = {};
    (this.create = function (name) {
      let promise = Promise.create();
      name ? (_map[name] = promise) : _list.push(promise);
    }),
      (this.open = function (name) {
        name &&
          (_map[name] || (_map[name] = Promise.create()), _map[name].resolve());
        let promise = _list.shift();
        promise && promise.resolve();
      }),
      (this.wait = function (name) {
        return _list.length || name
          ? name
            ? (_map[name] || (_map[name] = Promise.create()), _map[name])
            : _list[_list.length - 1] || Promise.resolve()
          : Promise.resolve();
      });
  }, "static"),
  Class(function Assets() {
    const _this = this;
    function AssetList(arr) {
      return (arr.__proto__ = AssetList.prototype), arr;
    }
    (this.__loaded = []),
      (this.FLIPY = !0),
      (this.CDN = ""),
      (this.CORS = "anonymous"),
      (this.IMAGES = {}),
      (this.VIDEOS = {}),
      (this.AUDIOS = {}),
      (this.SDF = {}),
      (this.JSON = {
        push(prop, value) {
          (this[prop] = value),
            Object.defineProperty(this, prop, {
              get: () => JSON.parse(JSON.stringify(value)),
            });
        },
      }),
      Object.defineProperty(this.JSON, "push", {
        enumerable: !1,
        writable: !0,
      }),
      (this.SVG = {}),
      (AssetList.prototype = new Array()),
      (AssetList.prototype.filter = function (items) {
        for (let i = this.length - 1; i >= 0; i--)
          this[i].includes(items) || this.splice(i, 1);
        return this;
      }),
      (AssetList.prototype.exclude = function (items) {
        for (let i = this.length - 1; i >= 0; i--)
          this[i].includes(items) && this.splice(i, 1);
        return this;
      }),
      (AssetList.prototype.prepend = function (prefix) {
        for (let i = this.length - 1; i >= 0; i--) this[i] = prefix + this[i];
        return this;
      }),
      (AssetList.prototype.append = function (suffix) {
        for (let i = this.length - 1; i >= 0; i--) this[i] = this[i] + suffix;
        return this;
      }),
      (this.list = function () {
        return (
          window.ASSETS || console.warn("ASSETS list not available"),
          new AssetList(window.ASSETS.slice(0) || [])
        );
      }),
      (this.BASE_PATH = ""),
      (this.getPath = function (path) {
        if (path.includes("~")) return _this.BASE_PATH + path.replace("~", "");
        if (path.includes("//")) return path;
        if (
          ((path = (function parseResolution(path) {
            if (!window.ASSETS || !ASSETS.RES) return path;
            var res = ASSETS.RES[path],
              ratio = Math.min(Device.pixelRatio, 3);
            if (!res) return path;
            if (!res[`x${ratio}`]) return path;
            var split = path.split("/"),
              file = split[split.length - 1];
            return (
              (split = file.split(".")),
              path.replace(file, `${split[0]}-${ratio}x.${split[1]}`)
            );
          })(path)),
          _this.replacementPaths)
        )
          for (let pathKey in _this.replacementPaths)
            if (path.startsWith(pathKey))
              return (path = path.replace(
                pathKey,
                _this.replacementPaths[pathKey]
              ));
        if (_this.dictionary)
          for (let pathKey in _this.dictionary)
            if (_this.dictionary[pathKey].includes(path.split("?")[0]))
              return pathKey + path;
        return (
          this.CDN && !~path.indexOf(this.CDN) && (path = this.CDN + path), path
        );
      }),
      (this.registerPathReplacement = function (path, replacedPath) {
        _this.replacementPaths || (_this.replacementPaths = {}),
          (_this.replacementPaths[path] = replacedPath);
      }),
      (this.registerPath = function (path, assets) {
        _this.dictionary || (_this.dictionary = {}),
          (_this.dictionary[path] = assets);
      }),
      (this.loadImage = function (path, isStore) {
        var img = new Image();
        return (
          (img.crossOrigin = this.CORS),
          (img.src = _this.getPath(path)),
          (img.loadPromise = function () {
            let promise = Promise.create();
            return (img.onload = promise.resolve), promise;
          }),
          isStore && (this.IMAGES[path] = img),
          img
        );
      }),
      (this.decodeImage = function (path, params, promise) {
        promise || (promise = Promise.create());
        let img = _this.loadImage(path);
        return (
          (img.onload = () => promise.resolve(img)),
          (img.onerror = () =>
            _this.decodeImage(
              "assets/images/_scenelayout/uv.jpg",
              params,
              promise
            )),
          promise
        );
      });
    const _supportsWebP = (function () {
      try {
        return (
          0 ==
          document
            .createElement("canvas")
            .toDataURL("image/webp")
            .indexOf("data:image/webp")
        );
      } catch (e) {
        return !1;
      }
    })();
    (this.supportsWebP = function () {
      return !!_supportsWebP;
    }),
      (this.perfImage = function (path) {
        let result = path;
        return (
          _this.supportsWebP() &&
            path.includes([".jpg", ".png"]) &&
            (result = `${path.substring(0, path.lastIndexOf("."))}.webp`),
          result
        );
      });
  }, "static"),
  Class(
    function AssetLoader(_assets, _callback, ASSETS = Assets) {
      Inherit(this, Events);
      const _this = this;
      let _total = _assets.length,
        _loaded = 0,
        _lastFiredPercent = 0;
      function loadAsset() {
        let path = _assets.splice(_assets.length - 1, 1)[0];
        const name = path.split("assets/").last().split(".")[0],
          ext = path.split(".").last().split("?")[0].toLowerCase();
        let timeout = Timer.create(timedOut, AssetLoader.TIMEOUT, path);
        if (!Assets.preventCache && ~Assets.__loaded.indexOf(path))
          return loaded();
        if (ext.includes(["jpg", "jpeg", "png", "gif"])) {
          let image = ASSETS.loadImage(path);
          return image.complete
            ? loaded()
            : ((image.onload = loaded), void (image.onerror = loaded));
        }
        function loaded() {
          timeout && clearTimeout(timeout),
            increment(),
            _assets.length && loadAsset();
        }
        ext.includes(["mp4", "webm"])
          ? fetch(path)
              .then(async (response) => {
                let blob = await response.blob();
                (Assets.VIDEOS[name] = URL.createObjectURL(blob)), loaded();
              })
              .catch((e) => {
                console.warn(e), loaded();
              })
          : ext.includes(["mp3"])
          ? fetch(path)
              .then(async (response) => {
                let blob = await response.blob();
                (Assets.AUDIOS[name] = URL.createObjectURL(blob)), loaded();
              })
              .catch((e) => {
                console.warn(e), loaded();
              })
          : get(Assets.getPath(path), Assets.HEADERS)
              .then((data) => {
                Assets.__loaded.push(path),
                  "json" == ext && ASSETS.JSON.push(name, data),
                  "svg" == ext && (ASSETS.SVG[name] = data),
                  "fnt" == ext && (ASSETS.SDF[name.split("/")[1]] = data),
                  "js" == ext && window.eval(data),
                  ext.includes(["fs", "vs", "glsl"]) &&
                    window.Shaders &&
                    Shaders.parse(data, path),
                  loaded();
              })
              .catch((e) => {
                console.warn(e), loaded();
              });
      }
      function increment() {
        let percent = Math.max(
          _lastFiredPercent,
          Math.min(1, ++_loaded / _total)
        );
        _this.events.fire(Events.PROGRESS, { percent: percent }),
          (_lastFiredPercent = percent),
          _loaded >= _total && defer(complete);
      }
      function complete() {
        _this.completed ||
          ((_this.completed = !0),
          defer(() => {
            _callback && _callback(), _this.events.fire(Events.COMPLETE);
          }));
      }
      function timedOut(path) {
        console.warn("Asset timed out", path);
      }
      !(function () {
        if (!Array.isArray(_assets))
          throw "AssetLoader requires array of assets to load";
        (_assets = _assets.slice(0).reverse()),
          (function init() {
            if (!_assets.length) return complete();
            for (let i = 0; i < AssetLoader.SPLIT; i++)
              _assets.length && loadAsset();
          })();
      })(),
        (this.loadModules = function () {
          if (!window._BUILT_) return;
          this.add(1);
          let src = `assets/js/${window._ES5_ ? "es5-modules" : "modules"}.js?${
              window._CACHE_
            }`,
            s = document.createElement("link");
          return (
            (s.href = src),
            (s.rel = "preload"),
            (s.as = "script"),
            document.head.appendChild(s),
            (s = document.createElement("script")),
            (s.src = src),
            (s.async = !0),
            document.head.appendChild(s),
            AssetLoader.waitForLib("_MODULES_").then((_) => _this.trigger(1))
          );
        }),
        (this.add = function (num) {
          _total += num || 1;
        }),
        (this.trigger = function (num) {
          for (let i = 0; i < (num || 1); i++) increment();
        });
    },
    () => {
      (AssetLoader.SPLIT = 2),
        (AssetLoader.TIMEOUT = 5e3),
        (AssetLoader.loadAllAssets = function (callback) {
          let promise = Promise.create();
          return (
            callback || (callback = promise.resolve),
            (promise.loader = new AssetLoader(Assets.list(), () => {
              callback && callback(),
                promise.loader &&
                  promise.loader.destroy &&
                  (promise.loader = promise.loader.destroy());
            })),
            promise
          );
        }),
        (AssetLoader.loadAssets = function (list, callback) {
          let promise = Promise.create();
          return (
            callback || (callback = promise.resolve),
            (promise.loader = new AssetLoader(list, () => {
              callback && callback(),
                promise.loader &&
                  promise.loader.destroy &&
                  (promise.loader = promise.loader.destroy());
            })),
            promise
          );
        }),
        (AssetLoader.waitForLib = function (name, callback) {
          let promise = Promise.create();
          return (
            callback || (callback = promise.resolve),
            Render.start(function check() {
              window[name] && (Render.stop(check), callback && callback());
            }),
            promise
          );
        }),
        (AssetLoader.waitForModules = function () {
          return AssetLoader.waitForLib(
            window._BUILT_ ? "_MODULES_" : "zUtils3D"
          );
        });
    }
  ),
  (function (e, t) {
    "object" == typeof exports && "undefined" != typeof module
      ? t(exports)
      : "function" == typeof define && define.amd
      ? define(["exports"], t)
      : t(((e = e || self).goober = {}));
  })(this, function (e) {
    let t = { data: "" },
      n = (e) =>
        "undefined" != typeof window
          ? (
              (e ? e.querySelector("#_goober") : window._goober) ||
              Object.assign(
                (e || document.head).appendChild(
                  document.createElement("style")
                ),
                { innerHTML: " ", id: "_goober" }
              )
            ).firstChild
          : e || t,
      o = /(?:([A-Z0-9-%@]+) *:? *([^{;]+?);|([^;}{]*?) *{)|(})/gi,
      r = /\/\*[^]*?\*\/|\s\s+|\n/g,
      l = (e, t) => {
        let n,
          o = "",
          r = "",
          a = "";
        for (let s in e) {
          let c = e[s];
          "object" == typeof c
            ? ((n = t
                ? t.replace(/([^,])+/g, (e) =>
                    s.replace(/([^,])+/g, (t) =>
                      /&/.test(t) ? t.replace(/&/g, e) : e ? `${e} ${t}` : t
                    )
                  )
                : s),
              (r +=
                "@" == s[0]
                  ? "f" == s[1]
                    ? l(c, s)
                    : `${s}{${l(c, "k" == s[1] ? "" : t)}}`
                  : l(c, n)))
            : "@" == s[0] && "i" == s[1]
            ? (o = `${s} ${c};`)
            : ((s = s.replace(/[A-Z]/g, "-$&").toLowerCase()),
              (a += l.p ? l.p(s, c) : `${s}:${c};`));
        }
        return a[0] ? ((n = t ? `${t}{${a}}` : a), o + n + r) : o + r;
      },
      a = {},
      s = (e) => {
        let t = "";
        for (let n in e) t += n + ("object" == typeof e[n] ? s(e[n]) : e[n]);
        return t;
      },
      c = (e, t, n, c, i) => {
        let f = "object" == typeof e ? s(e) : e,
          p =
            a[f] ||
            (a[f] = ((e) => {
              let t = 0,
                n = 11;
              for (; t < e.length; ) n = (101 * n + e.charCodeAt(t++)) >>> 0;
              return `go${n}`;
            })(f));
        if (!a[p]) {
          let t =
            "object" == typeof e
              ? e
              : ((e) => {
                  let t,
                    n = [{}];
                  for (; (t = o.exec(e.replace(r, ""))); )
                    t[4] && n.shift(),
                      t[3]
                        ? n.unshift((n[0][t[3]] = n[0][t[3]] || {}))
                        : t[4] || (n[0][t[1]] = t[2]);
                  return n[0];
                })(e);
          a[p] = l(i ? { [`@keyframes ${p}`]: t } : t, n ? "" : `.${p}`);
        }
        return (
          ((e, t, n) => {
            -1 == t.data.indexOf(e) && (t.data = n ? e + t.data : t.data + e);
          })(a[p], t, c),
          p
        );
      };
    function f(e) {
      let t = this || {},
        o = e.call ? e(t.p) : e;
      return c(
        o.unshift
          ? o.raw
            ? ((e, t, n) =>
                e.reduce((e, o, r) => {
                  let a = t[r];
                  if (a && a.call) {
                    let e = a(n),
                      t =
                        (e && e.props && e.props.className) ||
                        (/^go/.test(e) && e);
                    a = t
                      ? `.${t}`
                      : e && "object" == typeof e
                      ? e.props
                        ? ""
                        : l(e, "")
                      : e;
                  }
                  return e + o + (null == a ? "" : a);
                }, ""))(o, [].slice.call(arguments, 1), t.p)
            : o.reduce(
                (e, n) => (n ? Object.assign(e, n.call ? n(t.p) : n) : e),
                {}
              )
          : o,
        n(t.target),
        t.g,
        t.o,
        t.k
      );
    }
    let p,
      d,
      u,
      g = f.bind({ g: 1 }),
      b = f.bind({ k: 1 });
    (e.css = f),
      (e.extractCss = (e) => {
        let t = n(e),
          o = t.data;
        return (t.data = ""), o;
      }),
      (e.glob = g),
      (e.keyframes = b),
      (e.setup = function (e, t, n, o) {
        (l.p = t), (p = e), (d = n), (u = o);
      }),
      (e.styled = function (e, t) {
        let n = this || {};
        return function () {
          let o = arguments;
          function r(l, a) {
            let s = { ...l },
              c = s.className || r.className;
            (n.p = { theme: d && d(), ...s }),
              (n.o = / *go\d+/.test(c)),
              (s.className = f.apply(n, o) + (c ? ` ${c}` : "")),
              t && (s.ref = a);
            let i = s.as || e;
            return u && i[0] && u(s), p(i, s);
          }
          return t ? t(r) : r;
        };
      });
  }),
  (function (i, n) {
    "object" == typeof exports && "undefined" != typeof module
      ? n(exports)
      : "function" == typeof define && define.amd
      ? define(["exports"], n)
      : n(((i = i || self).gooberPrefixer = {}));
  })(this, function (i) {
    var n = new Map([
      ["align-self", "-ms-grid-row-align"],
      ["color-adjust", "-webkit-print-color-adjust"],
      ["column-gap", "grid-column-gap"],
      ["gap", "grid-gap"],
      ["grid-template-columns", "-ms-grid-columns"],
      ["grid-template-rows", "-ms-grid-rows"],
      ["justify-self", "-ms-grid-column-align"],
      ["margin-inline-end", "-webkit-margin-end"],
      ["margin-inline-start", "-webkit-margin-start"],
      ["overflow-wrap", "word-wrap"],
      ["padding-inline-end", "-webkit-padding-end"],
      ["padding-inline-start", "-webkit-padding-start"],
      ["row-gap", "grid-row-gap"],
      ["scroll-margin-bottom", "scroll-snap-margin-bottom"],
      ["scroll-margin-left", "scroll-snap-margin-left"],
      ["scroll-margin-right", "scroll-snap-margin-right"],
      ["scroll-margin-top", "scroll-snap-margin-top"],
      ["scroll-margin", "scroll-snap-margin"],
      ["text-combine-upright", "-ms-text-combine-horizontal"],
    ]);
    i.prefix = function (i, r) {
      let t = "";
      const e = n.get(i);
      e && (t += `${e}:${r};`);
      const o = (function (i) {
        var n =
          /^(?:(text-(?:decoration$|e|or|si)|back(?:ground-cl|d|f)|box-d|(?:mask(?:$|-[ispro]|-cl)))|(tab-|column(?!-s)|text-align-l)|(ap)|(u|hy))/i.exec(
            i
          );
        return n ? (n[1] ? 1 : n[2] ? 2 : n[3] ? 3 : 5) : 0;
      })(i);
      1 & o && (t += `-webkit-${i}:${r};`),
        2 & o && (t += `-moz-${i}:${r};`),
        4 & o && (t += `-ms-${i}:${r};`);
      const a = (function (i, n) {
        var r =
          /^(?:(pos)|(background-i)|((?:max-|min-)?(?:block-s|inl|he|widt))|(dis))/i.exec(
            i
          );
        return r
          ? r[1]
            ? /^sti/i.test(n)
              ? 1
              : 0
            : r[2]
            ? /^image-/i.test(n)
              ? 1
              : 0
            : r[3]
            ? "-" === n[3]
              ? 2
              : 0
            : /^(inline-)?grid$/i.test(n)
            ? 4
            : 0
          : 0;
      })(i, r);
      return (
        1 & a
          ? (t += `${i}:-webkit-${r};`)
          : 2 & a
          ? (t += `${i}:-moz-${r};`)
          : 4 & a && (t += `${i}:-ms-${r};`),
        (t += `${i}:${r};`),
        t
      );
    };
  }),
  (function (e, o) {
    "object" == typeof exports && "undefined" != typeof module
      ? o(exports, require("goober"))
      : "function" == typeof define && define.amd
      ? define(["exports", "goober"], o)
      : o(((e = e || self).gooberGlobal = {}), e.goober);
  })(this, function (e, o) {
    let n = o.css.bind({ g: 1 });
    (e.createGlobalStyles = function () {
      const e = o.styled.call({ g: 1 }, "div").apply(null, arguments);
      return function (o) {
        return e(o), null;
      };
    }),
      (e.glob = n);
  }),
  Hydra.ready(function () {
    (window.__window = $(window)),
      (window.__document = $(document)),
      (window.__body = $(document.getElementsByTagName("body")[0])),
      (window.Stage =
        window.Stage && window.Stage.style
          ? $(window.Stage)
          : __body.create("#Stage")),
      Stage.size("100%"),
      (Stage.__useFragment = !0),
      (Stage.width =
        window.innerWidth ||
        document.body.clientWidth ||
        document.documentElement.offsetWidth),
      (Stage.height =
        window.innerHeight ||
        document.body.clientHeight ||
        document.documentElement.offsetHeight);
  }),
  Class(function HydraCSS() {
    var _tag,
      _obj,
      _style,
      _needsUpdate,
      _this = this;
    function objToCSS(key) {
      var match = key.match(/[A-Z]/),
        camelIndex = match ? match.index : null;
      if (camelIndex) {
        var start = key.slice(0, camelIndex),
          end = key.slice(camelIndex);
        key = `${start}-${end.toLowerCase()}`;
      }
      return key;
    }
    function setHTML() {
      (_tag.innerHTML = _style), (_needsUpdate = !1);
    }
    Hydra.ready(function () {
      (_obj = {}),
        (_style = ""),
        ((_tag = document.createElement("style")).type = "text/css"),
        document.getElementsByTagName("head")[0].appendChild(_tag);
    }),
      (this._read = function () {
        return _style;
      }),
      (this._write = function (css) {
        (_style = css), _needsUpdate || ((_needsUpdate = !0), defer(setHTML));
      }),
      (this.style = function (selector, obj = {}) {
        _obj[selector] || (_obj[selector] = {}),
          Object.assign(_obj[selector], obj),
          (function render() {
            var s = "";
            for (let selector in _obj) {
              let obj = _obj[selector];
              for (var key in ((s += `${selector} {`), obj)) {
                var prop = objToCSS(key),
                  val = obj[key];
                "string" != typeof val && "opacity" != key && (val += "px"),
                  (s += `${prop}:${val}!important;`);
              }
              s += "}";
            }
            _this._write(s);
          })();
      }),
      (this.get = function (selector, prop) {
        if (!_obj[selector]) return prop ? null : {};
        let obj = { ..._obj[selector] };
        return prop ? obj[prop] : obj;
      }),
      (this.textSize = function ($obj) {
        var $clone = $obj.clone();
        $clone.css({
          position: "relative",
          cssFloat: "left",
          styleFloat: "left",
          marginTop: -99999,
          width: "",
          height: "",
        }),
          __body.addChild($clone);
        var width = $clone.div.offsetWidth,
          height = $clone.div.offsetHeight;
        return $clone.remove(), { width: width, height: height };
      }),
      (this.prefix = function (style) {
        return "" == _this.styles.vendor
          ? style.charAt(0).toLowerCase() + style.slice(1)
          : _this.styles.vendor + style;
      }),
      (this._toCSS = objToCSS);
  }, "Static"),
  Class(
    function HydraObject(_selector, _type, _exists, _useFragment) {
      (this._children = new LinkedList()),
        this._onDestroy,
        (this.__useFragment = _useFragment),
        this._initSelector(_selector, _type, _exists);
    },
    () => {
      var prototype = HydraObject.prototype;
      const svgElements = [
        "svg",
        "path",
        "rect",
        "circle",
        "filter",
        "clippath",
        "clipPath",
        "ellipse",
        "image",
        "mask",
        "polygon",
        "g",
        "animate",
        "line",
        "linearGradient",
        "marker",
        "mpath",
        "polyline",
        "set",
        "stop",
        "text",
      ];
      (prototype._initSelector = function (_selector, _type, _exists) {
        if (_selector && "string" != typeof _selector) this.div = _selector;
        else {
          var first = _selector ? _selector.charAt(0) : null,
            name = _selector ? _selector.slice(1) : null;
          if (
            ("." != first &&
              "#" != first &&
              ((name = _selector), (first = ".")),
            _exists)
          ) {
            if ("#" != first) throw "Hydra Selectors Require #ID";
            this.div = document.getElementById(name);
          } else
            (this._type = _type || "div"),
              svgElements.includes(this._type)
                ? ((this.div = document.createElementNS(
                    "http://www.w3.org/2000/svg",
                    this._type
                  )),
                  "svg" === this._type &&
                    this.div.setAttributeNS(
                      "http://www.w3.org/2000/xmlns/",
                      "xmlns:xlink",
                      "http://www.w3.org/1999/xlink"
                    ))
                : ((this.div = document.createElement(this._type)),
                  first &&
                    ("#" == first
                      ? (this.div.id = name)
                      : (this.div.className = name)));
        }
        this.div.hydraObject = this;
      }),
        (prototype.add = function (child, before = null) {
          this.div;
          var _this = this,
            doInsertChild = function (childDiv) {
              before &&
                (before.element && before.element instanceof HydraObject
                  ? (before = before.element.div)
                  : before.div
                  ? (before = before.div)
                  : before.nodeName || (before = null)),
                before && before.parentNode !== _this.div && (before = null),
                _this.div.insertBefore(childDiv, before);
            },
            insertChild = function (childDiv) {
              _this.__useFragment
                ? (_this._fragment ||
                    ((_this._fragment = document.createDocumentFragment()),
                    defer(function () {
                      if (_this._fragment && _this.div) {
                        if (
                          Array.prototype.every.call(
                            _this._fragment.childNodes,
                            (childDiv) => !childDiv._fragmentBefore
                          )
                        )
                          _this.div.appendChild(_this._fragment);
                        else
                          for (; _this._fragment.childNodes.length; )
                            (childDiv = _this._fragment.childNodes[0]),
                              (before = childDiv._fragmentBefore),
                              delete childDiv._fragmentBefore,
                              doInsertChild(childDiv);
                        delete _this._fragment,
                          _this.onMountedHook?.(),
                          delete _this.onMountedHook;
                      } else delete _this._fragment;
                    })),
                  _this._fragment.appendChild(childDiv),
                  (childDiv._fragmentBefore = before))
                : doInsertChild(childDiv);
            };
          return (
            child.element && child.element instanceof HydraObject
              ? (insertChild(child.element.div),
                this._children.push(child.element),
                (child.element._parent = this),
                (child.element.div.parentNode = this.div))
              : child.div
              ? (insertChild(child.div),
                this._children.push(child),
                (child._parent = this),
                (child.div.parentNode = this.div))
              : child.nodeName &&
                (insertChild(child), (child.parentNode = this.div)),
            this
          );
        }),
        (prototype.clone = function () {
          return $(this.div.cloneNode(!0));
        }),
        (prototype.create = function (name, type) {
          var $obj = $(name, type);
          return this.add($obj), $obj;
        }),
        (prototype.empty = function () {
          for (var child = this._children.start(); child; ) {
            var next = this._children.next();
            child && child.remove && child.remove(), (child = next);
          }
          return (this.div.innerHTML = ""), this;
        }),
        (prototype.parent = function () {
          return this._parent;
        }),
        (prototype.children = function (isHydraChildren = !1) {
          let children = this.div.children
            ? this.div.children
            : this.div.childNodes;
          if (isHydraChildren) {
            children = [];
            for (var child = this._children.start(); child; )
              child && (children.push(child), (child = this._children.next()));
          }
          return children;
        }),
        (prototype.removeChild = function (object, keep) {
          try {
            object.div.parentNode.removeChild(object.div);
          } catch (e) {}
          keep || this._children.remove(object);
        }),
        (prototype.remove = function (param) {
          param &&
            console.warn(
              "HydraObject.remove removes ITSELF from its parent. use removeChild instead"
            ),
            this._onDestroy && this._onDestroy.forEach((cb) => cb()),
            (this.removed = !0);
          var parent = this._parent;
          parent &&
            !parent.removed &&
            parent.removeChild &&
            parent.removeChild(this, !0);
          for (var child = this._children.start(); child; ) {
            var next = this._children.next();
            child && child.remove && child.remove(), (child = next);
          }
          this._children.destroy(),
            (this.div.hydraObject = null),
            Utils.nullObject(this);
        }),
        (prototype.destroy = function () {
          this.remove();
        }),
        (prototype._bindOnDestroy = function (cb) {
          this._onDestroy || (this._onDestroy = []), this._onDestroy.push(cb);
        }),
        (window.$ = function (selector, type, exists) {
          return new HydraObject(selector, type, exists);
        }),
        ($.fn = HydraObject.prototype);
    }
  ),
  (function () {
    ($.fn.text = function (text) {
      return void 0 !== text
        ? (this.__cacheText != text && (this.div.textContent = text),
          (this.__cacheText = text),
          this)
        : this.div.textContent;
    }),
      ($.fn.html = function (text, force) {
        return !text || text.includes("<") || force
          ? void 0 !== text
            ? ((this.div.innerHTML = text), this)
            : this.div.innerHTML
          : this.text(text);
      }),
      ($.fn.hide = function () {
        return (this.div.style.display = "none"), this;
      }),
      ($.fn.show = function () {
        return (this.div.style.display = ""), this;
      }),
      ($.fn.visible = function () {
        return (this.div.style.visibility = "visible"), this;
      }),
      ($.fn.invisible = function () {
        return (this.div.style.visibility = "hidden"), this;
      }),
      ($.fn.setZ = function (z) {
        return (this.div.style.zIndex = z), this;
      }),
      ($.fn.clearAlpha = function () {
        return (this.div.style.opacity = ""), this;
      }),
      ($.fn.size = function (w, h, noScale) {
        return (
          "string" == typeof w
            ? (void 0 === h
                ? (h = "100%")
                : "string" != typeof h && (h = `${h}px`),
              (this.div.style.width = w),
              (this.div.style.height = h))
            : ((this.div.style.width = `${w}px`),
              (this.div.style.height = `${h}px`),
              noScale || (this.div.style.backgroundSize = `${w}px ${h}px`)),
          (this.width = w),
          (this.height = h),
          this
        );
      }),
      ($.fn.mouseEnabled = function (bool) {
        return (this.div.style.pointerEvents = bool ? "auto" : "none"), this;
      }),
      ($.fn.fontStyle = function (family, size, color, style) {
        var font = {};
        return (
          family && (font.fontFamily = family),
          size && (font.fontSize = size),
          color && (font.color = color),
          style && (font.fontStyle = style),
          this.css(font),
          this
        );
      }),
      ($.fn.font = function (font) {
        return this.css("font", font), this;
      }),
      ($.fn.bg = function (src, x, y, repeat) {
        return src
          ? (src.includes(".") && (src = Assets.getPath(src)),
            src.includes(".")
              ? (this.div.style.backgroundImage = `url(${src})`)
              : (this.div.style.backgroundColor = src),
            void 0 !== x &&
              ((x = "number" == typeof x ? `${x}px` : x),
              (y = "number" == typeof y ? `${y}px` : y),
              (this.div.style.backgroundPosition = `${x} ${y}`)),
            repeat &&
              ((this.div.style.backgroundSize = ""),
              (this.div.style.backgroundRepeat = repeat)),
            ("cover" != x && "contain" != x) ||
              ((this.div.style.backgroundSize = x),
              (this.div.style.backgroundPosition =
                void 0 !== y ? `${y} ${repeat}` : "center")),
            this)
          : this;
      }),
      ($.fn.center = function (x, y, noPos) {
        var css = {};
        return (
          void 0 === x
            ? ((css.left = "50%"),
              (css.top = "50%"),
              (css.marginLeft = -this.width / 2),
              (css.marginTop = -this.height / 2))
            : (x && ((css.left = "50%"), (css.marginLeft = -this.width / 2)),
              y && ((css.top = "50%"), (css.marginTop = -this.height / 2))),
          noPos && (delete css.left, delete css.top),
          this.css(css),
          this
        );
      }),
      ($.fn.max = function (width, height) {
        let w, h;
        return (
          void 0 !== width &&
            ((w = "number" == typeof width ? `${width}px` : width),
            (this.div.style.maxWidth = w)),
          void 0 !== height
            ? ((h = "number" == typeof height ? `${height}px` : height),
              (this.div.style.maxHeight = h))
            : ((h = w), (this.div.style.maxHeight = h)),
          this
        );
      }),
      ($.fn.min = function (width, height) {
        let w, h;
        return (
          void 0 !== width &&
            ((w = "number" == typeof width ? `${width}px` : width),
            (this.div.style.minWidth = w)),
          void 0 !== height
            ? ((h = "number" == typeof height ? `${height}px` : height),
              (this.div.style.minHeight = h))
            : ((h = w), (this.div.style.minHeight = h)),
          this
        );
      }),
      ($.fn.flex = function (inline) {
        return (
          (this.div.style.display = inline ? "inline-flex" : "flex"),
          (this.div.style.justifyContent = "center"),
          (this.div.style.alignItems = "center"),
          this.div.classList.add("relative-children"),
          this
        );
      }),
      ($.fn.order = function (opts = {}) {
        let s = this.div.style;
        return (
          "none" === opts.flexWrap && (opts.flexWrap = "nowrap"),
          opts.direction && (s.flexDirection = opts.direction),
          opts.wrap && (s.flexWrap = opts.wrap),
          opts.order && (s.order = opts.order),
          this
        );
      }),
      ($.fn.align = function (opts = {}) {
        let s = this.div.style;
        function flex(str, contentMode = !1) {
          return "start" === str
            ? "flex-start"
            : "end" === str
            ? "flex-end"
            : "between" === str
            ? contentMode
              ? "space-between"
              : "flex-between"
            : "around" === str
            ? contentMode
              ? "space-around"
              : "flex-around"
            : "none" === str
            ? "nowrap"
            : str;
        }
        return (
          opts.justify && (s.justifyContent = flex(opts.justify)),
          opts.items && (s.alignItems = flex(opts.items)),
          opts.self && (s.alignSelf = flex(opts.self)),
          opts.content && (s.alignContent = flex(opts.content, !0)),
          this
        );
      }),
      ($.fn.flexibility = function (opts = {}) {
        let s = this.div.style;
        return (
          "undefined" !== opts.grow && (s.flexGrow = opts.grow),
          "undefined" !== opts.shrink && (s.flexGrow = opts.shrink),
          void 0 !== opts.basis &&
            (s.flexBasis =
              "number" == typeof opts.basis ? `${opts.basis}px` : opts.basis),
          this
        );
      }),
      ($.fn.mask = function (arg) {
        let maskPrefix =
          "Moz" === HydraCSS.styles.vendor ? "mask" : HydraCSS.prefix("Mask");
        return (
          (this.div.style[maskPrefix] = `${
            arg.includes(".") ? `url(${arg})` : arg
          } no-repeat`),
          (this.div.style[`${maskPrefix}Size`] = "contain"),
          this
        );
      }),
      ($.fn.blendMode = function (mode, bg) {
        return (
          bg
            ? (this.div.style["background-blend-mode"] = mode)
            : (this.div.style["mix-blend-mode"] = mode),
          this
        );
      });
    const DEFAULT_UNITS = {
      animationDelay: "ms",
      animationDuration: "ms",
      transitionDelay: "ms",
      transitionDuration: "ms",
      perspectiveOriginX: "%",
      perspectiveOriginY: "%",
      transformOrigin: "%",
      transformOriginX: "%",
      transformOriginY: "%",
      transformOriginZ: "%",
      animationIterationCount: !1,
      borderImageSlice: !1,
      borderImageWidth: !1,
      columnCount: !1,
      counterIncrement: !1,
      counterReset: !1,
      flex: !1,
      flexGrow: !1,
      flexShrink: !1,
      fontSizeAdjust: !1,
      fontWeight: !1,
      lineHeight: !1,
      navIndex: !1,
      opacity: !1,
      order: !1,
      orphans: !1,
      tabSize: !1,
      widows: !1,
      zIndex: !1,
    };
    ($.fn.css = function (obj, value) {
      if (
        ("boolean" == typeof value && (value = null), "object" != typeof obj)
      ) {
        if (!value) {
          var style = this.div.style[obj];
          if ("number" != typeof style) {
            if (!style) return !1;
            style.includes("px") && (style = Number(style.slice(0, -2))),
              "opacity" == obj &&
                (style = isNaN(Number(this.div.style.opacity))
                  ? 1
                  : Number(this.div.style.opacity));
          }
          return style || (style = 0), style;
        }
        return (this.div.style[obj] = value), this;
      }
      TweenManager._clearCSSTween(this);
      for (let type in obj) {
        let val = obj[type];
        if ("string" == typeof val || "number" == typeof val) {
          if ("number" == typeof val) {
            let unit = DEFAULT_UNITS[type];
            !1 !== unit && (val += unit || "px");
          }
          "position" == type &&
            "sticky" == val &&
            "safari" == Device.system.browser &&
            (val = "-webkit-sticky"),
            (this.div.style[type] = val);
        }
      }
      return this;
    }),
      ($.fn.transform = function (props) {
        if (
          (Hydra.LOCAL &&
            props &&
            !this.__warningShown &&
            !props._mathTween &&
            (this.__lastTransform &&
              performance.now() - this.__lastTransform < 20 &&
              ((this.__warningCount = ++this.__warningCount || 1),
              (props.__warningCount2 = ++props.__warningCount2 || 1),
              this.__warningCount > 10 &&
                props.__warningCount2 !== this.__warningCount &&
                (console.warn(
                  "Are you using .transform() in a loop? Avoid creating a new object {} every frame. Ex. assign .x = 1; and .transform();"
                ),
                console.log(this),
                (this.__warningShown = !0))),
            (this.__lastTransform = performance.now())),
          TweenManager._clearCSSTween(this),
          Device.tween.css2d)
        ) {
          if (props)
            for (var key in props)
              ("number" != typeof props[key] &&
                "string" != typeof props[key]) ||
                (this[key] = props[key]);
          else props = this;
          var transformString = TweenManager._parseTransform(props);
          this.__transformCache != transformString &&
            ((this.div.style[HydraCSS.styles.vendorTransform] =
              transformString),
            (this.__transformCache = transformString));
        }
        return this;
      }),
      ($.fn.willChange = function (props) {
        if ("boolean" == typeof props) this._willChangeLock = !0 === props;
        else if (this._willChangeLock) return;
        var string = "string" == typeof props;
        (this._willChange && !string) || "null" == typeof props
          ? ((this._willChange = !1), (this.div.style["will-change"] = ""))
          : ((this._willChange = !0),
            (this.div.style["will-change"] = string
              ? props
              : `${HydraCSS.transformProperty}, opacity`));
      }),
      ($.fn.backfaceVisibility = function (visible) {
        this.div.style[HydraCSS.prefix("BackfaceVisibility")] = visible
          ? "visible"
          : "hidden";
      }),
      ($.fn.enable3D = function (perspective, x, y) {
        return Device.tween.css3d
          ? ((this.div.style[HydraCSS.prefix("TransformStyle")] =
              "preserve-3d"),
            perspective &&
              (this.div.style[
                HydraCSS.prefix("Perspective")
              ] = `${perspective}px`),
            void 0 !== x &&
              ((x = "number" == typeof x ? `${x}px` : x),
              (y = "number" == typeof y ? `${y}px` : y),
              (this.div.style[
                HydraCSS.prefix("PerspectiveOrigin")
              ] = `${x} ${y}`)),
            this)
          : this;
      }),
      ($.fn.disable3D = function () {
        return (
          (this.div.style[HydraCSS.prefix("TransformStyle")] = ""),
          (this.div.style[HydraCSS.prefix("Perspective")] = ""),
          this
        );
      }),
      ($.fn.transformPoint = function (x, y, z) {
        var origin = "";
        return (
          void 0 !== x &&
            (origin += "number" == typeof x ? `${x}px ` : `${x} `),
          void 0 !== y &&
            (origin += "number" == typeof y ? `${y}px ` : `${y} `),
          void 0 !== z && (origin += "number" == typeof z ? `${z}px` : z),
          (this.div.style[HydraCSS.prefix("TransformOrigin")] = origin),
          this
        );
      }),
      ($.fn.tween = function (props, time, ease, delay, callback, manual) {
        "boolean" == typeof delay
          ? ((manual = delay), (delay = 0), (callback = null))
          : "function" == typeof delay && ((callback = delay), (delay = 0)),
          "boolean" == typeof callback &&
            ((manual = callback), (callback = null)),
          delay || (delay = 0);
        var usePromise = null;
        callback &&
          callback instanceof Promise &&
          ((usePromise = callback), (callback = callback.resolve));
        var tween = TweenManager._detectTween(
          this,
          props,
          time,
          ease,
          delay,
          callback,
          manual
        );
        return usePromise || tween;
      }),
      ($.fn.clearTransform = function () {
        return (
          "number" == typeof this.x && (this.x = 0),
          "number" == typeof this.y && (this.y = 0),
          "number" == typeof this.z && (this.z = 0),
          "number" == typeof this.scale && (this.scale = 1),
          "number" == typeof this.scaleX && (this.scaleX = 1),
          "number" == typeof this.scaleY && (this.scaleY = 1),
          "number" == typeof this.rotation && (this.rotation = 0),
          "number" == typeof this.rotationX && (this.rotationX = 0),
          "number" == typeof this.rotationY && (this.rotationY = 0),
          "number" == typeof this.rotationZ && (this.rotationZ = 0),
          "number" == typeof this.skewX && (this.skewX = 0),
          "number" == typeof this.skewY && (this.skewY = 0),
          (this.div.style[HydraCSS.styles.vendorTransform] = ""),
          (this.__transformCache = ""),
          this
        );
      }),
      ($.fn.clearTween = function () {
        return (
          this._cssTween && this._cssTween.stop(),
          this._mathTween && this._mathTween.stop(),
          this
        );
      }),
      ($.fn.stopTween = function () {
        return (
          console.warn(".stopTween deprecated. use .clearTween instead"),
          this.clearTween()
        );
      }),
      ($.fn.keypress = function (callback) {
        this.div.onkeypress = function (e) {
          ((e = e || window.event).code = e.keyCode ? e.keyCode : e.charCode),
            callback && callback(e);
        };
      }),
      ($.fn.keydown = function (callback) {
        this.div.onkeydown = function (e) {
          ((e = e || window.event).code = e.keyCode), callback && callback(e);
        };
      }),
      ($.fn.keyup = function (callback) {
        this.div.onkeyup = function (e) {
          ((e = e || window.event).code = e.keyCode), callback && callback(e);
        };
      }),
      ($.fn.attr = function (attr, value) {
        return "string" != typeof attr
          ? this
          : void 0 === value
          ? this.div.getAttribute(attr)
          : (!1 === value || null === value
              ? this.div.removeAttribute(attr)
              : this.div.setAttribute(attr, value),
            this);
      }),
      ($.fn.val = function (value) {
        return void 0 === value
          ? this.div.value
          : ((this.div.value = value), this);
      }),
      ($.fn.change = $.fn.onChange =
        function (callback) {
          var _this = this;
          this.div.onchange = this.div.onblur = function () {
            callback({ object: _this, value: _this.div.value || "" });
          };
        }),
      ($.fn.svgSymbol = function (id, width, height) {
        var config = SVG.getSymbolConfig(id),
          svgHTML = `<svg viewBox="0 0 ${config.width} ${config.height}" width="${width}" height="${height}"><use xlink:href="#${config.id}" x="0" y="0" /></svg>`;
        this.html(svgHTML, !0);
      }),
      ($.fn.svg = async function (url) {
        let promise = Promise.create();
        return (
          fetch(url).then(async (res) => {
            let svgHTML = await res.text();
            this.html(svgHTML, !0), promise.resolve();
          }),
          promise
        );
      }),
      ($.fn.overflowScroll = function (dir) {
        var x = !!dir.x,
          y = !!dir.y,
          overflow = {};
        return (
          ((!x && !y) || (x && y)) && (overflow.overflow = "auto"),
          !x &&
            y &&
            ((overflow.overflowY = "auto"), (overflow.overflowX = "hidden")),
          x &&
            !y &&
            ((overflow.overflowX = "auto"), (overflow.overflowY = "hidden")),
          Device.mobile &&
            ((overflow["-webkit-overflow-scrolling"] = "touch"),
            Mobile._addOverflowScroll(this)),
          this.css(overflow)
        );
      }),
      ($.fn.removeOverflowScroll = function () {
        return (
          this.css({
            overflow: "hidden",
            overflowX: "",
            overflowY: "",
            "-webkit-overflow-scrolling": "",
          }),
          Device.mobile && Mobile._removeOverflowScroll(this),
          this
        );
      }),
      ($.fn.accessible = function (type = "label", tabIndex = -1) {
        switch ((tabIndex > -1 && this.attr("tabindex", tabIndex), type)) {
          case "label":
            this.attr("aria-label", this.div.textContent);
            break;
          case "hidden":
            this.attr("aria-hidden", !0);
        }
        return this;
      }),
      ($.fn.tabIndex = function (tabIndex) {
        return this.attr("tabindex", tabIndex), this;
      }),
      ($.fn.createObserver = function (
        callback,
        { isViewport: isViewport = !1, ...options } = {}
      ) {
        isViewport && (options.root = this.div);
        const observer = (this._observer = new IntersectionObserver((array) => {
          array.forEach((entry) => {
            entry.object = entry.target.hydraObject;
          }),
            callback(array);
        }, options));
        return (
          this._bindOnDestroy(() => {
            observer.disconnect();
          }),
          this
        );
      }),
      ($.fn.observe = function (obj = this) {
        return this._observer?.observe(obj.div), this;
      }),
      ($.fn.unobserve = function (obj = this) {
        return this._observer?.unobserve(obj.div), this;
      }),
      ($.fn.cursor = function (cursor, lock) {
        if (!Device.mobile)
          return (
            lock &&
              (this.cursorLock || (this.cursorLock = new Map()),
              "auto" == cursor
                ? this.cursorLock.delete(lock)
                : this.cursorLock.set(lock, cursor)),
            this.cursorLock &&
              "auto" == cursor &&
              this.cursorLock.forEach((v) => {
                cursor = v;
              }),
            this.css("cursor", cursor),
            this
          );
      }),
      ($.fn.classList = function () {
        return this.div.classList;
      }),
      ($.fn.goob = function (styles) {
        let _styles;
        return (
          (_styles =
            "string" == typeof styles
              ? goober.css`${styles}`
              : goober.css(styles)),
          (this.goobClass = _styles),
          this.div.classList.add(_styles),
          this
        );
      }),
      ($.fn.href = function (str) {
        return this.attr("href", str), this;
      }),
      ($.fn.target = function (str) {
        return this.attr("target", str), this;
      }),
      ($.fn.ariaLabel = function (str) {
        return this.attr("aria-label", str), this;
      }),
      ($.fn.alt = function (str) {
        return this.attr("alt", str), this;
      }),
      ($.fn.src = function (str) {
        return this.attr("src", str), this;
      }),
      ($.fn.display = function (bool) {
        bool ? $this.show() : $this.hide();
      }),
      ($.fn.type = function (str) {
        return this.attr("type", str), this;
      }),
      ($.fn.id = function (str) {
        return this.attr("id", str), this;
      }),
      ($.fn.htmlFor = function (str) {
        return this.attr("for", str), this;
      }),
      ($.fn.ariaLabelledBy = function (str) {
        return this.attr("aria-labelledby", str), this;
      }),
      ($.fn.checked = function (bool) {
        return this.attr("checked", bool), this;
      }),
      ($.fn.min = function (num) {
        return this.attr("min", num), this;
      }),
      ($.fn.max = function (num) {
        return this.attr("max", num), this;
      }),
      ($.fn.step = function (num) {
        return this.attr("step", num), this;
      }),
      ($.fn.value = function (any) {
        return this.attr("value", any), this;
      }),
      ($.fn.title = function (str) {
        return this.attr("title", str), this;
      }),
      ($.fn.minlength = function (num) {
        return this.attr("minlength", num), this;
      }),
      ($.fn.maxlength = function (num) {
        return this.attr("maxlength", num), this;
      }),
      ($.fn.rows = function (num) {
        return this.attr("rows", num), this;
      }),
      ($.fn.readonly = function (bool) {
        return this.attr("readonly", bool), this;
      });
  })(),
  (function () {
    var windowsPointer = !!window.MSGesture,
      translateEvent = function (evt) {
        if (windowsPointer)
          switch (evt) {
            case "touchstart":
              return "pointerdown";
            case "touchmove":
              return "MSGestureChange";
            case "touchend":
              return "pointerup";
          }
        return evt;
      },
      convertTouchEvent = function (e) {
        var touchEvent = { x: 0, y: 0 };
        if (e.windowsPointer) return e;
        if (!e) return touchEvent;
        if (
          (e.touches || e.changedTouches
            ? e.touches.length
              ? ((touchEvent.x = e.touches[0].clientX),
                (touchEvent.y = e.touches[0].clientY))
              : ((touchEvent.x = e.changedTouches[0].clientX),
                (touchEvent.y = e.changedTouches[0].clientY))
            : ((touchEvent.x = e.clientX), (touchEvent.y = e.clientY)),
          Mobile.ScreenLock &&
            Mobile.ScreenLock.isActive &&
            Mobile.orientationSet &&
            Mobile.orientation !== Mobile.orientationSet)
        ) {
          if (90 == window.orientation || 0 === window.orientation) {
            var x = touchEvent.y;
            (touchEvent.y = touchEvent.x), (touchEvent.x = Stage.width - x);
          }
          if (-90 == window.orientation || 180 === window.orientation) {
            var y = touchEvent.x;
            (touchEvent.x = touchEvent.y), (touchEvent.y = Stage.height - y);
          }
        }
        return touchEvent;
      };
    ($.fn.click = function (callback) {
      var _this = this;
      return (
        this.div.addEventListener(
          translateEvent("click"),
          function click(e) {
            return (
              !!_this.div &&
              !Mouse._preventClicks &&
              ((e.object =
                "hit" == _this.div.className ? _this.parent() : _this),
              (e.action = "click"),
              callback && callback(e),
              void (Mouse.autoPreventClicks && Mouse.preventClicks()))
            );
          },
          !0
        ),
        (this.div.style.cursor = "pointer"),
        this
      );
    }),
      ($.fn.hover = function (callback) {
        var _time,
          _this = this,
          _over = !1;
        function hover(e) {
          if (!_this.div) return !1;
          var time = performance.now(),
            original = e.toElement || e.relatedTarget;
          if (_time && time - _time < 5) return (_time = time), !1;
          switch (
            ((_time = time),
            (e.object = "hit" == _this.div.className ? _this.parent() : _this),
            e.type)
          ) {
            case "mouseout":
            case "mouseleave":
              e.action = "out";
              break;
            default:
              e.action = "over";
          }
          if (_over) {
            if (Mouse._preventClicks) return !1;
            if ("over" == e.action) return !1;
            if ("out" == e.action && isAChild(_this.div, original)) return !1;
            _over = !1;
          } else {
            if ("out" == e.action) return !1;
            _over = !0;
          }
          callback && callback(e);
        }
        function isAChild(div, object) {
          for (var len = div.children.length - 1, i = len; i > -1; i--)
            if (object == div.children[i]) return !0;
          for (i = len; i > -1; i--)
            if (isAChild(div.children[i], object)) return !0;
        }
        return (
          this.div.addEventListener(translateEvent("mouseover"), hover, !0),
          this.div.addEventListener(translateEvent("mouseout"), hover, !0),
          this
        );
      }),
      ($.fn.press = function (callback) {
        var _this = this;
        function press(e) {
          if (!_this.div) return !1;
          if (
            ((e.object = "hit" == _this.div.className ? _this.parent() : _this),
            "mousedown" === e.type)
          )
            e.action = "down";
          else e.action = "up";
          callback && callback(e);
        }
        return (
          this.div.addEventListener(translateEvent("mousedown"), press, !0),
          this.div.addEventListener(translateEvent("mouseup"), press, !0),
          this
        );
      }),
      ($.fn.bind = function (evt, callback) {
        if (
          ((this._events = this._events || {}),
          windowsPointer && this == __window)
        )
          return Stage.bind(evt, callback);
        "touchstart" == evt
          ? Device.mobile ||
            (Device.touchCapable
              ? this.bind("mousedown", callback)
              : (evt = "mousedown"))
          : "touchmove" == evt
          ? (Device.mobile ||
              (Device.touchCapable
                ? this.bind("mousemove", callback)
                : (evt = "mousemove")),
            windowsPointer &&
              !this.div.msGesture &&
              ((this.div.msGesture = new MSGesture()),
              (this.div.msGesture.target = this.div)))
          : "touchend" == evt &&
            (Device.mobile ||
              (Device.touchCapable
                ? this.bind("mouseup", callback)
                : (evt = "mouseup"))),
          (this._events[`bind_${evt}`] = this._events[`bind_${evt}`] || []);
        var _events = this._events[`bind_${evt}`],
          e = {},
          target = this.div;
        function touchEvent(e) {
          windowsPointer &&
            target.msGesture &&
            "touchstart" == evt &&
            target.msGesture.addPointer(e.pointerId),
            Device.mobile || "touchstart" != evt || e.preventDefault();
          var touch = convertTouchEvent(e);
          if (windowsPointer) {
            var windowsEvt = e;
            ((e = {}).preventDefault = () => windowsEvt.preventDefault()),
              (e.stopPropagation = () => windowsEvt.stopPropagation()),
              (e.x = Number(windowsEvt.clientX)),
              (e.y = Number(windowsEvt.clientY)),
              (e.target = windowsEvt.target),
              (e.currentTarget = windowsEvt.currentTarget),
              (e.path = []);
            for (var node = e.target; node; )
              e.path.push(node), (node = node.parentElement || null);
            e.windowsPointer = !0;
          } else (e.x = touch.x), (e.y = touch.y);
          for (var i = 0; i < _events.length; i++) {
            var ev = _events[i];
            ev.target == e.currentTarget && ev.callback(e);
          }
        }
        return (
          (e.callback = callback),
          (e.target = this.div),
          _events.push(e),
          this._events[`fn_${evt}`] ||
            ((this._events[`fn_${evt}`] = touchEvent),
            this.div.addEventListener(translateEvent(evt), touchEvent, {
              capture: !0,
              passive: !1,
            })),
          this
        );
      }),
      ($.fn.unbind = function (evt, callback) {
        if (
          ((this._events = this._events || {}),
          windowsPointer && this == __window)
        )
          return Stage.unbind(evt, callback);
        "touchstart" == evt
          ? Device.mobile ||
            (Device.touchCapable
              ? this.unbind("mousedown", callback)
              : (evt = "mousedown"))
          : "touchmove" == evt
          ? Device.mobile ||
            (Device.touchCapable
              ? this.unbind("mousemove", callback)
              : (evt = "mousemove"))
          : "touchend" == evt &&
            (Device.mobile ||
              (Device.touchCapable
                ? this.unbind("mouseup", callback)
                : (evt = "mouseup")));
        var _events = this._events[`bind_${evt}`];
        if (!_events) return this;
        for (var i = 0; i < _events.length; i++) {
          _events[i].callback == callback && _events.splice(i, 1);
        }
        return (
          this._events[`fn_${evt}`] &&
            !_events.length &&
            (this.div.removeEventListener(
              translateEvent(evt),
              this._events[`fn_${evt}`],
              !Device.mobile || { passive: !0 }
            ),
            (this._events[`fn_${evt}`] = null)),
          this
        );
      }),
      ($.fn.interact = function (
        overCallback,
        clickCallback,
        seoLink,
        seoText,
        zIndex,
        options
      ) {
        if (!this.hit) {
          "object" == typeof arguments[arguments.length - 1] &&
            ((options = arguments[arguments.length - 1]),
            ([overCallback, clickCallback, seoLink, seoText, zIndex] =
              Array.prototype.slice.call(arguments, 0, -1)),
            options.overCallback && (overCallback = options.overCallback),
            options.clickCallback && (clickCallback = options.clickCallback),
            options.seoLink && (seoLink = options.seoLink),
            options.seoText && (seoText = options.seoText),
            options.zIndex && (zIndex = options.zIndex)),
            options || (options = {}),
            (this.hit = $(".hit", seoLink ? "a" : void 0)),
            this.hit.css({
              width: "100%",
              height: "100%",
              zIndex: zIndex || 99999,
              top: 0,
              left: 0,
              position: "absolute",
            }),
            this.add(this.hit);
          var _this = this;
          seoLink &&
            (this.hit.attr(
              "href",
              "#" === seoLink || seoLink.includes("mailto:")
                ? seoLink
                : Hydra.absolutePath(seoLink)
            ),
            this.hit.text(seoText || this.div.textContent),
            this.hit.css({ fontSize: 0 }),
            this.hit.accessible(),
            "function" == typeof overCallback &&
              ((this.hit.div.onfocus = (_) =>
                overCallback({ action: "over", object: this })),
              (this.hit.div.onblur = (_) =>
                overCallback({ action: "out", object: this }))),
            (this.hit.div.onclick = (e) => {
              e.preventDefault(),
                (e.object = _this),
                (e.action = "click"),
                clicked(e);
            })),
            options.role &&
              (this.hit.attr("role", options.role),
              "button" === options.role &&
                (this.hit.div.onkeydown = (e) => {
                  switch (e.key) {
                    case " ":
                    case "Spacebar":
                      e.preventDefault(),
                        e.stopPropagation(),
                        (e.object = _this),
                        (e.action = "click"),
                        clicked(e);
                  }
                }));
        }
        let time = Render.TIME;
        function clicked(e) {
          clickCallback && Render.TIME - time > 250 && clickCallback(e),
            (time = Render.TIME);
        }
        Device.mobile
          ? this.hit.touchClick(overCallback, clicked)
          : this.hit.hover(overCallback).click(clicked);
      }),
      ($.fn.clearInteract = function () {
        this.hit && (this.hit = this.hit.destroy());
      }),
      ($.fn.disableInteract = function () {
        this.hit && this.hit.css({ pointerEvents: "none" });
      }),
      ($.fn.enableInteract = function () {
        this.hit && this.hit.css({ pointerEvents: "auto" });
      }),
      ($.fn.touchSwipe = function (callback, distance) {
        if (!window.addEventListener) return this;
        var _startX,
          _startY,
          _this = this,
          _distance = distance || 75,
          _moving = !1,
          _move = {};
        function touchMove(e) {
          if (!_this.div) return !1;
          if (_moving) {
            var touch = convertTouchEvent(e),
              dx = _startX - touch.x,
              dy = _startY - touch.y;
            (_move.direction = null),
              (_move.moving = null),
              (_move.x = null),
              (_move.y = null),
              (_move.evt = e),
              Math.abs(dx) >= _distance
                ? (touchEnd(), (_move.direction = dx > 0 ? "left" : "right"))
                : Math.abs(dy) >= _distance
                ? (touchEnd(), (_move.direction = dy > 0 ? "up" : "down"))
                : ((_move.moving = !0), (_move.x = dx), (_move.y = dy)),
              callback && callback(_move, e);
          }
        }
        function touchEnd(e) {
          if (!_this.div) return !1;
          (_startX = _startY = _moving = !1),
            _this.div.removeEventListener(
              translateEvent("touchmove"),
              touchMove
            );
        }
        return (
          Device.mobile &&
            (this.div.addEventListener(
              translateEvent("touchstart"),
              function touchStart(e) {
                var touch = convertTouchEvent(e);
                if (!_this.div) return !1;
                1 == e.touches.length &&
                  ((_startX = touch.x),
                  (_startY = touch.y),
                  (_moving = !0),
                  _this.div.addEventListener(
                    translateEvent("touchmove"),
                    touchMove,
                    { passive: !0 }
                  ));
              },
              { passive: !0 }
            ),
            this.div.addEventListener(translateEvent("touchend"), touchEnd, {
              passive: !0,
            }),
            this.div.addEventListener(translateEvent("touchcancel"), touchEnd, {
              passive: !0,
            })),
          this
        );
      }),
      ($.fn.touchClick = function (hover, click) {
        if (!window.addEventListener) return this;
        var _time,
          _move,
          _this = this,
          _start = {},
          _touch = {};
        function setTouch(e) {
          var touch = convertTouchEvent(e);
          (e.touchX = touch.x),
            (e.touchY = touch.y),
            (_start.x = e.touchX),
            (_start.y = e.touchY);
        }
        return (
          Device.mobile &&
            (this.div.addEventListener(
              translateEvent("touchstart"),
              function touchStart(e) {
                if (!_this.div) return !1;
                (_time = performance.now()),
                  (e.action = "over"),
                  (e.object =
                    "hit" == _this.div.className ? _this.parent() : _this),
                  setTouch(e),
                  hover && !_move && hover(e);
              },
              { passive: !0 }
            ),
            this.div.addEventListener(
              translateEvent("touchend"),
              function touchEnd(e) {
                if (!_this.div) return !1;
                var time = performance.now();
                if (
                  ((_touch = convertTouchEvent(e)),
                  (_move =
                    (function findDistance(p1, p2) {
                      var dx = p2.x - p1.x,
                        dy = p2.y - p1.y;
                      return Math.sqrt(dx * dx + dy * dy);
                    })(_start, _touch) > 25),
                  (e.object =
                    "hit" == _this.div.className ? _this.parent() : _this),
                  setTouch(e),
                  _time && time - _time < 750)
                ) {
                  if (Mouse._preventClicks) return !1;
                  click &&
                    !_move &&
                    (!0,
                    (e.action = "click"),
                    click && !_move && click(e),
                    Mouse.autoPreventClicks && Mouse.preventClicks());
                }
                hover && ((e.action = "out"), Mouse._preventFire || hover(e));
                _move = !1;
              },
              { passive: !0 }
            )),
          this
        );
      });
  })(),
  Class(function Element(type = "div") {
    Inherit(this, Component);
    var name = Utils.getConstructorName(this);
    (this.__element = !0),
      (this.element = $(`.${name}`, type)),
      (this.element.__useFragment = !0),
      (this.destroy = function () {
        this.element &&
          this.element.remove &&
          (this.element = this.element.remove()),
          this._destroy && this._destroy();
      }),
      (this.querySelector = async function (selector) {
        if ((await defer(), !Array.isArray(selector)))
          return $(this.element.div.querySelector(selector));
        let values = [];
        return (
          selector.forEach((s) => {
            values.push($(this.element.div.querySelector(s)));
          }),
          values
        );
      }),
      (this.querySelectorAll = async function (selector) {
        await defer();
        let list = this.element.div.querySelectorAll(selector),
          values = [];
        for (let i = 0; i < list.length; i++) values.push($(list[i]));
        return values;
      });
  }),
  Hydra.ready(() => {
    (TweenManager.Transforms = [
      "scale",
      "scaleX",
      "scaleY",
      "x",
      "y",
      "z",
      "rotation",
      "rotationX",
      "rotationY",
      "rotationZ",
      "skewX",
      "skewY",
      "perspective",
    ]),
      (TweenManager.CubicEases = [
        {
          name: "easeOutCubic",
          curve: "cubic-bezier(0.215, 0.610, 0.355, 1.000)",
        },
        {
          name: "easeOutQuad",
          curve: "cubic-bezier(0.250, 0.460, 0.450, 0.940)",
        },
        {
          name: "easeOutQuart",
          curve: "cubic-bezier(0.165, 0.840, 0.440, 1.000)",
        },
        {
          name: "easeOutQuint",
          curve: "cubic-bezier(0.230, 1.000, 0.320, 1.000)",
        },
        {
          name: "easeOutSine",
          curve: "cubic-bezier(0.390, 0.575, 0.565, 1.000)",
        },
        {
          name: "easeOutExpo",
          curve: "cubic-bezier(0.190, 1.000, 0.220, 1.000)",
        },
        {
          name: "easeOutCirc",
          curve: "cubic-bezier(0.075, 0.820, 0.165, 1.000)",
        },
        {
          name: "easeOutBack",
          curve: "cubic-bezier(0.175, 0.885, 0.320, 1.275)",
        },
        {
          name: "easeInCubic",
          curve: "cubic-bezier(0.550, 0.055, 0.675, 0.190)",
        },
        {
          name: "easeInQuad",
          curve: "cubic-bezier(0.550, 0.085, 0.680, 0.530)",
        },
        {
          name: "easeInQuart",
          curve: "cubic-bezier(0.895, 0.030, 0.685, 0.220)",
        },
        {
          name: "easeInQuint",
          curve: "cubic-bezier(0.755, 0.050, 0.855, 0.060)",
        },
        {
          name: "easeInSine",
          curve: "cubic-bezier(0.470, 0.000, 0.745, 0.715)",
        },
        {
          name: "easeInCirc",
          curve: "cubic-bezier(0.600, 0.040, 0.980, 0.335)",
        },
        {
          name: "easeInBack",
          curve: "cubic-bezier(0.600, -0.280, 0.735, 0.045)",
        },
        {
          name: "easeInOutCubic",
          curve: "cubic-bezier(0.645, 0.045, 0.355, 1.000)",
        },
        {
          name: "easeInOutQuad",
          curve: "cubic-bezier(0.455, 0.030, 0.515, 0.955)",
        },
        {
          name: "easeInOutQuart",
          curve: "cubic-bezier(0.770, 0.000, 0.175, 1.000)",
        },
        {
          name: "easeInOutQuint",
          curve: "cubic-bezier(0.860, 0.000, 0.070, 1.000)",
        },
        {
          name: "easeInOutSine",
          curve: "cubic-bezier(0.445, 0.050, 0.550, 0.950)",
        },
        {
          name: "easeInOutExpo",
          curve: "cubic-bezier(1.000, 0.000, 0.000, 1.000)",
        },
        {
          name: "easeInOutCirc",
          curve: "cubic-bezier(0.785, 0.135, 0.150, 0.860)",
        },
        {
          name: "easeInOutBack",
          curve: "cubic-bezier(0.680, -0.550, 0.265, 1.550)",
        },
        { name: "easeInOut", curve: "cubic-bezier(.42,0,.58,1)" },
        { name: "linear", curve: "linear" },
      ]),
      (TweenManager.useCSSTrans = function (props, ease, object) {
        return !(
          props.math ||
          ("string" == typeof ease && ease.includes(["Elastic", "Bounce"])) ||
          object.multiTween ||
          TweenManager._inspectEase(ease).path ||
          !Device.tween.transition
        );
      }),
      (TweenManager._detectTween = function (
        object,
        props,
        time,
        ease,
        delay,
        callback
      ) {
        return TweenManager.useCSSTrans(props, ease, object)
          ? new CSSTransition(object, props, time, ease, delay, callback)
          : new FrameTween(object, props, time, ease, delay, callback);
      }),
      (TweenManager._parseTransform = function (props) {
        var unitRequiresCSSTween = ["%", "vw", "vh", "em"],
          transforms = "",
          translate = "";
        if (
          (props.perspective > 0 &&
            (transforms += `perspective(${props.perspective}px)`),
          void 0 !== props.x || void 0 !== props.y || void 0 !== props.z)
        ) {
          var x = props.x || 0,
            y = props.y || 0,
            z = props.z || 0;
          (translate +=
            x +
            ("string" == typeof props.x &&
            props.x.includes(unitRequiresCSSTween)
              ? ""
              : "px") +
            ", "),
            (translate +=
              y +
              ("string" == typeof props.y &&
              props.y.includes(unitRequiresCSSTween)
                ? ""
                : "px")),
            Device.tween.css3d
              ? (transforms += `translate3d(${(translate += `, ${z}px`)})`)
              : (transforms += `translate(${translate})`);
        }
        return (
          void 0 !== props.scale
            ? (transforms += `scale(${props.scale})`)
            : (void 0 !== props.scaleX &&
                (transforms += `scaleX(${props.scaleX})`),
              void 0 !== props.scaleY &&
                (transforms += `scaleY(${props.scaleY})`)),
          void 0 !== props.rotation &&
            (transforms += `rotate(${props.rotation}deg)`),
          void 0 !== props.rotationX &&
            (transforms += `rotateX(${props.rotationX}deg)`),
          void 0 !== props.rotationY &&
            (transforms += `rotateY(${props.rotationY}deg)`),
          void 0 !== props.rotationZ &&
            (transforms += `rotateZ(${props.rotationZ}deg)`),
          void 0 !== props.skewX && (transforms += `skewX(${props.skewX}deg)`),
          void 0 !== props.skewY && (transforms += `skewY(${props.skewY}deg)`),
          transforms
        );
      }),
      (TweenManager._clearCSSTween = function (obj) {
        obj &&
          !obj._cssTween &&
          obj.div._transition &&
          !obj.persistTween &&
          ((obj.div.style[HydraCSS.styles.vendorTransition] = ""),
          (obj.div._transition = !1),
          (obj._cssTween = null));
      }),
      (TweenManager._isTransform = function (key) {
        return TweenManager.Transforms.indexOf(key) > -1;
      }),
      (TweenManager._getAllTransforms = function (object) {
        for (
          var obj = {}, i = TweenManager.Transforms.length - 1;
          i > -1;
          i--
        ) {
          var tf = TweenManager.Transforms[i],
            val = object[tf];
          0 === val ||
            ("number" != typeof val && "string" != typeof val) ||
            (obj[tf] = val);
        }
        return obj;
      });
    const prefix = (function () {
      let pre = "",
        dom = "";
      try {
        var styles = window.getComputedStyle(document.documentElement, "");
        return (
          (pre = (Array.prototype.slice
            .call(styles)
            .join("")
            .match(/-(moz|webkit|ms)-/) ||
            ("" === styles.OLink && ["", "o"]))[1]),
          (dom = "WebKit|Moz|MS|O".match(new RegExp(`(${pre})`, "i"))[1]),
          {
            unprefixed:
              "ie" == Device.system.browser && !Device.detect("msie 9"),
            dom: dom,
            lowercase: pre,
            css: `-${pre}-`,
            js:
              ("ie" == Device.system.browser ? pre[0] : pre[0].toUpperCase()) +
              pre.substr(1),
          }
        );
      } catch (e) {
        return { unprefixed: !0, dom: "", lowercase: "", css: "", js: "" };
      }
    })();
    (HydraCSS.styles = {}),
      (HydraCSS.styles.vendor = prefix.unprefixed ? "" : prefix.js),
      (HydraCSS.styles.vendorTransition = HydraCSS.styles.vendor.length
        ? `${HydraCSS.styles.vendor}Transition`
        : "transition"),
      (HydraCSS.styles.vendorTransform = HydraCSS.styles.vendor.length
        ? `${HydraCSS.styles.vendor}Transform`
        : "transform"),
      (HydraCSS.vendor = prefix.css),
      (HydraCSS.transformProperty = (function () {
        switch (prefix.lowercase) {
          case "moz":
            return "-moz-transform";
          case "webkit":
            return "-webkit-transform";
          case "o":
            return "-o-transform";
          case "ms":
            return "-ms-transform";
          default:
            return "transform";
        }
      })()),
      (HydraCSS.tween = {}),
      (HydraCSS.tween.complete = prefix.unprefixed
        ? "transitionend"
        : `${prefix.lowercase}TransitionEnd`);
  }),
  Class(function CSSTransition(
    _object,
    _props,
    _time,
    _ease,
    _delay,
    _callback
  ) {
    const _this = this;
    let _transformProps, _transitionProps;
    function killed() {
      return !_this || _this.kill || !_object || !_object.div;
    }
    function clearCSSTween() {
      killed() ||
        ((_this.playing = !1),
        (_object._cssTween = null),
        _object.willChange(null),
        (_object = _props = null),
        Utils.nullObject(this));
    }
    (this.playing = !0),
      (function () {
        if ("number" != typeof _time)
          throw "CSSTween Requires object, props, time, ease";
        !(function initProperties() {
          var transform = TweenManager._getAllTransforms(_object),
            properties = [];
          for (var key in _props)
            TweenManager._isTransform(key)
              ? ((transform.use = !0),
                (transform[key] = _props[key]),
                delete _props[key])
              : ("number" == typeof _props[key] ||
                  key.includes(["-", "color"])) &&
                properties.push(key);
          transform.use &&
            (properties.push(HydraCSS.transformProperty), delete transform.use);
          (_transformProps = transform), (_transitionProps = properties);
        })(),
          (async function initCSSTween(values) {
            if (killed()) return;
            _object._cssTween && (_object._cssTween.kill = !0);
            (_object._cssTween = _this), (_object.div._transition = !0);
            var strings = (function buildStrings(time, ease, delay) {
              for (
                var props = "", str = "", len = _transitionProps.length, i = 0;
                i < len;
                i++
              ) {
                var transitionProp = _transitionProps[i];
                (props += (props.length ? ", " : "") + transitionProp),
                  (str += `${
                    (str.length ? ", " : "") + transitionProp
                  } ${time}ms ${TweenManager._getEase(ease)} ${delay}ms`);
              }
              return { props: props, transition: str };
            })(_time, _ease, _delay);
            _object.willChange(strings.props);
            var time = values ? values.time : _time,
              delay = values ? values.delay : _delay,
              props = values ? values.props : _props,
              transformProps = values ? values.transform : _transformProps,
              singleFrame = 1e3 / Render.REFRESH_RATE;
            if (
              ((_this.time = _time),
              (_this.delay = _delay),
              await Timer.delayedCall(3 * singleFrame),
              killed())
            )
              return;
            if (
              ((_object.div.style[HydraCSS.styles.vendorTransition] =
                strings.transition),
              (_this.playing = !0),
              "safari" == Device.system.browser)
            ) {
              if (
                (Device.system.browserVersion < 11 &&
                  (await Timer.delayedCall(singleFrame)),
                killed())
              )
                return;
              _object.css(props), _object.transform(transformProps);
            } else _object.css(props), _object.transform(transformProps);
            Timer.create(function () {
              killed() ||
                (clearCSSTween(),
                _callback && _callback(),
                _this.completePromise && _this.completePromise.resolve());
            }, time + delay);
          })();
      })(),
      (this.stop = function () {
        this.playing &&
          ((this.kill = !0),
          (this.playing = !1),
          (_object.div.style[HydraCSS.styles.vendorTransition] = ""),
          (_object.div._transition = !1),
          _object.willChange(null),
          (_object._cssTween = null),
          Utils.nullObject(this));
      }),
      (this.onComplete = function (callback) {
        return (_callback = callback), this;
      }),
      (this.promise = function () {
        return (
          (_this.completePromise = Promise.create()), _this.completePromise
        );
      });
  }),
  Class(function FrameTween(
    _object,
    _props,
    _time,
    _ease,
    _delay,
    _callback,
    _manual
  ) {
    var _endValues,
      _transformEnd,
      _transformStart,
      _startValues,
      _isTransform,
      _isCSS,
      _transformProps,
      _cssTween,
      _transformTween,
      _update,
      _this = this;
    function copy(obj) {
      let newObj = {};
      for (let key in obj)
        "number" == typeof obj[key] && (newObj[key] = obj[key]);
      return newObj;
    }
    function clear() {
      _object._cssTweens && _object._cssTweens.remove(_this),
        (_this.playing = !1),
        (_object._cssTween = null),
        (_object = _props = null);
    }
    function update() {
      if (
        !(function killed() {
          return _this.kill || !_object || !_object.div || !_object.css;
        })()
      ) {
        if ((_isCSS && _object.css(_props), _isTransform))
          if (_object.multiTween) {
            for (var key in _transformProps)
              "number" == typeof _transformProps[key] &&
                (_object[key] = _transformProps[key]);
            _object.transform();
          } else _object.transform(_transformProps);
        _update && _update();
      }
    }
    function tweenComplete() {
      _this.playing &&
        (clear(),
        _callback && _callback(),
        _this.completePromise && _this.completePromise.resolve());
    }
    (this.playing = !0),
      (_this.object = _object),
      (_this.props = _props),
      (_this.time = _time),
      (_this.ease = _ease),
      (_this.delay = _delay),
      defer(function () {
        if (_this.overrideValues) {
          let values = _this.overrideValues(
            _this,
            _object,
            _props,
            _time,
            _ease,
            _delay
          );
          values &&
            ((_this.props = _props = values.props || _props),
            (_this.time = _time = values.time || _time),
            (_this.ease = _ease = values.ease || _ease),
            (_this.delay = _delay = values.delay || _delay));
        }
        if (
          ("object" == typeof _ease && (_ease = "easeOutCubic"),
          _object && _props)
        ) {
          if (((_this.object = _object), "number" != typeof _time))
            throw "FrameTween Requires object, props, time, ease";
          !(function initValues() {
            _props.math && delete _props.math;
            Device.tween.transition &&
              _object.div &&
              _object.div._transition &&
              ((_object.div.style[HydraCSS.styles.vendorTransition] = ""),
              (_object.div._transition = !1));
            (_this.time = _time),
              (_this.delay = _delay),
              (_endValues = {}),
              (_transformEnd = {}),
              (_transformStart = {}),
              (_startValues = {}),
              _object.multiTween ||
                (void 0 === _props.x && (_props.x = _object.x),
                void 0 === _props.y && (_props.y = _object.y),
                void 0 === _props.z && (_props.z = _object.z));
            for (var key in _props)
              if (key.includes(["damping", "spring"]))
                (_endValues[key] = _props[key]),
                  (_transformEnd[key] = _props[key]);
              else if (TweenManager._isTransform(key))
                (_isTransform = !0),
                  (_transformStart[key] =
                    _object[key] || ("scale" == key ? 1 : 0)),
                  (_transformEnd[key] = _props[key]);
              else {
                _isCSS = !0;
                var v = _props[key];
                "string" == typeof v
                  ? (_object.div.style[key] = v)
                  : "number" == typeof v &&
                    ((_startValues[key] = _object.css
                      ? Number(_object.css(key))
                      : 0),
                    (_endValues[key] = v));
              }
          })(),
            (function startTween() {
              !_object._cssTween ||
                _manual ||
                _object.multiTween ||
                (_object._cssTween.kill = !0);
              (_this.time = _time),
                (_this.delay = _delay),
                _object.multiTween &&
                  (_object._cssTweens || (_object._cssTweens = []),
                  _object._cssTweens.push(_this));
              (_object._cssTween = _this),
                (_this.playing = !0),
                (_props = copy(_startValues)),
                (_transformProps = copy(_transformStart)),
                _isCSS &&
                  (_cssTween = tween(
                    _props,
                    _endValues,
                    _time,
                    _ease,
                    _delay,
                    null,
                    _manual
                  )
                    .onUpdate(update)
                    .onComplete(tweenComplete));
              _isTransform &&
                (_transformTween = tween(
                  _transformProps,
                  _transformEnd,
                  _time,
                  _ease,
                  _delay,
                  null,
                  _manual
                )
                  .onComplete(_isCSS ? null : tweenComplete)
                  .onUpdate(_isCSS ? null : update));
            })();
        }
      }),
      (this.stop = function () {
        this.playing &&
          (_cssTween && _cssTween.stop && _cssTween.stop(),
          _transformTween && _transformTween.stop && _transformTween.stop(),
          clear());
      }),
      (this.interpolate = function (elapsed) {
        _cssTween && _cssTween.interpolate(elapsed),
          _transformTween && _transformTween.interpolate(elapsed),
          update();
      }),
      (this.getValues = function () {
        return {
          start: _startValues,
          transformStart: _transformStart,
          end: _endValues,
          transformEnd: _transformEnd,
        };
      }),
      (this.setEase = function (ease) {
        _cssTween && _cssTween.setEase(ease),
          _transformTween && _transformTween.setEase(ease);
      }),
      (this.onUpdate = function () {
        return this;
      }),
      (this.onComplete = function (callback) {
        return (_callback = callback), this;
      }),
      (this.promise = function () {
        return (
          _this.completePromise || (_this.completePromise = Promise.create()),
          _this.completePromise
        );
      });
  });
class DOMAttribute {
  constructor({
    name: name,
    value: value,
    belongsTo: belongsTo,
    bindingLookup: bindingLookup,
  }) {
    (this.name = name),
      (this.value = value),
      (this.belongsTo = belongsTo),
      (this.bindingLookup = bindingLookup);
  }
}
class TemplateRoot {
  constructor(string, values) {
    (this.string = string), (this.values = values);
  }
  consolidate() {
    let template = this.string;
    const consolidatedValues = {};
    for (const [marker, value] of Object.entries(this.values))
      if (value instanceof TemplateHTML) {
        const [innerTemplate, innerValues] = value.consolidate();
        (template = template.replace(marker, innerTemplate)),
          Object.assign(consolidatedValues, innerValues);
      } else if (Array.isArray(value)) {
        let childTemplate = "";
        for (let k = 0; k < value.length; k++) {
          const [innerString, innerValue] = value[k].consolidate();
          (childTemplate += innerString),
            Object.assign(consolidatedValues, innerValue);
        }
        template = template.replace(marker, childTemplate);
      } else consolidatedValues[marker] = value;
    return [template, consolidatedValues];
  }
  modifyMarkers(template, config, dataMarkers, bindings) {
    let count = 0;
    return template
      .replace(
        /@([a-z]+)="\{\{(hydra-[0-9]+)\}\}"/g,
        function (_, event, marker) {
          const dataMarker = "data-attach-event-" + count++;
          return (
            dataMarkers.push(dataMarker), `${dataMarker}="${event}|${marker}"`
          );
        }
      )
      .replace(/\{\{hydra-[0-9]+\}\}/g, function (marker) {
        if (config[marker] && config[marker].state)
          return bindings.push({ lookup: marker.trim() }), marker;
        if (config[marker]["@style"]) {
          const styles = config[marker]["@style"];
          if (!styles || "object" != typeof styles)
            return void console.error("@style must contain an object");
          let styleString = "";
          return (
            Object.keys(styles).forEach((prop) => {
              const kebabProp = prop
                .replace(/([a-z0-9]|(?=[A-Z]))([A-Z])/g, "$1-$2")
                .toLowerCase();
              styleString += `${kebabProp}: ${styles[prop]};\n`;
            }),
            styleString
          );
        }
        return config[marker];
      });
  }
}
class TemplateHTML extends TemplateRoot {
  constructor(string, values) {
    super(string, values);
  }
  inflate(root, cssElement) {
    let [template, config] = this.consolidate(),
      dataMarkers = [],
      nestedComponents = [],
      bindings = new LinkedList(),
      scrollTop = root.firstChild?.scrollTop;
    const t = this.modifyMarkers(template, config, dataMarkers, bindings);
    for (; root.firstChild; ) root.removeChild(root.firstChild);
    root.flatBindings && root.flatBindings.forEach((b) => b.destroy()),
      (root.flatBindings = []);
    let fragment = document.createDocumentFragment(),
      newNode = DOMTemplate.parser.parseFromString(t, "text/html"),
      els = newNode.body.firstChild.querySelectorAll("*"),
      length = els.length;
    fragment.appendChild(newNode.body.firstChild),
      cssElement && fragment.appendChild(cssElement);
    for (let index = length - 1; index > -1; index--) {
      let el = els[index];
      ~el.tagName.indexOf("-") && nestedComponents.push(el);
      let innerText = el.innerText,
        innerHTML = el.innerHTML,
        attributes = [...el.attributes].map((a) => ({
          name: a.name,
          value: a.value,
        }));
      if (~innerHTML.indexOf("<")) continue;
      let binding = bindings.start();
      for (; binding; ) {
        let bindingLookup = binding.lookup;
        if (
          (attributes.forEach((attr) => {
            if (~attr?.value?.indexOf(bindingLookup)) {
              let obj = config[bindingLookup];
              const attrObject = new DOMAttribute({
                name: attr.name,
                value: el.getAttribute(attr.name),
                belongsTo: el,
                bindingLookup: bindingLookup,
              });
              root.flatBindings.push(obj.state.bind(obj.key, attrObject));
            }
          }),
          ~innerText.indexOf(bindingLookup))
        ) {
          let obj = config[bindingLookup];
          ~innerText.indexOf("@[") &&
            (el.innerText = innerText.replace(bindingLookup, obj.key)),
            root.flatBindings.push(obj.state.bind(obj.key, el));
        }
        binding = bindings.next();
      }
    }
    root.appendChild(fragment),
      dataMarkers.forEach((dataMarker) => {
        const element = root.querySelector(`[${dataMarker}]`),
          dataEvent = element.getAttribute(dataMarker),
          [event, marker] = dataEvent.split("|");
        element.removeAttribute(dataMarker),
          element.addEventListener(`${event}`, config[`{{${marker}}}`]);
      }),
      defer(() => {
        nestedComponents.forEach((template) => {
          const className = template.tagName
            .toLowerCase()
            .replace(/(^\w|-\w)/g, (str) => str.replace(/-/, "").toUpperCase());
          $(`#${template.id}`, className, !0).add(new window[className]());
        });
      }),
      scrollTop && (root.firstChild.scrollTop = scrollTop);
  }
}
class TemplateCSS extends TemplateRoot {
  constructor(string, values) {
    super(string, values);
  }
  inflate(root) {
    let [template, config] = this.consolidate(),
      bindings = new LinkedList(),
      element = document.createElement("style");
    return (
      (element.innerHTML = this.modifyMarkers(template, config, [], bindings)),
      element
    );
  }
}
function styleMap(object) {
  return Object.keys(object)
    .map((key) => (object[key] ? key : ""))
    .join(" ");
}
!(function () {
  let markerID = 0;
  function makeMarker() {
    return `{{hydra-${markerID++}}}`;
  }
  function html(strings, ...values) {
    const config = {};
    let string = "";
    for (let i = 0; i < strings.length - 1; i++) {
      const marker = makeMarker();
      (string += strings[i]), (string += marker), (config[marker] = values[i]);
    }
    return (
      (string += strings[strings.length - 1]), new TemplateHTML(string, config)
    );
  }
  function css(strings, ...values) {
    const config = {};
    let string = "";
    for (let i = 0; i < strings.length - 1; i++) {
      const marker = makeMarker();
      (string += strings[i]), (string += marker), (config[marker] = values[i]);
    }
    return (
      (string += strings[strings.length - 1]), new TemplateCSS(string, config)
    );
  }
  Class(
    function DOMTemplate() {
      Inherit(this, Element);
      const _this = this;
      if (((this.data = []), Hydra.LOCAL && window.UILSocket)) {
        let name = Utils.getConstructorName(_this);
        _this.events.sub(UILSocket.JS_FILE, (e) => {
          e.file.includes(name) &&
            (DOMTemplate.updateGlobalStyles(), _this.update());
        });
      }
      function update() {
        let cssContent;
        _this.dynamicStyle &&
          (cssContent = _this.dynamicStyle(css).inflate(_this.element.div)),
          _this.render?.(html).inflate?.(_this.element.div, cssContent),
          _this.postRender?.();
      }
      (this.update = function () {
        DOMTemplate.clearScheduled(update), DOMTemplate.schedule(update);
      }),
        (this.render = function (html) {
          throw new Error("render() needs to be overwritten.");
        }),
        (this.setSourceData = function (data) {
          (_this.data = data),
            this.update(),
            _this.events.sub(data, Events.UPDATE, this.update);
        }),
        _this.update();
    },
    (_) => {
      DOMTemplate.parser = new DOMParser();
      const queue = [],
        worker = new Render.Worker((_) => {
          let callback = queue.shift();
          callback ? callback() : worker.pause();
        }, 2);
      var _css;
      worker.pause(),
        (DOMTemplate.schedule = function (callback) {
          queue.push(callback), worker.resume();
        }),
        (DOMTemplate.clearScheduled = function (callback) {
          for (let i = 0; i < queue.length; i++) {
            if (queue[i] == callback) return queue.splice(i, 1);
          }
        }),
        (DOMTemplate.updateGlobalStyles = function () {
          Utils.debounce(async (_) => {
            let css = await get(Assets.getPath("assets/css/style-scss.css"));
            _css ||
              (_css = $(document.head).create("DOMTemplate-hotload", "style")),
              (_css.div.innerHTML = css);
          }, 20);
        });
    }
  );
})(),
  Class(
    function Interaction(_object) {
      Inherit(this, Events);
      const _this = this;
      var _touchId,
        _velocity = [],
        _moved = 0,
        _time = performance.now();
      function Vec2() {
        (this.x = 0),
          (this.y = 0),
          (this.length = function () {
            return Math.sqrt(this.x * this.x + this.y * this.y);
          });
      }
      var _vec2Pool = new ObjectPool(Vec2, 10);
      let _distance, _timeDown, _timeMove;
      function loop() {
        _moved++ > 10 &&
          ((_this.velocity.x = _this.velocity.y = 0),
          (_this.delta.x = _this.delta.y = 0));
      }
      function down(e) {
        const hitCondition =
          !!_this.hitReturn &&
          "hit" == e.target.className &&
          e.target.hydraObject != _object;
        if (
          (_this.isTouching && !_this.multiTouch) ||
          hitCondition ||
          Interaction.hitIsBound(e.target, _object)
        )
          return;
        _this.isTouching = !0;
        let x = e.x,
          y = e.y;
        e.changedTouches &&
          !_touchId &&
          ((x = e.changedTouches[0].clientX),
          (y = e.changedTouches[0].clientY),
          (_touchId = e.changedTouches[0].identifier)),
          e.touches &&
            "number" == typeof e.touches[0].force &&
            (e.force = e.touches[0].force),
          (e.x = _this.x = x),
          (e.y = _this.y = y),
          (_this.hold.x = _this.last.x = x),
          (_this.hold.y = _this.last.y = y),
          (_this.delta.x = _this.move.x = _this.velocity.x = 0),
          (_this.delta.y = _this.move.y = _this.velocity.y = 0),
          (_distance = 0),
          _this.events.fire(Interaction.START, e, !0),
          (_timeDown = _timeMove = Render.TIME);
      }
      function move(e) {
        if (!_this.isTouching && !_this.unlocked) return;
        let now = performance.now();
        if (now - _time < 16) return;
        _time = now;
        let x = e.x,
          y = e.y;
        if (e.touches)
          for (let i = 0; i < e.touches.length; i++) {
            let touch = e.touches[i];
            touch.identifier == _touchId &&
              ((x = touch.clientX), (y = touch.clientY));
          }
        _this.isTouching &&
          ((_this.move.x = x - _this.hold.x),
          (_this.move.y = y - _this.hold.y)),
          e.touches &&
            "number" == typeof e.touches[0].force &&
            (e.force = e.touches[0].force),
          (e.x = _this.x = x),
          (e.y = _this.y = y),
          (_this.delta.x = x - _this.last.x),
          (_this.delta.y = y - _this.last.y),
          (_this.last.x = x),
          (_this.last.y = y),
          (_moved = 0),
          (_distance += _this.delta.length());
        let delta = Render.TIME - (_timeMove || Render.TIME);
        if (((_timeMove = Render.TIME), delta > 0.01)) {
          let velocity = _vec2Pool.get();
          (velocity.x = Math.abs(_this.delta.x) / delta),
            (velocity.y = Math.abs(_this.delta.y) / delta),
            _velocity.push(velocity),
            _velocity.length > 5 && _vec2Pool.put(_velocity.shift());
        }
        _this.velocity.x = _this.velocity.y = 0;
        for (let i = 0; i < _velocity.length; i++)
          (_this.velocity.x += _velocity[i].x),
            (_this.velocity.y += _velocity[i].y);
        (_this.velocity.x /= _velocity.length),
          (_this.velocity.y /= _velocity.length),
          (_this.velocity.x = _this.velocity.x || 0),
          (_this.velocity.y = _this.velocity.y || 0),
          _this.events.fire(Interaction.MOVE, e, !0),
          _this.isTouching && _this.events.fire(Interaction.DRAG, e, !0);
      }
      function up(e) {
        if (e && e.changedTouches) {
          let someTouchIdentified = !1;
          for (let i = 0; i < e.changedTouches.length; i++)
            e.changedTouches[i].identifier === _touchId &&
              (someTouchIdentified = !0);
          if (!someTouchIdentified) return;
        }
        if (!_this.isTouching && !_this.unlocked) return;
        (_this.isTouching = !1),
          (_this.move.x = 0),
          (_this.move.y = 0),
          Math.max(0.001, Render.TIME - (_timeMove || Render.TIME)) >= 40 &&
            ((_this.delta.x = 0), (_this.delta.y = 0)),
          _distance < 20 &&
            Render.TIME - _timeDown < 1e3 &&
            !e.isLeaveEvent &&
            _this.events.fire(Interaction.CLICK, e, !0),
          _this.events.fire(Interaction.END, e, !0),
          (_touchId = null),
          Device.mobile && (_this.velocity.x = _this.velocity.y = 0);
      }
      function leave() {
        _this.ignoreLeave ||
          ((_this.delta.x = 0), (_this.delta.y = 0), up({ isLeaveEvent: !0 }));
      }
      (this.x = 0),
        (this.y = 0),
        (this.hold = new Vec2()),
        (this.last = new Vec2()),
        (this.delta = new Vec2()),
        (this.move = new Vec2()),
        (this.velocity = new Vec2()),
        (this.hitReturn = !0),
        (function () {
          if (!_object instanceof HydraObject)
            throw "Interaction.Input requires a HydraObject";
          !(function addHandlers() {
            _object == Stage || _object == __window
              ? Interaction.bind("touchstart", down)
              : (_object.bind("touchstart", down),
                Interaction.bindObject(_object));
            Interaction.bind("touchmove", move),
              Interaction.bind("touchend", up),
              Interaction.bind("leave", leave);
          })(),
            Render.start(loop);
        })(),
        (this.onDestroy = function () {
          Interaction.unbind("touchstart", down),
            Interaction.unbind("touchmove", move),
            Interaction.unbind("touchend", up),
            Render.stop(loop),
            Interaction.unbindObject(_object),
            _object && _object.unbind && _object.unbind("touchstart", down);
        });
    },
    () => {
      Namespace(Interaction),
        (Interaction.CLICK = "interaction_click"),
        (Interaction.START = "interaction_start"),
        (Interaction.MOVE = "interaction_move"),
        (Interaction.DRAG = "interaction_drag"),
        (Interaction.END = "interaction_end");
      const _objects = [],
        _events = { touchstart: [], touchmove: [], touchend: [], leave: [] };
      function touchMove(e) {
        _events.touchmove.forEach((c) => c(e));
      }
      function touchStart(e) {
        _events.touchstart.forEach((c) => c(e));
      }
      function touchEnd(e) {
        _events.touchend.forEach((c) => c(e));
      }
      function leave(e) {
        (e.leave = !0), _events.leave.forEach((c) => c(e));
      }
      Hydra.ready(async () => {
        await defer(),
          __window.bind("touchstart", touchStart),
          __window.bind("touchmove", touchMove),
          __window.bind("touchend", touchEnd),
          __window.bind("touchcancel", touchEnd),
          __window.bind("contextmenu", touchEnd),
          __window.bind("mouseleave", leave),
          __window.bind("mouseout", leave);
      }),
        (Interaction.bind = function (evt, callback) {
          _events[evt].push(callback);
        }),
        (Interaction.unbind = function (evt, callback) {
          _events[evt].remove(callback);
        }),
        (Interaction.bindObject = function (obj) {
          _objects.push(obj);
        }),
        (Interaction.unbindObject = function (obj) {
          _objects.remove(obj);
        }),
        (Interaction.hitIsBound = function (element, boundObj) {
          let obj = element.hydraObject;
          if (!obj) return !1;
          for (; obj; ) {
            if (obj != boundObj && _objects.includes(obj)) return !0;
            obj = obj._parent;
          }
          return !1;
        });
    }
  ),
  Class(function Mouse() {
    Inherit(this, Events);
    const _this = this;
    (this.x = 0),
      (this.y = 0),
      (this.normal = { x: 0, y: 0 }),
      (this.tilt = { x: 0, y: 0 }),
      (this.inverseNormal = { x: 0, y: 0 }),
      (this.resetOnRelease = !1);
    const _offset = { x: 0, y: 0 };
    function init() {
      (_this.x = Stage.width / 2),
        (_this.y = Stage.height / 2),
        defer((_) => {
          _this.resetOnRelease &&
            Device.mobile &&
            ((_this.x = Stage.width / 2), (_this.y = Stage.height / 2));
        }),
        (_this.input = new Interaction(__window)),
        (_this.input.unlocked = !0),
        _this.events.sub(_this.input, Interaction.START, start),
        _this.events.sub(_this.input, Interaction.MOVE, update),
        _this.events.sub(_this.input, Interaction.END, end),
        (_this.hold = _this.input.hold),
        (_this.last = _this.input.last),
        (_this.delta = _this.input.delta),
        (_this.move = _this.input.move),
        (_this.velocity = _this.input.velocity),
        defer(() => {
          _this.events.sub(Events.RESIZE, resize), resize();
        });
    }
    function start(e) {
      (_this.down = !0), update(e);
    }
    function update(e) {
      (_this.x = e.x),
        (_this.y = e.y),
        Stage.width &&
          Stage.height &&
          ((_this.normal.x = e.x / Stage.width - _offset.x),
          (_this.normal.y = e.y / Stage.height - _offset.y),
          (_this.tilt.x = 2 * _this.normal.x - 1),
          (_this.tilt.y = 1 - 2 * _this.normal.y),
          (_this.inverseNormal.x = _this.normal.x),
          (_this.inverseNormal.y = 1 - _this.normal.y));
    }
    function end(e) {
      (_this.down = !1),
        Device.mobile &&
          _this.resetOnRelease &&
          update({ x: Stage.width / 2, y: Stage.height / 2 });
    }
    function resize() {
      Stage.css("top") && (_offset.y = Stage.css("top") / Stage.height),
        Stage.css("left") && (_offset.x = Stage.css("left") / Stage.width);
    }
    Hydra.ready(init);
  }, "Static"),
  Class(function Keyboard() {
    Inherit(this, Component);
    var _this = this;
    function addListeners() {
      __window.keydown(keydown),
        __window.keyup(keyup),
        __window.keypress(keypress),
        window.addEventListener("focus", onFocus);
    }
    function keydown(e) {
      _this.pressing.includes(e.key) || _this.pressing.push(e.key),
        _this.events.fire(_this.DOWN, e),
        2 == _this.pressing.length &&
          _this.pressing.includes("Meta") &&
          _this.pressing.includes("Shift") &&
          (_this.pressing.length = 0);
    }
    function keyup(e) {
      _this.pressing.remove(e.key), _this.events.fire(_this.UP, e);
    }
    function keypress(e) {
      _this.events.fire(_this.PRESS, e);
    }
    function onFocus() {
      _this.pressing.length = 0;
    }
    (this.pressing = []),
      (_this.DOWN = "keyboard_down"),
      (_this.PRESS = "keyboard_press"),
      (_this.UP = "keyboard_up"),
      Hydra.ready(addListeners);
  }, "static"),
  Class(function Mobile() {
    Inherit(this, Component), Namespace(this);
    const _this = this;
    var $html,
      $featureDetects,
      _is100vh = !1;
    function preventNativeScroll(e) {
      if (_this.isAllowNativeScroll) return;
      let target = e.target;
      if (
        "LABEL" == target.nodeName ||
        "INPUT" == target.nodeName ||
        "TEXTAREA" == target.nodeName ||
        "SELECT" == target.nodeName ||
        "A" == target.nodeName
      )
        return;
      let prevent = target.hydraObject;
      for (; target.parentNode && prevent; )
        target._scrollParent && (prevent = !1), (target = target.parentNode);
      prevent && e.preventDefault();
    }
    function resize() {
      updateOrientation(),
        checkResizeRefresh(),
        updateMobileFullscreen(),
        _this.isAllowNativeScroll || (document.body.scrollTop = 0);
    }
    function updateOrientation() {
      (_this.orientation =
        Stage.width > Stage.height ? "landscape" : "portrait"),
        _this.orientationSet &&
          (window.Fullscreen?.isOpen || Device.mobile?.pwa) &&
          window.screen &&
          window.screen.orientation &&
          window.screen.orientation.lock(_this.orientationSet);
    }
    Hydra.ready(() => {
      if (Device.mobile) {
        if (
          ((function initFeatureDetects() {
            $featureDetects = __body.create("feature-detects");
          })(),
          (function addHandlers() {
            _this.events.sub(Events.RESIZE, resize),
              Device.mobile.native ||
                window.addEventListener("touchstart", preventNativeScroll, {
                  passive: !1,
                });
          })(),
          Device.mobile?.phone && !Device.mobile.native)
        ) {
          $html = $(document.documentElement);
          let ios = "safari" === Device.system.browser;
          ios ? $html.div.classList.add("ios") : $html.div.classList.add("mob"),
            (_is100vh = !0),
            ios && (__body.css({ height: "100%" }).div.scrollTop = 0),
            updateMobileFullscreen();
        }
        Device.mobile.native && Stage.css({ width: "100vw", height: "100vh" });
      }
    });
    const checkResizeRefresh = (function () {
      let _lastWidth;
      return function () {
        _this.isPreventResizeReload ||
          (_lastWidth != Stage.width &&
            ((_lastWidth = Stage.width),
            ("ios" === Device.system.os ||
              ("android" == Device.system.os && Device.system.version >= 7)) &&
              (!Device.mobile.tablet ||
                Math.max(Stage.width, Stage.height) > 800 ||
                window.location.reload())));
      };
    })();
    function updateMobileFullscreen() {
      if ($html) {
        let vh100 = $featureDetects.div.offsetHeight;
        $html.div.offsetHeight !== Stage.height
          ? Stage.height === vh100
            ? ($html.css({ height: "" }),
              Stage.css({ height: "100%" }),
              (_is100vh = !0))
            : ($html.css({ height: Stage.height }),
              Stage.css({ height: Stage.height }),
              (_is100vh = !1))
          : _is100vh ||
            Stage.height !== vh100 ||
            ($html.css({ height: "" }),
            Stage.css({ height: "100%" }),
            (_is100vh = !0));
      }
    }
    (this.vibrate = function (duration) {
      navigator.vibrate && navigator.vibrate(duration);
    }),
      (this.fullscreen = function () {
        if (
          Device.mobile &&
          !Device.mobile.native &&
          !Device.mobile.pwa &&
          !Dev.emulator
        ) {
          if (!window.Fullscreen)
            throw "Mobile.fullscreen requires Fullscreen module";
          "android" !== Device.system.os ||
            Device.detect("oculus") ||
            (__window.bind("touchend", () => {
              Fullscreen.open();
            }),
            _this.ScreenLock && _this.ScreenLock.isActive && window.onresize());
        }
      }),
      (this.setOrientation = function (orientation, isForce) {
        if (_this.System && _this.NativeCore.active)
          return (_this.System.orientation =
            _this.System[orientation.toUpperCase()]);
        if (
          ((_this.orientationSet = orientation), updateOrientation(), isForce)
        ) {
          if (!_this.ScreenLock)
            throw "Mobile.setOrientation isForce argument requires ScreenLock module";
          "any" === orientation
            ? _this.ScreenLock.unlock()
            : _this.ScreenLock.lock();
        }
      }),
      (this.isKeyboardOpen = function () {
        return (
          Device.mobile &&
          document.activeElement.tagName
            .toLowerCase()
            .includes(["textarea", "input"])
        );
      }),
      (this.allowNativeScroll = function (enabled = !0) {
        _this.isAllowNativeScroll = enabled;
        let action = enabled ? "unset" : "";
        [$(document.documentElement), __body, Stage].forEach(($el) =>
          $el.css({
            touchAction: action,
            MSContentZooming: action,
            MSTouchAction: action,
          })
        );
      }),
      (this.preventResizeReload = function () {
        _this.isPreventResizeReload = !0;
      }),
      (this._addOverflowScroll = function ($obj) {
        ($obj.div._scrollParent = !0),
          Device.mobile.native ||
            (($obj.div._preventEvent = function (e) {
              e.stopPropagation();
            }),
            $obj.bind("touchmove", $obj.div._preventEvent));
      }),
      (this._removeOverflowScroll = function ($obj) {
        $obj.unbind("touchmove", $obj.div._preventEvent);
      }),
      this.get("phone", () => {
        throw "Mobile.phone is removed. Use Device.mobile.phone";
      }),
      this.get("tablet", () => {
        throw "Mobile.tablet is removed. Use Device.mobile.tablet";
      }),
      this.get("os", () => {
        throw "Mobile.os is removed. Use Device.system.os";
      }),
      (function () {
        var _props = [
          "--safe-area-inset-top",
          "--safe-area-inset-right",
          "--safe-area-inset-bottom",
          "--safe-area-inset-left",
        ];
        function getSafeAreaInset(index) {
          if (!$featureDetects) return 0;
          let style = getComputedStyle($featureDetects.div);
          return parseInt(style.getPropertyValue(_props[index])) || 0;
        }
        (_this.getSafeAreaInsets = () =>
          _props.map((_, i) => getSafeAreaInset(i))),
          (_this.getSafeAreaInsetTop = () => getSafeAreaInset(0)),
          (_this.getSafeAreaInsetRight = () => getSafeAreaInset(1)),
          (_this.getSafeAreaInsetBottom = () => getSafeAreaInset(2)),
          (_this.getSafeAreaInsetLeft = () => getSafeAreaInset(3));
      })();
  }, "Static"),
  Class(
    function PushState(_isHash) {
      const _this = this;
      let _store,
        _useInternal,
        _root = "";
      function getState() {
        return _useInternal
          ? new String(_store)
          : _isHash
          ? String(window.location.hash.slice(3))
          : ("/" !== _root && "" !== _root
              ? location.pathname.split(_root)[1]
              : location.pathname.slice(1)) || "";
      }
      function handleStateChange(state, forced) {
        if (state === _store && !forced) return;
        if (_this.isLocked && !forced) {
          if (!_store) return;
          return void (
            _useInternal ||
            (_isHash
              ? (window.location.hash = `!/${_store}`)
              : window.history.pushState(
                  null,
                  null,
                  Utils.addQueryToPath(_root + _store)
                ))
          );
        }
        let prevValue = _store;
        (_store = state),
          _this.events.fire(Events.UPDATE, {
            prevValue: prevValue,
            value: state,
            split: state.split("/"),
          });
      }
      "boolean" != typeof _isHash &&
        (_isHash = Hydra.LOCAL || !Device.system.pushstate),
        (this.isLocked = !1),
        (function () {
          if (!_this.flag) throw "Inherit PushState/Router after main class";
          _this.flag("isNotBlocked", !0),
            (function addHandlers() {
              if (_isHash)
                return window.addEventListener(
                  "hashchange",
                  () => handleStateChange(getState()),
                  !1
                );
              window.onpopstate = history.onpushstate = () =>
                handleStateChange(getState());
            })(),
            (_store = getState());
        })(),
        (this.getState = this._getState =
          function () {
            return Device.mobile.native
              ? Storage.get("app_state") || ""
              : getState();
          }),
        (this.setRoot = function (root) {
          _root = "/" === root.charAt(0) ? root : `/${root}`;
        }),
        (this.setState = this._setState =
          async function (state, forced) {
            if (
              (_this.events.fire(PushState.SET_STATE),
              await _this.wait("isNotBlocked"),
              Device.mobile.native && Storage.set("app_state", state),
              state !== _store || forced)
            )
              return (
                _useInternal
                  ? (_store = state)
                  : _isHash
                  ? (window.location.hash = `!/${state}`)
                  : window.history.pushState(
                      null,
                      null,
                      Utils.addQueryToPath(_root + state)
                    ),
                _this.fireChangeWhenSet &&
                  handleStateChange(getState(), forced),
                (_store = state),
                !0
              );
          }),
        (this.enableBlocker = function () {
          _this.flag("isNotBlocked", !1);
        }),
        (this.disableBlocker = function () {
          _this.flag("isNotBlocked", !0);
        }),
        (this.replaceState = function (state) {
          state !== _store &&
            ((_store = state),
            _useInternal && (_store = state),
            _isHash
              ? (window.location.hash = `!/${state}`)
              : window.history.replaceState(
                  null,
                  null,
                  Utils.addQueryToPath(_root + state)
                ));
        }),
        (this.setTitle = function (title) {
          document.title = title;
        }),
        (this.lock = function () {
          (this.isLocked = !0), _this.events.fire(PushState.LOCK);
        }),
        (this.unlock = function () {
          (this.isLocked = !1), _this.events.fire(PushState.UNLOCK);
        }),
        (this.useHash = function () {
          _isHash = !0;
        }),
        (this.useInternal = function () {
          _useInternal = !0;
        });
    },
    (_) => {
      (PushState.SET_STATE = "push_state_set_state"),
        (PushState.LOCK = "push_state_lock"),
        (PushState.UNLOCK = "push_state_unlock");
    }
  ),
  Class(function Router(_isHash, _rootPath) {
    Inherit(this, PushState, _isHash);
    const _this = this;
    var _debounce,
      _prevView,
      _nextView,
      _404Route,
      _prevRoute,
      _callbacks = [],
      _routesFlattened = [];
    function matchRoute(path) {
      let params;
      const matchedRoute = _routesFlattened.find((route) => {
        const result = route.matcher.exec({ pathname: `/${path}` });
        return (
          !(!result || !result.pathname) &&
          ((params = result.pathname.groups), !0)
        );
      });
      return !!matchedRoute && { ...matchedRoute.route, params: params };
    }
    function handleState(e) {
      let value = e?.value;
      value || (value = _this.getState());
      let route = null,
        cb = null;
      if (
        (_this.lock(),
        _callbacks.forEach((callback) => {
          route || ((route = matchRoute(value)), (cb = callback));
        }),
        route && route.redirect)
      ) {
        let redirectedRoute = matchRoute(route.redirect);
        if (redirectedRoute) {
          if (route.updateURL)
            return _this.unlock(), void _this.setState(route.redirect);
          route = redirectedRoute;
        }
      }
      route || ((value = "404"), (route = _404Route)),
        AppState.set("Router/state", value),
        AppState.set("Router/route", route),
        (async function doRoute(route, path, callback) {
          if (((_nextView = route?.view), "$" == _nextView?.charAt?.(0))) {
            let ref = _nextView.slice(1);
            if (_this[ref]) _nextView = _this[ref];
            else
              for (let key in _this.classes) {
                let obj = _this.classes[key];
                obj.ref == ref && obj.force(), (_nextView = _this[ref]);
              }
          }
          let params = null;
          await callback?.(_prevView, _nextView, path, route.params, route),
            await _nextView?.onRouteChange?.({
              params: params,
              path: path,
              name: route.name,
              children: route.children,
              meta: route.meta,
            }),
            (_prevView = _nextView),
            AppState.set("Router/previous", _prevRoute?.path),
            AppState.set("Router/previousRoute", _prevRoute),
            (_this.currentRoute = { ...route, params: params }),
            _this.unlock(),
            (_prevRoute = route);
        })(route, value, cb);
    }
    function addChildrenRoutes(element, parentPath) {
      element.children &&
        element.children.length &&
        element.children.forEach((child) => {
          const path = `${parentPath}/${child.path}`;
          _routesFlattened.push({
            path: `${parentPath}/${child.path}`,
            route: child,
            matcher: new URLPattern({ pathname: path }),
          }),
            addChildrenRoutes(child, path);
        });
    }
    (_this.currentRoute = null),
      (_this.fireChangeWhenSet = !0),
      (function setRootPath(val) {
        let rootPath;
        (rootPath =
          "string" == typeof _rootPath ? _rootPath : Hydra.LOCAL ? "" : "/"),
          _this.setRoot(rootPath);
      })(),
      (function initEvents() {
        _this.events.sub(_this, Events.UPDATE, handleState);
      })(),
      (this._initFragRoutes = function (array) {
        array.forEach((obj) => {
          obj.view && (obj.view = _this[obj.view.slice(1)]),
            obj.lazyView && (obj.view = obj.lazyView);
        }),
          this.registerRoutes(_this.onRouteChange, array);
      }),
      (this.registerRoutes = function (callback, list) {
        if (
          (list.forEach((element) => {
            if (element.path.startsWith("/"))
              throw new Error("router paths should not start with /");
            if (element.redirect && element.redirect.startsWith("/"))
              throw new Error("redirect paths must not start with /");
            const path = `/${element.path}`;
            _routesFlattened.push({
              path: path,
              route: element,
              matcher: new URLPattern({ pathname: path }),
            }),
              addChildrenRoutes(element, path),
              "404" === element.path && (_404Route = element);
          }),
          !_404Route)
        )
          throw new Error(
            'Error: no 404 route defined.  Please define a route whos path is "404" '
          );
        _callbacks.push(callback),
          clearTimeout(_debounce),
          (_debounce = _this.delayedCall(handleState, 1));
      }),
      (this.navigate = function (path) {
        path.startsWith("/") && (path = path.substring(1)),
          _this.setState(path);
      }),
      (this.replace = function (path) {
        path.startsWith("/") && (path = path.substring(1)),
          _this.replaceState(path);
      });
  }),
  (() => {
    "use strict";
    var t = /[$_\p{ID_Start}]/u,
      e = /[$_\u200C\u200D\p{ID_Continue}]/u;
    function n(t, e) {
      return (e ? /^[\x00-\xFF]*$/ : /^[\x00-\x7F]*$/).test(t);
    }
    function s(s, r = !1) {
      const i = [];
      let a = 0;
      for (; a < s.length; ) {
        const o = s[a],
          h = function (t) {
            if (!r) throw new TypeError(t);
            i.push({ type: "INVALID_CHAR", index: a, value: s[a++] });
          };
        if ("*" !== o)
          if ("+" !== o && "?" !== o)
            if ("\\" !== o)
              if ("{" !== o)
                if ("}" !== o)
                  if (":" !== o)
                    if ("(" !== o)
                      i.push({ type: "CHAR", index: a, value: s[a++] });
                    else {
                      let t = 1,
                        e = "",
                        r = a + 1,
                        o = !1;
                      if ("?" === s[r]) {
                        h(`Pattern cannot start with "?" at ${r}`);
                        continue;
                      }
                      for (; r < s.length; ) {
                        if (!n(s[r], !1)) {
                          h(`Invalid character '${s[r]}' at ${r}.`), (o = !0);
                          break;
                        }
                        if ("\\" !== s[r]) {
                          if (")" === s[r]) {
                            if ((t--, 0 === t)) {
                              r++;
                              break;
                            }
                          } else if ("(" === s[r] && (t++, "?" !== s[r + 1])) {
                            h(`Capturing groups are not allowed at ${r}`),
                              (o = !0);
                            break;
                          }
                          e += s[r++];
                        } else e += s[r++] + s[r++];
                      }
                      if (o) continue;
                      if (t) {
                        h(`Unbalanced pattern at ${a}`);
                        continue;
                      }
                      if (!e) {
                        h(`Missing pattern at ${a}`);
                        continue;
                      }
                      i.push({ type: "PATTERN", index: a, value: e }), (a = r);
                    }
                  else {
                    let n = "",
                      r = a + 1;
                    for (; r < s.length; ) {
                      const i = s.substr(r, 1);
                      if (
                        !(
                          (r === a + 1 && t.test(i)) ||
                          (r !== a + 1 && e.test(i))
                        )
                      )
                        break;
                      n += s[r++];
                    }
                    if (!n) {
                      h(`Missing parameter name at ${a}`);
                      continue;
                    }
                    i.push({ type: "NAME", index: a, value: n }), (a = r);
                  }
                else i.push({ type: "CLOSE", index: a, value: s[a++] });
              else i.push({ type: "OPEN", index: a, value: s[a++] });
            else i.push({ type: "ESCAPED_CHAR", index: a++, value: s[a++] });
          else i.push({ type: "MODIFIER", index: a, value: s[a++] });
        else i.push({ type: "ASTERISK", index: a, value: s[a++] });
      }
      return i.push({ type: "END", index: a, value: "" }), i;
    }
    function r(t, e = {}) {
      const n = s(t),
        { prefixes: r = "./" } = e,
        a = `[^${i(e.delimiter || "/#?")}]+?`,
        o = [];
      let h = 0,
        p = 0,
        c = "",
        u = new Set();
      const f = (t) => {
          if (p < n.length && n[p].type === t) return n[p++].value;
        },
        l = () => f("MODIFIER") || f("ASTERISK"),
        m = (t) => {
          const e = f(t);
          if (void 0 !== e) return e;
          const { type: s, index: r } = n[p];
          throw new TypeError(`Unexpected ${s} at ${r}, expected ${t}`);
        },
        d = () => {
          let t,
            e = "";
          for (; (t = f("CHAR") || f("ESCAPED_CHAR")); ) e += t;
          return e;
        },
        g = e.encodePart || ((t) => t);
      for (; p < n.length; ) {
        const t = f("CHAR"),
          e = f("NAME");
        let n = f("PATTERN");
        if ((e || n || !f("ASTERISK") || (n = ".*"), e || n)) {
          let s = t || "";
          -1 === r.indexOf(s) && ((c += s), (s = "")),
            c && (o.push(g(c)), (c = ""));
          const i = e || h++;
          if (u.has(i)) throw new TypeError(`Duplicate name '${i}'.`);
          u.add(i),
            o.push({
              name: i,
              prefix: g(s),
              suffix: "",
              pattern: n || a,
              modifier: l() || "",
            });
          continue;
        }
        const s = t || f("ESCAPED_CHAR");
        if (s) c += s;
        else if (f("OPEN")) {
          const t = d(),
            e = f("NAME") || "";
          let n = f("PATTERN") || "";
          e || n || !f("ASTERISK") || (n = ".*");
          const s = d();
          m("CLOSE");
          const r = l() || "";
          if (!e && !n && !r) {
            c += t;
            continue;
          }
          if (!e && !n && !t) continue;
          c && (o.push(g(c)), (c = "")),
            o.push({
              name: e || (n ? h++ : ""),
              pattern: e && !n ? a : n,
              prefix: g(t),
              suffix: g(s),
              modifier: r,
            });
        } else c && (o.push(g(c)), (c = "")), m("END");
      }
      return o;
    }
    function i(t) {
      return t.replace(/([.+*?^${}()[\]|/\\])/g, "\\$1");
    }
    function a(t) {
      return t && t.sensitive ? "u" : "ui";
    }
    function o(t, e, n = {}) {
      const {
          strict: s = !1,
          start: r = !0,
          end: o = !0,
          encode: h = (t) => t,
        } = n,
        p = `[${i(n.endsWith || "")}]|$`,
        c = `[${i(n.delimiter || "/#?")}]`;
      let u = r ? "^" : "";
      for (const n of t)
        if ("string" == typeof n) u += i(h(n));
        else {
          const t = i(h(n.prefix)),
            s = i(h(n.suffix));
          if (n.pattern)
            if ((e && e.push(n), t || s))
              if ("+" === n.modifier || "*" === n.modifier) {
                const e = "*" === n.modifier ? "?" : "";
                u += `(?:${t}((?:${n.pattern})(?:${s}${t}(?:${n.pattern}))*)${s})${e}`;
              } else u += `(?:${t}(${n.pattern})${s})${n.modifier}`;
            else
              "+" === n.modifier || "*" === n.modifier
                ? (u += `((?:${n.pattern})${n.modifier})`)
                : (u += `(${n.pattern})${n.modifier}`);
          else u += `(?:${t}${s})${n.modifier}`;
        }
      if (o) s || (u += `${c}?`), (u += n.endsWith ? `(?=${p})` : "$");
      else {
        const e = t[t.length - 1],
          n =
            "string" == typeof e
              ? c.indexOf(e[e.length - 1]) > -1
              : void 0 === e;
        s || (u += `(?:${c}(?=${p}))?`), n || (u += `(?=${c}|${p})`);
      }
      return new RegExp(u, a(n));
    }
    function h(t, e, n) {
      return t instanceof RegExp
        ? (function (t, e) {
            if (!e) return t;
            const n = /\((?:\?<(.*?)>)?(?!\?)/g;
            let s = 0,
              r = n.exec(t.source);
            for (; r; )
              e.push({
                name: r[1] || s++,
                prefix: "",
                suffix: "",
                modifier: "",
                pattern: "",
              }),
                (r = n.exec(t.source));
            return t;
          })(t, e)
        : Array.isArray(t)
        ? (function (t, e, n) {
            const s = t.map((t) => h(t, e, n).source);
            return new RegExp(`(?:${s.join("|")})`, a(n));
          })(t, e, n)
        : (function (t, e, n) {
            return o(r(t, n), e, n);
          })(t, e, n);
    }
    var p = { delimiter: "", prefixes: "", sensitive: !0, strict: !0 },
      c = { delimiter: ".", prefixes: "", sensitive: !0, strict: !0 },
      u = { delimiter: "/", prefixes: "/", sensitive: !0, strict: !0 };
    function f(t, e) {
      return t.startsWith(e) ? t.substring(e.length, t.length) : t;
    }
    function l(t) {
      return !(
        !t ||
        t.length < 2 ||
        ("[" !== t[0] && (("\\" !== t[0] && "{" !== t[0]) || "[" !== t[1]))
      );
    }
    var m = ["ftp", "file", "http", "https", "ws", "wss"];
    function d(t) {
      if (!t) return !0;
      for (const e of m) if (t.test(e)) return !0;
      return !1;
    }
    function g(t) {
      switch (t) {
        case "ws":
        case "http":
          return "80";
        case "wws":
        case "https":
          return "443";
        case "ftp":
          return "21";
        default:
          return "";
      }
    }
    function x(t) {
      if ("" === t) return t;
      if (/^[-+.A-Za-z0-9]*$/.test(t)) return t.toLowerCase();
      throw new TypeError(`Invalid protocol '${t}'.`);
    }
    function S(t) {
      if ("" === t) return t;
      const e = new URL("https://example.com");
      return (e.username = t), e.username;
    }
    function w(t) {
      if ("" === t) return t;
      const e = new URL("https://example.com");
      return (e.password = t), e.password;
    }
    function k(t) {
      if ("" === t) return t;
      if (/[\t\n\r #%/:<>?@[\]^\\|]/g.test(t))
        throw new TypeError(`Invalid hostname '${t}'`);
      const e = new URL("https://example.com");
      return (e.hostname = t), e.hostname;
    }
    function y(t) {
      if ("" === t) return t;
      if (/[^0-9a-fA-F[\]:]/g.test(t))
        throw new TypeError(`Invalid IPv6 hostname '${t}'`);
      return t.toLowerCase();
    }
    function P(t) {
      if ("" === t) return t;
      if (/^[0-9]*$/.test(t) && parseInt(t) <= 65535) return t;
      throw new TypeError(`Invalid port '${t}'.`);
    }
    function R(t) {
      if ("" === t) return t;
      const e = new URL("https://example.com");
      return (
        (e.pathname = "/" !== t[0] ? `/-${t}` : t),
        "/" !== t[0] ? e.pathname.substring(2, e.pathname.length) : e.pathname
      );
    }
    function b(t) {
      return "" === t ? t : new URL(`data:${t}`).pathname;
    }
    function $(t) {
      if ("" === t) return t;
      const e = new URL("https://example.com");
      return (e.search = t), e.search.substring(1, e.search.length);
    }
    function I(t) {
      if ("" === t) return t;
      const e = new URL("https://example.com");
      return (e.hash = t), e.hash.substring(1, e.hash.length);
    }
    var C = [
        "protocol",
        "username",
        "password",
        "hostname",
        "port",
        "pathname",
        "search",
        "hash",
      ],
      E = "*";
    function L(t, e) {
      if ("string" != typeof t)
        throw new TypeError("parameter 1 is not of type 'string'.");
      const n = new URL(t, e);
      return {
        protocol: n.protocol.substring(0, n.protocol.length - 1),
        username: n.username,
        password: n.password,
        hostname: n.hostname,
        port: n.port,
        pathname: n.pathname,
        search:
          "" != n.search ? n.search.substring(1, n.search.length) : void 0,
        hash: "" != n.hash ? n.hash.substring(1, n.hash.length) : void 0,
      };
    }
    function v(t, e, n) {
      let s;
      if ("string" == typeof e.baseURL)
        try {
          (s = new URL(e.baseURL)),
            (t.protocol = s.protocol
              ? s.protocol.substring(0, s.protocol.length - 1)
              : ""),
            (t.username = s.username),
            (t.password = s.password),
            (t.hostname = s.hostname),
            (t.port = s.port),
            (t.pathname = s.pathname),
            (t.search = s.search ? s.search.substring(1, s.search.length) : ""),
            (t.hash = s.hash ? s.hash.substring(1, s.hash.length) : "");
        } catch {
          throw new TypeError(`invalid baseURL '${e.baseURL}'.`);
        }
      if (
        ("string" == typeof e.protocol &&
          (t.protocol = (function (t, e) {
            var n;
            return (
              (t = (n = t).endsWith(":") ? n.substr(0, n.length - 1) : n),
              e || "" === t ? t : x(t)
            );
          })(e.protocol, n)),
        "string" == typeof e.username &&
          (t.username = (function (t, e) {
            if (e || "" === t) return t;
            const n = new URL("https://example.com");
            return (n.username = t), n.username;
          })(e.username, n)),
        "string" == typeof e.password &&
          (t.password = (function (t, e) {
            if (e || "" === t) return t;
            const n = new URL("https://example.com");
            return (n.password = t), n.password;
          })(e.password, n)),
        "string" == typeof e.hostname &&
          (t.hostname = (function (t, e) {
            return e || "" === t ? t : l(t) ? y(t) : k(t);
          })(e.hostname, n)),
        "string" == typeof e.port &&
          (t.port = (function (t, e, n) {
            return g(e) === t && (t = ""), n || "" === t ? t : P(t);
          })(e.port, t.protocol, n)),
        "string" == typeof e.pathname)
      ) {
        if (
          ((t.pathname = e.pathname),
          s &&
            !(function (t, e) {
              return !(
                !t.length ||
                ("/" !== t[0] &&
                  (!e ||
                    t.length < 2 ||
                    ("\\" != t[0] && "{" != t[0]) ||
                    "/" != t[1]))
              );
            })(t.pathname, n))
        ) {
          const e = s.pathname.lastIndexOf("/");
          e >= 0 && (t.pathname = s.pathname.substring(0, e + 1) + t.pathname);
        }
        t.pathname = (function (t, e, n) {
          if (n || "" === t) return t;
          if (e && !m.includes(e)) return new URL(`${e}:${t}`).pathname;
          const s = "/" == t[0];
          return (
            (t = new URL(s ? t : `/-${t}`, "https://example.com").pathname),
            s || (t = t.substring(2, t.length)),
            t
          );
        })(t.pathname, t.protocol, n);
      }
      return (
        "string" == typeof e.search &&
          (t.search = (function (t, e) {
            if (((t = f(t, "?")), e || "" === t)) return t;
            const n = new URL("https://example.com");
            return (
              (n.search = t),
              n.search ? n.search.substring(1, n.search.length) : ""
            );
          })(e.search, n)),
        "string" == typeof e.hash &&
          (t.hash = (function (t, e) {
            if (((t = f(t, "#")), e || "" === t)) return t;
            const n = new URL("https://example.com");
            return (
              (n.hash = t), n.hash ? n.hash.substring(1, n.hash.length) : ""
            );
          })(e.hash, n)),
        t
      );
    }
    function A(t) {
      return t.replace(/([+*?:{}()\\])/g, "\\$1");
    }
    function T(t, e) {
      const n = `[^${
        ((s = e.delimiter || "/#?"),
        s.replace(/([.+*?^${}()[\]|/\\])/g, "\\$1"))
      }]+?`;
      var s;
      const r = /[$_\u200C\u200D\p{ID_Continue}]/u;
      let i = "";
      for (let s = 0; s < t.length; ++s) {
        const a = t[s],
          o = s > 0 ? t[s - 1] : null,
          h = s < t.length - 1 ? t[s + 1] : null;
        if ("string" == typeof a) {
          i += A(a);
          continue;
        }
        if ("" === a.pattern) {
          if ("" === a.modifier) {
            i += A(a.prefix);
            continue;
          }
          i += `{${A(a.prefix)}}${a.modifier}`;
          continue;
        }
        const p = "number" != typeof a.name,
          c = void 0 !== e.prefixes ? e.prefixes : "./";
        let u =
          "" !== a.suffix ||
          ("" !== a.prefix && (1 !== a.prefix.length || !c.includes(a.prefix)));
        if (
          !u &&
          p &&
          a.pattern === n &&
          "" === a.modifier &&
          h &&
          !h.prefix &&
          !h.suffix
        )
          if ("string" == typeof h) {
            const t = h.length > 0 ? h[0] : "";
            u = r.test(t);
          } else u = "number" == typeof h.name;
        if (
          !u &&
          "" === a.prefix &&
          o &&
          "string" == typeof o &&
          o.length > 0
        ) {
          const t = o[o.length - 1];
          u = c.includes(t);
        }
        u && (i += "{"),
          (i += A(a.prefix)),
          p && (i += `:${a.name}`),
          ".*" === a.pattern
            ? p ||
              (o &&
                "string" != typeof o &&
                !o.modifier &&
                !u &&
                "" === a.prefix)
              ? (i += "(.*)")
              : (i += "*")
            : a.pattern === n
            ? p || (i += `(${n})`)
            : (i += `(${a.pattern})`),
          a.pattern === n &&
            p &&
            "" !== a.suffix &&
            r.test(a.suffix[0]) &&
            (i += "\\"),
          (i += A(a.suffix)),
          u && (i += "}"),
          (i += a.modifier);
      }
      return i;
    }
    var U = class {
      constructor(t = {}, e) {
        (this.regexp = {}), (this.keys = {}), (this.component_pattern = {});
        try {
          if ("string" == typeof t) {
            const n = new (class {
              constructor(t) {
                (this.tokenList = []),
                  (this.internalResult = {}),
                  (this.tokenIndex = 0),
                  (this.tokenIncrement = 1),
                  (this.componentStart = 0),
                  (this.state = 0),
                  (this.groupDepth = 0),
                  (this.hostnameIPv6BracketDepth = 0),
                  (this.shouldTreatAsStandardURL = !1),
                  (this.input = t);
              }
              get result() {
                return this.internalResult;
              }
              parse() {
                for (
                  this.tokenList = s(this.input, !0);
                  this.tokenIndex < this.tokenList.length;
                  this.tokenIndex += this.tokenIncrement
                ) {
                  if (
                    ((this.tokenIncrement = 1),
                    "END" === this.tokenList[this.tokenIndex].type)
                  ) {
                    if (0 === this.state) {
                      this.rewind(),
                        this.isHashPrefix()
                          ? this.changeState(9, 1)
                          : this.isSearchPrefix()
                          ? (this.changeState(8, 1),
                            (this.internalResult.hash = ""))
                          : (this.changeState(7, 0),
                            (this.internalResult.search = ""),
                            (this.internalResult.hash = ""));
                      continue;
                    }
                    if (2 === this.state) {
                      this.rewindAndSetState(5);
                      continue;
                    }
                    this.changeState(10, 0);
                    break;
                  }
                  if (this.groupDepth > 0) {
                    if (!this.isGroupClose()) continue;
                    this.groupDepth -= 1;
                  }
                  if (this.isGroupOpen()) this.groupDepth += 1;
                  else
                    switch (this.state) {
                      case 0:
                        this.isProtocolSuffix() &&
                          ((this.internalResult.username = ""),
                          (this.internalResult.password = ""),
                          (this.internalResult.hostname = ""),
                          (this.internalResult.port = ""),
                          (this.internalResult.pathname = ""),
                          (this.internalResult.search = ""),
                          (this.internalResult.hash = ""),
                          this.rewindAndSetState(1));
                        break;
                      case 1:
                        if (this.isProtocolSuffix()) {
                          this.computeShouldTreatAsStandardURL();
                          let t = 7,
                            e = 1;
                          this.shouldTreatAsStandardURL &&
                            (this.internalResult.pathname = "/"),
                            this.nextIsAuthoritySlashes()
                              ? ((t = 2), (e = 3))
                              : this.shouldTreatAsStandardURL && (t = 2),
                            this.changeState(t, e);
                        }
                        break;
                      case 2:
                        this.isIdentityTerminator()
                          ? this.rewindAndSetState(3)
                          : (this.isPathnameStart() ||
                              this.isSearchPrefix() ||
                              this.isHashPrefix()) &&
                            this.rewindAndSetState(5);
                        break;
                      case 3:
                        this.isPasswordPrefix()
                          ? this.changeState(4, 1)
                          : this.isIdentityTerminator() &&
                            this.changeState(5, 1);
                        break;
                      case 4:
                        this.isIdentityTerminator() && this.changeState(5, 1);
                        break;
                      case 5:
                        this.isIPv6Open()
                          ? (this.hostnameIPv6BracketDepth += 1)
                          : this.isIPv6Close() &&
                            (this.hostnameIPv6BracketDepth -= 1),
                          this.isPortPrefix() && !this.hostnameIPv6BracketDepth
                            ? this.changeState(6, 1)
                            : this.isPathnameStart()
                            ? this.changeState(7, 0)
                            : this.isSearchPrefix()
                            ? this.changeState(8, 1)
                            : this.isHashPrefix() && this.changeState(9, 1);
                        break;
                      case 6:
                        this.isPathnameStart()
                          ? this.changeState(7, 0)
                          : this.isSearchPrefix()
                          ? this.changeState(8, 1)
                          : this.isHashPrefix() && this.changeState(9, 1);
                        break;
                      case 7:
                        this.isSearchPrefix()
                          ? this.changeState(8, 1)
                          : this.isHashPrefix() && this.changeState(9, 1);
                        break;
                      case 8:
                        this.isHashPrefix() && this.changeState(9, 1);
                    }
                }
              }
              changeState(t, e) {
                switch (this.state) {
                  case 0:
                  case 2:
                  case 10:
                    break;
                  case 1:
                    this.internalResult.protocol = this.makeComponentString();
                    break;
                  case 3:
                    this.internalResult.username = this.makeComponentString();
                    break;
                  case 4:
                    this.internalResult.password = this.makeComponentString();
                    break;
                  case 5:
                    this.internalResult.hostname = this.makeComponentString();
                    break;
                  case 6:
                    this.internalResult.port = this.makeComponentString();
                    break;
                  case 7:
                    this.internalResult.pathname = this.makeComponentString();
                    break;
                  case 8:
                    this.internalResult.search = this.makeComponentString();
                    break;
                  case 9:
                    this.internalResult.hash = this.makeComponentString();
                }
                this.changeStateWithoutSettingComponent(t, e);
              }
              changeStateWithoutSettingComponent(t, e) {
                (this.state = t),
                  (this.componentStart = this.tokenIndex + e),
                  (this.tokenIndex += e),
                  (this.tokenIncrement = 0);
              }
              rewind() {
                (this.tokenIndex = this.componentStart),
                  (this.tokenIncrement = 0);
              }
              rewindAndSetState(t) {
                this.rewind(), (this.state = t);
              }
              safeToken(t) {
                return (
                  t < 0 && (t = this.tokenList.length - t),
                  t < this.tokenList.length
                    ? this.tokenList[t]
                    : this.tokenList[this.tokenList.length - 1]
                );
              }
              isNonSpecialPatternChar(t, e) {
                const n = this.safeToken(t);
                return (
                  n.value === e &&
                  ("CHAR" === n.type ||
                    "ESCAPED_CHAR" === n.type ||
                    "INVALID_CHAR" === n.type)
                );
              }
              isProtocolSuffix() {
                return this.isNonSpecialPatternChar(this.tokenIndex, ":");
              }
              nextIsAuthoritySlashes() {
                return (
                  this.isNonSpecialPatternChar(this.tokenIndex + 1, "/") &&
                  this.isNonSpecialPatternChar(this.tokenIndex + 2, "/")
                );
              }
              isIdentityTerminator() {
                return this.isNonSpecialPatternChar(this.tokenIndex, "@");
              }
              isPasswordPrefix() {
                return this.isNonSpecialPatternChar(this.tokenIndex, ":");
              }
              isPortPrefix() {
                return this.isNonSpecialPatternChar(this.tokenIndex, ":");
              }
              isPathnameStart() {
                return this.isNonSpecialPatternChar(this.tokenIndex, "/");
              }
              isSearchPrefix() {
                if (this.isNonSpecialPatternChar(this.tokenIndex, "?"))
                  return !0;
                if ("?" !== this.tokenList[this.tokenIndex].value) return !1;
                const t = this.safeToken(this.tokenIndex - 1);
                return (
                  "NAME" !== t.type &&
                  "PATTERN" !== t.type &&
                  "CLOSE" !== t.type &&
                  "ASTERISK" !== t.type
                );
              }
              isHashPrefix() {
                return this.isNonSpecialPatternChar(this.tokenIndex, "#");
              }
              isGroupOpen() {
                return "OPEN" == this.tokenList[this.tokenIndex].type;
              }
              isGroupClose() {
                return "CLOSE" == this.tokenList[this.tokenIndex].type;
              }
              isIPv6Open() {
                return this.isNonSpecialPatternChar(this.tokenIndex, "[");
              }
              isIPv6Close() {
                return this.isNonSpecialPatternChar(this.tokenIndex, "]");
              }
              makeComponentString() {
                const t = this.tokenList[this.tokenIndex],
                  e = this.safeToken(this.componentStart).index;
                return this.input.substring(e, t.index);
              }
              computeShouldTreatAsStandardURL() {
                const t = {};
                Object.assign(t, p), (t.encodePart = x);
                const e = h(this.makeComponentString(), void 0, t);
                this.shouldTreatAsStandardURL = d(e);
              }
            })(t);
            if ((n.parse(), (t = n.result), e)) {
              if ("string" != typeof e)
                throw new TypeError(
                  "'baseURL' parameter is not of type 'string'."
                );
              t.baseURL = e;
            } else if ("string" != typeof t.protocol)
              throw new TypeError(
                "A base URL must be provided for a relative constructor string."
              );
          } else if (e)
            throw new TypeError("parameter 1 is not of type 'string'.");
          if (!t || "object" != typeof t)
            throw new TypeError(
              "parameter 1 is not of type 'string' and cannot convert to dictionary."
            );
          const n = {
            pathname: E,
            protocol: E,
            username: E,
            password: E,
            hostname: E,
            port: E,
            search: E,
            hash: E,
          };
          let i;
          for (i of ((this.pattern = v(n, t, !0)),
          g(this.pattern.protocol) === this.pattern.port &&
            (this.pattern.port = ""),
          C)) {
            if (!(i in this.pattern)) continue;
            const t = {},
              e = this.pattern[i];
            switch (((this.keys[i] = []), i)) {
              case "protocol":
                Object.assign(t, p), (t.encodePart = x);
                break;
              case "username":
                Object.assign(t, p), (t.encodePart = S);
                break;
              case "password":
                Object.assign(t, p), (t.encodePart = w);
                break;
              case "hostname":
                Object.assign(t, c),
                  l(e) ? (t.encodePart = y) : (t.encodePart = k);
                break;
              case "port":
                Object.assign(t, p), (t.encodePart = P);
                break;
              case "pathname":
                d(this.regexp.protocol)
                  ? (Object.assign(t, u), (t.encodePart = R))
                  : (Object.assign(t, p), (t.encodePart = b));
                break;
              case "search":
                Object.assign(t, p), (t.encodePart = $);
                break;
              case "hash":
                Object.assign(t, p), (t.encodePart = I);
            }
            try {
              const n = r(e, t);
              (this.regexp[i] = o(n, this.keys[i], t)),
                (this.component_pattern[i] = T(n, t));
            } catch {
              throw new TypeError(`invalid ${i} pattern '${this.pattern[i]}'.`);
            }
          }
        } catch (t) {
          throw new TypeError(`Failed to construct 'URLPattern': ${t.message}`);
        }
      }
      test(t = {}, e) {
        let n,
          s = {
            pathname: "",
            protocol: "",
            username: "",
            password: "",
            hostname: "",
            port: "",
            search: "",
            hash: "",
          };
        if ("string" != typeof t && e)
          throw new TypeError("parameter 1 is not of type 'string'.");
        if (void 0 === t) return !1;
        try {
          s = v(s, "object" == typeof t ? t : L(t, e), !1);
        } catch (t) {
          return !1;
        }
        for (n in this.pattern) if (!this.regexp[n].exec(s[n])) return !1;
        return !0;
      }
      exec(t = {}, e) {
        let n = {
          pathname: "",
          protocol: "",
          username: "",
          password: "",
          hostname: "",
          port: "",
          search: "",
          hash: "",
        };
        if ("string" != typeof t && e)
          throw new TypeError("parameter 1 is not of type 'string'.");
        if (void 0 === t) return;
        try {
          n = v(n, "object" == typeof t ? t : L(t, e), !1);
        } catch (t) {
          return null;
        }
        let s,
          r = {};
        for (s in ((r.inputs = e ? [t, e] : [t]), this.pattern)) {
          let t = this.regexp[s].exec(n[s]);
          if (!t) return null;
          let e = {};
          for (let [n, r] of this.keys[s].entries())
            if ("string" == typeof r.name || "number" == typeof r.name) {
              let s = t[n + 1];
              e[r.name] = s;
            }
          r[s] = { input: n[s] || "", groups: e };
        }
        return r;
      }
      get protocol() {
        return this.component_pattern.protocol;
      }
      get username() {
        return this.component_pattern.username;
      }
      get password() {
        return this.component_pattern.password;
      }
      get hostname() {
        return this.component_pattern.hostname;
      }
      get port() {
        return this.component_pattern.port;
      }
      get pathname() {
        return this.component_pattern.pathname;
      }
      get search() {
        return this.component_pattern.search;
      }
      get hash() {
        return this.component_pattern.hash;
      }
    };
    globalThis.URLPattern || (globalThis.URLPattern = U),
      (window.URLPattern = U);
  })(),
  Class(function AppState(_default) {
    const _this = this;
    var iGLUI,
      _map = new Map(),
      _bindings = new Map();
    class StateBinding {
      constructor(_keys, _obj) {
        if (
          ((this._keys = _keys),
          (this._obj = _obj),
          (this._string = ""),
          (this._oldValue = ""),
          (this._type = ""),
          (this._bindingLookup = ""),
          this._onDestroy,
          void 0 === iGLUI && (iGLUI = !!window.GLUI),
          _obj instanceof HTMLElement)
        )
          "INPUT" == _obj.nodeName
            ? (this._string = _obj.value)
            : (this._string = _obj.innerText),
            (this._type = "HTMLElement");
        else if (_obj instanceof DOMAttribute)
          (this._string = _obj.value),
            (this._name = _obj.name),
            (this._belongsTo = _obj.belongsTo),
            (this._bindingLookup = _obj.bindingLookup),
            (this._type = "DOMAttribute");
        else if ("function" == typeof Sprite && _obj instanceof Sprite)
          (this._string = _obj.id), (this._type = "Sprite");
        else if (_obj instanceof HydraObject)
          "input" == _obj._type
            ? (this._string = _obj.val())
            : (this._string = _obj.text()),
            (this._type = "HydraObject");
        else if (iGLUI && _obj instanceof GLUIText)
          (this._string = _obj.getTextString()), (this._type = "GLUIText");
        else if (
          (_obj.createLocal && (this._type = "appState"),
          _obj.onStateChange && (this._type = "class"),
          "function" == typeof _obj && (this._type = "function"),
          Array.isArray(_obj) && _obj.every((el) => "function" == typeof el))
        ) {
          this._type = "piped";
          const lastFunctionInChain = this._obj.pop();
          (this._operators = this._obj),
            (this._obj = lastFunctionInChain),
            (this._count = 0);
        }
      }
      parse(key, value) {
        if (!this._string || !this._string.includes("@[")) return value;
        let string = this._string;
        return (
          this._keys.forEach((key) => {
            string = string.replace(`@[${key}]`, _this.get(key));
          }),
          string
        );
      }
      async operateOnValue(value) {
        return await this._operators.reduce(async (prev, fn) => {
          const prevResolved = await prev;
          return (await fn)(prevResolved, this._count++, this);
        }, value);
      }
      update(key, value, force) {
        let newValue = this.parse(key, value);
        if (!(newValue !== this._oldValue || (value && value.push) || force))
          return;
        let oldValue = this._oldValue;
        this._oldValue = newValue;
        try {
          switch (this._type) {
            case "HTMLElement":
              "input" == this._obj._type
                ? (this._obj.value = newValue)
                : (this._obj.innerText = newValue);
              break;
            case "DOMAttribute":
              this._obj.belongsTo.setAttribute(
                this._obj.name,
                this._obj.value.replace(this._obj.bindingLookup, newValue)
              );
              break;
            case "Sprite":
              this._obj.id = newValue;
              break;
            case "HydraObject":
              "input" == this._obj._type
                ? this._obj.val(newValue)
                : this._obj.text(newValue);
              break;
            case "GLUIText":
              this._obj.setText(newValue);
              break;
            case "function":
              this._obj(value, oldValue);
              break;
            case "piped":
              this.operateOnValue(value).then(
                (val) => this._obj(val),
                (reject) => null
              );
              break;
            case "class":
              this._obj.onStateChange(value);
              break;
            case "appState":
              this._obj.set(key, value);
          }
        } catch (err) {
          throw (
            (console.error(
              "AppState binding failed to execute. You should probably be using _this.bindState instead"
            ),
            console.error(err),
            err)
          );
        }
        return !0;
      }
      _bindOnDestroy(cb) {
        this._onDestroy || (this._onDestroy = []), this._onDestroy.push(cb);
      }
      destroy() {
        this._onDestroy && this._onDestroy.forEach((cb) => cb()),
          (this._keys = null),
          (this._obj = null),
          (this._string = null),
          (this._oldValue = null),
          (this._type = null),
          (this._operators = null),
          (this._count = null),
          (this.update = null);
      }
    }
    (this.set = function (key, value, force) {
      if (_this.readonly)
        return console.warn("This AppState is locked and can not make changes");
      _map.set(key, value), _this.onUpdate && _this.onUpdate();
      let array = _bindings.get(key);
      if (array) {
        let len = array.length;
        for (let i = 0; i < len; i++) {
          let b = array[i];
          b && b.update
            ? b.update(key, value, force)
            : (array.splice(i, 1), (i -= 1), (len = array.length));
        }
      }
    }),
      (this.get = function (key) {
        return _map.get(key);
      }),
      (this.getMap = function () {
        return _map;
      }),
      (this.toJSON = function () {
        return Object.fromEntries(_map);
      }),
      (this.bind = function (keys, ...rest) {
        if (!rest.length) return { state: _this, key: keys };
        Array.isArray(keys) || (keys = [keys]);
        const obj = 1 === rest.length ? rest[0] : rest;
        let binding = new StateBinding(keys, obj);
        return (
          keys.forEach((key) => {
            _bindings.has(key)
              ? _bindings.get(key).push(binding)
              : _bindings.set(key, [binding]);
            let value = _map.get(key);
            void 0 !== value && binding.update(key, value);
          }),
          binding
        );
      }),
      (this.createLocal = function (obj, fixProps) {
        if (fixProps)
          for (let key in obj) {
            let val = obj[key];
            "true" === val && (obj[key] = !0),
              "false" === val && (obj[key] = !1),
              isNaN(val) || (obj[key] = Number(val));
          }
        let appState = new AppState(obj);
        return new Proxy(appState, {
          set: (target, property = "", value) => (
            property.includes(["origin", "onUpdate"])
              ? (appState[property] = value)
              : appState.set(property, value),
            !0
          ),
          get: (target, property) =>
            target[property] ? target[property] : appState.get(property),
        });
      }),
      (this.setAll = function (obj) {
        for (let key in obj) _this.set(key, obj[key]);
      }),
      (this.lock = function () {
        _this.readonly = !0;
      }),
      (this.unlock = function () {
        _this.readonly = !1;
      }),
      (this.isAppState = !0),
      _default && this.setAll(_default);
  }, "static"),
  Class(function AppStateOperators(_default) {
    Inherit(this, Component),
      (this.map = (fn) => (value) => fn(value)),
      (this.tap = (fn) => (value) => (fn(value), value)),
      (this.filter = (fn) => (value, emittedCount) =>
        fn(value, emittedCount) ? value : Promise.reject()),
      (this.skip = (skipCount) =>
        this.filter((_, emittedCount) => skipCount <= emittedCount)),
      (this.untilDestroyed = (ctx) => {
        let checked = !1;
        return (value, _, binding) => (
          checked ||
            ((checked = !0),
            ctx._bindOnDestroy((_) => {
              Hydra.LOCAL && console.log("binding destroyed "),
                binding.destroy?.();
            })),
          value
        );
      });
  }, "static"),
  Class(function AppStore() {
    const _this = this;
    this.state = AppState.createLocal();
    const _mutations = {},
      _actions = {};
    let _subscribers = [],
      _actionSubscribers = [];
    function registerMutation(type, handler) {
      (_mutations[type] || (_mutations[type] = [])).push(
        function wrappedMutationHandler(payload) {
          handler.call(_this, _this.state, payload);
        }
      );
    }
    function registerAction(type, handler) {
      (_actions[type] || (_actions[type] = [])).push(
        function wrappedActionHandler(payload) {
          let res = handler.call(
            _this,
            {
              dispatch: _this.dispatch,
              commit: _this.commit,
              state: _this.state,
              rootState: _this.state,
            },
            payload
          );
          return (
            (function isPromise(val) {
              return val && "function" == typeof val.then;
            })(res) || (res = Promise.resolve(res)),
            res
          );
        }
      );
    }
    function genericSubscribe(fn, subscribers, options) {
      return (
        subscribers.indexOf(fn) < 0 &&
          (options && options.prepend
            ? subscribers.unshift(fn)
            : subscribers.push(fn)),
        () => {
          const i = subscribers.indexOf(fn);
          i > -1 && subscribers.splice(i, 1);
        }
      );
    }
    (this.createAppStore = function (_params) {
      !(function setInitState(_params) {
        const { state: state } = _params;
        for (let key in state) _this.state.set(key, state[key]);
      })(_params),
        (function mapMutations(_params) {
          const { mutations: mutations } = _params;
          for (let key in mutations) registerMutation(key, mutations[key]);
        })(_params),
        (function mapActions(_params) {
          const { actions: actions } = _params;
          for (let key in actions) registerAction(key, actions[key]);
        })(_params);
    }),
      (this.commit = function (type, payload) {
        const mutation = { type: type, payload: payload },
          entry = _mutations[type];
        entry
          ? (entry.forEach(function commitIterator(handler) {
              handler(payload);
            }),
            _subscribers.slice().forEach((sub) => sub(mutation, this.state)))
          : Hydra.LOCAL && console.error(`Error: no mutation for type ${type}`);
      }),
      (this.dispatch = function (type, payload) {
        const action = { type: type, payload: payload },
          entry = _actions[type];
        entry ||
          (Hydra.LOCAL && console.error(`Error: no action for type ${type}`));
        try {
          _actionSubscribers
            .slice()
            .filter((sub) => sub.before)
            .forEach((sub) => sub.before(action, _this.state));
        } catch (e) {
          Hydra.LOCAL &&
            (console.warn("Error in before action subscribers: "),
            console.error(e));
        }
        const result =
          entry.length > 1
            ? Promise.all(entry.map((handler) => handler(payload)))
            : entry[0](payload);
        return new Promise((resolve, reject) => {
          result.then(
            (res) => {
              try {
                _actionSubscribers
                  .filter((sub) => sub.after)
                  .forEach((sub) => sub.after(action, _this.state));
              } catch (e) {
                Hydra.LOCAL &&
                  (console.warn("Error in after action subscribers: "),
                  console.error(e));
              }
              resolve(res);
            },
            (error) => {
              try {
                _actionSubscribers
                  .filter((sub) => sub.error)
                  .forEach((sub) => sub.error(action, _this.state, error));
              } catch (e) {
                Hydra.LOCAL &&
                  (console.warn("Error in error action subscribers: "),
                  console.error(e));
              }
              reject(error);
            }
          );
        });
      }),
      (this.subscribeAction = function (key, fn, options) {
        let subs = {};
        return (
          "function" == typeof fn
            ? (subs.before = function subscriberEmptyBeforeWrapper(action) {
                action.type === key && fn(action);
              })
            : (fn.before &&
                (subs.before = function subscriberBeforeWrapper(action) {
                  action.type === key && fn.before(action);
                }),
              fn.after &&
                (subs.after = function subscriberAfterWrapper(action) {
                  action.type === key && fn.after(action);
                })),
          genericSubscribe(subs, _actionSubscribers, options)
        );
      }),
      (this.subscribe = function (key, fn, options) {
        return genericSubscribe(
          function subscriberWrapper(mutation) {
            mutation.type === key && fn(mutation);
          },
          _subscribers,
          options
        );
      }),
      (this.bind = this.state.bind),
      (this.watch = this.state.bind),
      (this.get = this.state.get);
  }),
  Class(
    function StateArray(_src = [], _filterFn = null) {
      Inherit(this, Events);
      const _this = this;
      var _data = [];
      function wrap(obj) {
        if ("object" != typeof obj || Array.isArray(obj))
          throw "StateArray entries must be {objects}!";
        if ((obj._uid || (obj._uid = Utils.uuid()), obj.createLocal))
          return obj;
        let state = AppState.createLocal(obj);
        return (state.origin = obj), state;
      }
      if (
        (Object.defineProperty(_this, "length", { get: () => _data.length }),
        (this.setFilter = function (fn, refresh = !0) {
          (_filterFn = fn), refresh && this.refresh(_data.filter(fn));
        }),
        (this.push = function (obj) {
          if (_filterFn && !_filterFn(obj)) return;
          let state = wrap(obj);
          return (
            _data.push(state),
            (function setInterfaceAtIndex(index) {
              void 0 === _this[index] &&
                Object.defineProperty(_this, index, {
                  set(v) {
                    for (let key in v) _data[index].set(key, v[key]);
                  },
                  get: () => _data[index],
                });
            })(_data.length - 1),
            _this.events.fire(Events.UPDATE, { type: "add", state: state }),
            state
          );
        }),
        (this.remove = function (obj) {
          for (let i = 0; i < _data.length; i++) {
            let state = _data[i];
            (state.origin !== obj && state !== obj) ||
              (_data.splice(i, 1),
              _this.events.fire(
                Events.UPDATE,
                { type: "remove", state: state },
                !0
              ));
          }
        }),
        (this.update = async function (obj) {
          var _found = !1;
          for (let i = 0; i < _data.length; i++) {
            var state = _data[i];
            if (state.origin._uid === obj._uid || state._uid === obj._uid)
              return (
                await state.setAll(obj),
                _this.events.fire(Events.UPDATE, {
                  type: "modify",
                  state: state,
                  index: i,
                }),
                (_found = !0)
              );
          }
          return _found;
        }),
        (this.forEach = function (cb) {
          _data.forEach(function (...args) {
            return cb.apply(this, args);
          });
        }),
        (this.find = function (cb) {
          return _data.find(function (...args) {
            return cb.apply(this, args);
          });
        }),
        (this.insertAtIdx = function (idx, obj) {
          if ((obj._uid || (obj = wrap(obj)), !_data[Math.abs(idx)]))
            throw `There is no item at index ${idx} in this StateArray`;
          _data.splice(idx, 0, obj);
          const newData = _data.filter(() => !0);
          this.refresh(newData);
        }),
        (this.map = function (cb) {
          let array = [];
          return (
            _data.forEach(function (...args) {
              return array.push(cb.apply(this, args));
            }),
            array
          );
        }),
        (this.find = function (cb) {
          return _data.find(function (...args) {
            return cb.apply(this, args);
          });
        }),
        (this.toJSON = function () {
          let array = [];
          return (
            _data.forEach((appState) => {
              array.push(appState.toJSON());
            }),
            array
          );
        }),
        (this.getMap = function () {
          let array = [];
          return (
            _data.forEach((appState) => {
              array.push(appState.getMap());
            }),
            array
          );
        }),
        (this.indexOf = function (obj) {
          for (let i = 0; i < _data.length; i++) {
            let state = _data[i];
            if (state.origin === obj || state === obj) return i;
          }
        }),
        (this.refresh = function (array) {
          Array.isArray(array) ||
            array instanceof StateArray ||
            (array = [array]),
            _this.events.fire(StateArray.REFRESH, { type: "refresh" }, !0);
          let i = _data.length;
          for (; i--; ) {
            let state = _data.pop();
            _this.events.fire(
              Events.UPDATE,
              { type: "remove", state: state },
              !0
            );
          }
          (_data.length = 0), array.forEach(_this.push);
        }),
        (this.reflow = function () {
          this.refresh(_data.map((d) => d.origin));
        }),
        !Array.isArray(_src))
      )
        throw "StateArray can only take an array as a parameter";
      _src.forEach(_this.push);
    },
    (_) => {
      StateArray.REFRESH = "state_array_refresh";
    }
  ),
  Class(
    function ViewState(ViewClass, ...rest) {
      this.destroy || Inherit(this, Component);
      const _this = this;
      var _stateArray,
        _params,
        _callbacks = {},
        _bindings = [],
        _removals = [];
      "object" == typeof ViewClass &&
        ViewClass.view &&
        ((ViewClass = (_params = ViewClass).view),
        (rest = [_params]),
        delete _params.view,
        (_this.listen = function (key, callback) {
          _bindings.push(key), (_callbacks[key] = callback);
        })),
        "string" == typeof ViewClass && (ViewClass = window[ViewClass]);
      var _instances = (this.views = []);
      function remove(data) {
        _this.animating = !0;
        for (let i = 0; i < _instances.length; i++) {
          let inst = _instances[i];
          if (data == inst.data) {
            let promise =
              _this.onRemoveView?.(inst, i) || inst.onRemoveView?.(i);
            promise &&
              promise.then &&
              (_removals.push(promise),
              _this.disableAutoDestroy ||
                promise.then((_) => inst.destroy?.())),
              _instances.splice(i, 1),
              0 === _instances.length && _this.onEmpty?.(),
              (promise && promise.then) ||
                _this.disableAutoDestroy ||
                !inst.destroy ||
                inst.destroy();
            break;
          }
        }
        if ((ViewState.clearScheduled(data), _removals.length)) {
          let removals = _removals.slice();
          Promise.all(removals).then((_) => {
            removals.forEach((removal) => {
              _removals.remove(removal);
            }),
              0 === _removals.length && (_this.animating = !1);
          });
        }
      }
      async function dataUpdate(e) {
        switch (e.type) {
          case "add":
            for (; _removals.length; ) await Promise.all(_removals);
            _this.dataFilter(e.state) &&
              ViewState.schedule(
                _this,
                ViewClass,
                e.state,
                _stateArray.indexOf(e.state),
                rest
              );
            break;
          case "remove":
            remove(e.state);
            break;
          case "modify":
            _this.dataFilter(e.state)
              ? (function update(data, index) {
                  var _exists = !1;
                  for (let i = 0; i < _instances.length; i++) {
                    let inst = _instances[i];
                    if (data._uid === inst.data._uid)
                      return (
                        _this.onUpdateView?.(_instances[i], i),
                        void (_exists = !0)
                      );
                  }
                  _exists ||
                    ViewState.schedule(
                      _this,
                      ViewClass,
                      data,
                      _stateArray.indexOf(data)
                    );
                })(e.state, e.index)
              : remove(e.state);
        }
      }
      (this.setSourceData = function (array) {
        if (
          (!Array.isArray(array) ||
            array instanceof StateArray ||
            (array = new StateArray(array)),
          !(array instanceof StateArray || Array.isArray(array)))
        )
          throw "ViewState::setSourceData must be instance of StateArray";
        (_stateArray = _this.stateArray = array),
          _this.events.sub(array, Events.UPDATE, dataUpdate),
          array.forEach((state) => {
            _this.dataFilter(state) &&
              ViewState.schedule(
                _this,
                ViewClass,
                state,
                _stateArray.indexOf(state),
                rest
              );
          });
      }),
        (this.dataFilter = function (data) {
          return !0;
        }),
        (this.onInitialize = function (instance) {
          let unfilteredIndex = _stateArray.indexOf(instance.data),
            filteredIndex = -1;
          for (let i = 0; i < _instances.length; ++i) {
            let data = _instances[i].data;
            if (_stateArray.indexOf(data) > unfilteredIndex) {
              filteredIndex = i;
              break;
            }
          }
          if (
            (filteredIndex < 0 && (filteredIndex = _instances.length),
            instance.element &&
              _this.parent.element &&
              _this.parent.element.add)
          ) {
            let before = null;
            filteredIndex < _instances.length &&
              _instances[filteredIndex].element &&
              (before = _instances[filteredIndex]),
              _this.parent.element.add(instance.element, before);
          }
          _instances.splice(filteredIndex, 0, instance),
            _this.listen &&
              instance.state &&
              _bindings.forEach((key) => {
                _this.bindState(instance.state, key, (data) => {
                  _callbacks[key]?.({ target: instance, data: data });
                });
              }),
            _params?.__parent && _params.__parent.add(instance),
            _this.onAddView?.(instance, filteredIndex),
            _params?.onAddView?.(instance, filteredIndex);
        }),
        _params?.data && this.setSourceData(_params.data);
    },
    (_) => {
      const queue = [],
        worker = new Render.Worker((_) => {
          let obj = queue.shift();
          if (obj) {
            let {
              ref: ref,
              ViewClass: ViewClass,
              data: data,
              index: index,
              additionalArgs: additionalArgs,
            } = obj;
            if (!ref.initClass) return;
            let args = [];
            additionalArgs.forEach((arg) => {
              args.push(...arg);
            });
            let inst = ref.initClass(ViewClass, data, index, ...args, null);
            (inst.data = data), ref.onInitialize(inst);
          } else worker.pause();
        }, 2);
      worker.pause(),
        (ViewState.clearScheduled = function (data) {
          for (let i = 0; i < queue.length; i++) {
            if (queue[i].data === data) return queue.splice(i, 1);
          }
        }),
        (ViewState.schedule = function (ref, ViewClass, data, index, ...rest) {
          ref.initClass &&
            (queue.push({
              ref: ref,
              ViewClass: ViewClass,
              data: data,
              index: index,
              additionalArgs: rest,
            }),
            worker.resume());
        });
    }
  ),
  Class(function ViewStateElement() {}),
  Class(function StateComponent() {
    const _this = this;
    let _mutationsUnsubscribers = [],
      _actionsUnsubscribers = [];
    (this.unsubscribeMutations = function () {
      _mutationsUnsubscribers.forEach((u) => u());
    }),
      (this.unsubscribeActions = function () {
        _actionsUnsubscribers.forEach((u) => u());
      }),
      (this.unsubscribeAll = function () {
        _this.unsubscribeMutations(), _this.unsubscribeActions();
      }),
      (this.subscribeMutation = function (store, type, fn) {
        _mutationsUnsubscribers.push(store.subscribe(type, fn));
      }),
      (this.subscribeAction = function (store, type, fn) {
        _actionsUnsubscribers.push(store.subscribeAction(type, fn));
      }),
      (this.commit = function (store, type, payload) {
        store.commit(type, payload);
      }),
      (this.dispatch = async function (store, type, payload) {
        await store.dispatch(type, payload);
      }),
      (this.getState = function (store, key) {
        return store.get(key);
      }),
      (this.watch = function (store, key, fn, callInitial = !0) {
        let hasCalled = !1;
        const callback = (params) => {
          hasCalled || callInitial ? fn(params) : (hasCalled = !0);
        };
        return _this.bindState
          ? _this.bindState(store, key, callback)
          : store.watch(key, callback);
      }),
      (this.bind = this.watch),
      "function" == typeof this._bindOnDestroy &&
        this._bindOnDestroy(() => {
          _this.unsubscribeAll();
        });
  }),
  Class(function Dev() {
    const _this = this;
    let _post, _inter, _timerName;
    Utils.timestamp();
    function postError(error) {
      let device = getDebugInfo(),
        tests = getTests();
      post(`${_post}&type=error`, {
        error: error,
        device: device,
        tests: tests,
      }).catch(function () {
        Hydra.LOCAL && console.log("Error while posting to server");
      });
    }
    function getDebugInfo() {
      return {
        gpu: Device.graphics.webgl
          ? Device.graphics.webgl.gpu
          : "WEBGL UNAVAILABLE",
        version: Device.graphics.webgl
          ? Device.graphics.webgl.version
          : "WEBGL UNAVAILABLE",
        tier: window.GPU ? (Device.mobile ? GPU.M_TIER : GPU.TIER) : "",
        mobile: JSON.stringify(Device.mobile),
        userAgent: Device.agent,
        dpr: Device.pixelRatio,
        renderDPR: RenderManager.DPR,
        screenSize: `${screen.width} x ${screen.height}`,
        stageSize: `${Stage.width} x ${Stage.height}`,
        href: window.location.href,
        targetFPS: Render.REFRESH_RATE,
      };
    }
    function getTests() {
      let tests = {};
      try {
        if (window.Tests)
          for (let key in Tests)
            "function" == typeof Tests[key] && (tests[key] = Tests[key]());
      } catch (e) {}
      return tests;
    }
    function handleRenderCallbackError(info) {
      console.error("Error in render callback", info);
    }
    (_post = `https://us-central1-at-services.cloudfunctions.net/logger?projectId=${window.UIL_ID}`),
      Events.emitter._addEvent(
        Render.RENDER_CALLBACK_ERROR,
        handleRenderCallbackError
      ),
      (this.catchErrors = function catchErrors() {
        (window.onerror = function (message, file, line, column, e) {
          postError({
            message: message,
            file: file,
            line: line,
            column: column,
            stack: e && e.stack.toString(),
          });
        }),
          window.addEventListener("unhandledrejection", (e) => {
            postError({
              type: "unhandledrejection",
              message: e.reason.message,
              stack: e.reason.stack,
            });
          }),
          Events.emitter._addEvent(
            Render.RENDER_CALLBACK_ERROR,
            ({ callback: callback, error: error, component: component }) => {
              let name = callback.name;
              component &&
                (name = `${name} in ${Utils.getConstructorName(component)}`),
                postError({
                  message: `Error in render callback ${name}: ${
                    "string" == typeof error ? error : error.message
                  }`,
                  file: error.fileName,
                  line: error.lineNumber,
                  column: error.columnNumber,
                  stack: error.stack?.toString(),
                });
            }
          ),
          Events.emitter._removeEvent(
            Render.RENDER_CALLBACK_ERROR,
            handleRenderCallbackError
          );
      }),
      (this.emulator =
        Device.mobile &&
        navigator.platform &&
        navigator.platform.toLowerCase().includes(["mac", "windows"])),
      (this.expose = function (name, val, force) {
        (Hydra.LOCAL || force) && (window[name] = val);
      }),
      (this.unsupported = function (needsAlert) {
        needsAlert &&
          alert(
            "Hi! This build is not yet ready for this device, things may not work as expected. Refer to build schedule for when this device will be supported."
          );
      }),
      (this.checkForLeaks = function (flag, array) {
        if (window.AURA) return;
        let exceptions = [
          "_ga",
          "_typeface_js",
          "_xdc_",
          "_babelPolyfill",
          "$jscomp",
        ];
        window.HYDRA_LEAKS_EXCEPTIONS &&
          (exceptions = exceptions.concat(window.HYDRA_LEAKS_EXCEPTIONS));
        var matchArray = function (prop) {
          if (!array) return !1;
          for (var i = 0; i < array.length; i++)
            if (prop.includes(array[i])) return !0;
          return !1;
        };
        clearInterval(_inter),
          flag &&
            (_inter = setInterval(function () {
              for (var prop in window) {
                if (!prop.includes("webkit"))
                  if ("function" != typeof window[prop] && prop.length > 2) {
                    if (prop.includes(exceptions) || matchArray(prop)) continue;
                    var char1 = prop.charAt(0),
                      char2 = prop.charAt(1);
                    if (
                      ("_" == char1 || "$" == char1) &&
                      char2 !== char2.toUpperCase()
                    )
                      throw (
                        (console.log(window[prop]),
                        `Hydra Warning:: ${prop} leaking into global scope`)
                      );
                  }
              }
            }, 1e3));
      }),
      (this.postErrorsToServer = (_) => {}),
      (this.postPerfLog = function (perf) {
        let device = getDebugInfo(),
          tests = getTests();
        post(`${_post}&type=perf`, {
          perf: perf,
          device: device,
          tests: tests,
        }).catch(function () {
          Hydra.LOCAL && console.log("Error whle posting to server");
        });
      }),
      (this.startTimer = function (name) {
        (_timerName = name || "Timer"),
          console.time && !window._NODE_
            ? console.time(_timerName)
            : (_timer = performance.now());
      }),
      (this.stopTimer = function () {
        console.time && !window._NODE_
          ? console.timeEnd(_timerName)
          : console.log(`Render ${_timerName}: ${performance.now() - _timer}`);
      }),
      (this.writeFile = function (file, data) {
        let promise = Promise.create(),
          protocol = location.protocol,
          port = "https:" === protocol ? ":8018" : ":8017",
          url = `${protocol}//${location.hostname}${port}${
            _this.filesPath || location.pathname
          }${file}`;
        return (
          post(url, data, { headers: { "content-type": "text/plain" } }).then(
            (e) => {
              "OK" != e
                ? (console.warn(`Unable to write to ${file}`), promise.reject())
                : promise.resolve();
            }
          ),
          promise
        );
      }),
      (this.execUILScript = async function (name, data) {
        if (!Hydra.LOCAL) return;
        let url = `${location.protocol}//${location.hostname}:8017${
            _this.pathName || location.pathname
          }/uil/${name}`,
          response = await post(url, data, {
            headers: { "Content-Type": "text/plain" },
          });
        if ("ERROR" === response || !1 === response.success) throw response;
        return response;
      }),
      (this.auditCompressedTextures = function () {
        let compressedKeys = [],
          changes = 0;
        UILStorage.getKeys().forEach((key) => {
          let element = UILStorage.get(key);
          if ("string" == typeof element) {
            let json;
            try {
              (json = JSON.parse(element)),
                json.src &&
                  (!0 === json.compressed
                    ? console.warn(
                        `The texture ${json.src} is a ktx1 asset. Please convert it to ktx2.`
                      )
                    : "ktx2" === json.compressed &&
                      compressedKeys.push({
                        key: key,
                        src: json.src.split("?")[0],
                      }));
            } catch (e) {}
          }
        }),
          UILStorage.getKeys().forEach((key) => {
            let element = UILStorage.get(key);
            if ("string" == typeof element) {
              let json;
              try {
                (json = JSON.parse(element)),
                  json.src &&
                    compressedKeys.find(
                      (el) => json.src.split("?")[0] === el.src.split("?")[0]
                    ) &&
                    "ktx2" !== json.compressed &&
                    (changes++,
                    console.log(
                      `Changed ${
                        json.src.split("?")[0]
                      } in ${key} to use ktx2 compression.`
                    ),
                    UILStorage.set(
                      key,
                      JSON.stringify({
                        ...json,
                        src: json.src.split("?")[0],
                        compressed: "ktx2",
                      })
                    ),
                    _this.events.fire(UILControlImage.AUDIT));
              } catch (e) {}
            }
          }),
          changes
            ? console.warn(
                "Changes to UIL from auditCompressedTextures will not be saved until saving UIL and refreshing. Use Cmd+S or Ctrl+S to save and refresh any open SceneLayouts."
              )
            : console.log(
                "auditCompressedTextures did not find any textures that had instances using both uncompressed and compressed versions."
              );
      }),
      Hydra.LOCAL && _this.checkForLeaks(!0);
  }, "static"),
  Class(function Service() {
    Inherit(this, Component);
    var _sw,
      _this = this;
    function getSWAssets() {
      if (!window.ASSETS.SW || _this.cached) return [];
      var assets = window.ASSETS.SW;
      return (
        assets.forEach((asset, i) => {
          asset.includes(".js") &&
            (asset = assets[i].replace(".js", `.js?${window._CACHE_}`));
        }),
        assets
      );
    }
    function handleRegistration(e) {}
    function handleReady(e) {
      (_this.isReady = !0),
        _this.events.fire(Events.READY, e, !0),
        (_sw = navigator.serviceWorker.controller),
        (function checkCache() {
          Storage.get("service_cache") != window._CACHE_ &&
            _this.post("clearCache");
        })();
    }
    function handleError(e) {
      e && (_this.events.fire(Events.ERROR, e, !0), (_this.active = !1));
    }
    function handleMessage(e) {
      var data = e.data;
      data.evt && _this.events.fire(data.evt, data);
    }
    (this.active = !1),
      (this.ready = !1),
      (this.cached = !1),
      (this.offline = !1),
      (this.disabled = !1),
      (this.ready = function () {
        return this.wait(this, "isReady");
      }),
      (this.init = function () {
        Hydra.ready(() => {
          !("serviceWorker" in navigator) ||
            (Hydra.LOCAL && "" == location.port) ||
            window.process ||
            _this.disabled ||
            (function initWorker() {
              (_this.active = !0),
                navigator.serviceWorker
                  .register(`${window._SW_PATH_ ? window._SW_PATH_ : ""}sw.js`)
                  .then(handleRegistration)
                  .then(handleReady)
                  .then(handleError);
            })();
        });
      }),
      (this.cache = function (assets = []) {
        assets = Array.from(assets);
        _this.active &&
          _this.wait(_this, "ready", function () {
            _this.post("upload", {
              assets: assets,
              cdn: Assets.CDN,
              hostname: location.hostname,
              sw: getSWAssets(),
              offline: _this.offline,
            }),
              Storage.set("service_cache", window._CACHE_),
              (_this.cached = !0);
          });
      }),
      (this.post = function (fn, data = {}) {
        if (!_this.active) return;
        _this.wait(_this, "ready", function () {
          let mc = new MessageChannel();
          (mc.port1.onmessage = handleMessage),
            (data.fn = fn),
            _sw && _sw.postMessage(data, [mc.port2]);
        });
      });
  }, "static"),
  Class(function Storage() {
    var _storage,
      _this = this,
      _sessionData = {};
    function cookie(key, value, expires) {
      var options;
      if (
        arguments.length > 1 &&
        (null === value || "object" != typeof value)
      ) {
        if (
          (((options = {}).path = "/"),
          (options.expires = expires || 1),
          null === value && (options.expires = -1),
          "number" == typeof options.expires)
        ) {
          var days = options.expires,
            t = (options.expires = new Date());
          t.setDate(t.getDate() + days);
        }
        return (document.cookie = [
          encodeURIComponent(key),
          "=",
          options.raw ? String(value) : encodeURIComponent(String(value)),
          options.expires ? `; expires=${options.expires.toUTCString()}` : "",
          options.path ? `; path=${options.path}` : "",
          options.domain ? `; domain=${options.domain}` : "",
          options.secure ? "; secure" : "",
        ].join(""));
      }
      var result,
        decode = (options = value || {}).raw
          ? function (s) {
              return s;
            }
          : decodeURIComponent;
      return (result = new RegExp(
        `(?:^|; )${encodeURIComponent(key)}=([^;]*)`
      ).exec(document.cookie))
        ? decode(result[1])
        : null;
    }
    (this.noTracking = !1),
      (function testStorage() {
        try {
          if (window.localStorage)
            try {
              (window.localStorage.test = 1),
                window.localStorage.removeItem("test"),
                (_storage = !0);
            } catch (e) {
              _storage = !1;
            }
          else _storage = !1;
        } catch (e) {
          _storage = !1;
        }
      })(),
      (this.setCookie = function (key, value, expires) {
        cookie(key, value, expires);
      }),
      (this.getCookie = function (key) {
        return cookie(key);
      }),
      (this.set = function (key, value) {
        _this.noTracking
          ? (_sessionData[key] = value)
          : (null != value &&
              "object" == typeof value &&
              (value = JSON.stringify(value)),
            _storage
              ? null === value
                ? window.localStorage.removeItem(key)
                : (window.localStorage[key] = value)
              : cookie(key, value, 365));
      }),
      (this.get = function (key) {
        if (_this.noTracking) return _sessionData[key];
        var val, char0;
        (val = _storage ? window.localStorage[key] : cookie(key)) &&
          (val.charAt && (char0 = val.charAt(0)),
          ("{" != char0 && "[" != char0) || (val = JSON.parse(val)),
          ("true" != val && "false" != val) || (val = "true" == val));
        return val;
      });
  }, "Static"),
  Class(
    function Thread(_class) {
      Inherit(this, Component);
      var _this = this,
        _worker,
        _callbacks,
        _path,
        _mvc,
        _msg = {};
      function init() {
        let file = window._ES5_ ? "/hydra-thread-es5.js" : "/hydra-thread.js";
        (_callbacks = {}), (_worker = new Worker(Thread.PATH + file));
      }
      function importClasses() {
        importClass(Utils),
          importClass(Component),
          importClass(Events),
          importClass(_class, !0),
          importES5();
      }
      function importClass(_class, scoped) {
        if (_class) {
          var code;
          if (scoped) {
            for (
              code = (code = _class.toString().replace("{", "!!!")).split(
                "!!!"
              )[1];
              code.includes("this.");

            ) {
              var name = code
                .slice(code.indexOf("this."))
                .split("this.")[1]
                .split(/\s*=/)[0];
              (code = code.replace("this", "self")), createMethod(name);
            }
            code = (code = code.slice(0, -1)).replace(/_self/g, "_this");
          } else if ("function" != typeof _class) {
            if ((code = _class.constructor.toString()).includes("[native"))
              return;
            code = `${
              _class._namespace ? `${_class._namespace}.` : ""
            }Class(${code}, "static");`;
          } else
            code = `${
              _class._namespace ? `${_class._namespace}.` : ""
            }Class(${_class.toString()});`;
          _worker.postMessage({ code: code });
        }
      }
      function createMethod(name) {
        _this[name] = function (message = {}, callback, buffer) {
          let promise;
          return (
            Array.isArray(callback) &&
              ((buffer = callback), (callback = void 0)),
            Array.isArray(buffer) &&
              ((message = { msg: message, transfer: !0 }).buffer = buffer),
            void 0 === callback &&
              ((promise = Promise.create()), (callback = promise.resolve)),
            _this.send(name, message, callback),
            promise
          );
        };
      }
      function importES5() {
        window._ES5_ &&
          (["_createSuper", "_isNativeReflectConstruct"].forEach((name) => {
            let code = window[name].toString();
            code.includes("[native") || _worker.postMessage({ code: code });
          }),
          _worker.postMessage({
            code: "function _getPrototypeOf(o){_getPrototypeOf=Object.setPrototypeOf?Object.getPrototypeOf:function _getPrototypeOf(o){return o.__proto__||Object.getPrototypeOf(o);};return _getPrototypeOf(o);}",
          }));
      }
      function addListeners() {
        _worker.addEventListener("message", workerMessage);
      }
      function workerMessage(e) {
        if (e.data.console) console.log(e.data.message);
        else if (e.data.id) {
          (callback = _callbacks[e.data.id]) && callback(e.data.message),
            delete _callbacks[e.data.id];
        } else if (e.data.emit) {
          (callback = _callbacks[e.data.evt]) && callback(e.data.msg);
        } else {
          var callback;
          (callback = _callbacks.transfer) && callback(e.data);
        }
      }
      init(),
        importClasses(),
        addListeners(),
        (this.on = function (evt, callback) {
          _callbacks[evt] = callback;
        }),
        (this.off = function (evt) {
          delete _callbacks[evt];
        }),
        (this.loadFunction = function () {
          let names = [];
          for (var i = 0; i < arguments.length; i++)
            (split = void 0),
              (name = void 0),
              (split = (code = (code = (code =
                arguments[i]).toString()).replace("(", "!!!")).split("!!!")),
              (name = split[0].split(" ")[1]),
              (code = `self.${name} = function(${split[1]}`),
              _worker.postMessage({ code: code }),
              createMethod(name),
              names.push(name);
          var code, split, name;
          return names;
        }),
        (this.importScript = function (path) {
          _worker.postMessage({
            path: Thread.absolutePath(path),
            importScript: !0,
          });
        }),
        (this.importCode = function (code) {
          _worker.postMessage({ code: code });
        }),
        (this.importClass = function () {
          for (var i = 0; i < arguments.length; i++) {
            importClass(arguments[i]);
          }
        }),
        (this.importModules = this.importModule =
          function () {
            for (var i = 0; i < arguments.length; i++) {
              let code = Modules.getConstructor(arguments[i]).toString();
              _worker.postMessage({ code: `Module(${code})` });
            }
          }),
        (this.importES6Class = function (name) {
          if (window._ES5_) {
            let Class = window[name],
              base = Class.toString(),
              proto = [],
              sup,
              matches = /(_this\w+)\s*=\s*(_super\w+)\.call/g.exec(base);
            if (matches) {
              let superVar = matches[2],
                superConstructor = Object.getPrototypeOf(Class);
              if (!superConstructor.toString().includes("[native")) {
                let superName = Utils.getConstructorName(superConstructor);
                sup = `_inherits(${name}, ${superName}); var ${superVar} = _createSuper(${name});`;
              }
            }
            Object.getOwnPropertyNames(Class.prototype).forEach((fn) => {
              "constructor" != fn &&
                Class.prototype[fn] &&
                proto.push({ key: fn, string: Class.prototype[fn].toString() });
            }),
              _worker.postMessage({
                es5: base,
                name: name,
                proto: proto,
                sup: sup,
              });
          } else _worker.postMessage({ es6: `(${eval(name)})`, name: name });
        }),
        (this.send = function (name, message, callback) {
          if ("string" == typeof name) {
            (message = message || {}).fn = name;
          } else (callback = message), (message = name);
          Thread.UNIQUE_ID > 999999 && (Thread.UNIQUE_ID = 1);
          var id = Thread.UNIQUE_ID++;
          callback && (_callbacks[id] = callback),
            message.transfer
              ? ((message.msg.id = id),
                (message.msg.fn = message.fn),
                (message.msg.transfer = !0),
                _worker.postMessage(message.msg, message.buffer))
              : ((_msg.message = message),
                (_msg.id = id),
                _worker.postMessage(_msg));
        }),
        (this.onDestroy = function () {
          _worker.terminate && _worker.terminate();
        });
    },
    () => {
      var _shared;
      (Thread.PATH = window._THREAD_PATH_ || "assets/js/hydra"),
        (Thread.UNIQUE_ID = 1),
        (Thread.absolutePath = Hydra.absolutePath),
        (Thread.cluster = function () {
          return new (function () {
            let index = 0,
              array = [];
            (this.push = function (thread) {
              array.push(thread);
            }),
              (this.get = function () {
                let thread = array[index];
                return index++, index >= array.length && (index = 0), thread;
              }),
              (this.array = array);
          })();
        }),
        (Thread.upload = function (...args) {
          let name;
          Thread.shared();
          for (let i = 0; i < _shared.array.length; i++)
            name = _shared.array[i].loadFunction(...args);
          return name;
        }),
        (Thread.uploadClass = function (...args) {
          let name;
          Thread.shared();
          for (let i = 0; i < _shared.array.length; i++)
            name = _shared.array[i].importClass(...args);
          return name;
        }),
        (Thread.shared = function (list) {
          if (!_shared) {
            _shared = Thread.cluster();
            let hardware = navigator.hardwareConcurrency || 4,
              count = Math.max(Math.min(hardware, 8), 4);
            for (let i = 0; i < count; i++) _shared.push(new Thread());
          }
          return list ? _shared : _shared.get();
        });
    }
  ),
  Class(function TweenManager() {
    Namespace(this);
    var _this = this,
      _tweens = [];
    function updateTweens(time, dt) {
      for (let i = _tweens.length - 1; i >= 0; i--) {
        let tween = _tweens[i];
        tween.update ? tween.update(dt) : _this._removeMathTween(tween);
      }
    }
    function findEase(name) {
      for (var eases = _this.CubicEases, i = eases.length - 1; i > -1; i--)
        if (eases[i].name == name) return eases[i];
      return !1;
    }
    (this.CubicEases = []),
      Render.start(updateTweens),
      (this._addMathTween = function (tween) {
        _tweens.push(tween);
      }),
      (this._removeMathTween = function (tween) {
        _tweens.remove(tween);
      }),
      (this._getEase = function (name, values) {
        var ease = findEase(name);
        return (
          !!ease &&
          (values ? (ease.path ? ease.path.solve : ease.values) : ease.curve)
        );
      }),
      (this._inspectEase = function (name) {
        return findEase(name);
      }),
      (this.tween = function (
        object,
        props,
        time,
        ease,
        delay,
        complete,
        isManual,
        scaledTime
      ) {
        "number" != typeof delay &&
          ((update = complete), (complete = delay), (delay = 0));
        const tween = new MathTween(
          object,
          props,
          time,
          ease,
          delay,
          complete,
          isManual,
          scaledTime
        );
        let usePromise = null;
        return (
          complete &&
            complete instanceof Promise &&
            ((usePromise = complete), (complete = complete.resolve)),
          usePromise || tween
        );
      }),
      (this.clearTween = function (object) {
        if (
          (object._mathTween &&
            object._mathTween.stop &&
            object._mathTween.stop(),
          object._mathTweens)
        ) {
          for (var tweens = object._mathTweens, i = 0; i < tweens.length; i++) {
            var tw = tweens[i];
            tw && tw.stop && tw.stop();
          }
          object._mathTweens = null;
        }
      }),
      (this.addCustomEase = function (ease) {
        var add = !0;
        if ("object" != typeof ease || !ease.name || !ease.curve)
          throw "TweenManager :: addCustomEase requires {name, curve}";
        for (var i = _this.CubicEases.length - 1; i > -1; i--)
          ease.name == _this.CubicEases[i].name && (add = !1);
        if (add) {
          if ("m" == ease.curve.charAt(0).toLowerCase()) {
            if (!window.EasingPath)
              throw "Using custom eases requires easingpath module";
            ease.path = new EasingPath(ease.curve);
          } else
            ease.values = (function stringToValues(str) {
              for (
                var values = str.split("(")[1].slice(0, -1).split(","), i = 0;
                i < values.length;
                i++
              )
                values[i] = parseFloat(values[i]);
              return values;
            })(ease.curve);
          _this.CubicEases.push(ease);
        }
        return ease;
      }),
      (Math.interpolate = function (start, end, alpha, ease) {
        const fn = _this.Interpolation.convertEase(ease);
        return Math.mix(
          start,
          end,
          "function" == typeof fn
            ? fn(alpha)
            : _this.Interpolation.solve(fn, alpha)
        );
      }),
      (window.tween = this.tween),
      (window.clearTween = this.clearTween);
  }, "Static"),
  TweenManager.Class(function Interpolation() {
    function calculateBezier(aT, aA1, aA2) {
      return ((A(aA1, aA2) * aT + B(aA1, aA2)) * aT + C(aA1)) * aT;
    }
    function A(aA1, aA2) {
      return 1 - 3 * aA2 + 3 * aA1;
    }
    function B(aA1, aA2) {
      return 3 * aA2 - 6 * aA1;
    }
    function C(aA1) {
      return 3 * aA1;
    }
    (this.convertEase = function (ease) {
      var fn = (function () {
        switch (ease) {
          case "easeInQuad":
            return TweenManager.Interpolation.Quad.In;
          case "easeInCubic":
            return TweenManager.Interpolation.Cubic.In;
          case "easeInQuart":
            return TweenManager.Interpolation.Quart.In;
          case "easeInQuint":
            return TweenManager.Interpolation.Quint.In;
          case "easeInSine":
            return TweenManager.Interpolation.Sine.In;
          case "easeInExpo":
            return TweenManager.Interpolation.Expo.In;
          case "easeInCirc":
            return TweenManager.Interpolation.Circ.In;
          case "easeInElastic":
            return TweenManager.Interpolation.Elastic.In;
          case "easeInBack":
            return TweenManager.Interpolation.Back.In;
          case "easeInBounce":
            return TweenManager.Interpolation.Bounce.In;
          case "easeOutQuad":
            return TweenManager.Interpolation.Quad.Out;
          case "easeOutCubic":
            return TweenManager.Interpolation.Cubic.Out;
          case "easeOutQuart":
            return TweenManager.Interpolation.Quart.Out;
          case "easeOutQuint":
            return TweenManager.Interpolation.Quint.Out;
          case "easeOutSine":
            return TweenManager.Interpolation.Sine.Out;
          case "easeOutExpo":
            return TweenManager.Interpolation.Expo.Out;
          case "easeOutCirc":
            return TweenManager.Interpolation.Circ.Out;
          case "easeOutElastic":
            return TweenManager.Interpolation.Elastic.Out;
          case "easeOutBack":
            return TweenManager.Interpolation.Back.Out;
          case "easeOutBounce":
            return TweenManager.Interpolation.Bounce.Out;
          case "easeInOutQuad":
            return TweenManager.Interpolation.Quad.InOut;
          case "easeInOutCubic":
            return TweenManager.Interpolation.Cubic.InOut;
          case "easeInOutQuart":
            return TweenManager.Interpolation.Quart.InOut;
          case "easeInOutQuint":
            return TweenManager.Interpolation.Quint.InOut;
          case "easeInOutSine":
            return TweenManager.Interpolation.Sine.InOut;
          case "easeInOutExpo":
            return TweenManager.Interpolation.Expo.InOut;
          case "easeInOutCirc":
            return TweenManager.Interpolation.Circ.InOut;
          case "easeInOutElastic":
            return TweenManager.Interpolation.Elastic.InOut;
          case "easeInOutBack":
            return TweenManager.Interpolation.Back.InOut;
          case "easeInOutBounce":
            return TweenManager.Interpolation.Bounce.InOut;
          case "linear":
            return TweenManager.Interpolation.Linear.None;
        }
      })();
      if (!fn) {
        var curve = TweenManager._getEase(ease, !0);
        fn = curve || TweenManager.Interpolation.Cubic.Out;
      }
      return fn;
    }),
      (this.solve = function (values, elapsed) {
        return values[0] == values[1] && values[2] == values[3]
          ? elapsed
          : calculateBezier(
              (function getTForX(aX, mX1, mX2) {
                for (var aT, aA1, aA2, aGuessT = aX, i = 0; i < 4; i++) {
                  var currentSlope =
                    ((aT = aGuessT),
                    3 * A((aA1 = mX1), (aA2 = mX2)) * aT * aT +
                      2 * B(aA1, aA2) * aT +
                      C(aA1));
                  if (0 == currentSlope) return aGuessT;
                  aGuessT -=
                    (calculateBezier(aGuessT, mX1, mX2) - aX) / currentSlope;
                }
                return aGuessT;
              })(elapsed, values[0], values[2]),
              values[1],
              values[3]
            );
      }),
      (this.Linear = { None: (k) => k }),
      (this.Quad = {
        In: (k) => k * k,
        Out: (k) => k * (2 - k),
        InOut: (k) => ((k *= 2) < 1 ? 0.5 * k * k : -0.5 * (--k * (k - 2) - 1)),
      }),
      (this.Cubic = {
        In: (k) => k * k * k,
        Out: (k) => --k * k * k + 1,
        InOut: (k) =>
          (k *= 2) < 1 ? 0.5 * k * k * k : 0.5 * ((k -= 2) * k * k + 2),
      }),
      (this.Quart = {
        In: (k) => k * k * k * k,
        Out: (k) => 1 - --k * k * k * k,
        InOut: (k) =>
          (k *= 2) < 1
            ? 0.5 * k * k * k * k
            : -0.5 * ((k -= 2) * k * k * k - 2),
      }),
      (this.Quint = {
        In: (k) => k * k * k * k * k,
        Out: (k) => --k * k * k * k * k + 1,
        InOut: (k) =>
          (k *= 2) < 1
            ? 0.5 * k * k * k * k * k
            : 0.5 * ((k -= 2) * k * k * k * k + 2),
      }),
      (this.Sine = {
        In: (k) => 1 - Math.cos((k * Math.PI) / 2),
        Out: (k) => Math.sin((k * Math.PI) / 2),
        InOut: (k) => 0.5 * (1 - Math.cos(Math.PI * k)),
      }),
      (this.Expo = {
        In: (k) => (0 === k ? 0 : Math.pow(1024, k - 1)),
        Out: (k) => (1 === k ? 1 : 1 - Math.pow(2, -10 * k)),
        InOut: (k) =>
          0 === k
            ? 0
            : 1 === k
            ? 1
            : (k *= 2) < 1
            ? 0.5 * Math.pow(1024, k - 1)
            : 0.5 * (2 - Math.pow(2, -10 * (k - 1))),
      }),
      (this.Circ = {
        In: (k) => 1 - Math.sqrt(1 - k * k),
        Out: (k) => Math.sqrt(1 - --k * k),
        InOut: (k) =>
          (k *= 2) < 1
            ? -0.5 * (Math.sqrt(1 - k * k) - 1)
            : 0.5 * (Math.sqrt(1 - (k -= 2) * k) + 1),
      }),
      (this.Elastic = {
        In(k, a = 1, p = 0.4) {
          var s;
          return 0 === k
            ? 0
            : 1 === k
            ? 1
            : (!a || a < 1
                ? ((a = 1), (s = p / 4))
                : (s = (p * Math.asin(1 / a)) / (2 * Math.PI)),
              -a *
                Math.pow(2, 10 * (k -= 1)) *
                Math.sin(((k - s) * (2 * Math.PI)) / p));
        },
        Out(k, a = 1, p = 0.4) {
          var s;
          return 0 === k
            ? 0
            : 1 === k
            ? 1
            : (!a || a < 1
                ? ((a = 1), (s = p / 4))
                : (s = (p * Math.asin(1 / a)) / (2 * Math.PI)),
              a *
                Math.pow(2, -10 * k) *
                Math.sin(((k - s) * (2 * Math.PI)) / p) +
                1);
        },
        InOut(k, a = 1, p = 0.4) {
          var s;
          return 0 === k
            ? 0
            : 1 === k
            ? 1
            : (!a || a < 1
                ? ((a = 1), (s = p / 4))
                : (s = (p * Math.asin(1 / a)) / (2 * Math.PI)),
              (k *= 2) < 1
                ? a *
                  Math.pow(2, 10 * (k -= 1)) *
                  Math.sin(((k - s) * (2 * Math.PI)) / p) *
                  -0.5
                : a *
                    Math.pow(2, -10 * (k -= 1)) *
                    Math.sin(((k - s) * (2 * Math.PI)) / p) *
                    0.5 +
                  1);
        },
      }),
      (this.Back = {
        In(k) {
          var s = 1.70158;
          return k * k * ((s + 1) * k - s);
        },
        Out(k) {
          var s = 1.70158;
          return --k * k * ((s + 1) * k + s) + 1;
        },
        InOut(k) {
          var s = 2.5949095;
          return (k *= 2) < 1
            ? k * k * ((s + 1) * k - s) * 0.5
            : 0.5 * ((k -= 2) * k * ((s + 1) * k + s) + 2);
        },
      }),
      (this.Bounce = {
        In(k) {
          return 1 - this.Bounce.Out(1 - k);
        },
        Out: (k) =>
          k < 1 / 2.75
            ? 7.5625 * k * k
            : k < 2 / 2.75
            ? 7.5625 * (k -= 1.5 / 2.75) * k + 0.75
            : k < 2.5 / 2.75
            ? 7.5625 * (k -= 2.25 / 2.75) * k + 0.9375
            : 7.5625 * (k -= 2.625 / 2.75) * k + 0.984375,
        InOut(k) {
          return k < 0.5
            ? 0.5 * this.Bounce.In(2 * k)
            : 0.5 * this.Bounce.Out(2 * k - 1) + 0.5;
        },
      });
  }, "Static"),
  Class(function MathTween(
    _object,
    _props,
    _time,
    _ease,
    _delay,
    _callback,
    _manual,
    _scaledTime
  ) {
    var _startTime,
      _startValues,
      _endValues,
      _easeFunction,
      _paused,
      _newEase,
      _spring,
      _damping,
      _update,
      _currentTime,
      _this = this,
      _elapsed = 0;
    function clear() {
      if (!_object && !_props) return !1;
      (_object._mathTween = null),
        TweenManager._removeMathTween(_this),
        Utils.nullObject(_this),
        _object._mathTweens && _object._mathTweens.remove(_this._tweenWrapper);
    }
    (_this.object = _object),
      (_this.props = _props),
      (_this.time = _time),
      (_this.ease = _ease),
      (_this.delay = _delay),
      defer(function () {
        if (!_this.stopped) {
          if (_this.overrideValues) {
            let values = _this.overrideValues(
              _this,
              _object,
              _props,
              _time,
              _ease,
              _delay
            );
            values &&
              ((_this.props = _props = values.props || _props),
              (_this.time = _time = values.time || _time),
              (_this.ease = _ease = values.ease || _ease),
              (_this.delay = _delay = values.delay || _delay));
          }
          if (_object && _props) {
            if (((_this.object = _object), "number" != typeof _time))
              throw "MathTween Requires object, props, time, ease";
            !(function start() {
              _object.multiTween ||
                !_object._mathTween ||
                _manual ||
                TweenManager.clearTween(_object);
              _manual || TweenManager._addMathTween(_this);
              (_this.time = _time), (_this.delay = _delay);
              let propString = (function getPropString() {
                let string = "";
                for (let key in _props)
                  "number" == typeof _props[key] && (string += `${key} `);
                return string;
              })();
              (_object._mathTween = _this),
                _object.multiTween &&
                  (_object._mathTweens || (_object._mathTweens = []),
                  _object._mathTweens.forEach((t) => {
                    t.props == propString && t.tween.stop();
                  }),
                  (_this._tweenWrapper = { props: propString, tween: _this }),
                  _object._mathTweens.push(_this._tweenWrapper));
              _ease || (_ease = "linear");
              "string" == typeof _ease &&
                ((_ease = TweenManager.Interpolation.convertEase(_ease)),
                (_easeFunction = "function" == typeof _ease));
              (_startTime = _scaledTime ? Render.now() : performance.now()),
                (_currentTime = _startTime),
                (_startTime += _delay),
                (_endValues = _props),
                (_startValues = {}),
                _props.spring && (_spring = _props.spring);
              _props.damping && (_damping = _props.damping);
              for (var prop in ((_this.startValues = _startValues), _endValues))
                "number" == typeof _object[prop] &&
                  (_startValues[prop] = _object[prop]);
            })();
          }
        }
      }),
      (this.update = function (dt) {
        if (_paused) return;
        if ((_currentTime += _scaledTime ? dt : Render.DT) < _startTime) return;
        _elapsed =
          (_elapsed = (_currentTime - _startTime) / _time) > 1 ? 1 : _elapsed;
        let delta = this.interpolate(_elapsed);
        _update && _update(delta),
          1 == _elapsed &&
            (_callback && _callback(),
            _this.completePromise && _this.completePromise.resolve(),
            clear());
      }),
      (this.pause = function () {
        _paused = !0;
      }),
      (this.resume = function () {
        _paused = !1;
      }),
      (this.stop = function () {
        return (_this.stopped = !0), clear(), null;
      }),
      (this.setEase = function (ease) {
        _newEase != ease &&
          ((_newEase = ease),
          (_ease = TweenManager.Interpolation.convertEase(ease)),
          (_easeFunction = "function" == typeof _ease));
      }),
      (this.getValues = function () {
        return { start: _startValues, end: _endValues };
      }),
      (this.interpolate = function (elapsed) {
        var delta = _easeFunction
          ? _ease(elapsed, _spring, _damping)
          : TweenManager.Interpolation.solve(_ease, elapsed);
        for (var prop in _startValues)
          if (
            "number" == typeof _startValues[prop] &&
            "number" == typeof _endValues[prop]
          ) {
            var start = _startValues[prop],
              end = _endValues[prop];
            _object[prop] = start + (end - start) * delta;
          }
        return delta;
      }),
      (this.onUpdate = function (callback) {
        return (_update = callback), this;
      }),
      (this.onComplete = function (callback) {
        return (_callback = callback), this;
      }),
      (this.promise = function () {
        return (
          (_this.completePromise = Promise.create()), _this.completePromise
        );
      }),
      (this.setElapsed = function (elapsed) {
        (_startTime = performance.now()),
          (_currentTime = _startTime + _time * elapsed);
      });
  }),
  Class(function TweenTimeline() {
    Inherit(this, Component);
    const _this = this;
    let _tween,
      _total = 0;
    const _tweens = [];
    function calculate() {
      _tweens.sort(function (a, b) {
        const ta = a.time + a.delay;
        return b.time + b.delay - ta;
      });
      const first = _tweens[0];
      _total = first.time + first.delay;
    }
    function loop() {
      let time = _this.elapsed * _total;
      for (let i = _tweens.length - 1; i > -1; i--) {
        let t = _tweens[i],
          relativeTime = time - t.delay,
          elapsed = Math.clamp(relativeTime / t.time, 0, 1);
        t.interpolate(elapsed);
      }
      _this.events.fire(Events.UPDATE, _this, !0);
    }
    (this.elapsed = 0),
      this.get("timeRemaining", () => _total - _this.elapsed * _total),
      (this.add = function (object, props, time, ease, delay = 0) {
        let tween;
        return (
          (object instanceof MathTween || object instanceof FrameTween) &&
            ((props = object.props),
            (time = object.time),
            (ease = object.ease),
            (delay = object.delay),
            (object = object.object)),
          (tween =
            object instanceof HydraObject
              ? new FrameTween(object, props, time, ease, delay, null, !0)
              : new MathTween(object, props, time, ease, delay, null, !0)),
          _tweens.push(tween),
          defer(calculate),
          tween
        );
      }),
      (this.tween = function (to, time, ease, delay, callback) {
        return (
          _this.clearTween(),
          (_tween = tween(_this, { elapsed: to }, time, ease, delay)
            .onUpdate(loop)
            .onComplete(callback)),
          _tween
        );
      }),
      (this.clearTween = function () {
        _tween && _tween.stop && _tween.stop();
      }),
      (this.start = function () {
        _this.startRender(loop);
      }),
      (this.stop = function () {
        _this.stopRender(loop);
      }),
      (this.update = function () {
        loop();
      }),
      (this.onDestroy = function () {
        _this.clearTween(), Render.stop(loop);
        for (var i = 0; i < _tweens.length; i++) _tweens[i].stop();
      });
  }),
  (window.ASSETS = ["assets/shaders/compiled.vs"]),
  (ASSETS.SW = ["assets/js/app.1702557059236.js"]),
  Class(function StyleGuide() {
    Inherit(this, Component);
    const _this = this;
    !(async function () {
      await Hydra.ready(), Stage.goob(_this.fontRegular);
    })(),
      (this.colors = { black: "#101010", brand: "#FFD600" }),
      (_this.defaultFontFamily = "Decagram, Helvetica, Arial, sans-serif"),
      (_this.fontRegular = `\n        & {\n            font-family: ${_this.defaultFontFamily};\n            font-weight: 400;\n            font-style: normal;\n        }\n    `);
  }, "static"),
  (window.UIL_ASSETS_GEOMETRIES = []),
  (window.UIL_ASSETS_TEXTURES = [
    {
      filename: "Buttermax_Logo.png",
      bytes: 106254,
      lastChange: "2023-12-14T12:30:00.578Z",
    },
    {
      filename: "_lighting/arealights.json",
      bytes: 307348,
      lastChange: "2023-12-14T12:30:00.582Z",
    },
    {
      filename: "_scenelayout/black.jpg",
      bytes: 1129,
      lastChange: "2023-12-14T12:30:00.582Z",
    },
    {
      filename: "_scenelayout/mask.jpg",
      bytes: 1129,
      lastChange: "2023-12-14T12:30:00.582Z",
    },
    {
      filename: "_scenelayout/uv.jpg",
      bytes: 138695,
      lastChange: "2023-12-14T12:30:00.582Z",
    },
    {
      filename: "arrowUp.png",
      bytes: 206,
      lastChange: "2023-12-14T12:30:00.582Z",
    },
    {
      filename: "maps/boombox_data-high.png",
      bytes: 34105,
      lastChange: "2023-12-14T12:30:00.582Z",
    },
    {
      filename: "maps/boombox_data-high.png.ktx2",
      bytes: 43498,
      lastChange: "2023-12-14T12:30:00.582Z",
    },
    {
      filename: "maps/boombox_data-low.png",
      bytes: 8431,
      lastChange: "2023-12-14T12:30:00.582Z",
    },
    {
      filename: "maps/boombox_data-low.png.ktx2",
      bytes: 14197,
      lastChange: "2023-12-14T12:30:00.582Z",
    },
    {
      filename: "maps/boombox_data-medium.png",
      bytes: 18523,
      lastChange: "2023-12-14T12:30:00.586Z",
    },
    {
      filename: "maps/boombox_data-medium.png.ktx2",
      bytes: 26613,
      lastChange: "2023-12-14T12:30:00.586Z",
    },
    {
      filename: "maps/boombox_data.png",
      bytes: 29951,
      lastChange: "2023-12-14T12:30:00.586Z",
    },
    {
      filename: "maps/boombox_diffuse-high.png",
      bytes: 18880129,
      lastChange: "2023-12-14T12:30:00.702Z",
    },
    {
      filename: "maps/boombox_diffuse-high.png.ktx2",
      bytes: 10686342,
      lastChange: "2023-12-14T12:30:00.730Z",
    },
    {
      filename: "maps/boombox_diffuse-low.png",
      bytes: 5245922,
      lastChange: "2023-12-14T12:30:00.762Z",
    },
    {
      filename: "maps/boombox_diffuse-low.png.ktx2",
      bytes: 570024,
      lastChange: "2023-12-14T12:30:00.762Z",
    },
    {
      filename: "maps/boombox_diffuse-medium.png",
      bytes: 5245922,
      lastChange: "2023-12-14T12:30:00.794Z",
    },
    {
      filename: "maps/boombox_diffuse-medium.png.ktx2",
      bytes: 570024,
      lastChange: "2023-12-14T12:30:00.798Z",
    },
    {
      filename: "maps/boombox_diffuse.png",
      bytes: 14863102,
      lastChange: "2023-12-14T12:30:00.826Z",
    },
    {
      filename: "maps/boombox_glass-high.png",
      bytes: 2371353,
      lastChange: "2023-12-14T12:30:00.842Z",
    },
    {
      filename: "maps/boombox_glass-high.png.ktx2",
      bytes: 1846634,
      lastChange: "2023-12-14T12:30:00.850Z",
    },
    {
      filename: "maps/boombox_glass-low.png",
      bytes: 1111345,
      lastChange: "2023-12-14T12:30:00.858Z",
    },
    {
      filename: "maps/boombox_glass-low.png.ktx2",
      bytes: 345326,
      lastChange: "2023-12-14T12:30:00.862Z",
    },
    {
      filename: "maps/boombox_glass-medium.png",
      bytes: 1111345,
      lastChange: "2023-12-14T12:30:00.866Z",
    },
    {
      filename: "maps/boombox_glass-medium.png.ktx2",
      bytes: 345326,
      lastChange: "2023-12-14T12:30:00.870Z",
    },
    {
      filename: "maps/boombox_glass.png",
      bytes: 2194196,
      lastChange: "2023-12-14T12:30:00.886Z",
    },
    {
      filename: "maps/boombox_mask-0.png",
      bytes: 443467,
      lastChange: "2023-12-14T12:30:00.886Z",
    },
    {
      filename: "maps/boombox_mask-0.png.ktx2",
      bytes: 63591,
      lastChange: "2023-12-14T12:30:00.890Z",
    },
    {
      filename: "maps/boombox_mask-1.png",
      bytes: 620826,
      lastChange: "2023-12-14T12:30:00.894Z",
    },
    {
      filename: "maps/boombox_mask-1.png.ktx2",
      bytes: 76349,
      lastChange: "2023-12-14T12:30:00.894Z",
    },
    {
      filename: "maps/boombox_mv-high.png",
      bytes: 2525037,
      lastChange: "2023-12-14T12:30:00.910Z",
    },
    {
      filename: "maps/boombox_mv-high.png.ktx2",
      bytes: 2488405,
      lastChange: "2023-12-14T12:30:00.922Z",
    },
    {
      filename: "maps/boombox_mv-low.png",
      bytes: 338727,
      lastChange: "2023-12-14T12:30:00.926Z",
    },
    {
      filename: "maps/boombox_mv-low.png.ktx2",
      bytes: 219820,
      lastChange: "2023-12-14T12:30:00.926Z",
    },
    {
      filename: "maps/boombox_mv-medium.png",
      bytes: 950776,
      lastChange: "2023-12-14T12:30:00.934Z",
    },
    {
      filename: "maps/boombox_mv-medium.png.ktx2",
      bytes: 763179,
      lastChange: "2023-12-14T12:30:00.938Z",
    },
    {
      filename: "maps/boombox_mv.png",
      bytes: 526943,
      lastChange: "2023-12-14T12:30:00.938Z",
    },
    {
      filename: "maps/boombox_position-high.png",
      bytes: 2939607,
      lastChange: "2023-12-14T12:30:00.958Z",
    },
    {
      filename: "maps/boombox_position-high.png.ktx2",
      bytes: 2553557,
      lastChange: "2023-12-14T12:30:00.970Z",
    },
    {
      filename: "maps/boombox_position-low.png",
      bytes: 458603,
      lastChange: "2023-12-14T12:30:00.970Z",
    },
    {
      filename: "maps/boombox_position-low.png.ktx2",
      bytes: 198245,
      lastChange: "2023-12-14T12:30:00.970Z",
    },
    {
      filename: "maps/boombox_position-medium.png",
      bytes: 1309227,
      lastChange: "2023-12-14T12:30:00.978Z",
    },
    {
      filename: "maps/boombox_position-medium.png.ktx2",
      bytes: 713483,
      lastChange: "2023-12-14T12:30:00.982Z",
    },
    {
      filename: "maps/boombox_position.png",
      bytes: 4585738,
      lastChange: "2023-12-14T12:30:01.014Z",
    },
    {
      filename: "maps/controller_data-high.png",
      bytes: 63760,
      lastChange: "2023-12-14T12:30:01.014Z",
    },
    {
      filename: "maps/controller_data-high.png.ktx2",
      bytes: 74202,
      lastChange: "2023-12-14T12:30:01.014Z",
    },
    {
      filename: "maps/controller_data-low.png",
      bytes: 12841,
      lastChange: "2023-12-14T12:30:01.014Z",
    },
    {
      filename: "maps/controller_data-low.png.ktx2",
      bytes: 19052,
      lastChange: "2023-12-14T12:30:01.014Z",
    },
    {
      filename: "maps/controller_data-medium.png",
      bytes: 26887,
      lastChange: "2023-12-14T12:30:01.014Z",
    },
    {
      filename: "maps/controller_data-medium.png.ktx2",
      bytes: 38355,
      lastChange: "2023-12-14T12:30:01.014Z",
    },
    {
      filename: "maps/controller_data.png",
      bytes: 113810,
      lastChange: "2023-12-14T12:30:01.018Z",
    },
    {
      filename: "maps/controller_diffuse-high.png",
      bytes: 10901568,
      lastChange: "2023-12-14T12:30:01.086Z",
    },
    {
      filename: "maps/controller_diffuse-high.png.ktx2",
      bytes: 5986769,
      lastChange: "2023-12-14T12:30:01.102Z",
    },
    {
      filename: "maps/controller_diffuse-low.png",
      bytes: 3256018,
      lastChange: "2023-12-14T12:30:01.118Z",
    },
    {
      filename: "maps/controller_diffuse-low.png.ktx2",
      bytes: 381321,
      lastChange: "2023-12-14T12:30:01.122Z",
    },
    {
      filename: "maps/controller_diffuse-medium.png",
      bytes: 3256018,
      lastChange: "2023-12-14T12:30:01.142Z",
    },
    {
      filename: "maps/controller_diffuse-medium.png.ktx2",
      bytes: 381321,
      lastChange: "2023-12-14T12:30:01.142Z",
    },
    {
      filename: "maps/controller_diffuse.png",
      bytes: 9115780,
      lastChange: "2023-12-14T12:30:01.178Z",
    },
    {
      filename: "maps/controller_mask-0.png",
      bytes: 1361650,
      lastChange: "2023-12-14T12:30:01.182Z",
    },
    {
      filename: "maps/controller_mask-0.png.ktx2",
      bytes: 113262,
      lastChange: "2023-12-14T12:30:01.182Z",
    },
    {
      filename: "maps/controller_mask-1.png",
      bytes: 200660,
      lastChange: "2023-12-14T12:30:01.182Z",
    },
    {
      filename: "maps/controller_mask-1.png.ktx2",
      bytes: 31584,
      lastChange: "2023-12-14T12:30:01.182Z",
    },
    {
      filename: "maps/controller_mv-high.png",
      bytes: 2308913,
      lastChange: "2023-12-14T12:30:01.202Z",
    },
    {
      filename: "maps/controller_mv-high.png.ktx2",
      bytes: 1947159,
      lastChange: "2023-12-14T12:30:01.210Z",
    },
    {
      filename: "maps/controller_mv-low.png",
      bytes: 278883,
      lastChange: "2023-12-14T12:30:01.210Z",
    },
    {
      filename: "maps/controller_mv-low.png.ktx2",
      bytes: 167835,
      lastChange: "2023-12-14T12:30:01.214Z",
    },
    {
      filename: "maps/controller_mv-medium.png",
      bytes: 810877,
      lastChange: "2023-12-14T12:30:01.218Z",
    },
    {
      filename: "maps/controller_mv-medium.png.ktx2",
      bytes: 577943,
      lastChange: "2023-12-14T12:30:01.222Z",
    },
    {
      filename: "maps/controller_mv.png",
      bytes: 432647,
      lastChange: "2023-12-14T12:30:01.222Z",
    },
    {
      filename: "maps/controller_position-high.png",
      bytes: 2173463,
      lastChange: "2023-12-14T12:30:01.238Z",
    },
    {
      filename: "maps/controller_position-high.png.ktx2",
      bytes: 1852561,
      lastChange: "2023-12-14T12:30:01.246Z",
    },
    {
      filename: "maps/controller_position-low.png",
      bytes: 305592,
      lastChange: "2023-12-14T12:30:01.246Z",
    },
    {
      filename: "maps/controller_position-low.png.ktx2",
      bytes: 155316,
      lastChange: "2023-12-14T12:30:01.246Z",
    },
    {
      filename: "maps/controller_position-medium.png",
      bytes: 903145,
      lastChange: "2023-12-14T12:30:01.254Z",
    },
    {
      filename: "maps/controller_position-medium.png.ktx2",
      bytes: 530193,
      lastChange: "2023-12-14T12:30:01.254Z",
    },
    {
      filename: "maps/controller_position.png",
      bytes: 4810246,
      lastChange: "2023-12-14T12:30:01.290Z",
    },
    {
      filename: "maps/dashboard_data-high.png",
      bytes: 130389,
      lastChange: "2023-12-14T12:30:01.290Z",
    },
    {
      filename: "maps/dashboard_data-high.png.ktx2",
      bytes: 160139,
      lastChange: "2023-12-14T12:30:01.290Z",
    },
    {
      filename: "maps/dashboard_data-low.png",
      bytes: 19437,
      lastChange: "2023-12-14T12:30:01.290Z",
    },
    {
      filename: "maps/dashboard_data-low.png.ktx2",
      bytes: 31677,
      lastChange: "2023-12-14T12:30:01.294Z",
    },
    {
      filename: "maps/dashboard_data-medium.png",
      bytes: 53677,
      lastChange: "2023-12-14T12:30:01.294Z",
    },
    {
      filename: "maps/dashboard_data-medium.png.ktx2",
      bytes: 75225,
      lastChange: "2023-12-14T12:30:01.294Z",
    },
    {
      filename: "maps/dashboard_data.png",
      bytes: 360629,
      lastChange: "2023-12-14T12:30:01.294Z",
    },
    {
      filename: "maps/dashboard_diffuse-high.png",
      bytes: 12164830,
      lastChange: "2023-12-14T12:30:01.370Z",
    },
    {
      filename: "maps/dashboard_diffuse-high.png.ktx2",
      bytes: 5979339,
      lastChange: "2023-12-14T12:30:01.382Z",
    },
    {
      filename: "maps/dashboard_diffuse-low.png",
      bytes: 3251804,
      lastChange: "2023-12-14T12:30:01.398Z",
    },
    {
      filename: "maps/dashboard_diffuse-low.png.ktx2",
      bytes: 296747,
      lastChange: "2023-12-14T12:30:01.402Z",
    },
    {
      filename: "maps/dashboard_diffuse-medium.png",
      bytes: 3251804,
      lastChange: "2023-12-14T12:30:01.418Z",
    },
    {
      filename: "maps/dashboard_diffuse-medium.png.ktx2",
      bytes: 296747,
      lastChange: "2023-12-14T12:30:01.418Z",
    },
    {
      filename: "maps/dashboard_diffuse.png",
      bytes: 8066690,
      lastChange: "2023-12-14T12:30:01.450Z",
    },
    {
      filename: "maps/dashboard_mask-0.png",
      bytes: 609542,
      lastChange: "2023-12-14T12:30:01.450Z",
    },
    {
      filename: "maps/dashboard_mask-0.png.ktx2",
      bytes: 69635,
      lastChange: "2023-12-14T12:30:01.454Z",
    },
    {
      filename: "maps/dashboard_mask-1.png",
      bytes: 899791,
      lastChange: "2023-12-14T12:30:01.458Z",
    },
    {
      filename: "maps/dashboard_mask-1.png.ktx2",
      bytes: 81169,
      lastChange: "2023-12-14T12:30:01.458Z",
    },
    {
      filename: "maps/dashboard_mv-high.png",
      bytes: 1472374,
      lastChange: "2023-12-14T12:30:01.470Z",
    },
    {
      filename: "maps/dashboard_mv-high.png.ktx2",
      bytes: 1532630,
      lastChange: "2023-12-14T12:30:01.478Z",
    },
    {
      filename: "maps/dashboard_mv-low.png",
      bytes: 211843,
      lastChange: "2023-12-14T12:30:01.478Z",
    },
    {
      filename: "maps/dashboard_mv-low.png.ktx2",
      bytes: 140584,
      lastChange: "2023-12-14T12:30:01.478Z",
    },
    {
      filename: "maps/dashboard_mv-medium.png",
      bytes: 604830,
      lastChange: "2023-12-14T12:30:01.482Z",
    },
    {
      filename: "maps/dashboard_mv-medium.png.ktx2",
      bytes: 486889,
      lastChange: "2023-12-14T12:30:01.482Z",
    },
    {
      filename: "maps/dashboard_mv.png",
      bytes: 2047129,
      lastChange: "2023-12-14T12:30:01.498Z",
    },
    {
      filename: "maps/dashboard_position-high.png",
      bytes: 1670348,
      lastChange: "2023-12-14T12:30:01.510Z",
    },
    {
      filename: "maps/dashboard_position-high.png.ktx2",
      bytes: 1451697,
      lastChange: "2023-12-14T12:30:01.518Z",
    },
    {
      filename: "maps/dashboard_position-low.png",
      bytes: 280505,
      lastChange: "2023-12-14T12:30:01.518Z",
    },
    {
      filename: "maps/dashboard_position-low.png.ktx2",
      bytes: 112286,
      lastChange: "2023-12-14T12:30:01.522Z",
    },
    {
      filename: "maps/dashboard_position-medium.png",
      bytes: 796611,
      lastChange: "2023-12-14T12:30:01.526Z",
    },
    {
      filename: "maps/dashboard_position-medium.png.ktx2",
      bytes: 418333,
      lastChange: "2023-12-14T12:30:01.526Z",
    },
    {
      filename: "maps/dashboard_position.png",
      bytes: 2633511,
      lastChange: "2023-12-14T12:30:01.546Z",
    },
    {
      filename: "maps/gameboy_data-high.png",
      bytes: 74049,
      lastChange: "2023-12-14T12:30:01.546Z",
    },
    {
      filename: "maps/gameboy_data-high.png.ktx2",
      bytes: 74317,
      lastChange: "2023-12-14T12:30:01.550Z",
    },
    {
      filename: "maps/gameboy_data-low.png",
      bytes: 13577,
      lastChange: "2023-12-14T12:30:01.550Z",
    },
    {
      filename: "maps/gameboy_data-low.png.ktx2",
      bytes: 20176,
      lastChange: "2023-12-14T12:30:01.550Z",
    },
    {
      filename: "maps/gameboy_data-medium.png",
      bytes: 30462,
      lastChange: "2023-12-14T12:30:01.550Z",
    },
    {
      filename: "maps/gameboy_data-medium.png.ktx2",
      bytes: 39457,
      lastChange: "2023-12-14T12:30:01.550Z",
    },
    {
      filename: "maps/gameboy_data.png",
      bytes: 105976,
      lastChange: "2023-12-14T12:30:01.550Z",
    },
    {
      filename: "maps/gameboy_diffuse-high.png",
      bytes: 14740258,
      lastChange: "2023-12-14T12:30:01.642Z",
    },
    {
      filename: "maps/gameboy_diffuse-high.png.ktx2",
      bytes: 7283216,
      lastChange: "2023-12-14T12:30:01.662Z",
    },
    {
      filename: "maps/gameboy_diffuse-low.png",
      bytes: 3970137,
      lastChange: "2023-12-14T12:30:01.686Z",
    },
    {
      filename: "maps/gameboy_diffuse-low.png.ktx2",
      bytes: 438995,
      lastChange: "2023-12-14T12:30:01.686Z",
    },
    {
      filename: "maps/gameboy_diffuse-medium.png",
      bytes: 3970137,
      lastChange: "2023-12-14T12:30:01.710Z",
    },
    {
      filename: "maps/gameboy_diffuse-medium.png.ktx2",
      bytes: 438995,
      lastChange: "2023-12-14T12:30:01.714Z",
    },
    {
      filename: "maps/gameboy_diffuse.png",
      bytes: 11057061,
      lastChange: "2023-12-14T12:30:01.766Z",
    },
    {
      filename: "maps/gameboy_mask-0.png",
      bytes: 621516,
      lastChange: "2023-12-14T12:30:01.770Z",
    },
    {
      filename: "maps/gameboy_mask-0.png.ktx2",
      bytes: 86329,
      lastChange: "2023-12-14T12:30:01.770Z",
    },
    {
      filename: "maps/gameboy_mask-1.png",
      bytes: 746692,
      lastChange: "2023-12-14T12:30:01.774Z",
    },
    {
      filename: "maps/gameboy_mask-1.png.ktx2",
      bytes: 90046,
      lastChange: "2023-12-14T12:30:01.774Z",
    },
    {
      filename: "maps/gameboy_mv-high.png",
      bytes: 2192111,
      lastChange: "2023-12-14T12:30:01.790Z",
    },
    {
      filename: "maps/gameboy_mv-high.png.ktx2",
      bytes: 2290847,
      lastChange: "2023-12-14T12:30:01.798Z",
    },
    {
      filename: "maps/gameboy_mv-low.png",
      bytes: 256577,
      lastChange: "2023-12-14T12:30:01.802Z",
    },
    {
      filename: "maps/gameboy_mv-low.png.ktx2",
      bytes: 184985,
      lastChange: "2023-12-14T12:30:01.802Z",
    },
    {
      filename: "maps/gameboy_mv-medium.png",
      bytes: 638169,
      lastChange: "2023-12-14T12:30:01.806Z",
    },
    {
      filename: "maps/gameboy_mv-medium.png.ktx2",
      bytes: 661381,
      lastChange: "2023-12-14T12:30:01.810Z",
    },
    {
      filename: "maps/gameboy_mv.jpg",
      bytes: 96183,
      lastChange: "2023-12-14T12:30:01.810Z",
    },
    {
      filename: "maps/gameboy_mv.jpg.ktx2",
      bytes: 1878700,
      lastChange: "2023-12-14T12:30:01.818Z",
    },
    {
      filename: "maps/gameboy_mv.png",
      bytes: 638169,
      lastChange: "2023-12-14T12:30:01.822Z",
    },
    {
      filename: "maps/gameboy_position-high.png",
      bytes: 2285993,
      lastChange: "2023-12-14T12:30:01.838Z",
    },
    {
      filename: "maps/gameboy_position-high.png.ktx2",
      bytes: 1968586,
      lastChange: "2023-12-14T12:30:01.846Z",
    },
    {
      filename: "maps/gameboy_position-low.png",
      bytes: 351080,
      lastChange: "2023-12-14T12:30:01.846Z",
    },
    {
      filename: "maps/gameboy_position-low.png.ktx2",
      bytes: 140470,
      lastChange: "2023-12-14T12:30:01.846Z",
    },
    {
      filename: "maps/gameboy_position-medium.png",
      bytes: 1031584,
      lastChange: "2023-12-14T12:30:01.854Z",
    },
    {
      filename: "maps/gameboy_position-medium.png.ktx2",
      bytes: 542756,
      lastChange: "2023-12-14T12:30:01.858Z",
    },
    {
      filename: "maps/gameboy_position.png",
      bytes: 1908277,
      lastChange: "2023-12-14T12:30:01.870Z",
    },
    {
      filename: "maps/glove_data-high.png",
      bytes: 55312,
      lastChange: "2023-12-14T12:30:01.870Z",
    },
    {
      filename: "maps/glove_data-high.png.ktx2",
      bytes: 64673,
      lastChange: "2023-12-14T12:30:01.870Z",
    },
    {
      filename: "maps/glove_data-low.png",
      bytes: 10789,
      lastChange: "2023-12-14T12:30:01.870Z",
    },
    {
      filename: "maps/glove_data-low.png.ktx2",
      bytes: 15777,
      lastChange: "2023-12-14T12:30:01.870Z",
    },
    {
      filename: "maps/glove_data-medium.png",
      bytes: 23166,
      lastChange: "2023-12-14T12:30:01.870Z",
    },
    {
      filename: "maps/glove_data-medium.png.ktx2",
      bytes: 32149,
      lastChange: "2023-12-14T12:30:01.870Z",
    },
    {
      filename: "maps/glove_data.png",
      bytes: 101671,
      lastChange: "2023-12-14T12:30:01.870Z",
    },
    {
      filename: "maps/glove_diffuse-high.png",
      bytes: 9743629,
      lastChange: "2023-12-14T12:30:01.930Z",
    },
    {
      filename: "maps/glove_diffuse-high.png.ktx2",
      bytes: 7096348,
      lastChange: "2023-12-14T12:30:01.950Z",
    },
    {
      filename: "maps/glove_diffuse-low.png",
      bytes: 4274566,
      lastChange: "2023-12-14T12:30:01.974Z",
    },
    {
      filename: "maps/glove_diffuse-low.png.ktx2",
      bytes: 463098,
      lastChange: "2023-12-14T12:30:01.974Z",
    },
    {
      filename: "maps/glove_diffuse-medium.png",
      bytes: 4274566,
      lastChange: "2023-12-14T12:30:01.998Z",
    },
    {
      filename: "maps/glove_diffuse-medium.png.ktx2",
      bytes: 463098,
      lastChange: "2023-12-14T12:30:01.998Z",
    },
    {
      filename: "maps/glove_diffuse.png",
      bytes: 8383694,
      lastChange: "2023-12-14T12:30:02.054Z",
    },
    {
      filename: "maps/glove_mask-0.png",
      bytes: 34433,
      lastChange: "2023-12-14T12:30:02.054Z",
    },
    {
      filename: "maps/glove_mask-0.png.ktx2",
      bytes: 23777,
      lastChange: "2023-12-14T12:30:02.054Z",
    },
    {
      filename: "maps/glove_mask-1.png",
      bytes: 34433,
      lastChange: "2023-12-14T12:30:02.054Z",
    },
    {
      filename: "maps/glove_mask-1.png.ktx2",
      bytes: 23777,
      lastChange: "2023-12-14T12:30:02.054Z",
    },
    {
      filename: "maps/glove_mv-high.png",
      bytes: 3339466,
      lastChange: "2023-12-14T12:30:02.074Z",
    },
    {
      filename: "maps/glove_mv-high.png.ktx2",
      bytes: 2332667,
      lastChange: "2023-12-14T12:30:02.086Z",
    },
    {
      filename: "maps/glove_mv-low.png",
      bytes: 275297,
      lastChange: "2023-12-14T12:30:02.086Z",
    },
    {
      filename: "maps/glove_mv-low.png.ktx2",
      bytes: 157833,
      lastChange: "2023-12-14T12:30:02.086Z",
    },
    {
      filename: "maps/glove_mv-medium.png",
      bytes: 932944,
      lastChange: "2023-12-14T12:30:02.094Z",
    },
    {
      filename: "maps/glove_mv-medium.png.ktx2",
      bytes: 598625,
      lastChange: "2023-12-14T12:30:02.094Z",
    },
    {
      filename: "maps/glove_mv.png",
      bytes: 7108093,
      lastChange: "2023-12-14T12:30:02.110Z",
    },
    {
      filename: "maps/glove_position-high.png",
      bytes: 2676693,
      lastChange: "2023-12-14T12:30:02.126Z",
    },
    {
      filename: "maps/glove_position-high.png.ktx2",
      bytes: 1880260,
      lastChange: "2023-12-14T12:30:02.134Z",
    },
    {
      filename: "maps/glove_position-low.png",
      bytes: 348097,
      lastChange: "2023-12-14T12:30:02.138Z",
    },
    {
      filename: "maps/glove_position-low.png.ktx2",
      bytes: 146106,
      lastChange: "2023-12-14T12:30:02.138Z",
    },
    {
      filename: "maps/glove_position-medium.png",
      bytes: 1032729,
      lastChange: "2023-12-14T12:30:02.146Z",
    },
    {
      filename: "maps/glove_position-medium.png.ktx2",
      bytes: 515772,
      lastChange: "2023-12-14T12:30:02.146Z",
    },
    {
      filename: "maps/glove_position.png",
      bytes: 3507167,
      lastChange: "2023-12-14T12:30:02.166Z",
    },
    {
      filename: "maps/keycard_data-high.png",
      bytes: 111324,
      lastChange: "2023-12-14T12:30:02.166Z",
    },
    {
      filename: "maps/keycard_data-high.png.ktx2",
      bytes: 111889,
      lastChange: "2023-12-14T12:30:02.166Z",
    },
    {
      filename: "maps/keycard_data-low.png",
      bytes: 20562,
      lastChange: "2023-12-14T12:30:02.166Z",
    },
    {
      filename: "maps/keycard_data-low.png.ktx2",
      bytes: 29878,
      lastChange: "2023-12-14T12:30:02.166Z",
    },
    {
      filename: "maps/keycard_data-medium.png",
      bytes: 47304,
      lastChange: "2023-12-14T12:30:02.166Z",
    },
    {
      filename: "maps/keycard_data-medium.png.ktx2",
      bytes: 58702,
      lastChange: "2023-12-14T12:30:02.170Z",
    },
    {
      filename: "maps/keycard_data.png",
      bytes: 139880,
      lastChange: "2023-12-14T12:30:02.170Z",
    },
    {
      filename: "maps/keycard_diffuse-high.png",
      bytes: 13783005,
      lastChange: "2023-12-14T12:30:02.258Z",
    },
    {
      filename: "maps/keycard_diffuse-high.png.ktx2",
      bytes: 7034941,
      lastChange: "2023-12-14T12:30:02.278Z",
    },
    {
      filename: "maps/keycard_diffuse-low.png",
      bytes: 3801137,
      lastChange: "2023-12-14T12:30:02.302Z",
    },
    {
      filename: "maps/keycard_diffuse-low.png.ktx2",
      bytes: 371131,
      lastChange: "2023-12-14T12:30:02.302Z",
    },
    {
      filename: "maps/keycard_diffuse-medium.png",
      bytes: 3801137,
      lastChange: "2023-12-14T12:30:02.326Z",
    },
    {
      filename: "maps/keycard_diffuse-medium.png.ktx2",
      bytes: 371131,
      lastChange: "2023-12-14T12:30:02.326Z",
    },
    {
      filename: "maps/keycard_diffuse.png",
      bytes: 11343532,
      lastChange: "2023-12-14T12:30:02.390Z",
    },
    {
      filename: "maps/keycard_mask-0.png",
      bytes: 1144893,
      lastChange: "2023-12-14T12:30:02.398Z",
    },
    {
      filename: "maps/keycard_mask-0.png.ktx2",
      bytes: 135401,
      lastChange: "2023-12-14T12:30:02.398Z",
    },
    {
      filename: "maps/keycard_mask-1.png",
      bytes: 1749950,
      lastChange: "2023-12-14T12:30:02.410Z",
    },
    {
      filename: "maps/keycard_mask-1.png.ktx2",
      bytes: 178645,
      lastChange: "2023-12-14T12:30:02.410Z",
    },
    {
      filename: "maps/keycard_mv-high.png",
      bytes: 2372309,
      lastChange: "2023-12-14T12:30:02.430Z",
    },
    {
      filename: "maps/keycard_mv-high.png.ktx2",
      bytes: 2127829,
      lastChange: "2023-12-14T12:30:02.438Z",
    },
    {
      filename: "maps/keycard_mv-low.png",
      bytes: 301640,
      lastChange: "2023-12-14T12:30:02.442Z",
    },
    {
      filename: "maps/keycard_mv-low.png.ktx2",
      bytes: 191209,
      lastChange: "2023-12-14T12:30:02.442Z",
    },
    {
      filename: "maps/keycard_mv-medium.png",
      bytes: 845559,
      lastChange: "2023-12-14T12:30:02.450Z",
    },
    {
      filename: "maps/keycard_mv-medium.png.ktx2",
      bytes: 645443,
      lastChange: "2023-12-14T12:30:02.450Z",
    },
    {
      filename: "maps/keycard_mv.png",
      bytes: 441817,
      lastChange: "2023-12-14T12:30:02.454Z",
    },
    {
      filename: "maps/keycard_position-high.png",
      bytes: 3226920,
      lastChange: "2023-12-14T12:30:02.474Z",
    },
    {
      filename: "maps/keycard_position-high.png.ktx2",
      bytes: 2381730,
      lastChange: "2023-12-14T12:30:02.486Z",
    },
    {
      filename: "maps/keycard_position-low.png",
      bytes: 413588,
      lastChange: "2023-12-14T12:30:02.486Z",
    },
    {
      filename: "maps/keycard_position-low.png.ktx2",
      bytes: 167654,
      lastChange: "2023-12-14T12:30:02.486Z",
    },
    {
      filename: "maps/keycard_position-medium.png",
      bytes: 1249121,
      lastChange: "2023-12-14T12:30:02.494Z",
    },
    {
      filename: "maps/keycard_position-medium.png.ktx2",
      bytes: 609390,
      lastChange: "2023-12-14T12:30:02.494Z",
    },
    {
      filename: "maps/keycard_position.png",
      bytes: 2671050,
      lastChange: "2023-12-14T12:30:02.502Z",
    },
    {
      filename: "maps/magnifying-glass_data-high.png",
      bytes: 67960,
      lastChange: "2023-12-14T12:30:02.502Z",
    },
    {
      filename: "maps/magnifying-glass_data-high.png.ktx2",
      bytes: 75202,
      lastChange: "2023-12-14T12:30:02.502Z",
    },
    {
      filename: "maps/magnifying-glass_data-low.png",
      bytes: 13006,
      lastChange: "2023-12-14T12:30:02.502Z",
    },
    {
      filename: "maps/magnifying-glass_data-low.png.ktx2",
      bytes: 19795,
      lastChange: "2023-12-14T12:30:02.502Z",
    },
    {
      filename: "maps/magnifying-glass_data-medium.png",
      bytes: 29160,
      lastChange: "2023-12-14T12:30:02.506Z",
    },
    {
      filename: "maps/magnifying-glass_data-medium.png.ktx2",
      bytes: 38995,
      lastChange: "2023-12-14T12:30:02.506Z",
    },
    {
      filename: "maps/magnifying-glass_data.png",
      bytes: 122033,
      lastChange: "2023-12-14T12:30:02.506Z",
    },
    {
      filename: "maps/magnifying-glass_diffuse-high.png",
      bytes: 9329088,
      lastChange: "2023-12-14T12:30:02.566Z",
    },
    {
      filename: "maps/magnifying-glass_diffuse-high.png.ktx2",
      bytes: 4658422,
      lastChange: "2023-12-14T12:30:02.578Z",
    },
    {
      filename: "maps/magnifying-glass_diffuse-low.png",
      bytes: 2631945,
      lastChange: "2023-12-14T12:30:02.594Z",
    },
    {
      filename: "maps/magnifying-glass_diffuse-low.png.ktx2",
      bytes: 310447,
      lastChange: "2023-12-14T12:30:02.598Z",
    },
    {
      filename: "maps/magnifying-glass_diffuse-medium.png",
      bytes: 2631945,
      lastChange: "2023-12-14T12:30:02.614Z",
    },
    {
      filename: "maps/magnifying-glass_diffuse-medium.png.ktx2",
      bytes: 310447,
      lastChange: "2023-12-14T12:30:02.614Z",
    },
    {
      filename: "maps/magnifying-glass_diffuse.png",
      bytes: 7177659,
      lastChange: "2023-12-14T12:30:02.658Z",
    },
    {
      filename: "maps/magnifying-glass_glass-high.png",
      bytes: 1773236,
      lastChange: "2023-12-14T12:30:02.670Z",
    },
    {
      filename: "maps/magnifying-glass_glass-high.png.ktx2",
      bytes: 1349616,
      lastChange: "2023-12-14T12:30:02.678Z",
    },
    {
      filename: "maps/magnifying-glass_glass-low.png",
      bytes: 606245,
      lastChange: "2023-12-14T12:30:02.682Z",
    },
    {
      filename: "maps/magnifying-glass_glass-low.png.ktx2",
      bytes: 148048,
      lastChange: "2023-12-14T12:30:02.682Z",
    },
    {
      filename: "maps/magnifying-glass_glass-medium.png",
      bytes: 606245,
      lastChange: "2023-12-14T12:30:02.686Z",
    },
    {
      filename: "maps/magnifying-glass_glass-medium.png.ktx2",
      bytes: 148048,
      lastChange: "2023-12-14T12:30:02.690Z",
    },
    {
      filename: "maps/magnifying-glass_glass.png",
      bytes: 1561930,
      lastChange: "2023-12-14T12:30:02.698Z",
    },
    {
      filename: "maps/magnifying-glass_mask-0.png",
      bytes: 130424,
      lastChange: "2023-12-14T12:30:02.702Z",
    },
    {
      filename: "maps/magnifying-glass_mask-0.png.ktx2",
      bytes: 30030,
      lastChange: "2023-12-14T12:30:02.702Z",
    },
    {
      filename: "maps/magnifying-glass_mask-1.png",
      bytes: 55057,
      lastChange: "2023-12-14T12:30:02.702Z",
    },
    {
      filename: "maps/magnifying-glass_mask-1.png.ktx2",
      bytes: 16156,
      lastChange: "2023-12-14T12:30:02.702Z",
    },
    {
      filename: "maps/magnifying-glass_mv-high.png",
      bytes: 1558543,
      lastChange: "2023-12-14T12:30:02.714Z",
    },
    {
      filename: "maps/magnifying-glass_mv-high.png.ktx2",
      bytes: 1485850,
      lastChange: "2023-12-14T12:30:02.722Z",
    },
    {
      filename: "maps/magnifying-glass_mv-low.png",
      bytes: 196510,
      lastChange: "2023-12-14T12:30:02.722Z",
    },
    {
      filename: "maps/magnifying-glass_mv-low.png.ktx2",
      bytes: 133377,
      lastChange: "2023-12-14T12:30:02.722Z",
    },
    {
      filename: "maps/magnifying-glass_mv-medium.png",
      bytes: 572819,
      lastChange: "2023-12-14T12:30:02.726Z",
    },
    {
      filename: "maps/magnifying-glass_mv-medium.png.ktx2",
      bytes: 450544,
      lastChange: "2023-12-14T12:30:02.730Z",
    },
    {
      filename: "maps/magnifying-glass_mv.png",
      bytes: 297338,
      lastChange: "2023-12-14T12:30:02.730Z",
    },
    {
      filename: "maps/magnifying-glass_position-high.png",
      bytes: 1794699,
      lastChange: "2023-12-14T12:30:02.742Z",
    },
    {
      filename: "maps/magnifying-glass_position-high.png.ktx2",
      bytes: 1444608,
      lastChange: "2023-12-14T12:30:02.746Z",
    },
    {
      filename: "maps/magnifying-glass_position-low.png",
      bytes: 260436,
      lastChange: "2023-12-14T12:30:02.750Z",
    },
    {
      filename: "maps/magnifying-glass_position-low.png.ktx2",
      bytes: 122159,
      lastChange: "2023-12-14T12:30:02.750Z",
    },
    {
      filename: "maps/magnifying-glass_position-medium.png",
      bytes: 794478,
      lastChange: "2023-12-14T12:30:02.754Z",
    },
    {
      filename: "maps/magnifying-glass_position-medium.png.ktx2",
      bytes: 427457,
      lastChange: "2023-12-14T12:30:02.754Z",
    },
    {
      filename: "maps/magnifying-glass_position.png",
      bytes: 1171322,
      lastChange: "2023-12-14T12:30:02.762Z",
    },
    {
      filename: "maps/tablet_data-high.png",
      bytes: 120179,
      lastChange: "2023-12-14T12:30:02.766Z",
    },
    {
      filename: "maps/tablet_data-high.png.ktx2",
      bytes: 125575,
      lastChange: "2023-12-14T12:30:02.766Z",
    },
    {
      filename: "maps/tablet_data-low.png",
      bytes: 21352,
      lastChange: "2023-12-14T12:30:02.766Z",
    },
    {
      filename: "maps/tablet_data-low.png.ktx2",
      bytes: 33237,
      lastChange: "2023-12-14T12:30:02.766Z",
    },
    {
      filename: "maps/tablet_data-medium.png",
      bytes: 46857,
      lastChange: "2023-12-14T12:30:02.766Z",
    },
    {
      filename: "maps/tablet_data-medium.png.ktx2",
      bytes: 65922,
      lastChange: "2023-12-14T12:30:02.766Z",
    },
    {
      filename: "maps/tablet_data.png",
      bytes: 167017,
      lastChange: "2023-12-14T12:30:02.766Z",
    },
    {
      filename: "maps/tablet_diffuse-high.png",
      bytes: 4390093,
      lastChange: "2023-12-14T12:30:02.798Z",
    },
    {
      filename: "maps/tablet_diffuse-high.png.ktx2",
      bytes: 2691519,
      lastChange: "2023-12-14T12:30:02.802Z",
    },
    {
      filename: "maps/tablet_diffuse-low.png",
      bytes: 1565960,
      lastChange: "2023-12-14T12:30:02.814Z",
    },
    {
      filename: "maps/tablet_diffuse-low.png.ktx2",
      bytes: 251323,
      lastChange: "2023-12-14T12:30:02.814Z",
    },
    {
      filename: "maps/tablet_diffuse-medium.png",
      bytes: 1565960,
      lastChange: "2023-12-14T12:30:02.822Z",
    },
    {
      filename: "maps/tablet_diffuse-medium.png.ktx2",
      bytes: 251323,
      lastChange: "2023-12-14T12:30:02.822Z",
    },
    {
      filename: "maps/tablet_diffuse.png",
      bytes: 3728347,
      lastChange: "2023-12-14T12:30:02.842Z",
    },
    {
      filename: "maps/tablet_mask-0.png",
      bytes: 521177,
      lastChange: "2023-12-14T12:30:02.846Z",
    },
    {
      filename: "maps/tablet_mask-0.png.ktx2",
      bytes: 56717,
      lastChange: "2023-12-14T12:30:02.846Z",
    },
    {
      filename: "maps/tablet_mask-1.png",
      bytes: 599749,
      lastChange: "2023-12-14T12:30:02.850Z",
    },
    {
      filename: "maps/tablet_mask-1.png.ktx2",
      bytes: 77325,
      lastChange: "2023-12-14T12:30:02.850Z",
    },
    {
      filename: "maps/tablet_mv-high.png",
      bytes: 1872434,
      lastChange: "2023-12-14T12:30:02.866Z",
    },
    {
      filename: "maps/tablet_mv-high.png.ktx2",
      bytes: 1857228,
      lastChange: "2023-12-14T12:30:02.874Z",
    },
    {
      filename: "maps/tablet_mv-low.png",
      bytes: 255670,
      lastChange: "2023-12-14T12:30:02.878Z",
    },
    {
      filename: "maps/tablet_mv-low.png.ktx2",
      bytes: 175346,
      lastChange: "2023-12-14T12:30:02.878Z",
    },
    {
      filename: "maps/tablet_mv-medium.png",
      bytes: 679527,
      lastChange: "2023-12-14T12:30:02.882Z",
    },
    {
      filename: "maps/tablet_mv-medium.png.ktx2",
      bytes: 580195,
      lastChange: "2023-12-14T12:30:02.886Z",
    },
    {
      filename: "maps/tablet_mv.png",
      bytes: 379604,
      lastChange: "2023-12-14T12:30:02.886Z",
    },
    {
      filename: "maps/tablet_position-high.png",
      bytes: 2471968,
      lastChange: "2023-12-14T12:30:02.906Z",
    },
    {
      filename: "maps/tablet_position-high.png.ktx2",
      bytes: 1966888,
      lastChange: "2023-12-14T12:30:02.910Z",
    },
    {
      filename: "maps/tablet_position-low.png",
      bytes: 344425,
      lastChange: "2023-12-14T12:30:02.914Z",
    },
    {
      filename: "maps/tablet_position-low.png.ktx2",
      bytes: 138926,
      lastChange: "2023-12-14T12:30:02.914Z",
    },
    {
      filename: "maps/tablet_position-medium.png",
      bytes: 1000933,
      lastChange: "2023-12-14T12:30:02.922Z",
    },
    {
      filename: "maps/tablet_position-medium.png.ktx2",
      bytes: 506061,
      lastChange: "2023-12-14T12:30:02.922Z",
    },
    {
      filename: "maps/tablet_position.png",
      bytes: 2042154,
      lastChange: "2023-12-14T12:30:02.930Z",
    },
    {
      filename: "noise_rgb.png",
      bytes: 23209,
      lastChange: "2023-12-14T12:30:02.930Z",
    },
    {
      filename: "poster.jpg",
      bytes: 172754,
      lastChange: "2023-12-14T12:30:02.930Z",
    },
  ]),
  Class(function BalanceText() {
    Inherit(this, Component);
    this.relayout = (wrapper, ratio = 1) => {
      const container = wrapper.parentElement;
      if (!container) return;
      const update = (width) => (wrapper.style.maxWidth = `${width}px`);
      wrapper.style.maxWidth = "";
      const width = container.clientWidth,
        height = container.clientHeight;
      let middle,
        lower = width / 2 - 0.25,
        upper = width + 0.5;
      if (width) {
        for (; lower + 1 < upper; )
          (middle = Math.round((lower + upper) / 2)),
            update(middle),
            container.clientHeight === height
              ? (upper = middle)
              : (lower = middle);
        update(upper * ratio + width * (1 - ratio));
      }
    };
  }, "static"),
  Namespace("FX"),
  FX.Class(function Bloom(_nuke = World.NUKE, _unique) {
    Inherit(this, Component);
    var _mesh,
      _shader,
      _texture,
      _this = this,
      _scenes = [],
      _blurs = [],
      _dpr = World.DPR;
    function render(e) {
      if (!_this.enabled) return;
      _shader.set("tMap", _texture || _nuke.rttBuffer.texture),
        _shader.set("uBloomMinLuma", _this.shader.uniforms.uBloomMinLuma.value);
      let strength = _this.shader.uniforms.uBloomBlurStrength.value,
        radius = _this.shader.uniforms.uBloomBlurRadius.value;
      for (let i = _blurs.length - 1; i > -1; i--) {
        let blur = _blurs[i];
        blur.set("uStrength", strength),
          (blur.uniforms.uDir.value.x =
            blur.uniforms.uDir.value.x > 0 ? radius * _dpr : 0),
          (blur.uniforms.uDir.value.y =
            blur.uniforms.uDir.value.y > 0 ? radius * _dpr : 0);
      }
      for (let i = 0; i < _scenes.length; i++) {
        let scene = _scenes[i];
        (scene.nuke.camera = e.camera),
          (scene.nuke.stage = e.stage),
          scene.render();
      }
    }
    function resizeHandler() {
      for (let i = 0; i < _scenes.length; i++) {
        let w = Math.round(Stage.width / (2 * (i + 1))),
          h = Math.round(Stage.height / (2 * (i + 1)));
        _scenes[i].setSize(w, h);
      }
    }
    (this.uniforms = {}),
      (this.enabled = !0),
      (function initMesh() {
        (_this.shader = new Shader("TextureMaterial", {
          unique: "Bloom_" + _unique,
          uBloomMinLuma: { value: 0 },
          uBloomBlurStrength: { value: 1 },
          uBloomBlurRadius: { value: 2.5 },
        })),
          (_shader = _this.initClass(Shader, "BloomQuad", {
            tMap: { value: null },
            uBloomMinLuma: { value: 0 },
          })),
          ((_mesh = new Mesh(World.QUAD, _shader)).frustumCulled = !1);
      })(),
      (function initRTs() {
        let addBlur = (nuke) => {
          [new Vector2(2.5 * _dpr, 0), new Vector2(0, 2.5 * _dpr)].forEach(
            (dir) => {
              let pass = new NukePass("BloomBlur", {
                uDir: { value: dir },
                uStrength: { value: 0.5 },
              });
              nuke.add(pass), _blurs.push(pass);
            }
          );
        };
        for (let i = 0; i < 4; i++) {
          let w = Math.round(Stage.width / (2 * (i + 1))),
            h = Math.round(Stage.height / (2 * (i + 1))),
            scene = _this.initClass(FXScene, World.NUKE);
          scene.setSize(w, h),
            scene.scene.add(_mesh.clone()),
            _scenes.push(scene),
            addBlur(scene.nuke);
        }
      })(),
      (function initPass() {
        for (let i = 0; i < _scenes.length; i++)
          _this.uniforms[`tBloom${i}`] = {
            value: _scenes[i].rt.texture,
            ignoreUIL: !0,
          };
        (_this.uniforms.uBloomAddStrength = { value: 1 }),
          (_this.pass = _this.initClass(NukePass, "BloomPass", _this.uniforms));
      })(),
      (function addListeners() {
        _this.events.sub(Events.RESIZE, resizeHandler),
          _this.events.sub(RenderManager.RENDER, render);
      })(),
      ShaderUIL.add(_this.shader).setLabel("Bloom"),
      this.set("dpr", (dpr) => {
        _dpr = dpr;
        for (let i = 0; i < _scenes.length; i++) _scenes[i].setDPR(dpr);
      }),
      this.set("texture", (texture) => {
        _texture = texture;
      });
  }),
  Class(function ImageDecoder() {
    Inherit(this, Component);
    var _ktx1Settings,
      _this = this;
    this.scale = 1;
    var _offscreen = {};
    function decodeImage(data, id) {
      (async (_) => {
        try {
          let e = await fetch(data.path, { mode: "cors" });
          if (200 != e.status)
            throw (
              (resolve({ fail: !0 }, id), `Image not found :: ${data.path}`)
            );
          let blob = await e.blob(),
            obj = { imageOrientation: "flipY", crossOrigin: "anonymous" };
          data.params &&
            !1 === data.params.premultiplyAlpha &&
            (obj.premultiplyAlpha = "none"),
            (obj.imageOrientation =
              data.params && !1 === data.params.flipY ? void 0 : "flipY");
          let bitmap = await createImageBitmap(blob, obj),
            message = { post: !0, id: id, message: bitmap };
          self.postMessage(message, [bitmap]);
        } catch (e) {
          throw (
            (resolve(
              { fail: `${data.path} could not be decoded: ${e.message || e}` },
              id
            ),
            e)
          );
        }
      })();
    }
    function decodeCubeLUT(data, id) {
      (async (_) => {
        try {
          let cube = await get(data.path, { mode: "cors" });
          cube = cube
            .replace(/^#.*?(\n|\r)/gm, "")
            .replace(/^\s*?(\n|\r)/gm, "")
            .trim();
          let cubesize = findNumberAfterString(cube, "LUT_3D_SIZE", !0),
            domain_min = findNumberAfterString(cube, "DOMAIN_MIN"),
            domain_max = findNumberAfterString(cube, "DOMAIN_MAX");
          (cube = removeCubeHeader(cube, "TITLE")),
            (cube = removeCubeHeader(cube, "LUT_3D_SIZE")),
            (cube = removeCubeHeader(cube, "DOMAIN_MIN")),
            (cube = removeCubeHeader(cube, "DOMAIN_MAX"));
          let rgba = [];
          if (
            (cube
              .split(/\s+/)
              .filter((substr) => substr.length > 0)
              .forEach((element, index) => {
                rgba.push(+element),
                  (index + 1) % 3 == 0 &&
                    index !== 4 * Math.pow(cubesize, 3) - 1 &&
                    rgba.push(1);
              }),
            rgba.forEach((e, i) => {
              domain_min &&
                domain_max &&
                (rgba[i] = Math.map(rgba[i], domain_min, domain_max, 0, 1)),
                (rgba[i] = Math.clamp(Math.round(255 * rgba[i]), 0, 255));
            }),
            rgba.length !== cubesize ** 3 * 4)
          )
            throw `LUT .cube at ${data.path} has length mismatch: claims cube size of ${cubesize} but has ${rgba.length} elements.`;
          let imgBmp = new Uint8Array(rgba);
          resolve({ imgBmp: imgBmp, cubesize: cubesize }, id);
        } catch (e) {
          throw (
            (resolve(
              { fail: `${data.path} could not be decoded: ${e.message || e}` },
              id
            ),
            e)
          );
        }
      })();
    }
    function decodeKtx1CompressedImage(data, id) {
      (async (_) => {
        let ext;
        data.settings.dxt
          ? (ext = "dxt")
          : data.settings.etc
          ? (ext = "astc")
          : data.settings.pvrtc
          ? (ext = "pvrtc")
          : data.settings.astc && (ext = "astc");
        let fileName = data.path.split("/");
        fileName = fileName[fileName.length - 1];
        let e = await fetch(`${data.path}/${fileName}-${ext}.ktx`);
        if (200 != e.status) throw `Image not found :: ${data.path}`;
        let arrayBuffer = await e.arrayBuffer(),
          header = new Int32Array(arrayBuffer, 12, 13),
          gliFormat = (header[1], header[2], header[3], header[4]),
          baseWidth = (header[5], header[6]),
          baseHeight = header[7],
          width = baseWidth,
          height = baseHeight,
          numberOfArrayElements = header[9],
          numberOfFaces = header[10],
          miplevels = header[11],
          buffers = [],
          compressedData = [],
          sizes = [],
          cube = 6 === numberOfFaces && 0 === numberOfArrayElements,
          dataOffset = 64 + header[12];
        for (let level = 0; level < miplevels; level++) {
          let imageSize = new Int32Array(arrayBuffer, dataOffset, 1)[0];
          (dataOffset += 4), cube && (imageSize *= 6);
          let byteArray = new Uint8Array(arrayBuffer, dataOffset, imageSize);
          (dataOffset += imageSize),
            (dataOffset += 3 - ((imageSize + 3) % 4)),
            sizes.push(width),
            (width = Math.max(1, 0.5 * width)),
            (height = Math.max(1, 0.5 * height));
          let clone = new Uint8Array(byteArray);
          compressedData.push(clone), buffers.push(clone.buffer);
        }
        resolve(
          {
            gliFormat: gliFormat,
            compressedData: compressedData,
            sizes: sizes,
            width: baseWidth,
            height: baseHeight,
            cube: cube,
          },
          id,
          buffers
        );
      })().catch((e) => {
        console.log(e.toString()),
          resolve(
            { fail: `${data.path} could not be decoded: ${e.message || e}` },
            id
          );
      });
    }
    function renderOnQuad(image, compressionExtensions) {
      let aspect = image.width / image.height,
        width = Math.round(aspect > 1 ? 128 : 128 * aspect),
        height = Math.round(aspect > 1 ? 128 / aspect : 128);
      const gl = new OffscreenCanvas(width, height).getContext("webgl");
      if (!gl) throw new Error("Unable to initialize offscreen WebGL canvas");
      function loadShader(gl, shaderSource, shaderType) {
        const shader = gl.createShader(shaderType);
        gl.shaderSource(shader, shaderSource), gl.compileShader(shader);
        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
          const lastError = gl.getShaderInfoLog(shader);
          throw (
            (gl.deleteShader(shader),
            new Error("Shader compile error: " + lastError))
          );
        }
        return shader;
      }
      let vs = loadShader(
          gl,
          "\nattribute vec4 a_position;\nvarying vec2 v_texcoord;\n\nvoid main() {\n    gl_Position = a_position;\n    v_texcoord = a_position.xy * 0.5 + 0.5;\n}",
          gl.VERTEX_SHADER
        ),
        fs = loadShader(
          gl,
          "\nprecision mediump float;\nvarying vec2 v_texcoord;\nuniform sampler2D u_texture;\n\nvoid main() {\n    gl_FragColor = texture2D(u_texture, v_texcoord);\n}",
          gl.FRAGMENT_SHADER
        ),
        program = (function createProgram(gl, shaders) {
          const program = gl.createProgram();
          if (
            (shaders.forEach(function (shader) {
              gl.attachShader(program, shader);
            }),
            gl.linkProgram(program),
            !gl.getProgramParameter(program, gl.LINK_STATUS))
          ) {
            const lastError = gl.getProgramInfoLog(program);
            throw (
              (gl.deleteProgram(program),
              shaders.forEach(function (shader) {
                gl.deleteShader(shader);
              }),
              new Error("Shader link error:" + lastError))
            );
          }
          return program;
        })(gl, [vs, fs]);
      var positionLocation = gl.getAttribLocation(program, "a_position"),
        positionBuffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer),
        gl.bufferData(
          gl.ARRAY_BUFFER,
          new Float32Array([-1, -1, 3, -1, -1, 3]),
          gl.STATIC_DRAW
        ),
        gl.viewport(0, 0, gl.canvas.width, gl.canvas.height),
        gl.clear(gl.COLOR_BUFFER_BIT);
      const tex = gl.createTexture();
      gl.bindTexture(gl.TEXTURE_2D, tex),
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE),
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE),
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR),
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR),
        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, !0);
      let ext = {};
      compressionExtensions.forEach((str) => {
        switch (str) {
          case "astc":
            ext.astc = gl.getExtension("WEBGL_compressed_texture_astc");
            break;
          case "atc":
            ext.atc = gl.getExtension("WEBGL_compressed_texture_atc");
            break;
          case "etc":
            ext.etc = gl.getExtension("WEBGL_compressed_texture_etc");
            break;
          case "etc1":
            ext.etc1 = gl.getExtension("WEBGL_compressed_texture_etc1");
            break;
          case "pvrtc":
            ext.pvrtc =
              gl.getExtension("WEBGL_compressed_texture_pvrtc") ||
              gl.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
            break;
          case "s3tc":
            ext.s3tc =
              gl.getExtension("WEBGL_compressed_texture_s3tc") ||
              gl.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
            break;
          case "bptc":
            ext.bptc = gl.getExtension("EXT_texture_compression_bptc");
            break;
          case "s3tc_srgb":
            ext.s3tc_srgb = gl.getExtension(
              "WEBGL_compressed_texture_s3tc_srgb"
            );
        }
      });
      let index = image.sizes.findIndex(
        (e) => e.width <= 128 && e.height <= 128
      );
      gl.compressedTexImage2D(
        gl.TEXTURE_2D,
        0,
        image.gliFormat,
        image.sizes[index].width,
        image.sizes[index].height,
        0,
        image.compressedData[index]
      ),
        gl.useProgram(program),
        gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer),
        gl.enableVertexAttribArray(positionLocation),
        gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, !1, 0, 0),
        gl.drawArrays(gl.TRIANGLES, 0, 3),
        gl.useProgram(null);
      let data = new Uint8Array(65536);
      return (
        gl.readPixels(0, 0, 128, 128, gl.RGBA, gl.UNSIGNED_BYTE, data), data
      );
    }
    function findDominantColors(e, id) {
      function calculateCenterColor(colors) {
        let center = new ColorLAB();
        return (
          colors.forEach((color) => {
            (center.l += color.l), (center.a += color.a), (center.b += color.b);
          }),
          colors.length &&
            ((center.l /= colors.length),
            (center.a /= colors.length),
            (center.b /= colors.length)),
          center
        );
      }
      try {
        let data;
        if (e.compressionExtensions)
          data = renderOnQuad(e.image, e.compressionExtensions);
        else if (e.image) {
          let aspect = e.image.width / e.image.height,
            max = 128,
            width = Math.round(aspect > 1 ? max : max * aspect),
            height = Math.round(aspect > 1 ? max / aspect : max),
            ctx = new OffscreenCanvas(width, height).getContext("2d");
          ctx.drawImage(e.image, 0, 0, width, height),
            (data = ctx.getImageData(0, 0, width, height).data);
        } else data = e.data;
        let count = data.length / 4,
          colors = [],
          j = 0;
        for (let i = 0; i < count; ++i)
          data[j + 3] > 25 &&
            colors.push(
              new ColorLAB().setRGB(
                data[j] / 255,
                data[j + 1] / 255,
                data[j + 2] / 255
              )
            ),
            (j += 4);
        let results = (function kmeans(colors, k, minDiff) {
          let clusters = (function getInitialClusters(colors, k) {
            const sums = colors.map((color) => [
              color.l + color.a + color.b,
              color,
            ]);
            sums.sort((a, b) => a[0] - b[0]);
            const centroids = [...Array(k)].map((_, i) => {
              const shardSize = Math.floor(sums.length / k);
              return calculateCenterColor(
                sums
                  .slice(
                    shardSize * i,
                    i === k - 1 ? sums.length : shardSize * (i + 1)
                  )
                  .map((sum) => sum[1])
              );
            });
            for (let i = 0; i < centroids.length - 1; ++i) {
              const color = centroids[i],
                nextColor = centroids[i + 1];
              color.l === nextColor.l &&
                color.a === nextColor.a &&
                color.b === nextColor.b &&
                (centroids.splice(i + 1, 1), (i -= 1));
            }
            return centroids.map((color) => [color, []]);
          })(colors, k);
          k = clusters.length;
          for (let i = 1; ; i++) {
            let lists = [...Array(k)].map(() => []);
            for (let j = 0; j < colors.length; j++) {
              let c = colors[j],
                smallestDistance = 1 / 0,
                idx = 0;
              for (let i = 0; i < k; i++) {
                let distance = c.deltaECIE94(clusters[i][0]);
                distance < smallestDistance &&
                  ((smallestDistance = distance), (idx = i));
              }
              lists[idx].push(c);
            }
            let diff = 0;
            for (let i = 0; i < k; i++) {
              let old = clusters[i],
                center = calculateCenterColor(lists[i]),
                newCluster = [center, lists[i]],
                dist = old[0].deltaECIE94(center);
              (clusters[i] = newCluster), (diff = diff > dist ? diff : dist);
            }
            if (diff < minDiff || 50 === i) break;
          }
          return clusters;
        })(
          colors,
          "number" == typeof e.numColors ? e.numColors : 4,
          1 / 255
        ).filter((cluster) => cluster[1].length);
        results.sort((a, b) => b[1].length - a[1].length),
          (results = results.map((result) => result[0].getRGB())),
          resolve({ colors: results }, id);
      } catch (e) {
        throw (resolve({ fail: e.message || e }, id), e);
      }
    }
    function findNumberAfterString(source, str, toInt = !1) {
      const regex = new RegExp(str + "\\D*([0-9]*\\.?[0-9]+)"),
        num = source.match(regex);
      return num && num[1]
        ? toInt
          ? parseInt(num[1])
          : parseFloat(num[1])
        : null;
    }
    function removeCubeHeader(source, str) {
      const regex = new RegExp(str + "[\\s\\S]*?(\\n+)"),
        match = source.match(regex);
      if (match) {
        const newlineIndex = match.index + match[0].length - 1;
        return source.slice(newlineIndex + 1);
      }
      return source;
    }
    function checkCapabilities() {
      if (
        (void 0 === _offscreen["2d"] &&
          (_offscreen["2d"] =
            "OffscreenCanvas" in window &&
            !!new OffscreenCanvas(1, 1).getContext("2d")),
        void 0 === _offscreen.webgl &&
          ((_offscreen.webgl =
            "OffscreenCanvas" in window &&
            !!new OffscreenCanvas(1, 1).getContext("webgl")),
          _offscreen.webgl))
      ) {
        let compressionExtensions = [
            "compressed_texture",
            "texture_compression",
          ],
          enabledExtensions = Device.graphics.webgl?.extensions || [],
          dedupe = {};
        _offscreen.compressionExtensions = enabledExtensions
          .map((ext) =>
            compressionExtensions
              .map((name) => {
                let index = ext.indexOf(name);
                if (!(index < 0))
                  return (
                    (index += name.length),
                    "_" === ext.charAt(index) && (index += 1),
                    ext.substring(index)
                  );
              })
              .find(Boolean)
          )
          .filter((ext) => !(!ext || dedupe[ext]) && (dedupe[ext] = !0));
      }
    }
    !(async function () {
      await Hydra.ready(),
        Thread.upload(decodeImage),
        Thread.upload(decodeCubeLUT),
        Thread.upload(findNumberAfterString),
        Thread.upload(removeCubeHeader),
        Thread.upload(renderOnQuad),
        Thread.upload(findDominantColors),
        Thread.upload(decodeKtx1CompressedImage);
    })(),
      (this.decode = async function (path, params = {}) {
        let fallback = Thread.absolutePath(
          Assets.getPath("assets/images/_scenelayout/uv.jpg")
        );
        if (
          ((path = Thread.absolutePath(Assets.getPath(path))),
          void 0 === _ktx1Settings)
        ) {
          _ktx1Settings = {
            dxt: !!Renderer.extensions.s3tc,
            etc: !!Renderer.extensions.etc1,
            pvrtc: !!Renderer.extensions.pvrtc,
            astc: !!Renderer.extensions.astc,
          };
          let found = !1;
          for (let key in _ktx1Settings)
            !0 === _ktx1Settings[key] && (found = !0);
          found || (_ktx1Settings = null);
        }
        let compressedIdentifier = /-compressedKtx2?/.exec(path)?.[0],
          compressed =
            !!compressedIdentifier &&
            (compressedIdentifier.endsWith("2") ? "ktx2" : "ktx1");
        if (
          ((Utils.query("noKtx") ||
            (!_ktx1Settings && "ktx1" === compressed)) &&
            ((path = path.replace(compressedIdentifier, "")),
            (compressed = !1)),
          /\.ktx2(?:\?|#|$)/.test(path) &&
            ((compressed = "ktx2"),
            Utils.query("noKtx") && (params.uncompressed = !0)),
          compressed &&
            params.hintUsingPixelData &&
            (checkCapabilities(),
            _offscreen.webgl ||
              ("ktx2" === compressed
                ? (params.uncompressed = !0)
                : ((path = path.replace(compressedIdentifier, "")),
                  (compressed = !1)))),
          compressed)
        ) {
          try {
            let bitmap;
            if (
              ((path = path.substring(0, path.lastIndexOf("."))),
              (bitmap =
                "ktx1" === compressed
                  ? await Thread.shared().decodeKtx1CompressedImage({
                      path: path,
                      params: params,
                      settings: _ktx1Settings,
                    })
                  : await Ktx2Transcoder.transcode({
                      path: `${path}.ktx2`,
                      params: params,
                    })),
              !bitmap.fail)
            )
              return bitmap;
          } catch (e) {}
          return _this.decode(fallback, params);
        }
        {
          let getBitmap = (path, params) =>
            Thread.shared().decodeImage({ path: path, params: params });
          try {
            let bitmap = await getBitmap(path, params);
            if (
              bitmap.fail &&
              ((bitmap = await getBitmap(fallback, params)), bitmap.fail)
            )
              throw "could not decode " + path;
            return (function process(bitmap, scale) {
              if (1 == scale * _this.scale) return bitmap;
              let pow2 = Math.isPowerOf2(bitmap.width, bitmap.height),
                canvas = document.createElement("canvas");
              return (
                (canvas.context = canvas.getContext("2d")),
                (canvas.width = Math.round(bitmap.width * _this.scale * scale)),
                (canvas.height = Math.round(
                  bitmap.height * _this.scale * scale
                )),
                pow2 &&
                  scale * _this.scale < 1 &&
                  (canvas.width = canvas.height =
                    Math.floorPowerOf2(Math.max(canvas.width, canvas.height))),
                canvas.context.drawImage(
                  bitmap,
                  0,
                  0,
                  canvas.width,
                  canvas.height
                ),
                canvas
              );
            })(bitmap, params.scale || 1);
          } catch (e) {
            throw "could not decode " + path;
          }
        }
      }),
      (this.decodeCubeLUT = async function (path, params) {
        let fallback = Thread.absolutePath(
          Assets.getPath("assets/images/_scenelayout/invert.cube")
        );
        path = Thread.absolutePath(Assets.getPath(path));
        try {
          let bitmap = await Thread.shared().decodeCubeLUT({
            path: path,
            params: params,
          });
          if (
            bitmap.fail &&
            ((bitmap = await Thread.shared().decodeCubeLUT({
              path: fallback,
              params: params,
            })),
            bitmap.fail)
          )
            throw "could not decode " + path;
          return { imgBmp: bitmap.imgBmp, cubesize: bitmap.cubesize };
        } catch (e) {
          throw "could not decode " + path;
        }
      }),
      (this.parseColors = async function (image, numColors = 4) {
        let result;
        if ((checkCapabilities(), image.sizes))
          if (_offscreen.webgl)
            result = await Thread.shared().findDominantColors({
              image: image,
              numColors: numColors,
              compressionExtensions: _offscreen.compressionExtensions,
            });
          else {
            let index = image.sizes.findIndex(
              (e) => e.width <= 128 && e.height <= 128
            );
            index = Math.max(0, index);
            let data = (image = await _this.decode(
              image.path + "-compressedKtx2",
              { uncompressed: !0 }
            )).compressedData[index];
            result = await Thread.shared().findDominantColors(
              { data: data, numColors: numColors },
              [data.buffer]
            );
          }
        else {
          let buffers = [];
          if (
            (image instanceof HTMLImageElement &&
              ((image = await createImageBitmap(image)), buffers.push(image)),
            _offscreen["2d"])
          )
            result = await Thread.shared().findDominantColors(
              { image: image, numColors: numColors },
              buffers
            );
          else {
            let canvas = document.createElement("canvas");
            canvas.context = canvas.getContext("2d");
            let aspect = image.width / image.height,
              max = 128;
            (canvas.width = Math.round(aspect > 1 ? max : max * aspect)),
              (canvas.height = Math.round(aspect > 1 ? max / aspect : max)),
              canvas.context.drawImage(
                image,
                0,
                0,
                canvas.width,
                canvas.height
              );
            let data = canvas.context.getImageData(
              0,
              0,
              canvas.width,
              canvas.height
            ).data;
            result = await Thread.shared().findDominantColors(
              { data: data, numColors: numColors },
              [data.buffer]
            );
          }
        }
        if (result.fail) throw new Error(result.fail);
        return result.colors.map((color) => new Color().copy(color));
      });
  }, "static"),
  Class(function Ktx2Transcoder() {
    Inherit(this, Component);
    const _this = this;
    var _transcoderReady,
      _basisAssets = [
        "~assets/js/lib/basis_transcoder.js",
        "~assets/js/lib/basis_transcoder.wasm",
      ]
        .map(Assets.getPath)
        .map(Thread.absolutePath);
    async function initBasisTranscoder() {
      if (_transcoderReady) await _transcoderReady;
      else {
        _transcoderReady = Promise.create();
        let [js, wasmBinary] = await Promise.all(
            _basisAssets.map(async (path, i) => {
              let response = await fetch(path);
              return 0 === i ? response.text() : response.arrayBuffer();
            })
          ),
          formats = (function getSupportedFormats() {
            let supported = {
              astc: !!Renderer.extensions.astc,
              etc1: !!Renderer.extensions.etc1,
              etc2: !!Renderer.extensions.etc,
              dxt: !!Renderer.extensions.s3tc,
              bptc: !!Renderer.extensions.bptc,
              pvrtc: !!Renderer.extensions.pvrtc,
              uncompressed: !0,
            };
            Renderer.type === Renderer.WEBGL2 && (supported.etc1 = !1);
            let formats = {};
            return (
              Object.keys(supported)
                .filter((id) => supported[id])
                .forEach((id) => {
                  let format = { id: id, needsPowerOfTwo: !1 };
                  switch (((formats[id] = format), id)) {
                    case "astc":
                      format.gliFormat = [
                        Renderer.extensions.astc.COMPRESSED_RGBA_ASTC_4x4_KHR,
                        Renderer.extensions.astc.COMPRESSED_RGBA_ASTC_4x4_KHR,
                      ];
                      break;
                    case "bptc":
                      format.gliFormat = [
                        Renderer.extensions.bptc.COMPRESSED_RGBA_BPTC_UNORM_EXT,
                        Renderer.extensions.bptc.COMPRESSED_RGBA_BPTC_UNORM_EXT,
                      ];
                      break;
                    case "dxt":
                      format.gliFormat = [
                        Renderer.extensions.s3tc.COMPRESSED_RGB_S3TC_DXT1_EXT,
                        Renderer.extensions.s3tc.COMPRESSED_RGBA_S3TC_DXT5_EXT,
                      ];
                      break;
                    case "etc2":
                      format.gliFormat = [
                        Renderer.extensions.etc.COMPRESSED_RGB8_ETC2,
                        Renderer.extensions.etc.COMPRESSED_RGBA8_ETC2_EAC,
                      ];
                      break;
                    case "etc1":
                      format.gliFormat = [
                        Renderer.extensions.etc.COMPRESSED_RGB_ETC1_WEBGL,
                      ];
                      break;
                    case "pvrtc":
                      (format.gliFormat = [
                        Renderer.extensions.pvrtc
                          .COMPRESSED_RGB_PVRTC_4BPPV1_IMG,
                        Renderer.extensions.pvrtc
                          .COMPRESSED_RGBA_PVRTC_4BPPV1_IMG,
                      ]),
                        (format.needsPowerOfTwo = !0);
                      break;
                    case "uncompressed":
                      format.gliFormat = [
                        Renderer.context.RGBA,
                        Renderer.context.RGBA,
                      ];
                  }
                }),
              formats
            );
          })(),
          threads = Thread.shared(!0).array;
        await Promise.all(
          threads.map(async (thread) => {
            thread.importCode(js),
              thread.loadFunction(initKtx2TranscoderThread),
              thread.loadFunction(function transcodeKtx2() {}),
              await thread.initKtx2TranscoderThread({
                wasmBinary: wasmBinary,
                formats: formats,
              });
          })
        ),
          _transcoderReady.resolve(),
          _this.flag("transcoderLoaded", !0);
      }
    }
    function initKtx2TranscoderThread(e, id) {
      var _formats;
      async function transcodeKtx2({ path: path, params: params }, id) {
        let ktx2File;
        try {
          let response = await fetch(path);
          if (200 !== response.status)
            throw new Error(`Image not found :: ${path}`);
          let arrayBuffer = await response.arrayBuffer();
          if (
            ((ktx2File = new BasisModule.KTX2File(new Uint8Array(arrayBuffer))),
            !ktx2File.isValid())
          )
            throw new Error("Invalid or unsupported .ktx2 file");
          let ktxheader = ktx2File.getHeader(),
            basisFormat = ktx2File.isUASTC() ? "uastc" : "etc1s",
            baseWidth = ktx2File.getWidth(),
            baseHeight = ktx2File.getHeight(),
            baseDepth = ktxheader.pixelDepth,
            layers = ktx2File.getLayers() || 1,
            levels = ktx2File.getLevels(),
            faceCount = ktx2File.getFaces(),
            hasAlpha = ktx2File.getHasAlpha(),
            premultiplyAlpha = !!(1 & ktx2File.getDFDFlags()),
            {
              transcoderFormat: transcoderFormat,
              gliFormat: gliFormat,
              uncompressed: uncompressed,
            } = (function getTranscoderFormat(
              basisFormat,
              width,
              height,
              hasAlpha,
              params
            ) {
              let format;
              format = params.uncompressed
                ? _formats.uncompressed
                : _formats[basisFormat].find(
                    (format) =>
                      !(
                        (hasAlpha && format.transcoderFormat.length < 2) ||
                        (format.needsPowerOfTwo &&
                          !Math.isPowerOf2(width, height))
                      )
                  );
              let uncompressed = "uncompressed" === format.id;
              uncompressed &&
                !params.uncompressed &&
                console.warn(
                  "No suitable compressed texture format found. Decoding to RGBA32."
                );
              let which = hasAlpha ? 1 : 0;
              return {
                transcoderFormat: format.transcoderFormat[which],
                gliFormat: format.gliFormat[which],
                uncompressed: uncompressed,
              };
            })(basisFormat, baseWidth, baseHeight, hasAlpha, params);
          if (!baseWidth || !baseHeight || !levels)
            throw new Error("Invalid texture");
          if (layers > 1) throw new Error("Array textures not implemented");
          if (!ktx2File.startTranscoding())
            throw new Error("startTranscoding failed");
          let buffers = [],
            compressedData = [],
            sizes = [],
            cube = 6 === faceCount;
          if (params.isTexture3D && ktxheader.vkFormat && baseDepth) {
            const channelCount = 4;
            let data = new Uint8Array(
              arrayBuffer.slice(
                baseWidth *
                  baseHeight *
                  baseDepth *
                  ktxheader.typeSize *
                  channelCount *
                  -1
              )
            );
            compressedData.push(data),
              buffers.push(data.buffer),
              sizes.push({
                baseWidth: baseWidth,
                baseHeight: baseHeight,
                baseDepth: baseDepth,
              });
          } else
            for (let level = 0; level < levels; level++) {
              let width,
                height,
                data,
                faces = [];
              for (let faceIndex = 0; faceIndex < faceCount; ++faceIndex) {
                let levelInfo = ktx2File.getImageLevelInfo(level, 0, faceIndex);
                (width = levelInfo.origWidth), (height = levelInfo.origHeight);
                let data = new Uint8Array(
                  ktx2File.getImageTranscodedSizeInBytes(
                    level,
                    0,
                    faceIndex,
                    transcoderFormat
                  )
                );
                if (
                  !ktx2File.transcodeImage(
                    data,
                    level,
                    0,
                    faceIndex,
                    transcoderFormat,
                    0,
                    -1,
                    -1
                  )
                )
                  throw new Error("transcodeImage failed");
                faces.push(data);
              }
              if (faces.length > 1) {
                let totalLength = 0;
                faces.forEach((face) => {
                  totalLength += face.byteLength;
                }),
                  (data = new Uint8Array(totalLength));
                let offset = 0;
                faces.forEach((face) => {
                  data.set(face, offset), (offset += face.byteLength);
                });
              } else data = faces[0];
              compressedData.push(data),
                buffers.push(data.buffer),
                sizes.push({ width: width, height: height });
            }
          resolve(
            {
              path: path,
              gliFormat: gliFormat,
              compressedData: compressedData,
              sizes: sizes,
              width: baseWidth,
              height: baseHeight,
              depth: baseDepth,
              cube: cube,
              premultiplyAlpha: premultiplyAlpha,
              uncompressed: uncompressed,
            },
            id,
            buffers
          );
        } catch (e) {
          console.log(e.toString()),
            resolve(
              { fail: `${path} could not be decoded: ${e.message || e}` },
              id
            );
        } finally {
          ktx2File && (ktx2File.close(), ktx2File.delete());
        }
      }
      var BasisModule = {
        wasmBinary: e.wasmBinary,
        onRuntimeInitialized: function () {
          BasisModule.initializeBasis(),
            (function initFormats(formats) {
              Object.keys(formats).forEach((id) => {
                let format = formats[id];
                switch (id) {
                  case "astc":
                    format.transcoderFormat = [
                      BasisModule.transcoder_texture_format.cTFASTC_4x4_RGBA
                        .value,
                      BasisModule.transcoder_texture_format.cTFASTC_4x4_RGBA
                        .value,
                    ];
                    break;
                  case "bptc":
                    format.transcoderFormat = [
                      BasisModule.transcoder_texture_format.cTFBC7_RGBA.value,
                      BasisModule.transcoder_texture_format.cTFBC7_RGBA.value,
                    ];
                    break;
                  case "dxt":
                    format.transcoderFormat = [
                      BasisModule.transcoder_texture_format.cTFBC1_RGB.value,
                      BasisModule.transcoder_texture_format.cTFBC3_RGBA.value,
                    ];
                    break;
                  case "etc2":
                    format.transcoderFormat = [
                      BasisModule.transcoder_texture_format.cTFETC1_RGB.value,
                      BasisModule.transcoder_texture_format.cTFETC2_RGBA.value,
                    ];
                    break;
                  case "etc1":
                    format.transcoderFormat = [
                      BasisModule.transcoder_texture_format.cTFETC1_RGB.value,
                    ];
                    break;
                  case "pvrtc":
                    format.transcoderFormat = [
                      BasisModule.transcoder_texture_format.cTFPVRTC1_4_RGB
                        .value,
                      BasisModule.transcoder_texture_format.cTFPVRTC1_4_RGBA
                        .value,
                    ];
                    break;
                  case "uncompressed":
                    format.transcoderFormat = [
                      BasisModule.transcoder_texture_format.cTFRGBA32.value,
                      BasisModule.transcoder_texture_format.cTFRGBA32.value,
                    ];
                }
              }),
                (_formats = {
                  uastc: [
                    formats.astc,
                    formats.bptc,
                    formats.etc2,
                    formats.etc1,
                    formats.dxt,
                    formats.pvrtc,
                    formats.uncompressed,
                  ].filter(Boolean),
                  etc1s: [
                    formats.etc2,
                    formats.etc1,
                    formats.bptc,
                    formats.dxt,
                    formats.pvrtc,
                    formats.uncompressed,
                  ].filter(Boolean),
                  uncompressed: formats.uncompressed,
                });
            })(e.formats),
            (self.transcodeKtx2 = transcodeKtx2),
            delete self.initKtx2TranscoderThread,
            resolve(id);
        },
      };
      BASIS(BasisModule);
    }
    _this.transcode = async function ({ path: path, params: params }) {
      _this.flag("transcoderLoaded") || (await initBasisTranscoder());
      let result = await Thread.shared().transcodeKtx2({
        path: path,
        params: params,
      });
      if (result.fail) throw new Error(result.fail);
      return result;
    };
  }, "static"),
  Class(function BaseCamera(_input, _group) {
    Inherit(this, Object3D);
    const _this = this;
    var _debugCamera,
      _type = "perspective";
    function resize() {
      if (_this.overrideResize)
        "function" == typeof _this.overrideResize && _this.overrideResize();
      else
        switch (_type) {
          case "perspective":
            (_this.camera.aspect = Stage.width / Stage.height),
              _this.camera.updateProjectionMatrix();
            break;
          case "orthographic":
            if (_this.width || _this.height)
              _this.camera.setViewport(_this.width, _this.height);
            else {
              let m = 900 / Stage.height / 100;
              _this.camera.setViewport(Stage.width * m, Stage.height * m);
            }
        }
    }
    (this.camera = new PerspectiveCamera(
      30,
      Stage.width / Stage.height,
      0.1,
      1e3
    )),
      this.group.add(this.camera),
      (this.playgroundLock = function (camera = Camera.instance()) {
        if (!Global.PLAYGROUND) return;
        Utils.getConstructorName(_this.parent).includes(
          Global.PLAYGROUND.split("/")[0]
        ) &&
          RenderManager.type == RenderManager.NORMAL &&
          camera.lock(_this.camera);
      }),
      (this.lock = function (camera = Camera.instance()) {
        if ("orthographic" == _type && !camera.worldCamera.isOrthographicCamera)
          return console.error(
            "You can't lock an orthographic camera to the main camera. Use an FXScene .setCamera"
          );
        RenderManager.type == RenderManager.NORMAL && camera.lock(_this.camera);
      }),
      (this.transition = function (
        time,
        ease,
        delay,
        camera = Camera.instance()
      ) {
        "object" == typeof delay && ((camera = delay), (delay = 0));
        let p = Promise.create();
        return (
          camera.transition(_this.camera, time, ease, delay || 0),
          _this.delayedCall((_) => p.resolve(), time + (delay || 0)),
          p
        );
      }),
      (this.manualTransition = function (camera = Camera.instance()) {
        return camera.manualTransition(_this.camera);
      }),
      (this.setFOV = function (fov) {
        "orthographic" !== _type &&
          fov != this.camera.fov &&
          ((this.camera.fov = fov), this.camera.updateProjectionMatrix());
      }),
      (this.getFOV = function () {
        return this.camera.fov;
      }),
      (this.useOrthographic = function (w, h) {
        "orthographic" !== _type &&
          (isNaN(w) || (this.width = w),
          isNaN(h) || (this.height = h),
          this.camera && this.group.remove(this.camera),
          (this.camera = new OrthographicCamera()),
          this.group.add(this.camera),
          (this.camera.position.z = 1),
          (_type = "orthographic"),
          resize());
      }),
      (this.usePerspective = function () {
        "perspective" !== _type &&
          (this.camera && this.group.remove(this.camera),
          (this.camera = new PerspectiveCamera()),
          this.group.add(this.camera),
          (_type = "perspective"),
          resize());
      }),
      (this.useCurve = function (curve) {
        return (_this.camera.curve = curve), this;
      }),
      _this.get("zoom", () => _this.camera.zoom),
      _this.set("zoom", (zoom) => {
        (_this.camera.zoom = zoom), _this.camera.updateProjectionMatrix();
      }),
      _this.get("near", () => _this.camera.near),
      _this.set("near", (near) => {
        (_this.camera.near = near), _this.camera.updateProjectionMatrix();
      }),
      _this.get("far", () => _this.camera.far),
      _this.set("far", (far) => {
        (_this.camera.far = far), _this.camera.updateProjectionMatrix();
      }),
      (_this.setProjectionProperties = function ({
        fov: fov,
        near: near,
        far: far,
        zoom: zoom,
      }) {
        let needsUpdate = !1;
        "orthographic" !== _type &&
          void 0 !== fov &&
          fov !== this.camera.fov &&
          ((this.camera.fov = fov), (needsUpdate = !0)),
          void 0 !== near &&
            near !== this.camera.near &&
            ((this.camera.near = near), (needsUpdate = !0)),
          void 0 !== far &&
            far !== this.camera.far &&
            ((this.camera.far = far), (needsUpdate = !0)),
          void 0 !== zoom &&
            zoom !== this.camera.zoom &&
            ((this.camera.zoom = zoom), (needsUpdate = !0)),
          needsUpdate && _this.camera.updateProjectionMatrix();
      }),
      (function init() {
        if (
          (_this.startRender((_) => {
            if (
              (_this.group.updateMatrixWorld(!0),
              _debugCamera && _debugCamera.visible)
            ) {
              Utils3D.decompose(_this.camera, _debugCamera);
              let viewportHeight,
                active = AppState.get("playground_camera_active");
              (viewportHeight = active.isOrthographicCamera
                ? (active.top - active.bottom) / active.zoom
                : Utils3D.getHeightFromCamera(
                    active,
                    _this.camera.position.distanceTo(active.position)
                  )),
                _debugCamera.scale.setScalar((0.025 * viewportHeight) / 0.1);
            }
          }),
          _this.onResize(resize),
          _input)
        ) {
          _this.prefix = _input.prefix;
          let cameraUIL = CameraUIL.add(_this, _group);
          cameraUIL.setLabel("Camera"), (_this.group._cameraUIL = cameraUIL);
        }
        Global.PLAYGROUND &&
          AppState.bind("playground_camera_active", (active) => {
            _this.group._parent &&
              (active
                ? (_debugCamera ||
                    (((_debugCamera = new Mesh(
                      new BoxGeometry(0.1, 0.1, 0.2),
                      new Shader("DebugCamera", {
                        uColor: { value: new Color("#ffffff") },
                        transparent: !0,
                        depthTest: !1,
                      })
                    )).renderOrder = 9999),
                    _this.delayedCall(
                      (_) => _this.group._parent.add(_debugCamera),
                      50
                    )),
                  (_debugCamera.visible = !0))
                : _debugCamera && (_debugCamera.visible = !1));
          });
      })();
  }),
  Class(function Camera(_worldCamera) {
    Inherit(this, Component);
    const _this = this;
    var _debug,
      _prevCamera,
      _lockCamera,
      _curve,
      _manual,
      _scheduleSlot,
      _calc = new Vector3(),
      _target = new Group(),
      _anim = { weight: 0, weight2: 0 },
      _center = new Vector3(),
      _cameraTarget = new Group(),
      _cameraTarget2 = new Group();
    function loop() {
      _scheduleSlot || render();
    }
    function render() {
      if (
        (_debug && (_debug.visible = !_debug.position.equals(_center)),
        _manual && (_anim.weight2 = _manual.value),
        (_anim.weight += (_anim.weight2 - _anim.weight) * _this.lerp),
        _prevCamera)
      ) {
        if (
          (_prevCamera.updateMatrixWorld(),
          _lockCamera.updateMatrixWorld(),
          _curve)
        ) {
          _curve.lerpPos ||
            (_curve.lerpPos = new Vector3().copy(
              _prevCamera.getWorldPosition()
            )),
            _curve.lerpOffset ||
              (_curve.lerpOffset = new Vector3()
                .copy(_curve.getPointAt(1))
                .multiplyScalar(-2)
                .add(_lockCamera.getWorldPosition()));
          let pos = _calc
            .copy(_curve.getPointAt(_anim.weight))
            .add(_curve.lerpOffset)
            .add(_lockCamera.getWorldPosition());
          _curve.lerpPos.lerp(pos, _curve.lerp || 1, !1),
            _target.position.copy(_curve.lerpPos),
            _anim.weight >= 1 &&
              ((_curve = _curve.lerpPos = _curve.lerpOffset = null),
              _this.onCurveComplete && _this.onCurveComplete());
        } else
          _target.position
            .copy(_prevCamera.getWorldPosition())
            .lerp(_lockCamera.getWorldPosition(), _anim.weight, !1);
        _target.quaternion
          .copy(_prevCamera.getWorldQuaternion())
          .slerp(_lockCamera.getWorldQuaternion(), _anim.weight, !1);
        let needsUpdate = !1,
          zoom = Math.mix(_prevCamera.zoom, _lockCamera.zoom, _anim.weight);
        _worldCamera.zoom !== zoom &&
          ((_worldCamera.zoom = zoom), (needsUpdate = !0));
        let fov =
          !_worldCamera.isOrthographicCamera &&
          Math.mix(_prevCamera.fov, _lockCamera.fov, _anim.weight);
        fov &&
          _worldCamera.fov !== fov &&
          ((_worldCamera.fov = fov), (needsUpdate = !0));
        let near = Math.mix(_prevCamera.near, _lockCamera.near, _anim.weight);
        _worldCamera.near !== near &&
          ((_worldCamera.near = near), (needsUpdate = !0));
        let far = Math.mix(_prevCamera.far, _lockCamera.far, _anim.weight);
        _worldCamera.far !== far &&
          ((_worldCamera.far = far), (needsUpdate = !0)),
          needsUpdate && _worldCamera.updateProjectionMatrix(),
          _cameraTarget.position.lerp(_target.position, _this.lerp2, !1),
          _cameraTarget.quaternion.slerp(_target.quaternion, _this.lerp2, !1);
      } else if (_lockCamera) {
        _lockCamera.updateMatrixWorld(),
          Utils3D.decompose(_lockCamera, _cameraTarget);
        let needsUpdate = !1;
        _lockCamera.zoom &&
          _worldCamera.zoom != _lockCamera.zoom &&
          ((_worldCamera.zoom = _lockCamera.zoom), (needsUpdate = !0)),
          _worldCamera.isOrthographicCamera ||
            _worldCamera.fov == _lockCamera.fov ||
            ((_worldCamera.fov = _lockCamera.fov), (needsUpdate = !0)),
          _worldCamera.near !== _lockCamera.near &&
            ((_worldCamera.near = _lockCamera.near), (needsUpdate = !0)),
          _worldCamera.far !== _lockCamera.far &&
            ((_worldCamera.far = _lockCamera.far), (needsUpdate = !0)),
          needsUpdate && _worldCamera.updateProjectionMatrix();
      }
      _cameraTarget2.position.lerp(_cameraTarget.position, _this.finalLerp, !1),
        _cameraTarget2.quaternion.slerp(
          _cameraTarget.quaternion,
          _this.finalLerp,
          !1
        ),
        _worldCamera.position.lerp(
          _cameraTarget2.position,
          _this.finalLerp,
          !1
        ),
        _worldCamera.quaternion.slerp(
          _cameraTarget2.quaternion,
          _this.finalLerp,
          !1
        ),
        _worldCamera.updateMatrixWorld(),
        _debug &&
          (_debug.position.copy(_worldCamera.position),
          _debug.quaternion.copy(_worldCamera.quaternion)),
        RenderManager.fire(_this);
    }
    (this.lerp = 1),
      (this.lerp2 = 1),
      (this.worldCamera = _worldCamera),
      (this.finalLerp = 1),
      (this.multiTween = !0),
      (function () {
        if (RenderManager.type != RenderManager.NORMAL)
          return (
            (_worldCamera = void 0), void (_this.worldCamera = _worldCamera)
          );
        (_worldCamera.controllingCamera = _this),
          _this.startRender(loop, RenderManager.AFTER_LOOPS);
      })(),
      (this.lock = function (camera, scheduleSlot) {
        camera instanceof Camera
          ? ((scheduleSlot = camera), (camera = camera.worldCamera))
          : camera.controllingCamera &&
            (scheduleSlot = camera.controllingCamera),
          (_lockCamera = camera),
          (_prevCamera = null),
          _worldCamera &&
            (_scheduleSlot && _this.stopRender(render, _scheduleSlot),
            (_scheduleSlot = scheduleSlot) &&
              _this.startRender(render, _scheduleSlot),
            _lockCamera.zoom && (_worldCamera.zoom = _lockCamera.zoom),
            _worldCamera.isOrthographicCamera ||
              (_worldCamera.fov = _lockCamera.fov),
            _worldCamera.updateProjectionMatrix(),
            render());
      }),
      (this.transition = function (
        camera,
        duration = 1e3,
        ease = "easeInOutCubic",
        scheduleSlotOrDelay
      ) {
        let delay, scheduleSlot;
        return (
          "number" == typeof scheduleSlotOrDelay
            ? (delay = scheduleSlotOrDelay)
            : scheduleSlotOrDelay && (scheduleSlot = scheduleSlotOrDelay),
          camera instanceof Camera
            ? ((scheduleSlot = camera), (camera = camera.worldCamera))
            : camera.controllingCamera &&
              (scheduleSlot = camera.controllingCamera),
          _curve && (_curve = _curve.lerpPos = _curve.lerpOffset = null),
          camera.curve && ((_curve = camera.curve).lerpPos = camera.lerpPos),
          _prevCamera === camera
            ? ((duration *= 0.5 * Math.smoothStep(0.5, 1, _anim.weight) + 0.5),
              (_anim.weight = 1 - _anim.weight))
            : (_anim.weight = 0),
          (_manual = void 0),
          scheduleSlot &&
            _worldCamera &&
            (_scheduleSlot && _this.stopRender(render, _scheduleSlot),
            (_scheduleSlot = scheduleSlot),
            _this.startRender(render, _scheduleSlot)),
          (_anim.weight2 = _anim.weight),
          (_prevCamera = _lockCamera),
          (_lockCamera = camera),
          tween(_anim, { weight2: 1 }, duration, ease, delay)
        );
      }),
      (this.manualTransition = function (camera) {
        return this.transition(camera).stop(), (_manual = { value: 0 });
      }),
      (this.setPrevCamera = function (camera) {
        _prevCamera = camera.camera || camera;
      }),
      this.get("worldCamera", (_) => _worldCamera),
      this.get("lockCamera", (_) => _lockCamera),
      this.set("debugScale", (s) => {
        _debug && _debug.scale.setScalar(s);
      }),
      (this.createLocal = function (camera) {
        return (
          camera ||
            ((camera = World.CAMERA.clone()),
            _this.onResize((_) => {
              (camera.aspect = Stage.width / Stage.height),
                camera.updateProjectionMatrix();
            })),
          new Camera(camera.camera || camera)
        );
      });
  }, "singleton"),
  Class(function GazeCamera(_input, _group) {
    Inherit(this, BaseCamera);
    const _this = this;
    var _strength = { v: 1 },
      _cacheObj = {},
      _move = new Vector3(),
      _position = (new Vector3(), new Vector3()),
      _wobble = new Vector3(),
      _rotation = 0,
      _wobbleAngle = Math.radians(Math.rand(0, 360)),
      _innerGroup = new Group(),
      _viewportFocusOffset = new Vector3(),
      _hasViewportFocusOffset = !1,
      _manualRender = !1,
      _quaternion = new Quaternion(),
      _useCustomMove = !1,
      _prevMoveX = 0;
    const V3_ZERO = new Vector3(0);
    function loop() {
      _hasViewportFocusOffset &&
        _this.camera.position.sub(_viewportFocusOffset);
      let moveX = 0,
        moveY = 0;
      _useCustomMove
        ? ((moveX = Math.clamp(_this.customMove.x, -1, 1)),
          (moveY = Math.clamp(_this.customMove.y, -1, 1)))
        : _this.useAccelerometer &&
          Mobile.Accelerometer &&
          Mobile.Accelerometer.connected
        ? ((moveX = Math.range(Mobile.Accelerometer.x, -2, 2, -1, 1, !0)),
          (moveY = 0))
        : ((moveX = Math.range(Mouse.x, 0, Stage.width, -1, 1, !0)),
          (moveY = Math.range(Mouse.y, 0, Stage.height, -1, 1, !0))),
        (_move.x =
          _this.position.x +
          moveX * _strength.v * _this.moveXY.x * _this.strength),
        (_move.y =
          _this.position.y +
          moveY * _strength.v * _this.moveXY.y * _this.strength);
      let deltaX = moveX - _prevMoveX;
      _prevMoveX = moveX;
      let rotateStrength = Math.range(
        Math.abs(deltaX) / Stage.width,
        0,
        0.02,
        0,
        1,
        !0
      );
      if (
        ((_rotation = Math.lerp(
          Math.radians(_this.deltaRotate) * rotateStrength * Math.sign(deltaX),
          _rotation,
          0.02 * _this.deltaLerp * _strength.v
        )),
        (_innerGroup.rotation.z = Math.lerp(
          _rotation,
          _innerGroup.rotation.z,
          0.07 * _this.deltaLerp
        )),
        (_move.z = _this.position.z),
        _position.lerp(_move, _this.lerpSpeed2),
        (_position.z += _this.zoomOffset),
        _this.camera.position.lerp(_position, _this.lerpSpeed),
        _this.camera.lookAt(_this.lookAt),
        (Math.abs(_this.cameraRotation.x) > Base3D.DIRTY_EPSILON ||
          Math.abs(_this.cameraRotation.y) > Base3D.DIRTY_EPSILON ||
          Math.abs(_this.cameraRotation.z) > Base3D.DIRTY_EPSILON) &&
          (_quaternion.setFromEuler(_this.cameraRotation),
          _this.camera.quaternion.multiply(_quaternion)),
        (function focusViewport() {
          let nextHasViewportFocusOffset =
            Math.abs(_this.viewportFocus.x) > 1e-4 ||
            Math.abs(_this.viewportFocus.y) > 1e-4;
          nextHasViewportFocusOffset !== _hasViewportFocusOffset &&
            (nextHasViewportFocusOffset || _viewportFocusOffset.setScalar(0),
            (_hasViewportFocusOffset = nextHasViewportFocusOffset));
          if (!_hasViewportFocusOffset) return;
          let localCamera = _cacheObj,
            camera = _this.camera;
          camera.matrixDirty && camera.updateMatrix();
          (localCamera.matrixWorld = camera.matrix),
            (localCamera.projectionMatrix = camera.projectionMatrix),
            _viewportFocusOffset.copy(_this.lookAt).project(localCamera),
            isFinite(_viewportFocusOffset.x) ||
              _viewportFocusOffset.set(0, 0, 0);
          (_viewportFocusOffset.x -= _this.viewportFocus.x),
            (_viewportFocusOffset.y -= _this.viewportFocus.y),
            _viewportFocusOffset.unproject(localCamera),
            _viewportFocusOffset.sub(_this.lookAt),
            _this.camera.position.add(_viewportFocusOffset);
        })(),
        _this.wobbleStrength > 0)
      ) {
        let t = Render.TIME;
        (_wobble.x =
          Math.cos(_wobbleAngle + t * (75e-5 * _this.wobbleSpeed)) *
          (_wobbleAngle + 200 * Math.sin(t * (95e-5 * _this.wobbleSpeed)))),
          (_wobble.y =
            Math.sin(
              Math.asin(
                Math.cos(_wobbleAngle + t * (85e-5 * _this.wobbleSpeed))
              )
            ) *
            (150 * Math.sin(_wobbleAngle + t * (75e-5 * _this.wobbleSpeed)))),
          (_wobble.x *=
            2 * Math.sin(_wobbleAngle + t * (75e-5 * _this.wobbleSpeed))),
          (_wobble.y *=
            1.75 * Math.cos(_wobbleAngle + t * (65e-5 * _this.wobbleSpeed))),
          (_wobble.x *=
            1.1 * Math.cos(_wobbleAngle + t * (75e-5 * _this.wobbleSpeed))),
          (_wobble.y *=
            1.15 * Math.sin(_wobbleAngle + t * (25e-5 * _this.wobbleSpeed))),
          (_wobble.z =
            Math.sin(_wobbleAngle + 0.0025 * _wobble.x) *
            (100 * _this.wobbleZ)),
          _wobble.multiplyScalar(0.001 * _this.wobbleStrength * _strength.v),
          _innerGroup.position.lerp(_wobble, 0.07),
          _this.flag("hasWobble", !0);
      } else _this.flag("hasWobble") && (_innerGroup.position.lerp(V3_ZERO, 0.07), _innerGroup.position.length() < 0.001 && (_innerGroup.position.set(0, 0, 0), _this.flag("hasWobble", !1)));
    }
    (this.strength = 1),
      (this.moveXY = new Vector2(4, 4)),
      (this.position = new (function Position() {
        Inherit(this, Component);
        var _x = 0,
          _y = 0,
          _z = 0;
        this.get("x", (_) => _x),
          this.get("y", (_) => _y),
          this.get("z", (_) => _z),
          this.set("x", (x) => {
            _x = x;
          }),
          this.set("y", (y) => {
            _y = y;
          }),
          this.set("z", (z) => {
            (_z = z),
              (_move.z = _z),
              _this.camera.position.copy(_move),
              _position.copy(_move);
          }),
          (this.set = function (x, y, z, noCopy) {
            (_x = x),
              (_y = y),
              (_z = z),
              (_move.z = z),
              noCopy || _this.camera.position.copy(_move),
              _position.copy(_move);
          }),
          (this.toArray = function () {
            return [_x, _y, _z];
          }),
          (this.fromArray = function (array) {
            (_x = array[0]),
              (_y = array[1]),
              (_z = array[2]),
              _move.set(_x, _y, _z),
              _this.camera.position.copy(_move),
              _position.copy(_move);
          }),
          (this.copy = function (vec) {
            (_x = vec.x),
              (_y = vec.y),
              (_z = vec.z),
              _move.set(_x, _y, _z),
              _this.camera.position.copy(_move),
              _position.copy(_move);
          });
      })()),
      (this.lerpSpeed = 0.08),
      (this.lerpSpeed2 = 1),
      (this.lookAt = new Vector3(0, 0, 0)),
      (this.cameraRotation = new Euler()),
      (this.viewportFocus = new Vector2(0, 0)),
      (this.deltaRotate = 0),
      (this.deltaLerp = 1),
      (this.wobbleSpeed = 1),
      (this.wobbleStrength = 0),
      (this.wobbleZ = 1),
      (this.zoomOffset = 0),
      (function () {
        if (_input) {
          _this.prefix = _input.prefix;
          let cameraUIL = CameraUIL.add(_this, _group);
          cameraUIL.setLabel("Camera"), (_this.group._cameraUIL = cameraUIL);
        }
        _this.startRender(loop),
          _innerGroup.add(_this.camera),
          _this.group.add(_innerGroup);
      })(),
      (this.orbit = function (time = 1e3, ease = "easeInOutSine") {
        return tween(_strength, { v: 1 }, time, ease);
      }),
      (this.still = function (time = 300, ease = "easeInOutSine") {
        return tween(_strength, { v: 0 }, time, ease);
      });
    var _v1 = new Vector3(),
      _v2 = new Vector3(),
      _v3 = new Vector3();
    (this.move = function (vec) {
      let moveDiff = _v1.subVectors(_move, _this.position),
        positionDiff = _v2.subVectors(_move, _position),
        cameraPosDiff = _v3.subVectors(_this.camera.position, _position);
      _this.position.set(vec.x, vec.y, vec.z, !0),
        _move.copy(vec).add(moveDiff),
        _position.copy(_move).add(positionDiff),
        _this.camera.position.copy(_position).add(cameraPosDiff);
    }),
      this.get("manualRender", () => _manualRender),
      this.set("manualRender", (value) => {
        (value = !!value) !== _manualRender &&
          ((_manualRender = value)
            ? _this.stopRender(loop)
            : _this.startRender(loop));
      }),
      this.get("useCustomMove", () => _useCustomMove),
      this.set("useCustomMove", (value) => {
        value
          ? ((_useCustomMove = !0),
            _this.customMove || (_this.customMove = new Vector2()))
          : (_useCustomMove = !1);
      }),
      (this.update = function () {
        _manualRender ||
          !Hydra.LOCAL ||
          _this.flag("manualRenderWarned") ||
          (console.warn(
            "Set manualRender to true if using GazeCamera.update()"
          ),
          _this.flag("manualRenderWarned", !0)),
          loop();
      });
  });
class Base3D {
  constructor() {
    (this.position = new Vector3D()),
      (this.rotation = new Euler()),
      (this.quaternion = new Quaternion()),
      (this.scale = new Vector3D(1, 1, 1)),
      (this._parent = null),
      (this.up = new Vector3(0, 1, 0)),
      (this.isObject3D = !0),
      (this.children = []),
      (this.childrenLength = 0),
      (this.modelViewMatrix = new Matrix4()),
      (this.normalMatrix = new Matrix3()),
      (this.matrix = new Matrix4()),
      (this.matrixWorld = new Matrix4()),
      (this.matrixAutoUpdate = !0),
      (this.matrixWorldNeedsUpdate = !1),
      (this.matrixDirty = !0),
      (this.decomposeDirty = !0),
      (this.visible = !0),
      (this.hidden = !1),
      (this.castShadow = !1),
      (this.frustumCulled = !0),
      (this.occlusionCulled = !1),
      (this._renderOrder = 0),
      (this.worldPos = new Vector3()),
      (this.worldQuat = new Quaternion());
    const _this = this;
    this.quaternion.onChange((_) => {
      (_this.matrixDirty = !0),
        (_this.decomposeDirty = !0),
        _this.onMatrixDirty && _this.onMatrixDirty(),
        _this.rotation.setFromQuaternion(_this.quaternion, void 0, !1);
    }),
      this.rotation.onChange((_) => {
        (_this.matrixDirty = !0),
          (_this.decomposeDirty = !0),
          _this.onMatrixDirty && _this.onMatrixDirty(),
          _this.quaternion.setFromEuler(_this.rotation, !1);
      }),
      this.scale.onChange((_) => {
        (_this.matrixDirty = !0),
          (_this.decomposeDirty = !0),
          _this.onMatrixDirty && _this.onMatrixDirty();
      }),
      this.position.onChange((_) => {
        (_this.matrixDirty = !0),
          (_this.decomposeDirty = !0),
          _this.onMatrixDirty && _this.onMatrixDirty();
      });
  }
  get renderOrder() {
    return this._renderOrder;
  }
  set renderOrder(value) {
    this._renderOrder = value;
    let p = this._parent;
    for (; p; )
      p instanceof Scene && (p.displayNeedsUpdate = !0), (p = p._parent);
    for (let i = 0; i < this.children.length; i++)
      this.children[i].renderOrder += value;
  }
  applyMatrix(matrix) {
    return (
      this.matrix.multiplyMatrices(matrix, this.matrix),
      this.matrix.decompose(this.position, this.quaternion, this.scale),
      this
    );
  }
  applyQuaternion(q) {
    return this.quaternion.premultiply(q), this;
  }
  setRotationFromAxisAngle(axis, angle) {
    this.quaternion.setFromAxisAngle(axis, angle);
  }
  setRotationFromMatrix(m) {
    this.quaternion.setFromRotationMatrix(m);
  }
  setRotationFromQuaternion(q) {
    this.quaternion.copy(q);
  }
  localToWorld(v) {
    return v.applyMatrix4(this.matrixWorld);
  }
  worldToLocal(v) {
    let m1 = this.M1 || new Matrix4();
    return (this.M1 = m1), v.applyMatrix4(m1.getInverse(this.matrixWorld));
  }
  lookAt(x, y, z) {
    let m1 = this.M1 || new Matrix4();
    this.M1 = m1;
    let v = this.V1 || new Vector3();
    (this.V1 = v),
      x.isVector3 ? v.copy(x) : v.set(x, y, z),
      this.isCamera
        ? m1.lookAt(this.position, v, this.up)
        : m1.lookAt(v, this.position, this.up),
      this.quaternion.setFromRotationMatrix(m1);
  }
  add(object) {
    if (arguments.length > 1) {
      for (let i = 0; i < arguments.length; i++) this.add(arguments[i]);
      return this;
    }
    if (object === this) return this;
    if (
      (object && object.isObject3D
        ? (null !== object._parent && object._parent.remove(object),
          (object._parent = this),
          this.children.push(object),
          (this.childrenLength = this.children.length))
        : console.error("Object is not instance of Object3D", object),
      this.isScene)
    )
      this.displayNeedsUpdate = !0;
    else {
      let p = this._parent;
      for (; p; )
        p instanceof Scene && (p.displayNeedsUpdate = !0), (p = p._parent);
    }
    return this;
  }
  attach(object) {
    this.updateMatrixWorld(!0);
    let m1 = this.M1 || new Matrix4();
    this.M1 = m1;
    const worldInverse = this.M1.getInverse(this.matrixWorld);
    null !== object._parent &&
      (object._parent.updateMatrixWorld(!0),
      worldInverse.multiply(object._parent.matrixWorld)),
      object.applyMatrix(worldInverse),
      this.add(object),
      object.updateMatrixWorld(!0);
  }
  remove(object) {
    if (arguments.length > 1) {
      for (let i = 0; i < arguments.length; i++) this.remove(arguments[i]);
      return this;
    }
    if (this.isScene) this.displayNeedsUpdate = !0;
    else {
      let p = this._parent;
      for (; p; )
        p instanceof Scene && (p.displayNeedsUpdate = !0), (p = p._parent);
    }
    this.children.remove(object), (this.childrenLength = this.children.length);
  }
  getWorldPosition(target) {
    let v = this.V1 || new Vector3();
    return (
      (this.V1 = v),
      target || (target = v),
      this.updateMatrixWorld(),
      target.setFromMatrixPosition(this.matrixWorld)
    );
  }
  getWorldScale(target) {
    let v = this.V1S || new Vector3();
    this.V1S = v;
    let v2 = this.V12 || new Vector3();
    this.V2 = v2;
    let q = this.Q1 || new Quaternion();
    return (
      (this.Q1 = q),
      target || (target = v2),
      this.updateMatrixWorld(),
      this.matrixWorld.decompose(v, q, target),
      target
    );
  }
  getWorldQuaternion(target) {
    let v = this.V1Q || new Vector3();
    this.V1Q = v;
    let q = this.Q1 || new Quaternion();
    return (
      (this.Q1 = q),
      target || (target = q),
      this.updateMatrixWorld(),
      this.matrixWorld.decompose(v, target, v),
      target
    );
  }
  traverse(callback) {
    callback(this);
    let children = this.children;
    for (let i = 0; i < children.length; i++) children[i].traverse(callback);
  }
  updateMatrix() {
    !1 !== this.matrixAutoUpdate &&
      (this.matrix.compose(this.position, this.quaternion, this.scale),
      (this.matrixWorldNeedsUpdate = !0));
  }
  updateMatrixWorld(force) {
    if (!1 === this.matrixAutoUpdate) return;
    if (!force && !this.determineVisible()) return;
    (this.determineDirty() || force) &&
      !0 === this.matrixAutoUpdate &&
      this.updateMatrix(),
      (!0 !== this.matrixWorldNeedsUpdate && !0 !== force) ||
        (null === this._parent || this.determineNoTransform()
          ? this.matrixWorld.copy(this.matrix)
          : (this.matrixWorld.multiplyMatrices(
              this._parent.matrixWorld,
              this.matrix
            ),
            RenderStats.active && RenderStats.update("updateMatrixWorld")),
        (this.decomposeDirty = !0),
        (this.matrixWorldNeedsUpdate = !1));
    const children = this.children;
    for (let i = this.childrenLength - 1; i > -1; i--)
      children[i].updateMatrixWorld(force);
    this.matrixDirty = !1;
  }
  clone(recursive) {
    new this.constructor().copy(this, recursive);
  }
  copy(source, recursive) {
    if (
      ((this.name = source.name),
      this.up.copy(source.up),
      this.position.copy(source.position),
      this.quaternion.copy(source.quaternion),
      this.scale.copy(source.scale),
      this.matrix.copy(source.matrix),
      this.matrixWorld.copy(source.matrixWorld),
      (this.matrixAutoUpdate = source.matrixAutoUpdate),
      (this.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate),
      (this.visible = source.visible),
      (this.castShadow = source.castShadow),
      (this.receiveShadow = source.receiveShadow),
      (this.frustumCulled = source.frustumCulled),
      (this.renderOrder = source.renderOrder),
      !0 === recursive)
    )
      for (let i = 0; i < source.children.length; i++) {
        let child = source.children[i];
        this.add(child.clone());
      }
    return this;
  }
  render() {}
  determineVisible() {
    if (!this.visible || this.hidden) return !1;
    let p = this._parent;
    for (; p; ) {
      if (!p.visible || p.hidden) return !1;
      p = p._parent;
    }
    return !0;
  }
  determineDirty() {
    let p = this._parent;
    for (; p; ) {
      if (p.matrixDirty) return !0;
      p = p._parent;
    }
    return this.matrixDirty;
  }
  determineNoTransform() {
    return this._parent
      ? this._parent.determineNoTransform() && this.matrix.isIdentity()
      : this.matrix.isIdentity();
  }
  translateX(distance) {
    this.xAxis || (this.xAxis = new Vector3(1, 0, 0)),
      this.translateOnAxis(this.xAxis, distance);
  }
  translateY(distance) {
    this.yAxis || (this.yAxis = new Vector3(0, 1, 0)),
      this.translateOnAxis(this.yAxis, distance);
  }
  translateZ(distance) {
    this.zAxis || (this.zAxis = new Vector3(0, 0, 1)),
      this.translateOnAxis(this.zAxis, distance);
  }
  translateOnAxis(axis, distance) {
    let v = this.V1 || new Vector3();
    return (
      (this.V1 = v),
      v.copy(axis).applyQuaternion(this.quaternion),
      this.position.add(v.multiplyScalar(distance)),
      this
    );
  }
  upload() {
    this.shader &&
      (this.shader.upload(this, this.geometry),
      this.shader.shadow && this.shader.shadow.upload(this, this.geometry)),
      this.geometry && this.geometry.upload(this, this.shader);
  }
  destroy() {
    this.geometry && this.geometry.destroy && this.geometry.destroy(this),
      this.shader && this.shader.destroy && this.shader.destroy(this),
      this.hitDestroy && this.hitDestroy(),
      this._gl && this._gl.ubo && this._gl.ubo.destroy(),
      this._gl && this._gl.vao && this._gl.vao.destroy(),
      this._gl && (this._gl = null),
      this._parent && this._parent.remove(this),
      this.parent &&
        this.parent.__destroyChild &&
        this.parent.__destroyChild(this.__id);
  }
}
(Base3D.DIRTY_EPSILON = 1e-4),
  Class(
    function Renderer(_params = {}) {
      Inherit(this, Component);
      const _this = this;
      var _canvas,
        _gl,
        _width,
        _height,
        _anisotropy,
        _clearColor,
        _projScreenMatrix,
        _frustum,
        _ubo,
        _dpr = 1,
        _resolution = new Vector2(),
        _m0 = new Matrix4(),
        _m1 = new Matrix4(),
        _time = { value: 0 },
        _stencilActive = !1;
      function initCameraUBO(camera) {
        (camera._ubo = new UBO(0, _gl)),
          camera._ubo.push({ value: camera.projectionMatrix }),
          camera._ubo.push({ value: camera.matrixWorldInverse }),
          camera._ubo.push({ value: camera.worldPos }),
          camera._ubo.push({ value: camera.worldQuat }),
          camera._ubo.push({ value: _resolution }),
          camera._ubo.push(_time),
          camera._ubo.push(Render.timeScaleUniform),
          camera._ubo.upload();
      }
      function sortFrontToBack(array, sortOrder, camera) {
        for (let i = array.length - 1; i > -1; i--) {
          let obj = array[i];
          obj.__sortVec || (obj.__sortVec = new Vector3()),
            sortOrder == Scene.FRONT_TO_BACK_BOUNDING &&
            obj.geometry &&
            obj.geometry.boundingSphere
              ? obj.__sortVec.copy(obj.geometry.boundingSphere.center)
              : obj.__sortVec.setFromMatrixPosition(camera.modelViewMatrix);
        }
        array.sort((a, b) => b.__sortVec.z - a.__sortVec.z);
      }
      function projectObject(object, camera, scene) {
        if (
          (object.isOcclusionMesh &&
            scene.displayNeedsUpdate &&
            scene.toRender[0].push(object),
          object.doNotProject)
        )
          return;
        let isVisible = !1;
        if (void 0 !== object.shader) {
          let visible =
            object.determineVisible() &&
            object.shader.visible &&
            !object.shader.neverRender &&
            !object.hidden;
          visible &&
            (object.modelViewMatrix.multiplyMatrices(
              camera.matrixWorldInverse,
              object.matrixWorld
            ),
            object.normalMatrix.getNormalMatrix(object.modelViewMatrix),
            null !== object._occlusionMesh &&
              object.isMesh &&
              this.useOcclusionQuery &&
              (object.updateOcclusionMesh(),
              object._occlusionMesh.matrixWorld.copy(object.matrixWorld),
              object._occlusionMesh.normalMatrix.copy(object.normalMatrix),
              object._occlusionMesh.modelViewMatrix.copy(
                object.modelViewMatrix
              ))),
            (isVisible = visible),
            (scene.displayNeedsUpdate ||
              (object.shader.transparent &&
                !scene.disableAutoSort &&
                visible)) &&
              object.getWorldPosition(object.worldPos),
            scene.displayNeedsUpdate &&
              scene.toRender[object.shader.transparent ? 1 : 0].push(object);
        } else isVisible = object.visible && !object.hidden;
        if (isVisible || scene.displayNeedsUpdate)
          for (let i = object.childrenLength - 1; i > -1; i--)
            projectObject(object.children[i], camera, scene);
      }
      function attachSceneUniforms(object, scene, camera) {
        if (
          (Shader.renderer.appendUniform(
            object.shader,
            "normalMatrix",
            object.normalMatrix
          ),
          Shader.renderer.appendUniform(
            object.shader,
            "modelMatrix",
            object.matrixWorld
          ),
          Shader.renderer.appendUniform(
            object.shader,
            "modelViewMatrix",
            object.modelViewMatrix
          ),
          _ubo
            ? camera._ubo.bind(object.shader._gl.program, "global")
            : (Shader.renderer.appendUniform(
                object.shader,
                "projectionMatrix",
                camera.projectionMatrix
              ),
              Shader.renderer.appendUniform(
                object.shader,
                "viewMatrix",
                camera.matrixWorldInverse
              ),
              Shader.renderer.appendUniform(
                object.shader,
                "cameraPosition",
                camera.worldPos
              ),
              Shader.renderer.appendUniform(
                object.shader,
                "cameraQuaternion",
                camera.worldQuat
              ),
              Shader.renderer.appendUniform(
                object.shader,
                "resolution",
                _resolution
              ),
              Shader.renderer.appendUniform(object.shader, "time", _time.value),
              Shader.renderer.appendUniform(
                object.shader,
                "timeScale",
                Render.timeScaleUniform.value
              )),
          _this.shadows &&
            object.shader.receiveShadow &&
            !_this.overridePreventShadows)
        ) {
          let lights = Lighting.getShadowLights();
          object._gl || (object._gl = {}),
            object._gl.shadowData ||
              (object._gl.shadowData = {
                combined: new Float32Array(16 * lights.length),
              });
          for (let i = 0; i < lights.length; i++) {
            let light = lights[i];
            _m1.multiplyMatrices(
              light.shadow.camera.matrixWorldInverse,
              object.matrixWorld
            ),
              _m0.multiplyMatrices(light.shadow.camera.projectionMatrix, _m1),
              _m0.toArray(object._gl.shadowData.combined, 16 * i);
          }
          scene._shadowData &&
            scene._shadowData.count &&
            ((object.shader.uniforms.shadowMap.value =
              scene._shadowData[
                _this.overridePreventShadows ? "emptyMaps" : "maps"
              ]),
            Shader.renderer.appendUniform(
              object.shader,
              "shadowMatrix",
              object._gl.shadowData.combined,
              "matrix"
            ),
            Shader.renderer.appendUniform(
              object.shader,
              "shadowLightPos",
              scene._shadowData.pos,
              "vec3"
            ),
            Shader.renderer.appendUniform(
              object.shader,
              "shadowSize",
              scene._shadowData.size,
              "float"
            ));
        }
      }
      function attachShadowUniforms(object, scene, light) {
        light._mvm || (light._mvm = new Matrix4()),
          light._nm || (light._nm = new Matrix3()),
          light._mvm.multiplyMatrices(
            light.shadow.camera.matrixWorldInverse,
            object.matrixWorld
          ),
          light._nm.getNormalMatrix(object.modelViewMatrix),
          Shader.renderer.appendUniform(
            object.shader.shadow,
            "normalMatrix",
            light._nm
          ),
          Shader.renderer.appendUniform(
            object.shader.shadow,
            "modelMatrix",
            object.matrixWorld
          ),
          Shader.renderer.appendUniform(
            object.shader.shadow,
            "modelViewMatrix",
            light._mvm
          ),
          _ubo
            ? light.shadow.camera._ubo.bind(object.shader._gl.program, "global")
            : (Shader.renderer.appendUniform(
                object.shader.shadow,
                "projectionMatrix",
                light.shadow.camera.projectionMatrix
              ),
              Shader.renderer.appendUniform(
                object.shader.shadow,
                "viewMatrix",
                light.shadow.camera.matrixWorldInverse
              ));
      }
      function loop(t, dt) {
        _time.value += 0.001 * dt;
      }
      function render(scene, camera, rt) {
        rt && rt.width
          ? (_resolution.set(rt.width, rt.height),
            rt.multisample
              ? RenderTarget.renderer.bind(rt._rtMultisample)
              : RenderTarget.renderer.bind(rt))
          : (Renderer.overrideViewport ||
              (_gl.viewport(0, 0, _width * _dpr, _height * _dpr),
              _resolution.set(_canvas.width, _canvas.height)),
            _this.autoClear &&
              (_gl.clearColor(
                Renderer.CLEAR[0],
                Renderer.CLEAR[1],
                Renderer.CLEAR[2],
                Renderer.CLEAR[3]
              ),
              _gl.clear(_gl.COLOR_BUFFER_BIT | _gl.DEPTH_BUFFER_BIT))),
          camera.getWorldPosition(camera.worldPos),
          camera.getWorldQuaternion(camera.worldQuat),
          _frustum.setFromCamera(camera),
          _ubo && (camera._ubo ? camera._ubo.update() : initCameraUBO(camera));
        for (let l = 0; l < 2; l++) {
          let len = scene.toRender[l].length;
          for (let i = 0; i < len; i++) {
            let object = scene.toRender[l][i];
            if (
              (object.onBeforeRender && object.onBeforeRender(),
              (object._drawing = !1),
              object.determineVisible() &&
                object.shader.visible &&
                !object.shader.neverRender &&
                !object.neverRender &&
                (_this.useOcclusionQuery &&
                  object._occlusionGroup &&
                  (object._occlusionGroup.updateOcclusionBoundingBox(),
                  object._occlusionGroup.updateOcclusionVisibility(
                    object?._gl?.occluded
                  )),
                _this.useOcclusionQuery &&
                  object.isOcclusionMesh &&
                  _this.type == Renderer.WEBGL2 &&
                  object._queryMesh.occlusionCulled &&
                  (object.shader.draw(object, object.geometry),
                  attachSceneUniforms(object, scene, camera),
                  object.geometry.draw(object, object.shader, !0)),
                !1 === object.frustumCulled ||
                  !0 === _frustum.intersectsObject(object)))
            ) {
              if (
                ((object._drawing = !0),
                object.shader.nullRender ||
                  object?._gl?.occluded ||
                  object.isOcclusionMesh)
              )
                continue;
              let doubleSideTransparency =
                object.shader.side === Shader.DOUBLE_SIDE_TRANSPARENCY;
              doubleSideTransparency && (object.shader.side = Shader.BACK_SIDE),
                object.shader.draw(object, object.geometry),
                attachSceneUniforms(object, scene, camera),
                object.geometry.draw(object, object.shader),
                doubleSideTransparency &&
                  ((object.shader.side = Shader.FRONT_SIDE),
                  object.shader.draw(object, object.geometry),
                  attachSceneUniforms(object, scene, camera),
                  object.geometry.draw(object, object.shader),
                  (object.shader.side = Shader.DOUBLE_SIDE_TRANSPARENCY));
            }
          }
        }
        rt &&
          rt.width &&
          (rt.texture.generateMipmaps &&
            (_gl.bindTexture(_gl.TEXTURE_2D, rt.texture._gl),
            _gl.generateMipmap(_gl.TEXTURE_2D),
            _gl.bindTexture(_gl.TEXTURE_2D, null)),
          rt.multisample
            ? (_this.blit(rt._rtMultisample, rt),
              RenderTarget.renderer.unbind(rt._rtMultisample))
            : RenderTarget.renderer.unbind(rt));
      }
      (this.autoClear = !0),
        (this.shadows = Renderer.SHADOWS_MED),
        (this.useOcclusionQuery = !1),
        (Renderer.instance = _this),
        (Renderer.CLEAR = [0, 0, 0, 1]),
        (function initContext() {
          let contextAttributes = {
            antialias: void 0 !== _params.antialias && _params.antialias,
            powerPreference: _params.powerPreference,
            preserveDrawingBuffer: _params.preserveDrawingBuffer,
            xrCompatible: _params.xrCompatible,
            alpha: void 0 !== _params.alpha && _params.alpha,
            stencil: _params.stencil,
          };
          if (
            ((_this.stencil = !!_params.stencil),
            (_canvas = _params.canvas || document.createElement("canvas")),
            _params.gl
              ? ((_gl = _params.gl),
                (_this.type = Device.graphics.webgl.version.includes([
                  "webgl 2",
                  "webgl2",
                ])
                  ? Renderer.WEBGL2
                  : Renderer.WEBGL1))
              : Device.graphics.webgl
              ? ["webgl2", "webgl", "experimental-webgl"].forEach((name) => {
                  _gl ||
                    ("webgl2" == name && _params.forceWebGL1) ||
                    ((_gl = _canvas.getContext(name, contextAttributes)),
                    (_this.type =
                      _gl && "webgl2" == name
                        ? Renderer.WEBGL2
                        : Renderer.WEBGL1));
                })
              : ((_gl = new NoGLPolyfill()), (_this.type = Renderer.WEBGL2)),
            !_gl)
          )
            throw "Error! Could not create WebGL context";
          (_this.domElement = _canvas),
            (_canvas.style.background = "black"),
            (Renderer.type = _this.type),
            (Renderer.context = _this.context = _gl);
        })(),
        (function setExtensions() {
          (_this.extensions = {}),
            _this.type != Renderer.WEBGL2
              ? ((_this.extensions.VAO = _gl.getExtension(
                  "OES_vertex_array_object"
                )),
                (_this.extensions.instancedArrays = _gl.getExtension(
                  "ANGLE_instanced_arrays"
                )),
                (_this.extensions.standardDerivatives = _gl.getExtension(
                  "OES_standard_derivatives"
                )),
                (_this.extensions.elementIndexUint = _gl.getExtension(
                  "OES_element_index_uint"
                )),
                (_this.extensions.depthTextures = _gl.getExtension(
                  "WEBGL_depth_texture"
                )),
                (_this.extensions.drawBuffers =
                  _gl.getExtension("WEBGL_draw_buffers")),
                (_this.extensions.halfFloat = _gl.getExtension(
                  "OES_texture_half_float"
                )),
                (_this.extensions.float =
                  _gl.getExtension("OES_texture_float")),
                (_this.extensions.colorBufferFloat = _gl.getExtension(
                  "WEBGL_color_buffer_float"
                )),
                (_this.extensions.lod = _gl.getExtension(
                  "EXT_shader_texture_lod"
                )),
                (_this.extensions.minMax =
                  _gl.getExtension("EXT_blend_minmax")))
              : ((_this.extensions.disjointTimerQuery = _gl.getExtension(
                  "EXT_disjoint_timer_query_webgl2"
                )),
                (_this.extensions.colorBufferFloat = _gl.getExtension(
                  "EXT_color_buffer_float"
                ))),
            (_this.extensions.filterFloat = _gl.getExtension(
              "OES_texture_float_linear"
            )),
            (_this.extensions.anisotropy =
              _gl.getExtension("EXT_texture_filter_anisotropic") ||
              _gl.getExtension("WEBKIT_EXT_texture_filter_anisotropic")),
            (_this.extensions.astc = _gl.getExtension(
              "WEBGL_compressed_texture_astc"
            )),
            (_this.extensions.atc = _gl.getExtension(
              "WEBGL_compressed_texture_atc"
            )),
            (_this.extensions.etc = _gl.getExtension(
              "WEBGL_compressed_texture_etc"
            )),
            (_this.extensions.etc1 = _gl.getExtension(
              "WEBGL_compressed_texture_etc1"
            )),
            (_this.extensions.pvrtc =
              _gl.getExtension("WEBGL_compressed_texture_pvrtc") ||
              _gl.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc")),
            (_this.extensions.s3tc =
              _gl.getExtension("WEBGL_compressed_texture_s3tc") ||
              _gl.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc")),
            (_this.extensions.bptc = _gl.getExtension(
              "EXT_texture_compression_bptc"
            )),
            (_this.extensions.s3tc_srgb = _gl.getExtension(
              "WEBGL_compressed_texture_s3tc_srgb"
            )),
            (Renderer.extensions = _this.extensions);
        })(),
        (function initRenderers() {
          (Geometry.renderer = new GeometryRendererWebGL(_gl)),
            (Texture.renderer = new TextureRendererWebGL(_gl)),
            (Shader.renderer = new ShaderRendererWebGL(_gl)),
            (RenderTarget.renderer = new FBORendererWebGL(_gl));
        })(),
        (function initMath() {
          (_projScreenMatrix = new Matrix4()),
            new Vector3(),
            (_frustum = new Frustum());
        })(),
        (function initUBO() {
          _this.type == Renderer.WEBGL2 && (_ubo = !0), (Renderer.UBO = _ubo);
        })(),
        _this.startRender(loop),
        (this.render = function (scene, camera, rt, forceToScreen) {
          scene.displayNeedsUpdate &&
            ((scene.toRender[0].length = 0), (scene.toRender[1].length = 0)),
            _this.modifyCameraBeforeRender &&
              (camera.renderCamera || (camera.renderCamera = camera.clone()),
              camera.renderCamera.copy(camera),
              (camera = camera.renderCamera),
              _this.modifyCameraBeforeRender(camera)),
            scene.updateMatrixWorld(),
            camera.parent || camera.updateMatrixWorld(),
            projectObject(scene, camera, scene),
            (scene.displayNeedsUpdate ||
              scene.opaqueSortOrder == Scene.FRONT_TO_BACK) &&
              (function sortOpaque(array, sortOrder, camera) {
                for (let i = array.length - 1; i > -1; i--) {
                  let obj = array[i];
                  obj.shader._gl || obj.shader.upload();
                }
                sortOrder == Scene.FRONT_TO_BACK
                  ? sortFrontToBack(array, sortOrder, camera)
                  : array.sort((a, b) => {
                      if (a.renderOrder !== b.renderOrder)
                        return a.renderOrder - b.renderOrder;
                      let aid = a.shader._gl._id,
                        bid = b.shader._gl._id;
                      return aid !== bid ? aid - bid : a.id - b.id;
                    });
              })(scene.toRender[0], scene.opaqueSortOrder, camera),
            (scene.displayNeedsUpdate ||
              (scene.toRender[1].length && !scene.disableAutoSort)) &&
              (function sortTransparent(array, sortOrder, camera) {
                RenderStats.update("SortTransparent", array.length),
                  sortOrder == Scene.FRONT_TO_BACK ||
                  sortOrder == Scene.FRONT_TO_BACK_BOUNDING
                    ? sortFrontToBack(array, sortOrder, camera)
                    : array.sort((a, b) =>
                        a.renderOrder !== b.renderOrder
                          ? a.renderOrder - b.renderOrder
                          : a.worldPos.z !== b.worldPos.z
                          ? a.worldPos.z - b.worldPos.z
                          : a.id - b.id
                      );
              })(scene.toRender[1], scene.transparentSortOrder, camera),
            _this.shadows &&
              !_this.overridePreventShadows &&
              !_this.pauseShadowRendering &&
              scene.hasShadowLight &&
              (function renderShadows(scene, camera) {
                let render = (light, lightIndex) => {
                    RenderTarget.renderer.bind(light.shadow.rt),
                      RenderStats.update("ShadowLights"),
                      light.shadow.camera.updateMatrixWorld(),
                      camera.getWorldPosition(camera.worldPos),
                      _frustum.setFromCamera(camera),
                      _ubo &&
                        (light.shadow.camera._ubo
                          ? light.shadow.camera._ubo.update()
                          : initCameraUBO(light.shadow.camera));
                    for (let l = 0; l < 2; l++)
                      for (let i = 0; i < scene.toRender[l].length; i++) {
                        let object = scene.toRender[l][i];
                        (object.onBeforeRenderShadow &&
                          object.onBeforeRenderShadow(light, lightIndex)) ||
                          (!0 === object.castShadow &&
                            object.determineVisible() &&
                            object.shader.visible &&
                            !object.shader.neverRender &&
                            ((!1 !== object.frustumCulled &&
                              !0 !== _frustum.intersectsObject(object)) ||
                              (object.shader.shadow ||
                                Lighting.initShadowShader(object),
                              object.shader.shadow.draw(
                                object,
                                object.geometry
                              ),
                              attachShadowUniforms(object, 0, light),
                              object.geometry.draw(
                                object,
                                object.shader.shadow
                              ),
                              _ubo && light.shadow.camera._ubo.unbind(),
                              RenderStats.update("ShadowMesh"))));
                      }
                    RenderTarget.renderer.unbind(light.shadow.rt);
                  },
                  lights = Lighting.getShadowLights();
                scene._shadowData ||
                  (scene._shadowData = {
                    maps: [],
                    emptyMaps: [],
                    size: new Float32Array(lights.length),
                    pos: new Float32Array(3 * lights.length),
                    count: lights.length,
                  }),
                  scene._shadowData.count != lights.length &&
                    ((scene._shadowData.size = new Float32Array(lights.length)),
                    (scene._shadowData.pos = new Float32Array(
                      3 * lights.length
                    )),
                    (scene._shadowData.count = lights.length));
                for (let i = 0; i < lights.length; i++) {
                  let light = lights[i];
                  light.prepareRender(),
                    (scene._shadowData.maps[i] = light.shadow.rt.depth),
                    (scene._shadowData.emptyMaps[i] =
                      Utils3D.getEmptyTexture()),
                    (scene._shadowData.size[i] = light.shadow.size),
                    light.position.toArray(scene._shadowData.pos, 3 * i);
                }
                for (let i = 0; i < lights.length; i++) {
                  let light = lights[i];
                  !light.shadow.frozen &&
                    light.determineVisible() &&
                    render(light, i);
                }
              })(scene, camera),
            (rt && !rt.vrRT) || !_this.vrRenderingPath || forceToScreen
              ? rt || !_this.arRenderingPath || forceToScreen
                ? render(scene, camera, rt)
                : _this.arRenderingPath(render, scene, camera)
              : _this.vrRenderingPath(
                  scene,
                  camera,
                  _projScreenMatrix,
                  _frustum,
                  attachSceneUniforms,
                  rt
                ),
            (scene.displayNeedsUpdate = !1),
            Shader.renderer.resetState();
        }),
        (this.renderSingle = function (object, camera, rt) {
          rt
            ? (_resolution.set(rt.width, rt.height),
              rt.multisample
                ? RenderTarget.renderer.bind(rt._rtMultisample)
                : RenderTarget.renderer.bind(rt))
            : (Renderer.overrideViewport ||
                (_gl.viewport(0, 0, _width * _dpr, _height * _dpr),
                _resolution.set(_canvas.width, _canvas.height)),
              _this.autoClear &&
                (_gl.clearColor(
                  Renderer.CLEAR[0],
                  Renderer.CLEAR[1],
                  Renderer.CLEAR[2],
                  Renderer.CLEAR[3]
                ),
                _gl.clear(_gl.COLOR_BUFFER_BIT | _gl.DEPTH_BUFFER_BIT))),
            camera.getWorldPosition(camera.worldPos),
            camera.getWorldQuaternion(camera.worldQuat),
            object.modelViewMatrix.multiplyMatrices(
              camera.matrixWorldInverse,
              object.matrixWorld
            ),
            object.normalMatrix.getNormalMatrix(object.modelViewMatrix),
            object.getWorldPosition(object.worldPos),
            _ubo &&
              (camera._ubo
                ? camera.pauseUBO || camera._ubo.update()
                : initCameraUBO(camera));
          let doubleSideTransparency =
            object.shader.side === Shader.DOUBLE_SIDE_TRANSPARENCY;
          doubleSideTransparency &&
            ((object.shader.side = Shader.BACK_SIDE),
            object.shader._renderFrontFirst &&
              (object.shader.side = Shader.FRONT_SIDE)),
            object.shader.draw(object, object.geometry),
            object.noMatrices ||
              (Shader.renderer.appendUniform(
                object.shader,
                "normalMatrix",
                object.normalMatrix
              ),
              Shader.renderer.appendUniform(
                object.shader,
                "modelMatrix",
                object.matrixWorld
              ),
              Shader.renderer.appendUniform(
                object.shader,
                "modelViewMatrix",
                object.modelViewMatrix
              )),
            _ubo
              ? camera._ubo.bind(object.shader._gl.program, "global")
              : (Shader.renderer.appendUniform(
                  object.shader,
                  "projectionMatrix",
                  camera.projectionMatrix
                ),
                Shader.renderer.appendUniform(
                  object.shader,
                  "viewMatrix",
                  camera.matrixWorldInverse
                ),
                Shader.renderer.appendUniform(
                  object.shader,
                  "cameraPosition",
                  camera.worldPos
                ),
                Shader.renderer.appendUniform(
                  object.shader,
                  "cameraQuaternion",
                  camera.worldQuat
                ),
                Shader.renderer.appendUniform(
                  object.shader,
                  "resolution",
                  _resolution
                ),
                Shader.renderer.appendUniform(
                  object.shader,
                  "time",
                  _time.value
                ),
                Shader.renderer.appendUniform(
                  object.shader,
                  "timeScale",
                  Render.timeScaleUniform.value
                )),
            object.geometry.draw(object, object.shader),
            doubleSideTransparency &&
              ((object.shader.side = Shader.FRONT_SIDE),
              object.shader._renderFrontFirst &&
                (object.shader.side = Shader.BACK_SIDE),
              object.shader.draw(object, object.geometry),
              object.geometry.draw(object, object.shader),
              (object.shader.side = Shader.DOUBLE_SIDE_TRANSPARENCY)),
            _ubo && camera._ubo.unbind(),
            rt &&
              (rt.texture.generateMipmaps &&
                (_gl.bindTexture(_gl.TEXTURE_2D, rt.texture._gl),
                _gl.generateMipmap(_gl.TEXTURE_2D),
                _gl.bindTexture(_gl.TEXTURE_2D, null)),
              rt.multisample
                ? (_this.blit(rt._rtMultisample, rt),
                  RenderTarget.renderer.unbind(rt._rtMultisample))
                : RenderTarget.renderer.unbind(rt)),
            Shader.renderer.resetState();
        }),
        (this.setClearColor = function (color, alpha = 1) {
          (_clearColor = new Color(color)),
            (Renderer.CLEAR = [
              _clearColor.r,
              _clearColor.g,
              _clearColor.b,
              alpha,
            ]);
        }),
        (this.setClearAlpha = function (alpha) {
          Renderer.CLEAR[3] = alpha;
        }),
        (this.getClearColor = function () {
          return _clearColor || (_clearColor = new Color(0, 0, 0)), _clearColor;
        }),
        (this.getClearAlpha = function () {
          return Renderer.CLEAR[3];
        }),
        (this.setPixelRatio = function (dpr) {
          (_dpr = dpr), this.setSize(_width, _height);
        }),
        (this.setSize = function (width, height) {
          (_width = width),
            (_height = height),
            (_canvas.width = width * _dpr),
            (_canvas.height = height * _dpr),
            (_canvas.style.width = `${width}px`),
            (_canvas.style.height = `${height}px`),
            _resolution.set(_canvas.width, _canvas.height);
        }),
        (this.getMaxAnisotropy = function () {
          return Device.graphics.webgl && _this.extensions.anisotropy
            ? (_anisotropy ||
                (_anisotropy = _gl.getParameter(
                  _this.extensions.anisotropy.MAX_TEXTURE_MAX_ANISOTROPY_EXT
                )),
              _anisotropy)
            : 0;
        }),
        (this.readPixels = function (
          rt,
          x = 0,
          y = 0,
          width,
          height,
          array,
          type = _gl.UNSIGNED_BYTE
        ) {
          return (
            width || (width = rt ? rt.width : 1),
            height || (height = rt ? rt.height : 1),
            (width = Math.round(width)),
            (height = Math.round(height)),
            (type = type || _gl.UNSIGNED_BYTE),
            array || (array = new Uint8Array(width * height * 4)),
            _gl.bindFramebuffer(_gl.FRAMEBUFFER, rt ? rt._gl : null),
            _gl.readPixels(x, y, width, height, _gl.RGBA, type, array),
            _gl.bindFramebuffer(_gl.FRAMEBUFFER, null),
            array
          );
        }),
        (this.blit = function (input, output, mask = _gl.COLOR_BUFFER_BIT) {
          if (_this.type != Renderer.WEBGL2) return !1;
          if (
            (input._gl || input.upload(),
            output._gl || output.upload(),
            _gl.bindFramebuffer(_gl.READ_FRAMEBUFFER, input._gl),
            _gl.bindFramebuffer(_gl.DRAW_FRAMEBUFFER, output._gl),
            input === output._rtMultisample &&
              (output.depth && (mask |= _gl.DEPTH_BUFFER_BIT),
              output.stencil && (mask |= _gl.STENCIL_BUFFER_BIT)),
            _gl.blitFramebuffer(
              0,
              0,
              input.width,
              input.height,
              0,
              0,
              output.width,
              output.height,
              mask,
              _gl.NEAREST
            ),
            input === output._rtMultisample && output.multi)
          ) {
            let attachments = output.attachments;
            for (let i = 1; i < attachments.length; i++) {
              let texture = attachments[i];
              _gl.readBuffer(_gl[`COLOR_ATTACHMENT${i}`]),
                _gl.bindFramebuffer(
                  _gl.DRAW_FRAMEBUFFER,
                  texture._blitFramebuffer
                ),
                _gl.blitFramebuffer(
                  0,
                  0,
                  input.width,
                  input.height,
                  0,
                  0,
                  output.width,
                  output.height,
                  _gl.COLOR_BUFFER_BIT,
                  _gl.NEAREST
                );
            }
            _gl.readBuffer(_gl.COLOR_ATTACHMENT0);
          }
          return (
            _gl.bindFramebuffer(_gl.READ_FRAMEBUFFER, null),
            _gl.bindFramebuffer(_gl.DRAW_FRAMEBUFFER, null),
            !0
          );
        }),
        (this.setupStencilMask = function (ref = 1) {
          _stencilActive ||
            (_gl.enable(_gl.STENCIL_TEST),
            _gl.clear(_gl.STENCIL_BUFFER_BIT | _gl.DEPTH_BUFFER_BIT)),
            (_stencilActive = !0),
            _gl.stencilFunc(_gl.ALWAYS, ref, 255),
            _gl.stencilOp(_gl.KEEP, _gl.KEEP, _gl.REPLACE),
            _gl.stencilMask(255),
            _gl.colorMask(!1, !1, !1, !1),
            _gl.disable(_gl.DEPTH_TEST);
        }),
        (this.setupStencilDraw = function (mode, ref = 1) {
          _gl.colorMask(!0, !0, !0, !0),
            _gl.enable(_gl.DEPTH_TEST),
            _gl.stencilFunc(
              "inside" == mode ? _gl.EQUAL : _gl.NOTEQUAL,
              ref,
              255
            ),
            _gl.stencilOp(_gl.KEEP, _gl.KEEP, _gl.KEEP);
        }),
        (this.clearStencil = function () {
          _gl.disable(_gl.STENCIL_TEST), (_stencilActive = !1);
        }),
        (this.clearDepth = function (rt) {
          rt && !rt._gl && rt.upload(),
            rt && _gl.bindFramebuffer(_gl.FRAMEBUFFER, rt._gl),
            _gl.clear(_gl.DEPTH_BUFFER_BIT),
            rt && _gl.bindFramebuffer(_gl.FRAMEBUFFER, null);
        }),
        (this.clearColor = function (rt) {
          rt && !rt._gl && rt.upload(),
            rt && _gl.bindFramebuffer(_gl.FRAMEBUFFER, rt._gl),
            _gl.clearColor(
              Renderer.CLEAR[0],
              Renderer.CLEAR[1],
              Renderer.CLEAR[2],
              Renderer.CLEAR[3]
            ),
            _gl.clear(_gl.COLOR_BUFFER_BIT),
            rt && _gl.bindFramebuffer(_gl.FRAMEBUFFER, null);
        }),
        this.get("resolution", (_) => _resolution),
        this.get("time", (_) => _time),
        this.get("canvas", (_) => _canvas);
    },
    (_) => {
      (Renderer.WEBGL1 = "webgl1"),
        (Renderer.WEBGL2 = "webgl2"),
        (Renderer.STATIC_SHADOWS = "static_shadows"),
        (Renderer.SHADOWS_LOW = "shadows_low"),
        (Renderer.SHADOWS_MED = "shadows_med"),
        (Renderer.SHADOWS_HIGH = "shadows_high"),
        (Renderer.ID = 0);
    }
  );
class CameraBase3D extends Base3D {
  constructor() {
    super(),
      (this.matrixWorldInverse = new Matrix4()),
      (this.projectionMatrix = new Matrix4()),
      (this.isCamera = !0);
  }
  copy(source, recursive) {
    return (
      Base3D.prototype.copy.call(this, source, recursive),
      this.matrixWorldInverse.copy(source.matrixWorldInverse),
      this.projectionMatrix.copy(source.projectionMatrix),
      this
    );
  }
  updateMatrixWorld(force) {
    Base3D.prototype.updateMatrixWorld.call(this, force),
      this.offsetMatrixWorld &&
        this.matrixWorld.multiply(this.offsetMatrixWorld),
      this.matrixWorldInverse.getInverse(this.matrixWorld);
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
class CubeCamera extends Base3D {
  constructor(near = 0.1, far = 1e3, cubeResolution = 512) {
    super();
    (this.px = new PerspectiveCamera(90, 1, near, far)),
      this.px.up.set(0, -1, 0),
      this.px.lookAt(new Vector3(1, 0, 0)),
      this.add(this.px),
      (this.nx = new PerspectiveCamera(90, 1, near, far)),
      this.nx.up.set(0, -1, 0),
      this.nx.lookAt(new Vector3(-1, 0, 0)),
      this.add(this.nx),
      (this.py = new PerspectiveCamera(90, 1, near, far)),
      this.py.up.set(0, 0, 1),
      this.py.lookAt(new Vector3(0, 1, 0)),
      this.add(this.py),
      (this.ny = new PerspectiveCamera(90, 1, near, far)),
      this.ny.up.set(0, 0, -1),
      this.ny.lookAt(new Vector3(0, -1, 0)),
      this.add(this.ny),
      (this.pz = new PerspectiveCamera(90, 1, near, far)),
      this.pz.up.set(0, -1, 0),
      this.pz.lookAt(new Vector3(0, 0, 1)),
      this.add(this.pz),
      (this.nz = new PerspectiveCamera(90, 1, near, far)),
      this.nz.up.set(0, -1, 0),
      this.nz.lookAt(new Vector3(0, 0, -1)),
      this.add(this.nz),
      (this.rt = new CubeRenderTarget(cubeResolution, cubeResolution));
  }
  render(scene = World.SCENE, renderer = World.RENDERER) {
    let rt = this.rt;
    this.updateMatrixWorld(!0),
      this.beforeRender && this.beforeRender(this.px),
      (rt.activeFace = 0),
      renderer.render(scene, this.px, rt),
      this.afterRender && this.afterRender(rt),
      this.beforeRender && this.beforeRender(this.nx),
      (rt.activeFace = 1),
      renderer.render(scene, this.nx, rt),
      this.afterRender && this.afterRender(rt),
      this.beforeRender && this.beforeRender(this.py),
      (rt.activeFace = 2),
      renderer.render(scene, this.py, rt),
      this.afterRender && this.afterRender(rt),
      this.beforeRender && this.beforeRender(this.ny),
      (rt.activeFace = 3),
      renderer.render(scene, this.ny, rt),
      this.afterRender && this.afterRender(rt),
      this.beforeRender && this.beforeRender(this.pz),
      (rt.activeFace = 4),
      renderer.render(scene, this.pz, rt),
      this.afterRender && this.afterRender(rt),
      this.beforeRender && this.beforeRender(this.nz),
      (rt.activeFace = 5),
      renderer.render(scene, this.nz, rt),
      this.afterRender && this.afterRender(rt);
  }
}
class OrthographicCamera extends CameraBase3D {
  constructor(left, right, top, bottom, near, far) {
    super(),
      (this.isOrthographicCamera = !0),
      (this.zoom = 1),
      (this.left = left),
      (this.right = right),
      (this.top = top),
      (this.bottom = bottom),
      (this.near = void 0 !== near ? near : 0.1),
      (this.far = void 0 !== far ? far : 2e3),
      (this.position.z = 1),
      this.updateProjectionMatrix();
  }
  clone() {
    return new OrthographicCamera().copy(this);
  }
  copy(source, recursive) {
    return (
      CameraBase3D.prototype.copy.call(this, source, recursive),
      (this.left = source.left),
      (this.right = source.right),
      (this.top = source.top),
      (this.bottom = source.bottom),
      (this.near = source.near),
      (this.far = source.far),
      (this.zoom = source.zoom),
      (this.view =
        null === source.view ? null : Object.assign({}, source.view)),
      this
    );
  }
  updateProjectionMatrix() {
    let dx = (this.right - this.left) / (2 * this.zoom),
      dy = (this.top - this.bottom) / (2 * this.zoom),
      cx = (this.right + this.left) / 2,
      cy = (this.top + this.bottom) / 2,
      left = cx - dx,
      right = cx + dx,
      top = cy + dy,
      bottom = cy - dy;
    this.projectionMatrix.makeOrthographic(
      left,
      right,
      top,
      bottom,
      this.near,
      this.far
    );
  }
  setViewport(width, height) {
    (this.left = width / -2),
      (this.right = width / 2),
      (this.top = height / 2),
      (this.bottom = height / -2),
      this.updateProjectionMatrix();
  }
}
class PerspectiveCamera extends CameraBase3D {
  constructor(fov, aspect, near, far) {
    super(),
      (this.type = "PerspectiveCamera"),
      (this.fov = fov || 50),
      (this.zoom = 1),
      (this.near = near || 0.1),
      (this.far = far || 2e3),
      (this.focus = 10),
      (this.aspect = aspect || 1),
      (this.filmGauge = 35),
      (this.filmOffset = 0),
      this.updateProjectionMatrix();
  }
  clone() {
    return new PerspectiveCamera().copy(this);
  }
  copy(source, recursive) {
    return (
      CameraBase3D.prototype.copy.call(this, source, recursive),
      (this.fov = source.fov),
      (this.zoom = source.zoom),
      (this.near = source.near),
      (this.far = source.far),
      (this.focus = source.focus),
      (this.aspect = source.aspect),
      (this.filmGauge = source.filmGauge),
      (this.filmOffset = source.filmOffset),
      this
    );
  }
  setFocalLength(focalLength) {
    let vExtentSlope = (0.5 * this.getFilmHeight()) / focalLength;
    (this.fov = Math.degrees(2 * Math.atan(vExtentSlope))),
      this.updateProjectionMatrix();
  }
  getFocalLength() {
    let vExtentSlope = Math.tan(Math.radians(0.5 * this.fov));
    return (0.5 * this.getFilmHeight()) / vExtentSlope;
  }
  getEffectiveFOV() {
    return Math.degrees(
      2 * Math.atan(Math.tan(Math.radians(0.5 * this.fov)) / this.zoom)
    );
  }
  getFilmWidth() {
    return this.filmGauge * Math.min(this.aspect, 1);
  }
  getFilmHeight() {
    return this.filmGauge / Math.max(this.aspect, 1);
  }
  updateProjectionMatrix() {
    let near = this.near,
      top = (near * Math.tan(Math.radians(0.5 * this.fov))) / this.zoom,
      height = 2 * top,
      width = this.aspect * height,
      left = -0.5 * width,
      skew = (this.view, this.filmOffset);
    0 !== skew && (left += (near * skew) / this.getFilmWidth()),
      this.projectionMatrix.makePerspective(
        left,
        left + width,
        top,
        top - height,
        near,
        this.far
      );
  }
}
class Geometry {
  constructor() {
    (this.attributes = Geometry.createAttributes(this)),
      (this.drawRange = { start: 0, end: 0 }),
      (this.boundingBox = null),
      (this.boundingSphere = null),
      (this.index = null),
      (this.maxInstancedCount = void 0),
      (this.keepAlive = !1),
      (this.id = Utils.timestamp());
  }
  draw(mesh, shader, isQuery = !1) {
    Geometry.renderer.draw(this, mesh, shader, isQuery);
  }
  upload(mesh, shader) {
    Geometry.renderer.upload(this, mesh, shader);
  }
  destroy(mesh) {
    this.keepAlive || Geometry.renderer.destroy(this, mesh);
  }
  addAttribute(name, attribute) {
    attribute.meshPerAttribute >= 1 &&
      ((this.isInstanced = !0), (this.maxInstancedCount = attribute.count)),
      (this.attributes[name] = attribute);
  }
  setIndex(attribute) {
    this.index = attribute.array || attribute;
  }
  toNonIndexed() {
    let geometry2 = new Geometry(),
      indices = this.index,
      attributes = this.attributes;
    for (let name in attributes) {
      let attribute = attributes[name],
        array = attribute.array,
        itemSize = attribute.itemSize,
        array2 = new array.constructor(indices.length * itemSize),
        index = 0,
        index2 = 0;
      for (let i = 0, l = indices.length; i < l; i++) {
        index = indices[i] * itemSize;
        for (let j = 0; j < itemSize; j++) array2[index2++] = array[index++];
      }
      geometry2.addAttribute(name, new GeometryAttribute(array2, itemSize));
    }
    return geometry2;
  }
  normalizeNormals() {
    let vector = this._V1 || new Vector3();
    this._V1 = vector;
    let x,
      y,
      z,
      normals = this.attributes.normal;
    for (let i = 0, il = normals.count; i < il; i++)
      (x = 3 * i + 0),
        (y = 3 * i + 1),
        (z = 3 * i + 2),
        (vector.x = normals.array[x]),
        (vector.y = normals.array[y]),
        (vector.z = normals.array[z]),
        vector.normalize(),
        (normals.array[x] = vector.x),
        (normals.array[y] = vector.y),
        (normals.array[z] = vector.z);
  }
  computeFaceNormals() {
    let cb = new Vector3(),
      ab = new Vector3();
    for (let f = 0, fl = this.faces.length; f < fl; f++) {
      let face = this.faces[f],
        vA = this.vertices[face.a],
        vB = this.vertices[face.b],
        vC = this.vertices[face.c];
      cb.subVectors(vC, vB),
        ab.subVectors(vA, vB),
        cb.cross(ab),
        cb.normalize(),
        face.normal.copy(cb);
    }
  }
  computeVertexNormals() {
    let index = this.index,
      attributes = this.attributes,
      groups = this.groups;
    if (attributes.position) {
      let positions = attributes.position.array;
      if (void 0 === attributes.normal)
        this.addAttribute(
          "normal",
          new GeometryAttribute(new Float32Array(positions.length), 3)
        );
      else {
        let array = attributes.normal.array;
        for (let i = 0, il = array.length; i < il; i++) array[i] = 0;
      }
      let vA,
        vB,
        vC,
        normals = attributes.normal.array,
        pA = new Vector3(),
        pB = new Vector3(),
        pC = new Vector3(),
        cb = new Vector3(),
        ab = new Vector3();
      if (index) {
        let indices = index.array;
        0 === groups.length && this.addGroup(0, indices.length);
        for (let j = 0, jl = groups.length; j < jl; ++j) {
          let group = groups[j],
            start = group.start;
          for (let i = start, il = start + group.count; i < il; i += 3)
            (vA = 3 * indices[i + 0]),
              (vB = 3 * indices[i + 1]),
              (vC = 3 * indices[i + 2]),
              pA.fromArray(positions, vA),
              pB.fromArray(positions, vB),
              pC.fromArray(positions, vC),
              cb.subVectors(pC, pB),
              ab.subVectors(pA, pB),
              cb.cross(ab),
              (normals[vA] += cb.x),
              (normals[vA + 1] += cb.y),
              (normals[vA + 2] += cb.z),
              (normals[vB] += cb.x),
              (normals[vB + 1] += cb.y),
              (normals[vB + 2] += cb.z),
              (normals[vC] += cb.x),
              (normals[vC + 1] += cb.y),
              (normals[vC + 2] += cb.z);
        }
      } else
        for (let i = 0, il = positions.length; i < il; i += 9)
          pA.fromArray(positions, i),
            pB.fromArray(positions, i + 3),
            pC.fromArray(positions, i + 6),
            cb.subVectors(pC, pB),
            ab.subVectors(pA, pB),
            cb.cross(ab),
            (normals[i] = cb.x),
            (normals[i + 1] = cb.y),
            (normals[i + 2] = cb.z),
            (normals[i + 3] = cb.x),
            (normals[i + 4] = cb.y),
            (normals[i + 5] = cb.z),
            (normals[i + 6] = cb.x),
            (normals[i + 7] = cb.y),
            (normals[i + 8] = cb.z);
      this.normalizeNormals(), (attributes.normal.needsUpdate = !0);
    }
  }
  computeBoundingBox() {
    this.boundingBox || (this.boundingBox = new Box3());
    let position = this.attributes.position;
    position
      ? this.boundingBox.setFromBufferAttribute(position)
      : this.boundingBox.makeEmpty();
  }
  computeBoundingSphere() {
    let box = new Box3(),
      vector = new Vector3();
    this.boundingSphere || (this.boundingSphere = new Sphere());
    let position = this.attributes.position;
    if (position) {
      let center = this.boundingSphere.center;
      box.setFromBufferAttribute(position), box.getCenter(center);
      let maxRadiusSq = 0;
      for (let i = 0, il = position.count; i < il; i++)
        (vector.x = position.array[3 * i + 0]),
          (vector.y = position.array[3 * i + 1]),
          (vector.z = position.array[3 * i + 2]),
          (maxRadiusSq = Math.max(
            maxRadiusSq,
            center.distanceToSquared(vector)
          ));
      (this.boundingSphere.radius = Math.sqrt(maxRadiusSq)),
        isNaN(this.boundingSphere.radius) &&
          console.error(
            "Bounding Sphere came up NaN, broken position buffer.",
            this
          );
    }
  }
  merge(geometry) {
    let Float32ArrayConcat = (first, second) => {
        let firstLength = first.length,
          result = new Float32Array(firstLength + second.length);
        return result.set(first), result.set(second, firstLength), result;
      },
      attributes = this.attributes;
    if (this.index) {
      let indices = geometry.index,
        offset = attributes.position.count;
      for (let i = 0, il = indices.length; i < il; i++)
        indices[i] = offset + indices[i];
      this.index = ((first, second) => {
        let firstLength = first.length,
          result = new (
            Geometry.arrayNeedsUint32(second) ? Uint32Array : Uint16Array
          )(firstLength + second.length);
        return result.set(first), result.set(second, firstLength), result;
      })(this.index, indices);
    }
    for (let key in attributes)
      void 0 !== geometry.attributes[key] &&
        ((attributes[key].array = Float32ArrayConcat(
          attributes[key].array,
          geometry.attributes[key].array
        )),
        (attributes[key].count =
          attributes[key].array.length / attributes[key].itemSize));
    return this;
  }
  clone(noCopy) {
    return new Geometry().copy(this, noCopy);
  }
  copy(source, noCopy) {
    (this.index = null),
      (this.boundingBox = null),
      (this.boundingSphere = null),
      (this.index = source.index);
    let attributes = source.attributes;
    for (let name in attributes)
      this.addAttribute(name, attributes[name].clone(noCopy));
    let boundingBox = source.boundingBox;
    boundingBox &&
      boundingBox.clone &&
      (this.boundingBox = boundingBox.clone());
    let boundingSphere = source.boundingSphere;
    return (
      boundingSphere &&
        boundingSphere.clone &&
        (this.boundingSphere = boundingSphere.clone()),
      this
    );
  }
  center() {
    let offset = new Vector3();
    return (
      this.computeBoundingBox(),
      this.boundingBox.getCenter(offset).negate(),
      this.applyMatrix(
        new Matrix4().makeTranslation(offset.x, offset.y, offset.z)
      ),
      this
    );
  }
  applyMatrix(matrix) {
    let position = this.attributes.position;
    position &&
      (matrix.applyToBufferAttribute(position), (position.needsUpdate = !0));
    let normal = this.attributes.normal;
    if (normal) {
      new Matrix3().getNormalMatrix(matrix).applyToBufferAttribute(normal),
        (normal.needsUpdate = !0);
    }
    return (
      this.boundingBox && this.computeBoundingBox(),
      this.boundingSphere && this.computeBoundingSphere(),
      this
    );
  }
  scale(x, y, z) {
    this.applyMatrix(new Matrix4().makeScale(x, y, z));
  }
  setFromPoints(points) {
    let position = [];
    for (let i = 0, l = points.length; i < l; i++) {
      let point = points[i];
      position.push(point.x, point.y, point.z || 0);
    }
    return (
      this.addAttribute(
        "position",
        new GeometryAttribute(new Float32Array(position), 3)
      ),
      this
    );
  }
  instanceFrom(geom) {
    return geom.clone();
  }
  uploadBuffersAsync() {
    return Geometry.renderer.uploadBuffersAsync(this);
  }
  toJSON() {
    let props = {};
    this.index && (props.index = Array.from(this.index));
    for (let key in this.attributes)
      props[key] = Array.from(this.attributes[key].array);
    return JSON.stringify(props);
  }
}
class GeometryAttribute {
  constructor(_array, _itemSize, _meshPerAttribute, _dynamic = !1) {
    (this.array = _array),
      (this.itemSize = _itemSize),
      (this.count = void 0 !== _array ? _array.length / _itemSize : 0),
      (this.dynamic = _dynamic),
      (this.updateRange = { offset: 0, count: -1 }),
      (this.meshPerAttribute = _meshPerAttribute);
  }
  setArray(array) {
    let newCount = void 0 !== array ? array.length / this.itemSize : 0;
    newCount != this.count && (this.needsNewBuffer = !0),
      (this.array = array),
      (this.count = newCount),
      (this.needsUpdate = !0);
  }
  clone(noCopy) {
    return noCopy
      ? this
      : new GeometryAttribute(
          new Float32Array(this.array),
          this.itemSize,
          this.meshPerAttribute
        );
  }
  getX(index) {
    return this.array[index * this.itemSize];
  }
  setX(index, x) {
    return (this.array[index * this.itemSize] = x), this;
  }
  getY(index) {
    return this.array[index * this.itemSize + 1];
  }
  setY(index, y) {
    return (this.array[index * this.itemSize + 1] = y), this;
  }
  getZ(index) {
    return this.array[index * this.itemSize + 2];
  }
  setZ(index, z) {
    return (this.array[index * this.itemSize + 2] = z), this;
  }
  getW(index) {
    return this.array[index * this.itemSize + 3];
  }
  setW(index, w) {
    return (this.array[index * this.itemSize + 3] = w), this;
  }
  setXY(index, x, y) {
    return (
      (index *= this.itemSize),
      (this.array[index + 0] = x),
      (this.array[index + 1] = y),
      this
    );
  }
  setXYZ(index, x, y, z) {
    return (
      (index *= this.itemSize),
      (this.array[index + 0] = x),
      (this.array[index + 1] = y),
      (this.array[index + 2] = z),
      this
    );
  }
  setXYZW(index, x, y, z, w) {
    return (
      (index *= this.itemSize),
      (this.array[index + 0] = x),
      (this.array[index + 1] = y),
      (this.array[index + 2] = z),
      (this.array[index + 3] = w),
      this
    );
  }
}
class InterleavedBuffer {
  constructor(array, stride) {
    (this.array = array),
      (this.stride = stride),
      (this.count = array ? array.length / stride : 0),
      (this.isInterleaved = !0),
      (this.needsUpdate = !1),
      (this.dynamic = !1),
      (this.updateRange = { offset: 0, count: -1 });
  }
}
class InterleavedGeometryAttribute {
  constructor(interleavedBuffer, itemSize, offset) {
    (this.data = interleavedBuffer),
      (this.itemSize = itemSize),
      (this.offset = offset),
      (this.isInterleaved = !0);
  }
}
class Group extends Base3D {
  constructor() {
    super(),
      (this.isGroup = !0),
      (this._occlusionMesh = null),
      (this._bbVertices = []);
    for (let i = 0; i < 8; i++) this._bbVertices.push(new Vector3());
  }
  generateOcclusionMesh() {
    if (!this.occlusionCulled) {
      this.occlusionCulled = !0;
      let occShader = new Shader("OcclusionMaterial", {
        bbMin: { value: new Vector3(0, 0, 0) },
        bbMax: { value: new Vector3(1, 1, 1) },
      });
      occShader.wireframe = !0;
      let _occlusionMesh = new Mesh(World.BOX, occShader);
      (_occlusionMesh.occlusionCulled = !0),
        (_occlusionMesh._occlusionGroup = this),
        (_occlusionMesh.renderOrder = -1e3),
        (_occlusionMesh.hideByOcclusion = !0),
        (_occlusionMesh._occlusionMesh.renderOrder = 1e3),
        this.add(_occlusionMesh),
        (this._occlusionMesh = _occlusionMesh),
        (this.bb = new Box3());
    }
  }
  updateOcclusionBoundingBox() {
    this.bb.makeEmpty();
    const _this = this;
    _this.children.forEach((child) => {
      if (void 0 === child._occlusionGroup) {
        child.updateOcclusionMesh();
        let bb = child._geometry.boundingBox,
          m = bb.min,
          M = bb.max;
        _this._bbVertices[0].set(m.x, m.y, m.z),
          _this._bbVertices[1].set(m.x, m.y, M.z),
          _this._bbVertices[2].set(m.x, M.y, m.z),
          _this._bbVertices[3].set(M.x, m.y, m.z),
          _this._bbVertices[4].set(M.x, M.y, m.z),
          _this._bbVertices[5].set(M.x, m.y, M.z),
          _this._bbVertices[6].set(m.x, M.y, M.z),
          _this._bbVertices[7].set(M.x, M.y, M.z),
          _this._bbVertices.forEach((vertex) => {
            vertex.applyMatrix4(child.matrix),
              (_this.bb.min.x = Math.min(_this.bb.min.x, vertex.x)),
              (_this.bb.min.y = Math.min(_this.bb.min.y, vertex.y)),
              (_this.bb.min.z = Math.min(_this.bb.min.z, vertex.z)),
              (_this.bb.max.x = Math.max(_this.bb.max.x, vertex.x)),
              (_this.bb.max.y = Math.max(_this.bb.max.y, vertex.y)),
              (_this.bb.max.z = Math.max(_this.bb.max.z, vertex.z));
          });
      }
    }),
      this._occlusionMesh?.shader?.set("bbMin", this.bb.min),
      this._occlusionMesh?.shader?.set("bbMax", this.bb.max),
      this._occlusionMesh?._occlusionMesh?.shader?.set(
        "bbMin",
        this.bb.min.add(new Vector3(-0.01, -0.01, -0.01))
      ),
      this._occlusionMesh?._occlusionMesh?.shader?.set(
        "bbMax",
        this.bb.max.add(new Vector3(0.01, 0.01, 0.01))
      ),
      this._occlusionMesh.position.copy(
        this.bb.max.clone().add(this.bb.min).multiplyScalar(0.5)
      );
  }
  updateOcclusionVisibility(doHide) {
    this.children.forEach((child) => {
      void 0 === child._occlusionGroup && (child.hideByOcclusion = doHide);
    });
  }
}
class BaseLight extends Base3D {
  constructor(color = 16777215, intensity = 1, distance = 9999) {
    super(),
      (this.color = new Color(color)),
      (this.data = new Vector4()),
      (this.data2 = new Vector4()),
      (this.data3 = new Vector4()),
      (this.properties = new Vector4(intensity, distance, 0, 0));
  }
  destroy() {
    this.shadow &&
      (Lighting.removeFromShadowGroup(this), this.shadow.destroy());
  }
  prepareRender() {
    this.shadow.camera.position.copy(this.position),
      this.shadow.camera.lookAt(this.shadow.target);
  }
  set castShadow(bool) {
    (this.shadow || bool) &&
      (this.shadow || (this.shadow = new Shadow(this)),
      (this.shadow.enabled = bool),
      this.silentShadow ||
        (bool
          ? Lighting.addToShadowGroup(this)
          : Lighting.removeFromShadowGroup(this)));
  }
  set intensity(v) {
    this.properties.x = v;
  }
  get intensity() {
    return this.properties.x;
  }
  set distance(v) {
    this.properties.y = v;
  }
  get distance() {
    return this.properties.y;
  }
  set bounce(v) {
    this.properties.z = v;
  }
  get bounce() {
    return this.properties.z;
  }
}
class Line extends Base3D {
  constructor(geometry, shader) {
    super(),
      (this.geometry = geometry),
      (this.shader = shader),
      (this.isLine = !0),
      (this.id = Renderer.ID++);
  }
  clone() {
    return new Line(this.geometry, this.shader).copy(this);
  }
}
class Mesh extends Base3D {
  constructor(geometry, shader, isQuery = !1) {
    super(),
      shader || window.THREAD || (shader = new Shader("TestMaterial")),
      (this._geometry = geometry),
      (this._shader = shader && shader.shader ? shader.shader : shader),
      (this.isMesh = !0);
    if (
      ((this.occlusionMesh = null),
      !isQuery && !window.THREAD && Renderer.useOcclusionQuery)
    ) {
      let occShader = new Shader("OcclusionMaterial", {
        bbMin: { value: new Vector3() },
        bbMax: { value: new Vector3() },
      });
      occShader.side = Shader.DOUBLE_SIDE;
      let _occlusionMesh = new Mesh(World.BOX, occShader, !0);
      (_occlusionMesh.occlusionCulled = !1),
        (_occlusionMesh.doNotProject = !0),
        (_occlusionMesh._queryMesh = this),
        (_occlusionMesh.isOcclusionMesh = !0),
        this.add(_occlusionMesh),
        (this._occlusionMesh = _occlusionMesh),
        (this._occlusionDirty = !0);
    }
    (this.id = Utils.timestamp()), shader && (this._shader.mesh = this);
  }
  clone() {
    return new Mesh(this._geometry, this.shader).copy(this);
  }
  set geometry(g) {
    Geometry.renderer.resetMeshGeom(this), (this._geometry = g);
  }
  get geometry() {
    return this._geometry;
  }
  set shader(shader) {
    this._shader = shader && shader.shader ? shader.shader : shader;
  }
  get shader() {
    return this._shader;
  }
  isInsideOf(mesh) {
    return (
      this.box3 || (this.box3 = new Box3()),
      this.box3.setFromObject(this),
      mesh.isMeshInside(this)
    );
  }
  isMeshInside(mesh) {
    return (
      this.box3 || (this.box3 = new Box3()),
      this.box3.setFromObject(this),
      mesh.box3.intersectsBox(this.box3)
    );
  }
  updateOcclusionMesh(force) {
    if (
      this.occlusionCulled &&
      !Renderer.useOcclusionQuery &&
      (this._occlusionDirty || force)
    ) {
      this._geometry.computeBoundingBox();
      let bb = this._geometry.boundingBox;
      this._occlusionMesh?.shader?.set(
        "bbMin",
        bb.min.add(new Vector3(-0.01, -0.01, -0.01))
      ),
        this._occlusionMesh?.shader?.set(
          "bbMax",
          bb.max.add(new Vector3(0.01, 0.01, 0.01))
        ),
        (this._occlusionMesh.renderOrder = this.renderOrder + 1e3),
        (this._occlusionDirty = !1);
    }
  }
}
class Points extends Base3D {
  constructor(geometry, shader) {
    super(),
      (this._geometry = geometry),
      (this.shader = shader),
      (this.isPoints = !0),
      (this.id = Renderer.ID++),
      shader && (this.shader.mesh = this);
  }
  clone() {
    return new Points(this._geometry, this.shader).copy(this);
  }
  set geometry(g) {
    Geometry.renderer.resetMeshGeom(this), (this._geometry = g);
  }
  get geometry() {
    return this._geometry;
  }
}
class Scene extends Base3D {
  constructor() {
    super(),
      (this.autoUpdate = !0),
      (this.toRender = [[], []]),
      (this._displayNeedsUpdate = !0),
      (this.isScene = !0),
      (this.changes = []);
  }
  set displayNeedsUpdate(v) {
    !0 === v && this.changes.forEach((cb) => cb()),
      (this._displayNeedsUpdate = v);
  }
  get displayNeedsUpdate() {
    return this._displayNeedsUpdate;
  }
  bindSceneChange(cb) {
    this.changes.push(cb);
  }
}
Class(function FBORendererWebGL(_gl) {
  const WEBGL2 = Renderer.type == Renderer.WEBGL2;
  let _maxSamples = WEBGL2 && _gl.getParameter(_gl.MAX_SAMPLES);
  const {
    getFormat: getFormat,
    getInternalFormat: getInternalFormat,
    getProperty: getProperty,
    getType: getType,
    getFloatParams: getFloatParams,
  } = require("GLTypes");
  function prepareTexture(texture) {
    (texture._gl = _gl.createTexture()),
      _gl.bindTexture(_gl.TEXTURE_2D, texture._gl),
      _gl.texParameteri(
        _gl.TEXTURE_2D,
        _gl.TEXTURE_WRAP_S,
        getProperty(texture.wrapS)
      ),
      _gl.texParameteri(
        _gl.TEXTURE_2D,
        _gl.TEXTURE_WRAP_T,
        getProperty(texture.wrapT)
      ),
      _gl.texParameteri(
        _gl.TEXTURE_2D,
        _gl.TEXTURE_MAG_FILTER,
        getProperty(texture.magFilter)
      ),
      _gl.texParameteri(
        _gl.TEXTURE_2D,
        _gl.TEXTURE_MIN_FILTER,
        getProperty(texture.minFilter)
      ),
      (texture.needsUpdate = !1);
  }
  function texImageDB(rt, texture) {
    if (texture.type.includes("float")) {
      let {
        internalformat: internalformat,
        format: format,
        type: type,
      } = getFloatParams(texture);
      _gl.texImage2D(
        _gl.TEXTURE_2D,
        0,
        internalformat,
        rt.width,
        rt.height,
        0,
        format,
        type,
        null
      );
    } else _gl.texImage2D(_gl.TEXTURE_2D, 0, getFormat(texture), rt.width, rt.height, 0, getFormat(texture), getType(texture), null);
    _gl.bindTexture(_gl.TEXTURE_2D, null);
  }
  function getRenderBufferInternalFormat(texture) {
    return texture.type.includes("float")
      ? getFloatParams(texture).internalformat
      : getInternalFormat(texture);
  }
  (this.upload = function (rt) {
    if (!rt._gl) {
      if (rt.cube)
        return (function uploadCube(rt) {
          (rt._gl = _gl.createFramebuffer()),
            _gl.bindFramebuffer(_gl.FRAMEBUFFER, rt._gl);
          let texture = rt.texture;
          (texture._gl = _gl.createTexture()),
            (texture.cube = !0),
            (texture.needsUpdate = !1),
            _gl.bindTexture(_gl.TEXTURE_CUBE_MAP, texture._gl);
          for (let i = 0; i < 6; i++)
            _gl.texImage2D(
              _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i,
              0,
              getFormat(texture),
              rt.width,
              rt.height,
              0,
              getFormat(texture),
              _gl.UNSIGNED_BYTE,
              null
            );
          _gl.texParameteri(
            _gl.TEXTURE_CUBE_MAP,
            _gl.TEXTURE_WRAP_S,
            getProperty(texture.wrapS)
          ),
            _gl.texParameteri(
              _gl.TEXTURE_CUBE_MAP,
              _gl.TEXTURE_WRAP_T,
              getProperty(texture.wrapT)
            ),
            _gl.texParameteri(
              _gl.TEXTURE_CUBE_MAP,
              _gl.TEXTURE_MAG_FILTER,
              getProperty(texture.magFilter)
            ),
            _gl.texParameteri(
              _gl.TEXTURE_CUBE_MAP,
              _gl.TEXTURE_MIN_FILTER,
              getProperty(texture.minFilter)
            ),
            (rt._depthBuffer = _gl.createRenderbuffer()),
            _gl.bindRenderbuffer(_gl.RENDERBUFFER, rt._depthBuffer),
            _gl.renderbufferStorage(
              _gl.RENDERBUFFER,
              _gl.DEPTH_COMPONENT16,
              rt.width,
              rt.height
            ),
            _gl.framebufferRenderbuffer(
              _gl.FRAMEBUFFER,
              _gl.DEPTH_ATTACHMENT,
              _gl.RENDERBUFFER,
              rt._depthBuffer
            ),
            _gl.bindFramebuffer(_gl.FRAMEBUFFER, null),
            _gl.bindTexture(_gl.TEXTURE_2D, null),
            _gl.bindRenderbuffer(_gl.RENDERBUFFER, null);
        })(rt);
      if (rt.texture.isTexture3D)
        return (function upload3DTexture(rt) {
          rt.texture.upload();
          let colorAttachments = [];
          (rt._gl = _gl.createFramebuffer()),
            _gl.bindFramebuffer(_gl.FRAMEBUFFER, rt._gl);
          for (let i = 0; i < rt.indices.length; i++) {
            let key = "COLOR_ATTACHMENT" + i;
            colorAttachments.push(_gl[key]),
              _gl.framebufferTextureLayer(
                _gl.FRAMEBUFFER,
                _gl[key],
                rt.texture._gl,
                0,
                rt.indices[i]
              );
          }
          _gl.drawBuffers(colorAttachments),
            _gl.bindFramebuffer(_gl.FRAMEBUFFER, null);
        })(rt);
      if (((rt._gl = _gl.createFramebuffer()), !rt.depth && !rt.disableDepth))
        if (
          ((rt._depthBuffer = _gl.createRenderbuffer()),
          _gl.bindRenderbuffer(_gl.RENDERBUFFER, rt._depthBuffer),
          rt.internalMultisample)
        ) {
          let samples = Math.min(_maxSamples, rt._samplesAmount);
          _gl.renderbufferStorageMultisample(
            _gl.RENDERBUFFER,
            samples,
            rt.stencil ? _gl.DEPTH24_STENCIL8 : _gl.DEPTH_COMPONENT24,
            rt.width,
            rt.height
          );
        } else
          _gl.renderbufferStorage(
            _gl.RENDERBUFFER,
            rt.stencil
              ? WEBGL2
                ? _gl.DEPTH24_STENCIL8
                : _gl.DEPTH_STENCIL
              : WEBGL2
              ? _gl.DEPTH_COMPONENT24
              : _gl.DEPTH_COMPONENT16,
            rt.width,
            rt.height
          );
      if (
        (RenderCount.add(
          `fbo_${Math.round(rt.width)}x${Math.round(rt.height)}`,
          rt
        ),
        _gl.bindFramebuffer(_gl.FRAMEBUFFER, rt._gl),
        rt.multi)
      )
        if (WEBGL2) {
          let colorAttachments = [];
          for (let i = 0; i < rt.attachments.length; i++) {
            let key = "COLOR_ATTACHMENT" + i,
              texture = rt.attachments[i];
            colorAttachments.push(_gl[key]),
              prepareTexture(texture),
              texImageDB(rt, texture),
              _gl.framebufferTexture2D(
                _gl.FRAMEBUFFER,
                _gl[key],
                _gl.TEXTURE_2D,
                texture._gl,
                0
              ),
              rt.multisample &&
                i > 0 &&
                ((texture._blitFramebuffer = _gl.createFramebuffer()),
                _gl.bindFramebuffer(_gl.FRAMEBUFFER, texture._blitFramebuffer),
                _gl.framebufferTexture2D(
                  _gl.FRAMEBUFFER,
                  _gl.COLOR_ATTACHMENT0,
                  _gl.TEXTURE_2D,
                  texture._gl,
                  0
                ));
          }
          _gl.drawBuffers(colorAttachments);
        } else {
          let ext = Renderer.extensions.drawBuffers,
            colorAttachments = [];
          for (let i = 0; i < rt.attachments.length; i++) {
            let key = "COLOR_ATTACHMENT" + i + "_WEBGL",
              texture = rt.attachments[i];
            colorAttachments.push(ext[key]),
              prepareTexture(texture),
              texImageDB(rt, texture),
              _gl.framebufferTexture2D(
                _gl.FRAMEBUFFER,
                ext[key],
                _gl.TEXTURE_2D,
                texture._gl,
                0
              );
          }
          ext.drawBuffersWEBGL(colorAttachments);
        }
      else if (rt.internalMultisample) {
        let samples = Math.min(_maxSamples, rt._samplesAmount);
        if (rt.parent.multi) {
          let colorAttachments = [],
            attachments = rt.parent.attachments;
          for (let i = 0; i < attachments.length; i++) {
            let key = "COLOR_ATTACHMENT" + i,
              texture = attachments[i];
            colorAttachments.push(_gl[key]),
              (texture._colorBuffer = _gl.createRenderbuffer()),
              _gl.bindRenderbuffer(_gl.RENDERBUFFER, texture._colorBuffer),
              _gl.renderbufferStorageMultisample(
                _gl.RENDERBUFFER,
                samples,
                getRenderBufferInternalFormat(texture),
                rt.width,
                rt.height
              ),
              _gl.framebufferRenderbuffer(
                _gl.FRAMEBUFFER,
                _gl[key],
                _gl.RENDERBUFFER,
                texture._colorBuffer
              ),
              _gl.bindRenderbuffer(_gl.RENDERBUFFER, null);
          }
          _gl.drawBuffers(colorAttachments);
        } else
          (rt._colorBuffer = _gl.createRenderbuffer()),
            _gl.bindRenderbuffer(_gl.RENDERBUFFER, rt._colorBuffer),
            _gl.renderbufferStorageMultisample(
              _gl.RENDERBUFFER,
              samples,
              getRenderBufferInternalFormat(rt.texture),
              rt.width,
              rt.height
            ),
            _gl.framebufferRenderbuffer(
              _gl.FRAMEBUFFER,
              _gl.COLOR_ATTACHMENT0,
              _gl.RENDERBUFFER,
              rt._colorBuffer
            );
      } else {
        if ((prepareTexture(rt.texture), rt.texture.type.includes("float"))) {
          let {
            internalformat: internalformat,
            format: format,
            type: type,
          } = getFloatParams(rt.texture);
          _gl.texImage2D(
            _gl.TEXTURE_2D,
            0,
            internalformat,
            rt.width,
            rt.height,
            0,
            format,
            type,
            null
          );
        } else
          _gl.texImage2D(
            _gl.TEXTURE_2D,
            0,
            getFormat(rt.texture),
            rt.width,
            rt.height,
            0,
            getFormat(rt.texture),
            getType(rt.texture),
            null
          );
        _gl.framebufferTexture2D(
          _gl.FRAMEBUFFER,
          _gl.COLOR_ATTACHMENT0,
          _gl.TEXTURE_2D,
          rt.texture._gl,
          0
        );
      }
      if (rt.depth) {
        prepareTexture(rt.depth);
        let iformat = rt.stencil
            ? WEBGL2
              ? _gl.DEPTH24_STENCIL8
              : _gl.DEPTH_STENCIL
            : WEBGL2
            ? _gl.DEPTH_COMPONENT24
            : _gl.DEPTH_COMPONENT,
          type = rt.stencil
            ? WEBGL2
              ? _gl.UNSIGNED_INT_24_8
              : Renderer.extensions.depthTextures.UNSIGNED_INT_24_8_WEBGL
            : _gl.UNSIGNED_INT;
        _gl.texImage2D(
          _gl.TEXTURE_2D,
          0,
          iformat,
          rt.width,
          rt.height,
          0,
          rt.stencil ? _gl.DEPTH_STENCIL : _gl.DEPTH_COMPONENT,
          type,
          null
        ),
          _gl.framebufferTexture2D(
            _gl.FRAMEBUFFER,
            rt.stencil ? _gl.DEPTH_STENCIL_ATTACHMENT : _gl.DEPTH_ATTACHMENT,
            _gl.TEXTURE_2D,
            rt.depth._gl,
            0
          );
      } else
        rt.disableDepth ||
          (rt.internalMultisample,
          _gl.framebufferRenderbuffer(
            _gl.FRAMEBUFFER,
            rt.stencil ? _gl.DEPTH_STENCIL_ATTACHMENT : _gl.DEPTH_ATTACHMENT,
            _gl.RENDERBUFFER,
            rt._depthBuffer
          ));
      _gl.bindFramebuffer(_gl.FRAMEBUFFER, null),
        _gl.bindTexture(_gl.TEXTURE_2D, null),
        _gl.bindRenderbuffer(_gl.RENDERBUFFER, null);
    }
  }),
    (this.bind = function (rt) {
      rt._gl || this.upload(rt),
        _gl.bindFramebuffer(_gl.FRAMEBUFFER, rt._gl),
        rt.cube &&
          _gl.framebufferTexture2D(
            _gl.FRAMEBUFFER,
            _gl.COLOR_ATTACHMENT0,
            _gl.TEXTURE_CUBE_MAP_POSITIVE_X + rt.activeFace,
            rt.texture._gl,
            0
          ),
        rt.scissor &&
          (_gl.enable(_gl.SCISSOR_TEST),
          _gl.scissor(
            rt.scissor.x,
            rt.scissor.y,
            rt.scissor.width,
            rt.scissor.height
          )),
        _gl.viewport(rt.viewport.x, rt.viewport.y, rt.width, rt.height),
        rt.customViewport &&
          _gl.viewport(
            rt.customViewport.x,
            rt.customViewport.y,
            rt.customViewport.z,
            rt.customViewport.w
          ),
        Renderer.instance.autoClear &&
          (_gl.clearColor(
            Renderer.CLEAR[0],
            Renderer.CLEAR[1],
            Renderer.CLEAR[2],
            Renderer.CLEAR[3]
          ),
          rt.sharedRenderbuffer
            ? rt.clearDepth
              ? _gl.clear(_gl.COLOR_BUFFER_BIT | _gl.DEPTH_BUFFER_BIT)
              : _gl.clear(_gl.COLOR_BUFFER_BIT)
            : _gl.clear(
                _gl.COLOR_BUFFER_BIT |
                  _gl.DEPTH_BUFFER_BIT |
                  _gl.STENCIL_BUFFER_BIT
              ));
    }),
    (this.unbind = function (rt) {
      rt.scissor && _gl.disable(_gl.SCISSOR_TEST),
        _gl.bindFramebuffer(_gl.FRAMEBUFFER, null);
    }),
    (this.resize = function (rt) {
      if (rt.texture._gl && rt._gl) {
        if ((_gl.bindFramebuffer(_gl.FRAMEBUFFER, rt._gl), rt.multi))
          for (let i = 0; i < rt.attachments.length; i++) {
            let texture = rt.attachments[i];
            if (
              (_gl.bindTexture(_gl.TEXTURE_2D, texture._gl),
              texture.type.includes("float"))
            ) {
              let {
                internalformat: internalformat,
                format: format,
                type: type,
              } = getFloatParams(texture);
              _gl.texImage2D(
                _gl.TEXTURE_2D,
                0,
                internalformat,
                rt.width,
                rt.height,
                0,
                format,
                type,
                null
              );
            } else
              _gl.texImage2D(
                _gl.TEXTURE_2D,
                0,
                getFormat(texture),
                rt.width,
                rt.height,
                0,
                getFormat(texture),
                getType(texture),
                null
              );
          }
        else if (rt.internalMultisample) {
          let samples = Math.min(_maxSamples, rt._samplesAmount);
          if (rt.parent.multi) {
            let attachments = rt.parent.attachments;
            for (let i = 0; i < attachments.length; i++) {
              let texture = attachments[i];
              _gl.bindRenderbuffer(_gl.RENDERBUFFER, texture._colorBuffer),
                _gl.renderbufferStorageMultisample(
                  _gl.RENDERBUFFER,
                  samples,
                  getRenderBufferInternalFormat(texture),
                  rt.width,
                  rt.height
                ),
                _gl.bindRenderbuffer(_gl.RENDERBUFFER, null);
            }
          } else
            _gl.bindRenderbuffer(_gl.RENDERBUFFER, rt._colorBuffer),
              _gl.renderbufferStorageMultisample(
                _gl.RENDERBUFFER,
                samples,
                getRenderBufferInternalFormat(rt.texture),
                rt.width,
                rt.height
              ),
              _gl.framebufferRenderbuffer(
                _gl.FRAMEBUFFER,
                _gl.COLOR_ATTACHMENT0,
                _gl.RENDERBUFFER,
                rt._colorBuffer
              );
        } else if (
          (_gl.bindTexture(_gl.TEXTURE_2D, rt.texture._gl),
          rt.texture.type.includes("float"))
        ) {
          let {
            internalformat: internalformat,
            format: format,
            type: type,
          } = getFloatParams(rt.texture);
          _gl.texImage2D(
            _gl.TEXTURE_2D,
            0,
            internalformat,
            rt.width,
            rt.height,
            0,
            format,
            type,
            null
          );
        } else
          _gl.texImage2D(
            _gl.TEXTURE_2D,
            0,
            getFormat(rt.texture),
            rt.width,
            rt.height,
            0,
            getFormat(rt.texture),
            getType(rt.texture),
            null
          );
        if (rt.depth) {
          _gl.bindTexture(_gl.TEXTURE_2D, rt.depth._gl);
          let iformat = rt.stencil
              ? WEBGL2
                ? _gl.DEPTH24_STENCIL8
                : _gl.DEPTH_STENCIL
              : WEBGL2
              ? _gl.DEPTH_COMPONENT24
              : _gl.DEPTH_COMPONENT,
            type = rt.stencil
              ? WEBGL2
                ? _gl.UNSIGNED_INT_24_8
                : Renderer.extensions.depthTextures.UNSIGNED_INT_24_8_WEBGL
              : _gl.UNSIGNED_INT;
          _gl.texImage2D(
            _gl.TEXTURE_2D,
            0,
            iformat,
            rt.width,
            rt.height,
            0,
            rt.stencil ? _gl.DEPTH_STENCIL : _gl.DEPTH_COMPONENT,
            type,
            null
          ),
            _gl.framebufferTexture2D(
              _gl.FRAMEBUFFER,
              rt.stencil ? _gl.DEPTH_STENCIL_ATTACHMENT : _gl.DEPTH_ATTACHMENT,
              _gl.TEXTURE_2D,
              rt.depth._gl,
              0
            );
        } else if (!rt.disableDepth)
          if (
            (_gl.bindRenderbuffer(_gl.RENDERBUFFER, rt._depthBuffer),
            rt.internalMultisample)
          ) {
            let samples = Math.min(_maxSamples, rt._samplesAmount);
            _gl.renderbufferStorageMultisample(
              _gl.RENDERBUFFER,
              samples,
              rt.stencil ? _gl.DEPTH24_STENCIL8 : _gl.DEPTH_COMPONENT24,
              rt.width,
              rt.height
            );
          } else
            _gl.renderbufferStorage(
              _gl.RENDERBUFFER,
              rt.stencil
                ? WEBGL2
                  ? _gl.DEPTH24_STENCIL8
                  : _gl.DEPTH_STENCIL
                : WEBGL2
                ? _gl.DEPTH_COMPONENT24
                : _gl.DEPTH_COMPONENT16,
              rt.width,
              rt.height
            );
        _gl.bindTexture(_gl.TEXTURE_2D, null),
          _gl.bindFramebuffer(_gl.FRAMEBUFFER, null),
          _gl.bindRenderbuffer(_gl.RENDERBUFFER, null);
      }
    }),
    (this.destroy = function (rt) {
      _gl.deleteFramebuffer(rt._gl),
        rt._depthBuffer && _gl.deleteRenderbuffer(rt._depthBuffer),
        Texture.renderer.destroy(rt.texture),
        RenderCount.remove(
          `fbo_${Math.round(rt.width)}x${Math.round(rt.height)}`
        ),
        rt.multi &&
          rt.attachments.forEach((t) => {
            t._colorBuffer && _gl.deleteRenderbuffer(t._colorBuffer),
              t._blitFramebuffer && _gl.deleteFramebuffer(t._blitFramebuffer),
              Texture.renderer.destroy(t);
          }),
        (rt._gl = null);
    });
}),
  Class(function GeometryRendererWebGL(_gl) {
    var _cache = {},
      _isDebbugingShader = Utils.query("displayShaderError");
    const WEBGL2 = Renderer.type == Renderer.WEBGL2;
    function updateBuffer(attrib) {
      if (!attrib._gl) return;
      (attrib.needsUpdate = !1),
        _gl.bindBuffer(_gl.ARRAY_BUFFER, attrib._gl.buffer),
        RenderStats.update("BufferUpdates");
      let array = attrib.array,
        updateRange = attrib.updateRange;
      if (-1 === updateRange.count)
        attrib.needsNewBuffer
          ? (_gl.bufferData(_gl.ARRAY_BUFFER, attrib.array, _gl.DYNAMIC_DRAW),
            (attrib.needsNewBuffer = !1))
          : _gl.bufferSubData(_gl.ARRAY_BUFFER, 0, array);
      else if (Array.isArray(updateRange)) {
        for (let i = updateRange.length - 1; i > -1; i--) {
          let { offset: offset, count: count } = updateRange[i];
          _gl.bufferSubData(
            _gl.ARRAY_BUFFER,
            offset * array.BYTES_PER_ELEMENT,
            array.subarray(offset, offset + count)
          );
        }
        updateRange.length = 0;
      } else
        _gl.bufferSubData(
          _gl.ARRAY_BUFFER,
          updateRange.offset * array.BYTES_PER_ELEMENT,
          array.subarray(
            updateRange.offset,
            updateRange.offset + updateRange.count
          )
        );
      _gl.bindBuffer(_gl.ARRAY_BUFFER, null);
    }
    function renderingCount(count, mode, instanceCount = 1) {
      if (RenderStats.active)
        switch (mode) {
          case _gl.TRIANGLES:
            RenderStats.update("Triangles", instanceCount * (count / 3));
            break;
          case _gl.LINES:
            RenderStats.update("Lines", instanceCount * (count / 2));
            break;
          case _gl.LINE_STRIP:
            RenderStats.update("LineStrip", instanceCount * (count - 1));
            break;
          case _gl.LINE_LOOP:
            RenderStats.update("LineLoop", instanceCount * count);
            break;
          case _gl.POINTS:
            RenderStats.update("Points", instanceCount * count);
        }
    }
    (this.draw = function (geom, mesh, shader, isQuery) {
      (geom._gl && !geom.needsUpdate && mesh._gl && mesh._gl.geomInit) ||
        this.upload(geom, mesh, shader),
        RenderStats.active &&
          RenderStats.update(
            "DrawCalls",
            1,
            shader.vsName + "|" + shader.fsName,
            mesh
          );
      for (let i = geom._attributeKeys.length - 1; i > -1; i--) {
        let key = geom._attributeKeys[i],
          attrib = geom._attributeValues[i];
        (mesh._gl.program == shader._gl.program && void 0 !== mesh._gl[key]) ||
          (mesh._gl[key] = _gl.getAttribLocation(shader._gl.program, key)),
          -1 !== mesh._gl[key] &&
            (attrib.isInterleaved && attrib.data.needsUpdate
              ? updateBuffer(attrib.data)
              : (attrib.needsUpdate || attrib.dynamic) && updateBuffer(attrib));
      }
      if (((mesh._gl.program = shader._gl.program), geom.indexNeedsUpdate)) {
        if (
          ((geom._gl.indexType =
            geom.index instanceof Uint16Array
              ? _gl.UNSIGNED_SHORT
              : _gl.UNSIGNED_INT),
          _gl.bindBuffer(_gl.ELEMENT_ARRAY_BUFFER, geom._gl.index),
          geom.indexUpdateRange)
        ) {
          let updateRange = geom.indexUpdateRange;
          _gl.bufferSubData(
            _gl.ELEMENT_ARRAY_BUFFER,
            updateRange.offset * geom.index.BYTES_PER_ELEMENT,
            geom.index.subarray(
              updateRange.offset,
              updateRange.offset + updateRange.count
            )
          );
        } else
          _gl.bufferData(_gl.ELEMENT_ARRAY_BUFFER, geom.index, _gl.STATIC_DRAW);
        _gl.bindBuffer(_gl.ELEMENT_ARRAY_BUFFER, null),
          (geom.indexNeedsUpdate = !1);
      }
      mesh._gl.vao.bind();
      let mode = mesh._gl.mode;
      mode ||
        (mesh._gl.mode = mode =
          (function getMode(mesh, shader) {
            return mesh.isPoints
              ? _gl.POINTS
              : mesh.isLine
              ? _gl.LINE_STRIP
              : shader.wireframe
              ? _gl.LINES
              : _gl.TRIANGLES;
          })(mesh, shader));
      let drawStart = geom.drawRange.start || 0,
        drawEnd = geom.drawRange.end || geom.attributes.position.count;
      if (isQuery && WEBGL2) {
        let queryMesh = mesh._queryMesh;
        void 0 !== queryMesh._gl &&
          (queryMesh._gl.queryInProgress &&
            _gl.getQueryParameter(
              queryMesh._gl.query,
              _gl.QUERY_RESULT_AVAILABLE
            ) &&
            ((queryMesh._gl.occluded = !_gl.getQueryParameter(
              queryMesh._gl.query,
              _gl.QUERY_RESULT
            )),
            (queryMesh._gl.queryInProgress = !1)),
          queryMesh._gl.queryInProgress ||
            (_gl.beginQuery(
              _gl.ANY_SAMPLES_PASSED_CONSERVATIVE,
              queryMesh._gl.query
            ),
            _gl.colorMask(!1, !1, !1, !1),
            _gl.depthMask(!1),
            geom.index
              ? (_gl.bindBuffer(_gl.ELEMENT_ARRAY_BUFFER, geom._gl.index),
                _gl.drawElements(
                  mode,
                  geom.index.length,
                  geom._gl.indexType,
                  0
                ))
              : _gl.drawArrays(mode, drawStart, drawEnd),
            _gl.colorMask(!0, !0, !0, !0),
            _gl.depthMask(!0),
            _gl.endQuery(_gl.ANY_SAMPLES_PASSED_CONSERVATIVE),
            (queryMesh._gl.queryInProgress = !0)));
      } else {
        if (geom.isInstanced) {
          let maxInstancedCount = mesh.maxInstancedCount
            ? Math.min(mesh.maxInstancedCount, geom.maxInstancedCount)
            : geom.maxInstancedCount;
          shader.maxInstancedCount &&
            (maxInstancedCount = Math.min(
              maxInstancedCount || 9999,
              shader.maxInstancedCount
            )),
            WEBGL2
              ? geom.index
                ? _gl.drawElementsInstanced(
                    mode,
                    geom.index.length,
                    geom._gl.indexType,
                    0,
                    maxInstancedCount
                  )
                : _gl.drawArraysInstanced(
                    mode,
                    drawStart,
                    drawEnd,
                    maxInstancedCount
                  )
              : geom.index
              ? Renderer.extensions.instancedArrays.drawElementsInstancedANGLE(
                  mode,
                  geom.index.length,
                  geom._gl.indexType,
                  0,
                  maxInstancedCount
                )
              : Renderer.extensions.instancedArrays.drawArraysInstancedANGLE(
                  mode,
                  drawStart,
                  drawEnd,
                  maxInstancedCount
                ),
            renderingCount(
              geom.index ? geom.index.length : drawEnd,
              mode,
              maxInstancedCount
            );
        } else
          mesh.hideByOcclusion ||
            (geom.index
              ? _gl.drawElements(mode, geom.index.length, geom._gl.indexType, 0)
              : _gl.drawArrays(mode, drawStart, drawEnd),
            renderingCount(geom.index ? geom.index.length : drawEnd, mode, 1));
        _isDebbugingShader &&
          _gl.getError() != _gl.NO_ERROR &&
          console.log(mesh, shader),
          mesh._gl.vao.unbind(),
          WEBGL2 &&
            RenderMonitor.active &&
            shader?.renderTimeQuery?.endTest?.();
      }
    }),
      (this.upload = function (geom, mesh, shader, hotload) {
        if (!mesh) return;
        geom._gl || (geom._gl = { id: Utils.timestamp() }),
          mesh._gl || (mesh._gl = {}),
          (mesh._gl.geomInit = !0),
          (geom.uploaded = !0),
          !mesh.isOcclusionMesh &&
            WEBGL2 &&
            ((mesh._gl.query = _gl.createQuery()),
            (mesh._gl.queryInProgress = !1),
            (mesh._gl.occluded = !1));
        const KEY = `${geom._gl.id}_${shader._gl._id}`;
        let cached = _cache[KEY];
        if (cached && !hotload)
          return (
            cached.count++,
            (mesh._gl.vao = cached.vao),
            void (mesh._gl.lookup = KEY)
          );
        Utils.query("debugUpload") &&
          console.log("?debugUpload – upload geometry", geom),
          RenderCount.add("geometry"),
          mesh._gl.vao && mesh._gl.vao.destroy(),
          (mesh._gl.vao = new VAO(_gl)),
          geom.distributeBufferData || RenderCount.add("geom_upload", geom);
        for (let i = geom._attributeKeys.length - 1; i > -1; i--) {
          let key = geom._attributeKeys[i],
            attrib = geom._attributeValues[i],
            location =
              (mesh._gl.program === shader._gl.program && mesh._gl[key]) ||
              _gl.getAttribLocation(shader._gl.program, key);
          if (((mesh._gl[key] = location), attrib._gl)) continue;
          attrib._gl = {};
          let { array: array, dynamic: dynamic } = attrib;
          attrib.isInterleaved &&
            (attrib.data._gl || (attrib.data._gl = attrib._gl),
            (attrib._gl = attrib.data._gl),
            (array = attrib.data.array),
            (dynamic = attrib.data.dynamic)),
            attrib._gl.buffer ||
              ((attrib._gl.buffer = _gl.createBuffer()),
              (attrib._gl.bufferUploaded = !geom.distributeBufferData),
              _gl.bindBuffer(_gl.ARRAY_BUFFER, attrib._gl.buffer),
              _gl.bufferData(
                _gl.ARRAY_BUFFER,
                geom.distributeBufferData
                  ? array.length * array.BYTES_PER_ELEMENT
                  : array,
                dynamic ? _gl.DYNAMIC_DRAW : _gl.STATIC_DRAW
              ),
              _gl.bindBuffer(_gl.ARRAY_BUFFER, null)),
            (attrib.needsUpdate = !1);
        }
        geom.index &&
          (geom._gl.index ||
            ((geom._gl.index = _gl.createBuffer()),
            (geom._gl.indexType =
              geom.index instanceof Uint16Array
                ? _gl.UNSIGNED_SHORT
                : _gl.UNSIGNED_INT),
            _gl.bindBuffer(_gl.ELEMENT_ARRAY_BUFFER, geom._gl.index),
            _gl.bufferData(
              _gl.ELEMENT_ARRAY_BUFFER,
              geom.index,
              _gl.STATIC_DRAW
            ),
            _gl.bindBuffer(_gl.ELEMENT_ARRAY_BUFFER, null))),
          mesh._gl.vao.bind();
        for (let i = geom._attributeKeys.length - 1; i > -1; i--) {
          let key = geom._attributeKeys[i],
            attrib = geom._attributeValues[i],
            location = mesh._gl[key];
          if (-1 == location) continue;
          let stride = 0,
            offset = 0;
          if (attrib.isInterleaved) {
            let bytes = attrib.data.array.BYTES_PER_ELEMENT;
            (stride = attrib.data.stride * bytes),
              (offset = attrib.offset * bytes);
          }
          _gl.bindBuffer(_gl.ARRAY_BUFFER, attrib._gl.buffer),
            _gl.vertexAttribPointer(
              location,
              attrib.itemSize,
              _gl.FLOAT,
              !1,
              stride,
              offset
            ),
            _gl.enableVertexAttribArray(location),
            geom.isInstanced &&
              (WEBGL2
                ? _gl.vertexAttribDivisor(location, attrib.meshPerAttribute)
                : Renderer.extensions.instancedArrays.vertexAttribDivisorANGLE(
                    location,
                    attrib.meshPerAttribute
                  ));
        }
        geom.index && _gl.bindBuffer(_gl.ELEMENT_ARRAY_BUFFER, geom._gl.index),
          mesh._gl.vao.unbind(),
          (_cache[KEY] = { count: 1, vao: mesh._gl.vao });
      }),
      (this.destroy = function (geom, mesh) {
        for (let i = geom._attributeKeys.length - 1; i > -1; i--) {
          geom._attributeKeys[i];
          let attrib = geom._attributeValues[i];
          attrib._gl &&
            (_gl.deleteBuffer(attrib._gl.buffer), (attrib._gl = null));
        }
        if (
          (geom._gl?.index && _gl.deleteBuffer(geom._gl.index),
          RenderCount.remove("geometry"),
          mesh && mesh._gl && mesh._gl.vao)
        ) {
          let cache = _cache[mesh._gl.lookup];
          cache
            ? (cache.count--,
              0 == cache.count &&
                (cache.vao.destroy(), delete _cache[mesh._gl.lookup]))
            : mesh._gl.vao.destroy(),
            delete mesh._gl.vao;
        }
        delete geom._gl;
      }),
      (this.resetMeshGeom = function (mesh) {
        mesh._gl && (mesh._gl.geomInit = !1);
      }),
      (this.uploadBuffersAsync = async function (geom) {
        if (geom._gl && geom._gl.uploadedAsync) return;
        let upload = (attrib) => {
            let array = attrib.array,
              buffer = attrib._gl.buffer,
              promise = Promise.create(),
              amt = 4,
              match = !1;
            for (; !match; ) amt--, array.length % amt == 0 && (match = !0);
            let chunk = array.length / amt,
              i = 0,
              worker = new Render.Worker(function uploadBuffersAsync() {
                let offset = i * chunk,
                  subarray = array.subarray(offset, offset + chunk);
                if (!attrib._gl) return worker.stop(), promise.resolve();
                subarray.length &&
                  (_gl.bindBuffer(_gl.ARRAY_BUFFER, buffer),
                  _gl.bufferSubData(
                    _gl.ARRAY_BUFFER,
                    offset * array.BYTES_PER_ELEMENT,
                    subarray
                  ),
                  _gl.bindBuffer(_gl.ARRAY_BUFFER, null)),
                  ++i == amt && (promise.resolve(), worker.stop());
              });
            return promise;
          },
          uploaded = !1;
        for (let i = geom._attributeKeys.length - 1; i > -1; i--) {
          geom._attributeKeys[i];
          let attrib = geom._attributeValues[i];
          if (!attrib._gl) {
            geom.distributeBufferData = !0;
            let { array: array, dynamic: dynamic } = attrib;
            (attrib._gl = {}),
              attrib.isInterleaved &&
                (attrib.data._gl || (attrib.data._gl = attrib._gl),
                (attrib._gl = attrib.data._gl),
                (array = attrib.data.array),
                (dynamic = attrib.data.dynamic)),
              attrib._gl.buffer ||
                ((attrib._gl.buffer = _gl.createBuffer()),
                (attrib._gl.bufferUploaded = !geom.distributeBufferData),
                attrib.array.length &&
                  (_gl.bindBuffer(_gl.ARRAY_BUFFER, attrib._gl.buffer),
                  _gl.bufferData(
                    _gl.ARRAY_BUFFER,
                    array.length * array.BYTES_PER_ELEMENT,
                    dynamic ? _gl.DYNAMIC_DRAW : _gl.STATIC_DRAW
                  ),
                  _gl.bindBuffer(_gl.ARRAY_BUFFER, null))),
              (attrib.needsUpdate = !1),
              (geom.needsUpdate = !0);
          }
          attrib._gl.bufferUploaded ||
            ((attrib._gl.bufferUploaded = !0),
            (uploaded = !0),
            await upload(attrib),
            (attrib.needsUpdate = !1));
        }
        (geom._gl.uploadedAsync = !0),
          uploaded && RenderCount.add("geom_uploadAsync", geom);
      });
  }),
  Class(function ShaderRendererWebGL(_gl) {
    var _pool = {},
      _programID = 0,
      _cached = {},
      _uboCache = {};
    const PROFILER = !!window.OptimizationProfiler,
      WEBGL2 = Renderer.type == Renderer.WEBGL2,
      GLOBAL_UNIFORMS = [
        "normalMatrix",
        "modelMatrix",
        "modelViewMatrix",
        "projectionMatrix",
        "viewMatrix",
        "cameraPosition",
        "cameraQuaternion",
        "resolution",
        "time",
        "shadowMatrix",
        "shadowLightPos",
        "shadowSize",
      ],
      DEPTH_FUNC_KEYS = {
        [Shader.DEPTH_FUNC_NEVER]: "NEVER",
        [Shader.DEPTH_FUNC_LESS]: "LESS",
        [Shader.DEPTH_FUNC_EQUAL]: "EQUAL",
        [Shader.DEPTH_FUNC_LEQUAL]: "LEQUAL",
        [Shader.DEPTH_FUNC_GREATER]: "GREATER",
        [Shader.DEPTH_FUNC_NOTEQUAL]: "NOTEQUAL",
        [Shader.DEPTH_FUNC_GEQUAL]: "GEQUAL",
        [Shader.DEPTH_FUNC_ALWAYS]: "ALWAYS",
      };
    function toTypedArray(uni) {
      uni.value;
      return (
        uni._gl || (uni._gl = {}),
        uni._gl.array && uni._gl.array.length == uni.value.length
          ? uni._gl.array.set(uni.value)
          : (uni._gl.array = new Float32Array(uni.value)),
        uni._gl.array
      );
    }
    function createShader(str, type, name = "Shader") {
      let shader = _gl.createShader(type);
      return (
        void 0 !== window.SPECTOR &&
          (shader.__SPECTOR_Metadata = { name: name }),
        _gl.shaderSource(shader, str),
        _gl.compileShader(shader),
        Hydra.LOCAL &&
          (_gl.getShaderParameter(shader, _gl.COMPILE_STATUS) ||
            (!(function logPrettyShaderError(shader) {
              const shaderSrc = _gl
                  .getShaderSource(shader)
                  .split("\n")
                  .map((line, index) => `${index}: ${line}`),
                shaderLog = _gl.getShaderInfoLog(shader),
                splitShader = shaderLog.split("\n"),
                dedupe = {},
                lineNumbers = splitShader
                  .map((line) =>
                    parseFloat(line.replace(/^ERROR\: 0\:([\d]+)\:.*$/, "$1"))
                  )
                  .filter((n) => !(!n || dedupe[n]) && ((dedupe[n] = !0), !0)),
                logArgs = [""];
              lineNumbers.forEach((number) => {
                (shaderSrc[number - 1] = `%c${shaderSrc[number - 1]}%c`),
                  logArgs.push(
                    "background: #FF0000; color:#FFFFFF; font-size: 10px",
                    "font-size: 10px"
                  );
              });
              const fragmentSourceToLog = shaderSrc.join("\n");
              (logArgs[0] = fragmentSourceToLog),
                console.error(shaderLog),
                console.groupCollapsed("click to view full shader code"),
                console.warn(...logArgs),
                console.groupEnd();
            })(shader),
            _gl.deleteShader(shader))),
        shader
      );
    }
    function createProgram(shader) {
      shader.vertexShader || Shader.runPreProcess(shader);
      let vsCode = shader.onBeforeCompile(shader.vertexShader, "vs"),
        fsCode = shader.onBeforeCompile(shader.fragmentShader, "fs");
      PROFILER &&
        OptimizationProfiler.active &&
        ([vsCode, fsCode] = OptimizationProfiler.override(
          shader,
          vsCode,
          fsCode
        )),
        RenderCount.add("shader", shader);
      let vs = createShader(
          vsCode,
          _gl.VERTEX_SHADER,
          `${shader.vsName} - ${shader.UILPrefix}`
        ),
        fs = createShader(
          fsCode,
          _gl.FRAGMENT_SHADER,
          `${shader.fsName} - ${shader.UILPrefix}`
        );
      Hydra.LOCAL &&
        window.GLSLLinter &&
        GLSLLinter.lint(shader, vsCode, fsCode);
      let program = _gl.createProgram();
      return (
        _gl.attachShader(program, vs),
        _gl.attachShader(program, fs),
        _gl.linkProgram(program),
        Hydra.LOCAL &&
          (_gl.getProgramParameter(program, _gl.LINK_STATUS) ||
            (console.warn(`Shader: ${shader.vsName} | ${shader.vsName}`),
            console.error(
              `Could not compile WebGL program. ${shader.vsName} ${shader.fsName} \n\n` +
                _gl.getProgramInfoLog(program)
            ))),
        _gl.deleteShader(vs),
        _gl.deleteShader(fs),
        program
      );
    }
    function setupShaders(shader) {
      for (let i = shader._uniformKeys.length - 1; i > -1; i--) {
        let key = shader._uniformKeys[i],
          uniform = shader._uniformValues[i];
        if (void 0 === shader._gl[key] && uniform)
          if (uniform.ubo)
            if (WEBGL2) {
              if (
                (_uboCache[shader.UILPrefix] &&
                  !shader.ubo &&
                  (shader.ubo = _uboCache[shader.UILPrefix]),
                _uboCache[shader.UILPrefix])
              ) {
                shader._gl[key] = "U";
                continue;
              }
              shader.ubo || (shader.ubo = new UBO(1, _gl)),
                shader.ubo.push(uniform),
                (shader._gl[key] = "U");
            } else
              shader._gl[key] = _gl.getUniformLocation(shader._gl.program, key);
          else
            WEBGL2 && uniform.lightUBO
              ? ((shader._gl[key] = "U"), (shader.uboLight = !0))
              : (shader._gl[key] = _gl.getUniformLocation(
                  shader._gl.program,
                  key
                ));
      }
      shader.ubo &&
        !_uboCache[shader.UILPrefix] &&
        (_uboCache[shader.UILPrefix] = shader.ubo),
        shader._gl.setupGlobals ||
          ((shader._gl.setupGlobals = !0),
          GLOBAL_UNIFORMS.forEach((key) => {
            shader._gl[key] = _gl.getUniformLocation(shader._gl.program, key);
          })),
        shader.uboLight &&
          _gl.getUniformBlockIndex(shader._gl.program, "lights"),
        WEBGL2 && _gl.getUniformBlockIndex(shader._gl.program, "global");
    }
    function uniformTextureArray(uni, uLoc, shader) {
      let array = shader._gl.texArray || [];
      (array.length = 0), (shader._gl.texArray = array);
      for (let i = 0; i < uni.value.length; i++) {
        array.push(shader._gl.texIndex);
        let texture = uni.value[i];
        !1 === texture.loaded && (texture = Utils3D.getEmptyTexture()),
          (void 0 === texture._gl || texture.needsReupload) &&
            Texture.renderer.upload(texture),
          _gl.activeTexture(_gl["TEXTURE" + shader._gl.texIndex++]),
          _gl.bindTexture(_gl.TEXTURE_2D, texture._gl);
      }
      _gl.uniform1iv(uLoc, array);
    }
    (this.upload = function (shader) {
      if (
        (PROFILER &&
          OptimizationProfiler.active &&
          OptimizationProfiler.setupShader(shader),
        !shader._gl)
      ) {
        shader._gl = {};
        let key = `${shader.vsName}_${shader.fsName}_${shader.customCompile}`,
          cached = _pool[key];
        cached
          ? ((shader._gl.program = cached.program),
            (shader._gl._id = cached.id),
            shader.onBeforePrecompilePromise.resolve(),
            cached.count++,
            Hydra.LOCAL && _pool[key].references.push(shader))
          : ((shader._gl.program = createProgram(shader)),
            (shader._gl._id = _programID++),
            (_pool[key] = {
              count: 1,
              program: shader._gl.program,
              id: shader._gl._id,
            }),
            Shader.registerPreProcess(shader),
            Hydra.LOCAL && (_pool[key].references = [shader]));
      }
      setupShaders(shader),
        shader.ubo && shader.ubo.upload(),
        (Renderer.type == Renderer.WEBGL1 && FXLayer.exists) ||
          (shader.vertexShader = shader.fragmentShader = "");
    }),
      (this.findCachedProgram = function (shader) {
        let key = `${shader.vsName}_${shader.fsName}_${shader.customCompile}`,
          cached = _pool[key];
        return (
          !!cached &&
          ((shader._gl = {}),
          (shader._gl.program = cached.program),
          (shader._gl._id = cached.id),
          shader.onBeforePrecompilePromise.resolve(),
          _uboCache[shader.UILPrefix] && (shader.ubo = shader.UILPrefix),
          cached.count++,
          Hydra.LOCAL && _pool[key].references.push(shader),
          !0)
        );
      }),
      (this.draw = function (shader) {
        void 0 === shader._gl && this.upload(shader),
          WEBGL2 &&
            RenderMonitor.active &&
            !shader.renderTimeQuery &&
            (shader.renderTimeQuery = RenderMonitor.createQuery(_gl, shader)),
          WEBGL2 &&
            RenderMonitor.active &&
            shader.renderTimeQuery?.beginTest?.(),
          (shader._gl.texIndex = 0),
          shader._gl.program != _cached.program &&
            (_gl.useProgram(shader._gl.program),
            (_cached.program = shader._gl.program)),
          shader.ubo && shader.ubo.bind(shader._gl.program, "ubo"),
          shader.uboLight && Lighting.bindUBO(shader._gl.program);
        for (let i = shader._uniformKeys.length - 1; i > -1; i--) {
          let key = shader._uniformKeys[i],
            uni = shader._uniformValues[i];
          if (!uni) continue;
          let uLoc = shader._gl[key];
          if (
            (void 0 === uLoc &&
              (setupShaders(shader), (uLoc = shader._gl[key])),
            null !== uLoc && -1 !== uLoc && "U" !== uLoc)
          ) {
            if (
              (null === uni.value && (uni.value = Utils3D.getEmptyTexture()),
              Hydra.LOCAL && void 0 === uni.value)
            )
              throw `Uniform ${key} value is undefined. | ${shader.vsName} ${shader.fsName}`;
            switch (
              (uni.type ||
                (uni.type =
                  "string" == typeof (uniform = uni).type
                    ? uniform.type
                    : "boolean" == typeof uniform.value
                    ? "b"
                    : null === uniform.value ||
                      uniform.value instanceof Texture ||
                      uniform.value.texture ||
                      (uniform.value.rt && uniform.value.rt.texture)
                    ? "t"
                    : uniform.value instanceof Vector2
                    ? "v2"
                    : uniform.value instanceof Vector3 ||
                      uniform.value instanceof Vector3D
                    ? "v3"
                    : uniform.value instanceof Vector4
                    ? "v4"
                    : uniform.value instanceof Matrix4
                    ? "m4"
                    : uniform.value instanceof Matrix3
                    ? "m3"
                    : uniform.value instanceof Color
                    ? "c"
                    : uniform.value instanceof Quaternion
                    ? "q"
                    : Array.isArray(uniform.value) &&
                      uniform.value[0] instanceof Texture
                    ? "tv"
                    : "f"),
              uni.type)
            ) {
              case "f":
                _gl.uniform1f(uLoc, uni.value);
                break;
              case "i":
                _gl.uniform1i(uLoc, Math.floor(uni.value));
                break;
              case "b":
                _gl.uniform1i(uLoc, uni.value);
                break;
              case "v2":
                _gl.uniform2f(uLoc, uni.value.x, uni.value.y);
                break;
              case "v3":
                _gl.uniform3f(uLoc, uni.value.x, uni.value.y, uni.value.z);
                break;
              case "c":
                _gl.uniform3f(uLoc, uni.value.r, uni.value.g, uni.value.b);
                break;
              case "q":
              case "v4":
                _gl.uniform4f(
                  uLoc,
                  uni.value.x,
                  uni.value.y,
                  uni.value.z,
                  uni.value.w
                );
                break;
              case "v3v":
                _gl.uniform3fv(uLoc, toTypedArray(uni));
                break;
              case "v4v":
                _gl.uniform4fv(uLoc, toTypedArray(uni));
                break;
              case "v2v":
                _gl.uniform2fv(uLoc, toTypedArray(uni));
                break;
              case "fv":
                _gl.uniform1fv(uLoc, toTypedArray(uni));
                break;
              case "m4":
                _gl.uniformMatrix4fv(uLoc, !1, uni.value.elements);
                break;
              case "m3":
                _gl.uniformMatrix3fv(uLoc, !1, uni.value.elements);
                break;
              case "tv":
                uniformTextureArray(uni, uLoc, shader);
                break;
              case "t":
                let texture = uni.value;
                texture.isTexture ||
                  (uni.value.rt &&
                    (texture =
                      uni.value.rt.overrideTexture || uni.value.rt.texture),
                  uni.value.texture && (texture = uni.value.texture)),
                  !1 === texture.loaded &&
                    (texture = Utils3D.getEmptyTexture());
                let texIndex = shader._gl.texIndex++;
                uni.value.vrRT &&
                  ((shader._gl.vrRT = !0), (uni.value._glTexIndex = texIndex)),
                  Texture.renderer.draw(texture, uLoc, key, texIndex);
            }
          }
        }
        var uniform;
        if (!shader.glCustomState) {
          if (shader.polygonOffset) {
            let key =
              shader.polygonOffsetFactor + "_" + shader.polygonOffsetUnits;
            _cached.polygonOffset != key &&
              (_gl.enable(_gl.POLYGON_OFFSET_FILL),
              _gl.polygonOffset(
                shader.polygonOffsetFactor,
                shader.polygonOffsetUnits
              )),
              (_cached.polygonOffset = key);
          } else
            _cached.polygonOffset && _gl.disable(_gl.POLYGON_OFFSET_FILL),
              (_cached.polygonOffset = !1);
          if (
            (shader.transparent || shader.opacity
              ? (_cached.transparent || _gl.enable(_gl.BLEND),
                (_cached.transparent = !0))
              : (_cached.transparent && _gl.disable(_gl.BLEND),
                (_cached.transparent = !1)),
            _cached.blending != shader.blending)
          ) {
            switch (shader.blending) {
              case Shader.ADDITIVE_BLENDING:
                _gl.blendEquation(_gl.FUNC_ADD),
                  _gl.blendFunc(_gl.SRC_ALPHA, _gl.ONE);
                break;
              case Shader.PREMULTIPLIED_ALPHA_BLENDING:
                _gl.blendEquation(_gl.FUNC_ADD),
                  _gl.blendFunc(_gl.ONE, _gl.ONE_MINUS_SRC_ALPHA);
                break;
              case Shader.ADDITIVE_COLOR_ALPHA:
                _gl.blendEquation(_gl.FUNC_ADD),
                  _gl.blendFunc(_gl.ONE, _gl.ONE);
                break;
              case Shader.MAX:
                _gl.blendEquation(
                  WEBGL2 ? _gl.MAX : Renderer.extensions.minMax.MAX_EXT
                ),
                  _gl.blendFunc(_gl.ONE, _gl.ONE);
                break;
              case Shader.MIN:
                _gl.blendEquation(
                  WEBGL2 ? _gl.MIN : Renderer.extensions.minMax.MIN_EXT
                ),
                  _gl.blendFunc(_gl.ONE, _gl.ONE);
                break;
              default:
                _gl.blendEquationSeparate(_gl.FUNC_ADD, _gl.FUNC_ADD),
                  _gl.blendFuncSeparate(
                    _gl.SRC_ALPHA,
                    _gl.ONE_MINUS_SRC_ALPHA,
                    _gl.ONE,
                    _gl.ONE_MINUS_SRC_ALPHA
                  );
            }
            _cached.blending = shader.blending;
          }
          shader.depthTest
            ? (_cached.depthTest || _gl.enable(_gl.DEPTH_TEST),
              (_cached.depthTest = !0))
            : (_cached.depthTest && _gl.disable(_gl.DEPTH_TEST),
              (_cached.depthTest = !1));
          let depthFunc =
            _gl[DEPTH_FUNC_KEYS[shader.depthFunc || Shader.DEPTH_FUNC_LESS]];
          if (
            (_cached.depthFunc !== depthFunc &&
              (_gl.depthFunc(depthFunc), (_cached.depthFunc = depthFunc)),
            shader.stencilTest)
          )
            if (
              (_cached.stencilTest || _gl.enable(_gl.STENCIL_TEST),
              (_cached.stencilTest = !0),
              shader.stencilMask)
            )
              _gl.stencilFunc(_gl.ALWAYS, 1, 255),
                _gl.stencilOp(_gl.KEEP, _gl.KEEP, _gl.REPLACE),
                _gl.stencilMask(255),
                _gl.colorMask(!1, !1, !1, !1),
                _gl.disable(_gl.DEPTH_TEST);
            else {
              _gl.colorMask(!0, !0, !0, !0), _gl.enable(_gl.DEPTH_TEST);
              let mode = "inside";
              _gl.stencilFunc(
                "inside" == mode ? _gl.EQUAL : _gl.NOTEQUAL,
                1,
                255
              ),
                _gl.stencilOp(_gl.KEEP, _gl.KEEP, _gl.KEEP);
            }
          else
            _cached.stencilTest && _gl.disable(_gl.STENCIL_TEST),
              (_cached.stencilTest = !1);
          switch (shader.side) {
            case Shader.BACK_SIDE:
              _cached.side != Shader.BACK_SIDE &&
                (_gl.enable(_gl.CULL_FACE),
                _gl.cullFace(_gl.FRONT),
                (_cached.side = Shader.BACK_SIDE));
              break;
            case Shader.DOUBLE_SIDE:
              _cached.side != Shader.DOUBLE_SIDE &&
                (_gl.disable(_gl.CULL_FACE),
                (_cached.side = Shader.DOUBLE_SIDE));
              break;
            default:
              _cached.side != Shader.FRONT_SIDE &&
                (_gl.enable(_gl.CULL_FACE),
                _gl.cullFace(_gl.BACK),
                (_cached.side = Shader.FRONT_SIDE));
          }
          if (
            (_cached.depthMask != shader.depthWrite &&
              (_gl.depthMask(!!shader.depthWrite),
              (_cached.depthMask = shader.depthWrite)),
            shader.colorMask && shader.colorMask.push)
          )
            _gl.colorMask(
              shader.colorMask[0] || !1,
              shader.colorMask[1] || !1,
              shader.colorMask[2] || !1,
              shader.colorMask[3] || !1
            );
          else
            switch (shader.colorMask) {
              case Shader.COLOR_MASK_NONE:
                _cached.colorMask != shader.colorMask &&
                  (_gl.colorMask(!0, !0, !0, !0),
                  (_cached.colorMask = shader.colorMask));
                break;
              case Shader.COLOR_MASK_RGB:
                _cached.colorMask != shader.colorMask &&
                  (_gl.colorMask(!1, !1, !1, !0),
                  (_cached.colorMask = shader.colorMask));
                break;
              case Shader.COLOR_MASK_RGBA:
                _cached.colorMask != shader.colorMask &&
                  (_gl.colorMask(!1, !1, !1, !1),
                  (_cached.colorMask = shader.colorMask));
            }
        }
        if (shader.customState)
          for (let i = 0; i < shader.customState.length; i++) {
            let obj = shader.customState[i];
            _gl[obj.fn].apply(_gl, obj.params);
          }
      }),
      (this.destroy = function (shader) {
        delete shader._gl, shader.ubo && shader.ubo.destroy();
      }),
      (this.appendUniform = function (shader, key, value, hint) {
        let loc = shader._gl[key];
        if (
          (void 0 === loc &&
            (loc = loc = _gl.getUniformLocation(shader._gl.program, key)),
          null !== loc)
        )
          if (value.isMatrix4) _gl.uniformMatrix4fv(loc, !1, value.elements);
          else if (value.isMatrix3)
            _gl.uniformMatrix3fv(loc, !1, value.elements);
          else if (value.isVector4)
            _gl.uniform4f(loc, value.x, value.y, value.z, value.w);
          else if (value.isQuaternion)
            _gl.uniform4f(loc, value.x, value.y, value.z, value.w);
          else if (value.isVector3)
            _gl.uniform3f(loc, value.x, value.y, value.z);
          else if (value.isVector2) _gl.uniform2f(loc, value.x, value.y);
          else if (value instanceof Float32Array)
            switch (hint) {
              case "matrix":
                _gl.uniformMatrix4fv(loc, !1, value);
                break;
              case "float":
                _gl.uniform1fv(loc, value);
                break;
              case "vec3":
                _gl.uniform3fv(loc, value);
            }
          else if (Array.isArray(value)) {
            let array = shader._gl.texArray || [];
            (array.length = 0), (shader._gl.texArray = array);
            for (let i = 0; i < value.length; i++)
              array.push(shader._gl.texIndex),
                _gl.activeTexture(_gl["TEXTURE" + shader._gl.texIndex++]),
                _gl.bindTexture(_gl.TEXTURE_2D, value[i]._gl);
            _gl.uniform1iv(loc, array);
          } else _gl.uniform1f(loc, value);
      }),
      (this.resetState = function () {
        _cached.depthMask || (_gl.depthMask(!0), (_cached.depthMask = !0)),
          _cached.depthTest || _gl.enable(_gl.DEPTH_TEST),
          (_cached.depthTest = !0),
          _cached.depthFunc !== _gl.LESS && _gl.depthFunc(_gl.LESS),
          (_cached.depthFunc = _gl.LESS),
          _cached.colorMask != Shader.COLOR_MASK_NONE &&
            (_gl.colorMask(!0, !0, !0, !0),
            (_cached.colorMask = Shader.COLOR_MASK_NONE)),
          (_cached.program = null);
      }),
      (this.clearState = function () {
        _cached = {};
      }),
      (this.hotReload = function (file) {
        file = file.split(".")[0].trim();
        for (let key in _pool)
          if (
            key.includes(file) &&
            !["|instance", "|Line3D", "|MergedLine"].find((part) =>
              key.includes(part)
            )
          ) {
            let obj = _pool[key],
              rootShader = obj.references[0];
            for (let i = 0; i < obj.references.length; i++) {
              let shader = obj.references[i];
              0 === i
                ? ((shader.restoreFS = shader.restoreVS = null),
                  shader.resetProgram(),
                  (shader._gl = {}),
                  (shader._gl.program = createProgram(shader)),
                  (shader._gl._id = _programID++),
                  (obj.program = shader._gl.program),
                  (obj.id = shader._gl._id))
                : (shader.destroy(),
                  (shader.restoreFS = rootShader.restoreFS),
                  (shader.restoreVS = rootShader.restoreVS),
                  (shader.vertexShader = rootShader.vertexShader),
                  (shader.fragmentShader = rootShader.fragmentShader),
                  (shader._gl = {}),
                  (shader._gl.program = obj.program),
                  (shader._gl._id = obj.id)),
                setupShaders(rootShader);
            }
          }
      }),
      (this.hotReloadClearProgram = function (id) {
        for (let key in _pool) key.includes(id) && delete _pool[key];
      });
  }),
  Class(function TextureRendererWebGL(_gl) {
    const _this = this;
    var _state = {};
    const FLOAT_DATA = new Float32Array([0, 0, 0, 0]),
      UINT_DATA = new Uint32Array([0, 0, 0, 0]),
      INT_DATA = new Int32Array([0, 0, 0, 0]),
      DATA = new Uint8Array([0, 0, 0, 0]),
      {
        getFormat: getFormat,
        getProperty: getProperty,
        getType: getType,
        getFloatParams: getFloatParams,
        getInternalFormat: getInternalFormat,
      } = require("GLTypes");
    function setTextureParams(texture, textureType = _gl.TEXTURE_2D) {
      let format = getFormat(texture),
        internalFormat = getInternalFormat(texture),
        type = getType(texture),
        data = DATA;
      switch (texture.type) {
        case Texture.FLOAT:
          data = FLOAT_DATA;
          break;
        case Texture.UNSIGNED_INTEGER:
          data = UINT_DATA;
          break;
        case Texture.INTEGER:
          data = INT_DATA;
          break;
        case Texture.HALF_FLOAT:
          data = null;
      }
      textureType != _gl.TEXTURE_2D ||
        texture.compressed ||
        _gl.texImage2D(
          textureType,
          0,
          internalFormat,
          1,
          1,
          0,
          format,
          type,
          data
        ),
        _gl.texParameteri(
          textureType,
          _gl.TEXTURE_WRAP_S,
          getProperty(texture.wrapS)
        ),
        _gl.texParameteri(
          textureType,
          _gl.TEXTURE_WRAP_T,
          getProperty(texture.wrapT)
        ),
        _gl.texParameteri(
          textureType,
          _gl.TEXTURE_MAG_FILTER,
          getProperty(texture.magFilter)
        ),
        _gl.texParameteri(
          textureType,
          _gl.TEXTURE_MIN_FILTER,
          getProperty(texture.minFilter)
        ),
        texture.data || texture.format != Texture.RGBAFormat
          ? 1 == _state.premultiply &&
            (_gl.pixelStorei(_gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, !1),
            (_state.premultiply = !1))
          : !1 === texture.premultiplyAlpha
          ? (_gl.pixelStorei(_gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, !1),
            (_state.premultiply = !1))
          : (_gl.pixelStorei(_gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, !0),
            (_state.premultiply = !0)),
        texture.anisotropy > 1 &&
          _gl.texParameterf(
            textureType,
            Renderer.extensions.anisotropy.TEXTURE_MAX_ANISOTROPY_EXT,
            texture.anisotropy
          );
    }
    function updateDynamic(texture) {
      if (texture.isDataTexture) {
        if (
          (!0 === texture.flipY
            ? _state.flipY ||
              (_gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, !0),
              (_state.flipY = !0))
            : _state.flipY &&
              (_gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, !1),
              (_state.flipY = !1)),
          _state.premultiply &&
            (_gl.pixelStorei(_gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, !1),
            (_state.premultiply = !1)),
          !texture.glFormat)
        ) {
          let {
            internalformat: internalformat,
            format: format,
            type: type,
          } = getFloatParams(texture);
          (texture.iformat = internalformat),
            (texture.glFormat = format),
            (texture.glType = type);
        }
        _gl.texSubImage2D(
          _gl.TEXTURE_2D,
          0,
          0,
          0,
          texture.width,
          texture.height,
          texture.glFormat,
          texture.glType,
          texture.data
        );
      } else {
        _state.flipY ||
          (_gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, !0), (_state.flipY = !0)),
          texture.format == Texture.RGBAFormat
            ? !1 === texture.premultiplyAlpha
              ? (_gl.pixelStorei(_gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, !1),
                (_state.premultiply = !1))
              : (_gl.pixelStorei(_gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, !0),
                (_state.premultiply = !0))
            : _state.premultiply &&
              (_gl.pixelStorei(_gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, !1),
              (_state.premultiply = !1)),
          texture.glFormat || (texture.glFormat = getFormat(texture));
        try {
          _gl.texImage2D(
            _gl.TEXTURE_2D,
            0,
            texture.glFormat,
            texture.glFormat,
            getType(texture),
            texture.image
          );
        } catch (e) {}
      }
    }
    (this.draw = function (texture, loc, key, id) {
      if (
        ((void 0 === texture._gl || texture.needsReupload) &&
          this.upload(texture),
        _gl.activeTexture(_gl[`TEXTURE${id}`]),
        texture.cube)
      )
        _gl.bindTexture(_gl.TEXTURE_CUBE_MAP, texture._gl);
      else if (texture.isTexture3D)
        _gl.bindTexture(_gl.TEXTURE_3D, texture._gl);
      else {
        let texType = texture.EXT_OES
          ? _gl.TEXTURE_EXTERNAL_OES
          : _gl.TEXTURE_2D;
        _gl.bindTexture(texType, texture._gl);
      }
      _gl.uniform1i(loc, id),
        (texture.dynamic || texture.needsUpdate) && updateDynamic(texture),
        (texture.needsUpdate = !1);
    }),
      (this.upload = function (texture) {
        if (texture._gl && !texture.needsReupload && !texture.needsUpdate)
          return;
        let format = getFormat(texture);
        if (
          (Utils.query("debugUpload") &&
            console.log("?debugUpload – upload texture", texture),
          texture.cube)
        ) {
          if (texture.compressed) {
            if (1 !== texture.cube.length)
              throw "Compressed cube texture requires 1 file with 6 faces";
          } else if (6 !== texture.cube.length)
            throw "Cube texture requires 6 images";
          return (function uploadCube(texture) {
            if (void 0 === texture._gl) {
              (texture._gl = _gl.createTexture()),
                _gl.bindTexture(_gl.TEXTURE_CUBE_MAP, texture._gl);
              let needsFlipY = !0 === texture.flipY;
              needsFlipY !== !!_state.flipY &&
                (_gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, needsFlipY),
                (_state.flipY = needsFlipY)),
                setTextureParams(texture, _gl.TEXTURE_CUBE_MAP);
            }
            let format = getFormat(texture);
            if (texture.compressed) {
              let image = texture.cube[0];
              for (let i = 0; i < image.compressedData.length; i++) {
                let size = image.sizes[i],
                  data = image.compressedData[i],
                  faceLength = data.length / 6;
                for (let j = 0; j < 6; j++)
                  if (image.uncompressed) {
                    let view = new Uint8Array(
                      data.buffer,
                      j * faceLength,
                      faceLength
                    );
                    _gl.texImage2D(
                      _gl.TEXTURE_CUBE_MAP_POSITIVE_X + j,
                      i,
                      _gl.RGBA,
                      size.width,
                      size.height,
                      0,
                      _gl.RGBA,
                      _gl.UNSIGNED_BYTE,
                      view
                    );
                  } else {
                    let view = new DataView(
                      data.buffer,
                      j * faceLength,
                      faceLength
                    );
                    _gl.compressedTexImage2D(
                      _gl.TEXTURE_CUBE_MAP_POSITIVE_X + j,
                      i,
                      image.gliFormat,
                      size.width || size,
                      size.height || size,
                      0,
                      view
                    );
                  }
              }
            } else {
              for (let i = 0; i < 6; i++)
                _gl.texImage2D(
                  _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i,
                  0,
                  format,
                  format,
                  getType(texture),
                  texture.cube[i]
                );
              _gl.generateMipmap(_gl.TEXTURE_CUBE_MAP);
            }
            (texture.needsUpdate = texture.needsReupload = !1),
              texture.onUpdate && texture.onUpdate();
          })(texture);
        }
        if (texture.isTexture3D)
          return (function uploadTexture3D(texture) {
            if (void 0 === texture._gl) {
              let format = getFormat(texture),
                internalFormat = getInternalFormat(texture),
                type = getType(texture);
              (texture._gl = _gl.createTexture()),
                _gl.bindTexture(_gl.TEXTURE_3D, texture._gl),
                _gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, !1),
                _gl.pixelStorei(_gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, !1),
                _gl.texParameteri(
                  _gl.TEXTURE_3D,
                  _gl.TEXTURE_WRAP_S,
                  getProperty(texture.wrapS)
                ),
                _gl.texParameteri(
                  _gl.TEXTURE_3D,
                  _gl.TEXTURE_WRAP_T,
                  getProperty(texture.wrapT)
                ),
                _gl.texParameteri(
                  _gl.TEXTURE_3D,
                  _gl.TEXTURE_WRAP_R,
                  getProperty(texture.wrapR)
                ),
                _gl.texParameteri(
                  _gl.TEXTURE_3D,
                  _gl.TEXTURE_MAG_FILTER,
                  getProperty(texture.magFilter)
                ),
                _gl.texParameteri(
                  _gl.TEXTURE_3D,
                  _gl.TEXTURE_MIN_FILTER,
                  getProperty(texture.minFilter)
                ),
                _gl.texImage3D(
                  _gl.TEXTURE_3D,
                  0,
                  internalFormat,
                  texture.width,
                  texture.height,
                  texture.depth,
                  0,
                  format,
                  type,
                  texture.image
                ),
                (texture.needsUpdate = texture.needsReupload = !1),
                texture.onUpdate && texture.onUpdate();
            }
          })(texture);
        let texType = texture.EXT_OES
          ? _gl.TEXTURE_EXTERNAL_OES
          : _gl.TEXTURE_2D;
        if (
          (void 0 === texture._gl
            ? ((texture._gl = _gl.createTexture()),
              RenderCount.add("texture"),
              _gl.bindTexture(texType, texture._gl),
              setTextureParams(texture, texType))
            : _gl.bindTexture(texType, texture._gl),
          texture.isDataTexture ||
            (texture.type && texture.type.includes("float")))
        ) {
          !0 === texture.flipY
            ? _state.flipY ||
              (_gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, !0),
              (_state.flipY = !0))
            : _state.flipY &&
              (_gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, !1),
              (_state.flipY = !1)),
            _gl.pixelStorei(_gl.UNPACK_ALIGNMENT, 1);
          let {
            internalformat: internalformat,
            format: format,
            type: type,
          } = getFloatParams(texture);
          if ("ie" === Device.system.browser)
            try {
              _gl.texImage2D(
                _gl.TEXTURE_2D,
                0,
                internalformat,
                texture.width,
                texture.height,
                0,
                format,
                type,
                texture.distributeTextureData ? null : texture.data
              );
            } catch (e) {
              console.log(e);
            }
          else
            _gl.texImage2D(
              _gl.TEXTURE_2D,
              0,
              internalformat,
              texture.width,
              texture.height,
              0,
              format,
              type,
              texture.distributeTextureData ? null : texture.data
            );
          texture.destroyDataAfterUpload &&
            ((texture.data = null),
            delete texture.data,
            texture.onDataDestroyed?.());
        } else {
          let needsFlipY = !texture.compressed && !1 !== texture.flipY;
          if (
            (needsFlipY !== !!_state.flipY &&
              (_gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, needsFlipY),
              (_state.flipY = needsFlipY)),
            texture.image && texture.compressed)
          ) {
            let data = texture.image.compressedData;
            for (let i = 0; i < data.length; i++) {
              let size = texture.image.sizes[i];
              texture.image.uncompressed
                ? _gl.texImage2D(
                    _gl.TEXTURE_2D,
                    i,
                    _gl.RGBA,
                    size.width,
                    size.height,
                    0,
                    _gl.RGBA,
                    _gl.UNSIGNED_BYTE,
                    data[i]
                  )
                : _gl.compressedTexImage2D(
                    _gl.TEXTURE_2D,
                    i,
                    texture.image.gliFormat,
                    size.width || size,
                    size.height || size,
                    0,
                    data[i]
                  );
            }
            data.length = 0;
          } else if (
            texture.image &&
            !(texture.image instanceof HTMLVideoElement)
          )
            try {
              _gl.texImage2D(
                _gl.TEXTURE_2D,
                0,
                format,
                format,
                getType(texture),
                texture.image
              );
            } catch (e) {
              console.log("error loading texture", e, texture.image);
            }
          texture.distributeTextureData ||
            RenderCount.add("tex_upload", texture);
        }
        (texture.image || texture.data) &&
          texture.generateMipmaps &&
          !texture.compressed &&
          _gl.generateMipmap(_gl.TEXTURE_2D),
          (texture.needsUpdate = texture.needsReupload = !1),
          texture.onUpdate && texture.onUpdate();
      }),
      (this.manualUpdateDynamic = function (texture) {
        (void 0 === texture._gl || texture.needsReupload) &&
          this.upload(texture),
          _gl.bindTexture(_gl.TEXTURE_2D, texture._gl),
          updateDynamic(texture);
      }),
      (this.uploadAsync = function (texture) {
        let { format: format, type: type } = getFloatParams(texture);
        if (texture._uploadAsyncPromise) return texture._uploadAsyncPromise;
        (texture._uploadAsyncPromise = Promise.create()),
          RenderCount.add("tex_uploadAsync", texture),
          texture._gl ||
            ((texture.distributeTextureData = !0), _this.upload(texture));
        let pixelsPerChunk = texture.height / 4,
          dataPerChunk = texture.data.length / 4,
          i = 0,
          worker = new Render.Worker(function workerUploadAsync() {
            let pixelOffset = pixelsPerChunk * i,
              dataOffset = dataPerChunk * i,
              subarray = texture.data.subarray(
                dataOffset,
                dataOffset + dataPerChunk
              );
            !0 === texture.flipY
              ? _state.flipY ||
                (_gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, !0),
                (_state.flipY = !0))
              : _state.flipY &&
                (_gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, !1),
                (_state.flipY = !1)),
              _gl.bindTexture(_gl.TEXTURE_2D, texture._gl),
              _gl.texSubImage2D(
                _gl.TEXTURE_2D,
                0,
                0,
                pixelOffset,
                texture.width,
                pixelsPerChunk,
                format,
                type,
                subarray
              ),
              _gl.bindTexture(_gl.TEXTURE_2D, null),
              4 == ++i &&
                (worker.stop(), texture._uploadAsyncPromise.resolve());
          });
        return texture._uploadAsyncPromise;
      }),
      (this.destroy = function (texture) {
        texture._gl &&
          (_gl.deleteTexture(texture._gl),
          RenderCount.remove("texture"),
          RenderCount.add("tex_destroy", texture)),
          texture.data && ((texture.data = null), delete texture.data),
          delete texture._gl;
      });
  });
class RenderTarget {
  constructor(width, height, options = {}) {
    (this.width = width),
      (this.height = height),
      (this.options = options),
      (this.viewport = new Vector2(0, 0)),
      void 0 === options.minFilter && (options.minFilter = Texture.LINEAR),
      (this.stencil = "boolean" == typeof options.stencil && options.stencil),
      options.sharedRenderbuffer &&
        ((this.sharedRenderbuffer = !0),
        (this.clearDepth =
          "boolean" != typeof options.clearDepth || options.clearDepth),
        (this._depthBuffer = options.sharedRenderbuffer.rt._depthBuffer)),
      (this.texture = new Texture(null)),
      (this.texture.generateMipmaps = options.generateMipmaps),
      (this.texture.rt = this),
      (this.texture.width = width),
      (this.texture.height = height),
      (this.texture.minFilter = options.minFilter || Texture.LINEAR),
      (this.texture.magFilter = options.magFilter || Texture.LINEAR),
      (this.texture.wrapS = options.wrapS || Texture.CLAMP_TO_EDGE),
      (this.texture.wrapT = options.wrapT || Texture.CLAMP_TO_EDGE),
      (this.texture.format = options.format || Texture.RGBFormat),
      options.type && (this.texture.type = options.type),
      options.multisample &&
        (Renderer.type
          ? Renderer.type == Renderer.WEBGL2
          : Device.graphics.webgl.webgl2) &&
        ((options.multisample = !1),
        (this.multisample = !0),
        (this._rtMultisample = new RenderTarget(width, height, options)),
        (this._rtMultisample.internalMultisample = !0),
        (this._rtMultisample.parent = this),
        (this._rtMultisample._samplesAmount =
          void 0 === options.samplesAmount ? 100 : options.samplesAmount)),
      (this.isRT = !0);
  }
  setSize(width, height) {
    (this.width = width),
      (this.height = height),
      (this.texture.width = width),
      (this.texture.height = height),
      this.viewport.set(0, 0),
      RenderTarget.renderer.resize(this),
      !this.multisample ||
        (this._rtMultisample.width === width &&
          this._rtMultisample.height === height) ||
        (this._rtMultisample.destroy(),
        (this._rtMultisample = new RenderTarget(width, height, this.options)),
        (this._rtMultisample.internalMultisample = !0),
        (this._rtMultisample.parent = this),
        (this._rtMultisample._samplesAmount =
          void 0 === this.options.samplesAmount
            ? 100
            : this.options.samplesAmount));
  }
  clone() {
    return new RenderTarget(this.width, this.height, { ...this.options }).copy(
      this
    );
  }
  copy(source) {
    (this.width = source.width), (this.height = source.height);
    let options = { ...this.options };
    return (
      (this.options = options),
      this.viewport.copy(source.viewport),
      (this.stencil = source.stencil),
      source.sharedRenderbuffer &&
        ((this.sharedRenderbuffer = !0),
        (this.clearDepth = source.clearDepth),
        (this._depthBuffer = source._depthBuffer)),
      (this.texture = source.texture.clone()),
      source.multisample &&
        ((options.multisample = !1),
        (this.multisample = !0),
        (this._rtMultisample = new RenderTarget(
          this.width,
          this.height,
          options
        )),
        (this._rtMultisample.internalMultisample = !0),
        (this._rtMultisample.parent = this),
        (this._rtMultisample._samplesAmount =
          source._rtMultisample._samplesAmount)),
      this
    );
  }
  createDepthTexture() {
    return (
      (this.depth = new Texture(null)),
      (this.depth.generateMipmaps = !1),
      (this.depth.minFilter = Texture.NEAREST),
      (this.depth.magFilter = Texture.NEAREST),
      (this.depth.wrapS = Texture.CLAMP_TO_EDGE),
      (this.depth.wrapT = Texture.CLAMP_TO_EDGE),
      this._gl && RenderTarget.renderer.destroy(this),
      this.depth
    );
  }
  destroy() {
    RenderTarget.renderer.destroy(this);
  }
  upload() {
    this._gl || RenderTarget.renderer.upload(this),
      this._rtMultisample && this._rtMultisample.upload();
  }
}
class MultiRenderTarget extends RenderTarget {
  constructor(width, height, options = {}) {
    super(width, height, options),
      (this.multi = !0),
      (this.attachments = [this.texture]);
  }
}
class CubeRenderTarget extends RenderTarget {
  constructor(width, height, options = {}) {
    super(width, height, options), (this.activeFace = 0), (this.cube = !0);
  }
}
Class(
  function Shader(
    _vertexShader,
    _fragmentShader,
    _params,
    _onBeforeBuild,
    _postfix
  ) {
    "object" == typeof _vertexShader &&
      ((_fragmentShader = _vertexShader.uniforms),
      (_vertexShader = _vertexShader.name));
    const _this = this;
    (this.uniforms = Shader.createUniforms(this)),
      (this.side = Shader.FRONT_SIDE),
      (this.blending = Shader.NORMAL_BLENDING),
      (this.colorMask = Shader.COLOR_MASK_NONE),
      (this.polygonOffset = !1),
      (this.polygonOffsetFactor = 0),
      (this.polygonOffsetUnits = 1),
      (this.depthTest = !0),
      (this.depthWrite = !0),
      (this.ssReflections = _params?.ssReflections || !1),
      (this.depthFunc = Shader.DEPTH_FUNC_LESS),
      (this.stencilTest = !1),
      (this.stencilMask = !1),
      (this.wireframe = !1),
      (this.transparent = !1),
      (this.visible = !0),
      (this.persists = !1),
      (this.precision = "high"),
      (this.customCompile = _params?.customCompile || ""),
      (this.onBeforePrecompilePromise = Promise.create()),
      "string" != typeof _fragmentShader &&
        ((_params = _fragmentShader), (_fragmentShader = _vertexShader)),
      (_params = _params || {}),
      (_this.vsParam = _vertexShader),
      (_this.fsParam = _fragmentShader),
      (_this.params = _params),
      (_this.onBeforeBuild = _onBeforeBuild),
      (_this.vsName = _vertexShader),
      (_this.fsName = (_fragmentShader || _vertexShader) + (_postfix || "")),
      _params.vsName &&
        ((_this.vsName = _params.vsName), delete _params.vsName),
      _params.precision && (_this.precision = _params.precision),
      _params.receiveShadow &&
        ((_this.receiveLight = !0),
        World.RENDERER.shadows && (_this.precision = "high"));
    let vs = _vertexShader,
      fs = _fragmentShader;
    _params.uilFrom &&
      ((vs = _params.uilFrom), (fs = _params.uilFrom), delete _params.uilFrom),
      (_this.UILPrefix =
        _params.UILPrefix ||
        `${vs}/${fs}/${_params.unique ? _params.unique + "/" : ""}`),
      Shader.parseParams(_params, _this),
      Shader.renderer.findCachedProgram(_this) ||
        Shader.hasAlreadyPreProcessed(_this) ||
        Shader.runPreProcess(_this);
  },
  (_) => {
    function getLightingCode(_this) {
      if (
        (!_this.receiveShadow &&
          Shader.shouldReceiveShadow(_this) &&
          (_this.receiveShadow = !0),
        !_this.receiveLight || _this.isShadow)
      )
        return "";
      let numLights = Lighting.getLighting(_this).position.length / 4;
      return 0 == numLights
        ? Lighting.getShadowUniforms(_this)
        : [
            `#define NUM_LIGHTS ${numLights}`,
            "uniform lights {",
            `vec4 lightPos[${numLights}];`,
            `vec4 lightColor[${numLights}];`,
            `vec4 lightData[${numLights}];`,
            `vec4 lightData2[${numLights}];`,
            `vec4 lightData3[${numLights}];`,
            `vec4 lightProperties[${numLights}];`,
            "};",
          ].join("\n") + Lighting.getShadowUniforms(_this);
    }
    function setupssReflections(code, type, _this) {
      if ("vs" == type) {
        if (!code.includes("vec3 pos = position;"))
          throw `Shader ${_this.vsName} needs to have "vec3 pos = position;" in order for dynamic merging to work`;
        let vsDeferred =
            "\n            vPosDeferred = modelViewMatrix * vec4(pos, 1.);\n            vNormalDeferred = normalMatrix * normal;\n            vST = uv;\n            ",
          main = code.split("vec3 pos = position;");
        (main[1] = "\n" + vsDeferred + main[1]),
          (code = main.join("vec3 pos = position;"));
      }
      return code;
    }
    (Shader.FRONT_SIDE = "shader_front_side"),
      (Shader.BACK_SIDE = "shader_back_side"),
      (Shader.DOUBLE_SIDE = "shader_double_side"),
      (Shader.DOUBLE_SIDE_TRANSPARENCY = "shader_double_side_trasparency"),
      (Shader.ADDITIVE_BLENDING = "shader_additive_blending"),
      (Shader.NORMAL_BLENDING = "shader_normal_blending"),
      (Shader.PREMULTIPLIED_ALPHA_BLENDING =
        "shader_premultiplied_alpha_blending"),
      (Shader.ADDITIVE_COLOR_ALPHA = "shader_additive_color_alpha"),
      (Shader.MAX = "shader_max"),
      (Shader.MIN = "shader_min"),
      (Shader.CUSTOM_DEPTH = "shader_custom_depth"),
      (Shader.COLOR_MASK_RGB = "shader_colormask_rgb"),
      (Shader.COLOR_MASK_RGBA = "shader_colormask_rgba"),
      (Shader.COLOR_MASK_NONE = "shader_colormask_none"),
      (Shader.DEPTH_FUNC_NEVER = "shader_depth_func_never"),
      (Shader.DEPTH_FUNC_LESS = "shader_depth_func_less"),
      (Shader.DEPTH_FUNC_EQUAL = "shader_depth_func_equal"),
      (Shader.DEPTH_FUNC_LEQUAL = "shader_depth_func_lequal"),
      (Shader.DEPTH_FUNC_GREATER = "shader_depth_func_greater"),
      (Shader.DEPTH_FUNC_NOTEQUAL = "shader_depth_func_notequal"),
      (Shader.DEPTH_FUNC_GEQUAL = "shader_depth_func_gequal"),
      (Shader.DEPTH_FUNC_ALWAYS = "shader_depth_func_always"),
      (Shader.parseParams = function (_params, _this) {
        for (let key in _params)
          if ("receiveShadow" == key) _this.receiveShadow = _params[key];
          else if ("receiveLight" == key) _this.receiveLight = _params[key];
          else if (_params[key] && void 0 !== _params[key].value)
            window.UILStorage && UILStorage.hasData()
              ? ((_this.uniforms[key] =
                  UILStorage.parse(_this.UILPrefix + key, _params[key].value) ||
                  _params[key]),
                _params[key].ubo && (_this.uniforms[key].ubo = !0))
              : (_this.uniforms[key] = _params[key]);
          else {
            if ("unique" == key) continue;
            _this[key] = _params[key];
          }
      }),
      (Shader.runPreProcess = function (shader) {
        if (
          ((shader.vertexShader = Shader.process(
            Shaders.getShader(shader.vsParam + ".vs"),
            "vs",
            shader,
            shader.onBeforeBuild
          )),
          (shader.fragmentShader = Shader.process(
            Shaders.getShader(shader.fsParam + ".fs"),
            "fs",
            shader,
            shader.onBeforeBuild
          )),
          shader.vertexShader.includes("//js") && !window[shader.vsName])
        ) {
          let code = shader.vertexShader.split("\n"),
            adders = [];
          code.forEach((line) => {
            if (line.includes("//js")) {
              let name = line.split(" ")[2].replace(";", ""),
                value = line.split("//js ")[1].replace(";", "");
              adders.push((obj) => {
                obj[name] = { value: eval(value) };
              });
            } else if (line.includes("sampler2D")) {
              let name = line.split(" ")[2].replace(";", "");
              if (name.includes("sampler")) return;
              adders.push((obj) => {
                obj[name] = { value: null };
              });
            }
          }),
            (window[shader.vsName] = function (_mesh, _shader) {
              let uniforms = {};
              adders.forEach((addTo) => addTo(uniforms)),
                _shader.addUniforms(uniforms);
            });
        }
      }),
      (Shader.process = function (code, type, _this, _onBeforeBuild) {
        const WEBGL2 = Renderer.type == Renderer.WEBGL2;
        if (!code)
          throw "No shader found! " + _this.vsName + " | " + _this.fsName;
        const externalOES =
            code.includes("samplerExternalOES") &&
            window.AURA &&
            "android" == Device.system.os,
          standardDeriv = !WEBGL2 && code.includes(["fwidth", "dFdx", "dFdy"]),
          drawBuffers =
            !WEBGL2 &&
            code.includes(["gl_FragData", "#drawbuffer"]) &&
            window.World &&
            World.NUKE.useDrawBuffers;
        let levelOfDetail =
          !WEBGL2 &&
          code.includes([
            "textureGrad",
            "textureProjGrad",
            "texture2DGrad",
            "textureCubeGrad",
            "texture2DProjGrad",
          ]);
        levelOfDetail ||
          WEBGL2 ||
          "fs" !== type ||
          (levelOfDetail = code.includes([
            "textureLod",
            "texture2DLod",
            "textureCubeLod",
            "texture2DProjLod",
          ]));
        const layoutsDefined = code.includes("layout") || _this.ssReflections;
        let header;
        if (
          ((header =
            "vs" == type
              ? [
                  "#version 300 es",
                  externalOES
                    ? "#extension GL_OES_EGL_image_external_essl3 : require"
                    : "",
                  levelOfDetail
                    ? "#extension GL_EXT_shader_texture_lod : enable"
                    : "",
                  `precision ${_this.precision}p float;`,
                  `precision ${_this.precision}p int;`,
                  WEBGL2 ? `precision ${_this.precision}p sampler3D;` : "",
                  WEBGL2 ? `precision ${_this.precision}p usampler2D;` : "",
                  WEBGL2 ? `precision ${_this.precision}p isampler2D;` : "",
                  "attribute vec2 uv;",
                  "attribute vec3 position;",
                  "attribute vec3 normal;",
                  "uniform mat3 normalMatrix;",
                  "uniform mat4 modelMatrix;",
                  "uniform mat4 modelViewMatrix;",
                  "uniform global {",
                  "mat4 projectionMatrix;",
                  "mat4 viewMatrix;",
                  "vec3 cameraPosition;",
                  "vec4 cameraQuaternion;",
                  "vec2 resolution;",
                  "float time;",
                  "float timeScale;",
                  "};",
                ].join("\n")
              : [
                  "#version 300 es",
                  externalOES
                    ? "#extension GL_OES_EGL_image_external_essl3 : require"
                    : "",
                  standardDeriv
                    ? "#extension GL_OES_standard_derivatives : enable"
                    : "",
                  drawBuffers ? "#extension GL_EXT_draw_buffers : require" : "",
                  levelOfDetail
                    ? "#extension GL_EXT_shader_texture_lod : enable"
                    : "",
                  `precision ${_this.precision}p float;`,
                  `precision ${_this.precision}p int;`,
                  WEBGL2 ? `precision ${_this.precision}p sampler3D;` : "",
                  WEBGL2 ? `precision ${_this.precision}p usampler2D;` : "",
                  WEBGL2 ? `precision ${_this.precision}p isampler2D;` : "",
                  "uniform mat3 normalMatrix;",
                  "uniform mat4 modelMatrix;",
                  "uniform mat4 modelViewMatrix;",
                  "uniform global {",
                  "mat4 projectionMatrix;",
                  "mat4 viewMatrix;",
                  "vec3 cameraPosition;",
                  "vec4 cameraQuaternion;",
                  "vec2 resolution;",
                  "float time;",
                  "float timeScale;",
                  "};",
                  layoutsDefined ? "" : "out vec4 FragColor;",
                ].join("\n")),
          (header += "\n__ACTIVE_THEORY_LIGHTS__\n\n"),
          window.AURA && (header += "#define AURA\n"),
          _this.defines &&
            _this.defines.forEach(
              (d) => (header += `#define ${d.toUpperCase()}\n`)
            ),
          _onBeforeBuild && (code = _onBeforeBuild(code, type)),
          _this.ssReflections)
        ) {
          let GIVaryings = [
            "uniform float ssReflectivity;",
            "uniform float ssIORrefl;",
            "uniform float ssRougness;",
            "uniform float ssgiIntensity;",
            "uniform sampler2D tReflectivity;",
            "uniform sampler2D tRoughness;",
            "varying vec4 vPosDeferred;",
            "varying vec3 vNormalDeferred;",
            "varying vec2 vST;",
          ].join("\n");
          header += GIVaryings;
        }
        let split = code.split("\n");
        for (let i = split.length - 1; i > -1; i--) {
          let line = split[i];
          if (line.includes("uniform sampler2D")) {
            let name = line.split("sampler2D ")[1].replace(";", "").trim();
            _this.uniforms[name] || (_this.uniforms[name] = { value: null });
          }
        }
        if (((code = header + code), _this.ssReflections && "fs" == type)) {
          let buffersDeferred =
              "\n            float ssReflectionMap = texture(tReflectivity, vST).r;\n            float ssRougnessMap = texture(tRoughness, vST).r;\n            #drawbuffer PositionLayer gl_FragColor = vPosDeferred;\n            #drawbuffer NormalsLayer gl_FragColor = vec4(vNormalDeferred, 1.);\n            #drawbuffer ReflectivityLayer gl_FragColor = vec4(ssIORrefl, ssReflectivity * ssReflectionMap, ssRougness * ssRougnessMap, ssgiIntensity);\n            ",
            main = code.split("main() {");
          (main[1] = "\n" + buffersDeferred + main[1]),
            (code = main.join("main() {"));
        }
        return code;
      });
    const prototype = Shader.prototype;
    (prototype.copyUniformsTo = function (shader, linked, ignore) {
      for (let key in this.uniforms)
        void 0 !== this.uniforms[key] &&
          ((ignore && ignore.includes?.(key)) ||
            (shader.uniforms[key] = linked
              ? this.uniforms[key]
              : {
                  type: this.uniforms[key].type,
                  value: this.uniforms[key].value,
                }));
    }),
      (prototype.replicateUniformsTo = function (shader) {
        (shader.uniforms = this.uniforms),
          (shader._uniformKeys = this._uniformKeys),
          (shader._uniformValues = this._uniformValues);
      }),
      (prototype.addUniforms = function (uniforms) {
        uniforms.UILPrefix &&
          ((this.UILPrefix = uniforms.UILPrefix), delete uniforms.UILPrefix);
        for (let key in uniforms)
          (this.hotReloading && this.uniforms[key]) ||
            (this.uniforms[key] = uniforms[key]);
      }),
      (prototype.draw = function (mesh, geom) {
        this.receiveLight && !this.__lighting && Lighting.getLighting(this),
          Shader.renderer.draw(this, mesh, geom);
      }),
      (prototype.upload = function (mesh, geom) {
        !this.receiveShadow &&
          Shader.shouldReceiveShadow(this) &&
          (this.receiveShadow = !0),
          Shader.renderer.upload(this, mesh, geom),
          this.receiveShadow &&
            !this.shadow &&
            Lighting.initShadowShader(this, mesh);
      }),
      (prototype.destroy = function () {
        this.persists ||
          (Shader.renderer.destroy(this), this.shadow && this.shadow.destroy()),
          this.receiveLight && Lighting.destroyShader(this);
      }),
      (prototype.onBeforeCompile = function (code, type) {
        const WEBGL2 = Renderer.type == Renderer.WEBGL2;
        "}" != (code = code.trim())[code.length - 1] && (code += "\n}");
        let p = this.mesh,
          scene = World.SCENE;
        for (; p; ) p instanceof Scene && (scene = p), (p = p._parent);
        scene.nuke && scene.nuke.onBeforeShaderCompile
          ? scene.nuke.onBeforeShaderCompile(this.mesh)
          : this.onBeforePrecompilePromise.resolve(),
          this.receiveShadow && (this.receiveLight = !0);
        let varyings = [],
          uniforms = [];
        this.ssReflections && (code = setupssReflections(code, type, this)),
          (code = code.split("\n")).forEach((line, index) => {
            "fs" == type &&
              line.includes("#drawbuffer") &&
              (line.includes("#drawbuffer Color")
                ? (code[index] = line.replace("#drawbuffer Color", ""))
                : (code[index] = "")),
              line.includes("varying") && varyings.push(line.trim()),
              line.includes("uniform") && uniforms.push(line.trim());
          }),
          (code = code.join("\n"));
        const process = function (array) {
          let replace,
            counts = [];
          array.forEach((value) => {
            let count = 0;
            array.forEach((v2) => {
              value == v2 && count++;
            }),
              count > 1 &&
                (replace || (replace = []),
                replace.includes(value) ||
                  (replace.push(value), counts.push(count)));
          }),
            replace &&
              replace.forEach((value, i) => {
                let count = counts[i];
                for (let j = 0; j < count - 1; j++) {
                  let index = code.lastIndexOf(value);
                  code =
                    code.substring(0, index) +
                    code.substring(index + value.length);
                }
              });
        };
        process(varyings),
          process(uniforms),
          "fs" == type &&
            (WEBGL2
              ? code.includes("gl_FragColor") &&
                (code = code.replace(/gl_FragColor/g, "FragColor"))
              : code.includes("#applyShadow") &&
                (code = code.replace("#applyShadow", ""))),
          (code = code.replace(
            "__ACTIVE_THEORY_LIGHTS__",
            getLightingCode(this)
          )),
          "fs" == type &&
            code.includes("SHADOW_MAPS") &&
            (code = require("GLSLOptimizer")(
              code.replaceAll("SHADOW_COUNT", Lighting.getShadowCount(this))
            )),
          this.preCompile && (code = this.preCompile(code, type));
        let converter = require("ShaderCode");
        return (code = WEBGL2
          ? converter.convertWebGL2(code, type)
          : converter.convertWebGL1(code, type));
      }),
      (prototype.set = function (key, value, ref) {
        let _this = ref || this;
        return _this.uniforms[key]
          ? (void 0 !== value &&
              (TweenManager.clearTween(_this.uniforms[key]),
              (_this.uniforms[key].value = value),
              _this.ubo && (_this.ubo.needsUpdate = !0)),
            _this.uniforms[key].value)
          : console.warn(`No key ${key} found on shader`, _this);
      }),
      (prototype.get = function (key, ref) {
        let _this = ref || this;
        return _this.uniforms[key] && _this.uniforms[key].value;
      }),
      (prototype.tween = function (
        key,
        value,
        time,
        ease,
        delay,
        callback,
        update,
        scaledTime
      ) {
        return "number" == typeof value
          ? tween(
              this.uniforms[key],
              { value: value },
              time,
              ease,
              delay,
              callback,
              update,
              null,
              scaledTime
            )
          : tween(
              this.uniforms[key].value,
              value,
              time,
              ease,
              delay,
              callback,
              update,
              null,
              scaledTime
            );
      }),
      (prototype.clone = function (noShadows, postfix) {
        const _this = this;
        noShadows && (_this.params.receiveShadow = !1);
        let shader = new Shader(
          _this.vsParam,
          _this.fsParam,
          _this.params,
          null,
          postfix
        );
        for (let key in _this)
          key.includes(["vsName", "fsName", "uniforms", "_uniform", "_gl"]) ||
            "function" == typeof _this[key] ||
            (shader[key] = _this[key]);
        for (let key in _this.uniforms)
          shader.uniforms[key] = {
            type: _this.uniforms[key].type,
            value: _this.uniforms[key].value,
          };
        return shader;
      }),
      (prototype.resetProgram = function () {
        this.destroy(),
          (this.vertexShader =
            this.restoreVS ||
            Shader.process(
              Shaders.getShader(this.vsName + ".vs"),
              "vs",
              this,
              this.onBeforeBuild
            )),
          (this.fragmentShader =
            this.restoreFS ||
            Shader.process(
              Shaders.getShader(this.fsName + ".fs"),
              "fs",
              this,
              this.onBeforeBuild
            ));
      });
    var _shaderShadowMap = {},
      _emptyShadowMap;
    Object.defineProperty(prototype, "receiveShadow", {
      set: function (v) {
        (_shaderShadowMap[this.vsName + "_" + this.fsName] = v),
          (this._receiveShadow = v),
          v &&
            !this.uniforms.shadowMap &&
            (_emptyShadowMap || (_emptyShadowMap = [Utils3D.getEmptyTexture()]),
            (this.uniforms.shadowMap = { value: _emptyShadowMap }));
      },
      get: function () {
        return this._receiveShadow;
      },
    });
    let shaders = {};
    (Shader.hasAlreadyPreProcessed = function (shader) {
      let key =
        shader.vsName + "_" + shader.vsName + "_" + shader.customCompile;
      return shaders[key];
    }),
      (Shader.registerPreProcess = function (shader) {
        let key =
          shader.vsName + "_" + shader.vsName + "_" + shader.customCompile;
        shaders[key] = !0;
      }),
      (Shader.shouldReceiveShadow = function (shader) {
        return _shaderShadowMap[shader.vsName + "_" + shader.fsName];
      });
  }
),
  (Shader.createUniforms = function (shader) {
    let uniforms = {},
      handler = {
        set(target, property, value) {
          (target[property] = value),
            (shader._uniformKeys.length = 0),
            (shader._uniformValues.length = 0);
          for (let key in uniforms)
            shader._uniformKeys.push(key),
              shader._uniformValues.push(uniforms[key]);
          return !0;
        },
      };
    return (
      (shader._uniformValues = []),
      (shader._uniformKeys = []),
      new Proxy(uniforms, handler)
    );
  }),
  Class(function ShaderVariants(_params = {}) {
    const _this = this;
    var _target,
      _destination,
      _map = {};
    const LERP = _params.lerp || 1;
    function generate(key, shaderOrUniforms) {
      let uniforms,
        prefix =
          _this.parent.uilInput?.prefix ||
          Utils.getConstructorName(_this.parent);
      (prefix += "_shaderVariants_" + key),
        (uniforms =
          Array.isArray(shaderOrUniforms) || shaderOrUniforms.uniforms
            ? shaderOrUniforms.uniforms
            : shaderOrUniforms);
      for (let key in uniforms) {
        let uni = uniforms[key];
        "string" == typeof uni.value && (uni.value = Number(uni.value));
      }
      return [uniforms, prefix];
    }
    _this.parent.startRender(function loop() {
      _destination && ShaderUIL.lerpShader(_destination, _target, LERP);
    }),
      (_this.parent.createShaderOverride = function createShaderOverride(
        key,
        inUniforms,
        active
      ) {
        if (inUniforms.uniforms)
          throw "Using an entire shader for createShaderOverride is not what you want. Just pass in the uniforms that are meant to be overriden.";
        let [uniforms, prefix] = generate(key, inUniforms),
          shader = ShaderUIL.createOverride(
            prefix,
            uniforms,
            null,
            null,
            !active
          );
        ShaderUIL.add(shader, _this.parent.uilFolder).setLabel(
          `Shader: ${key}`
        ),
          active &&
            _this.parent.startRender((_) => {
              ShaderUIL.lerpShader(shader, uniforms, 1);
            });
      }),
      (_this.parent.createShaderVariant = function createShaderVariant(
        key,
        shaderOrUniforms
      ) {
        let [uniforms, prefix] = generate(key, shaderOrUniforms),
          shader = ShaderUIL.createOverride(prefix, uniforms, null, null, !0);
        ShaderUIL.add(shader, _this.parent.uilFolder).setLabel(
          `Shader: ${key}`
        ),
          (_map[key] = shader),
          _target || (_target = shader),
          _destination ||
            (_destination = ShaderUIL.createOverride(
              "OverrideDestination" + Utils.uuid(),
              uniforms,
              null,
              null
            ));
      }),
      (_this.parent.setShaderVariant = function setShaderVariant(key) {
        if (!(_target = _map[key])) throw `No Shader variant ${key}`;
      });
  });
class Texture {
  constructor(img) {
    (this.magFilter = Texture.LINEAR),
      (this.minFilter = Texture.LINEAR_MIPMAP),
      (this.format = Texture.RGBAFormat),
      (this.wrapS = this.wrapT = Texture.CLAMP_TO_EDGE),
      (this._image = img),
      (this.needsUpdate = !0),
      (this.generateMipmaps = !0),
      (this.anisotropy = 1),
      (this.type = Texture.UNSIGNED_BYTE),
      (this.isTexture = !0),
      img && img.onCreateTexture && img.onCreateTexture(this);
  }
  set image(img) {
    (this._image = img),
      img && img.onCreateTexture && img.onCreateTexture(this);
  }
  get image() {
    return this._image;
  }
  upload() {
    this._gl || Texture.renderer.upload(this);
  }
  destroy() {
    Texture.renderer.destroy(this), (this._image = null);
  }
  clone() {
    let texture = new Texture(this.img);
    return (
      (texture.format = this.format),
      (texture.type = this.type),
      (texture.anisotropy = this.anisotropy),
      (texture.wrapS = this.wrapS),
      (texture.wrapT = this.wrapT),
      (texture.generateMipmaps = this.generateMipmaps),
      (texture.minFilter = this.minFilter),
      (texture.magFilter = this.magFilter),
      texture
    );
  }
}
class DataTexture extends Texture {
  constructor(data, width, height, format, type, filter = null) {
    super(),
      format && (this.format = format),
      (this.width = width),
      (this.height = height),
      (this.data = data),
      (this.minFilter = this.magFilter = filter || Texture.NEAREST),
      (this.generateMipmaps = !1),
      (this.type = type || Texture.FLOAT),
      (this.isDataTexture = !0),
      (this.destroyDataAfterUpload = !1);
  }
  uploadAsync() {
    return Texture.renderer.uploadAsync(this);
  }
}
class Texture3D extends Texture {
  constructor(image, width, height, depth, format, type, filter = null) {
    super(),
      (this.format = format || Texture.RGBAFormat),
      (this.width = width),
      (this.height = height),
      (this.depth = depth),
      (this.image = image),
      (this.minFilter = this.magFilter = filter || Texture.LINEAR),
      (this.wrapS = this.wrapT = this.wrapR = Texture.CLAMP_TO_EDGE),
      (this.generateMipmaps = !1),
      (this.type = type || Texture.FLOAT),
      (this.isTexture3D = !0);
  }
}
(Texture.NEAREST = "texture_nearest"),
  (Texture.CLAMP_TO_EDGE = "texture_clamp"),
  (Texture.REPEAT = "texture_repeat"),
  (Texture.MIRROR_REPEAT = "texture_mirror_repeat"),
  (Texture.LINEAR = "texture_linear"),
  (Texture.LINEAR_MIPMAP = "texture_linear_mip"),
  (Texture.LINEAR_MIPMAP_NEAREST = "texture_linear_mip_nearest"),
  (Texture.NEAREST_MIPMAP = "texture_nearest_mip"),
  (Texture.RFormat = "texture_rFormat"),
  (Texture.RGFormat = "texture_rgFormat"),
  (Texture.RGBFormat = "texture_rgbFormat"),
  (Texture.RGBAFormat = "texture_rgbaFormat"),
  (Texture.UNSIGNED_BYTE = "texture_unsigned_byte"),
  (Texture.DEPTH = "texture_depth"),
  (Texture.FLOAT = "texture_float"),
  (Texture.HALF_FLOAT = "texture_half_float"),
  (Texture.UNSIGNED_INTEGER = "texture_unsigned_integer"),
  (Texture.INTEGER = "texture_integer"),
  Module(function GLSLOptimizer() {
    this.exports = function (code) {
      return (function unrollLoops(string) {
        return string.replace(
          /#pragma unroll_loop[\s]+?for \(int i \= (\d+)\; i < (\d+)\; i\+\+\) \{([\s\S]+?)(?=\})\}/g,
          function replace(match, start, end, snippet) {
            let unroll = "";
            for (let i = parseInt(start); i < parseInt(end); i++)
              unroll += snippet.replace(/\[i\]/g, "[" + i + "]");
            return unroll;
          }
        );
      })(code);
    };
  }),
  Module(function GLTypes() {
    function getFormat(texture) {
      let _gl = Renderer.context,
        integer =
          texture.type === Texture.UNSIGNED_INTEGER ||
          texture.type === Texture.INTEGER;
      switch (texture.format) {
        case Texture.RGBAFormat:
          return integer ? _gl.RGBA_INTEGER : _gl.RGBA;
        case Texture.RGBFormat:
          return integer ? _gl.RGB_INTEGER : _gl.RGB;
        case Texture.RGFormat:
          return integer ? _gl.RG_INTEGER : _gl.RG;
        case Texture.RFormat:
          return integer ? _gl.RED_INTEGER : _gl.RED;
      }
    }
    function getInternalFormat(texture) {
      let _gl = Renderer.context;
      if (Renderer.type !== Renderer.WEBGL2)
        return texture.format === Texture.RGBAFormat ? _gl.RGBA : _gl.RGB;
      switch (texture.format) {
        case Texture.RGBAFormat:
          switch (texture.type) {
            case Texture.FLOAT:
              return _gl.RGBA32F;
            case Texture.HALF_FLOAT:
              return _gl.RGBA16F;
            case Texture.UNSIGNED_INTEGER:
              return _gl.RGBA32UI;
            case Texture.INTEGER:
              return _gl.RGBA32I;
            case Texture.UNSIGNED_BYTE:
              return _gl.RGBA8;
          }
          break;
        case Texture.RGBFormat:
          switch (texture.type) {
            case Texture.FLOAT:
              return _gl.RGB32F;
            case Texture.HALF_FLOAT:
              return _gl.RGB16F;
            case Texture.UNSIGNED_INTEGER:
              return _gl.RGB32UI;
            case Texture.INTEGER:
              return _gl.RGB32I;
            case Texture.UNSIGNED_BYTE:
              return _gl.RGB8;
          }
          break;
        case Texture.RGFormat:
          switch (texture.type) {
            case Texture.FLOAT:
              return _gl.RG32F;
            case Texture.HALF_FLOAT:
              return _gl.RG16F;
            case Texture.UNSIGNED_INTEGER:
              return _gl.RG32UI;
            case Texture.INTEGER:
              return _gl.RG32I;
            case Texture.UNSIGNED_BYTE:
              return _gl.RG8;
          }
          break;
        case Texture.RFormat:
          switch (texture.type) {
            case Texture.FLOAT:
              return _gl.R32F;
            case Texture.HALF_FLOAT:
              return _gl.R16F;
            case Texture.UNSIGNED_INTEGER:
              return _gl.R32UI;
            case Texture.INTEGER:
              return _gl.R32I;
            case Texture.UNSIGNED_BYTE:
              return _gl.R8;
          }
      }
    }
    function getType(texture) {
      let _gl = Renderer.context;
      switch (texture.type) {
        case Texture.FLOAT:
          return _gl.FLOAT;
        case Texture.HALF_FLOAT:
          return Renderer.type == Renderer.WEBGL2
            ? _gl.HALF_FLOAT
            : Renderer.extensions.halfFloat.HALF_FLOAT_OES;
        case Texture.UNSIGNED_INTEGER:
          return _gl.UNSIGNED_INT;
        case Texture.INTEGER:
          return _gl.INT;
        default:
          return _gl.UNSIGNED_BYTE;
      }
    }
    this.exports = {
      getFormat: getFormat,
      getInternalFormat: getInternalFormat,
      getProperty: function getProperty(property) {
        let _gl = Renderer.context;
        switch (property) {
          case Texture.NEAREST:
            return _gl.NEAREST;
          case Texture.LINEAR:
            return _gl.LINEAR;
          case Texture.LINEAR_MIPMAP:
            return _gl.LINEAR_MIPMAP_LINEAR;
          case Texture.NEAREST_MIPMAP:
            return _gl.NEAREST_MIPMAP_LINEAR;
          case Texture.LINEAR_MIPMAP_NEAREST:
            return _gl.LINEAR_MIPMAP_NEAREST;
          case Texture.CLAMP_TO_EDGE:
            return _gl.CLAMP_TO_EDGE;
          case Texture.REPEAT:
            return _gl.REPEAT;
          case Texture.MIRROR_REPEAT:
            return _gl.MIRRORED_REPEAT;
        }
      },
      getType: getType,
      getFloatParams: function getFloatParams(texture) {
        return {
          internalformat: getInternalFormat(texture),
          format: getFormat(texture),
          type: getType(texture),
        };
      },
    };
  }),
  Module(function ShaderCode() {
    let textureExpression = /texture(2D|Cube)?(\w+)?\s*\(/g;
    function removeUBO(code, name) {
      let uniforms = code.split(`uniform ${name} {`)[1];
      (uniforms = uniforms.split("};")[0]),
        (uniforms = uniforms.split("\n")),
        uniforms.forEach((u) => {
          (u = u.trim()).length && (code = code.replace(u, "uniform " + u));
        });
      let split = code.split(`uniform ${name} {`);
      return (
        (split[1] = split[1].replace("};", "")),
        (code = (code = split.join("")).replace(`uniform ${name} {`, ""))
      );
    }
    this.exports = {
      convertWebGL1: function convertWebGL1(code, type) {
        return (
          (code = (code = code.replace("#version 300 es", "")).replace(
            "out vec4 FragColor;",
            ""
          )).includes("samplerExternalOES") &&
            (code = code.replace("samplerExternalOES", "sampler2D")),
          (code = code.replace(
            textureExpression,
            function (match, samplerType, suffix = "", offset, origCode) {
              if (!samplerType) {
                let name = origCode
                  .substring(offset + match.length)
                  .split(",", 1)[0]
                  ?.trim();
                name &&
                  (samplerType = new RegExp(`sampler(\\w+)\\s+${name}`).exec(
                    origCode
                  )?.[1]),
                  samplerType || (samplerType = "2D");
              }
              if (
                (suffix.endsWith("EXT") && (suffix = suffix.slice(0, -3)),
                "vs" === type && ["Lod", "ProjLod"].includes(suffix))
              )
                return `texture${samplerType}${suffix}(`;
              if (["Lod", "Grad", "ProjLod", "ProjGrad"].includes(suffix)) {
                if (Renderer.extensions.lod)
                  return `texture${samplerType}${suffix}EXT(`;
                suffix.endsWith("Lod") && (suffix = suffix.slice(0, -3));
              }
              return `texture${samplerType}${suffix}(`;
            }
          )).includes("uniform global {") && (code = removeUBO(code, "global")),
          code.includes("uniform ubo {") && (code = removeUBO(code, "ubo")),
          code.includes("uniform lights {") &&
            (code = removeUBO(code, "lights")),
          code
        );
      },
      convertWebGL2: function convertWebGL2(code, type) {
        return (
          !(code = (code =
            "vs" == type
              ? (code = code.replace(/attribute/g, "in")).replace(
                  /varying/g,
                  "out"
                )
              : code.replace(/varying/g, "in")).replace(
            textureExpression,
            function (match, samplerType, suffix = "") {
              return (
                suffix.endsWith("EXT") && (suffix = suffix.slice(0, -3)),
                `texture${suffix}(`
              );
            }
          )).includes("samplerExternalOES") ||
            ("android" == Device.system.os && window.AURA) ||
            (code = code.replace("samplerExternalOES", "sampler2D")),
          Renderer.UBO
            ? (code.includes("uniform global {") &&
                (code = code.replace(
                  "uniform global",
                  "layout(std140) uniform global"
                )),
              code.includes("uniform ubo {") &&
                (code = code.replace(
                  "uniform ubo",
                  "layout(std140) uniform ubo"
                )),
              Lighting.UBO
                ? code.includes("uniform lights {") &&
                  (code = code.replace(
                    "uniform lights",
                    "layout(std140) uniform lights"
                  ))
                : code.includes("uniform lights {") &&
                  (code = removeUBO(code, "lights")))
            : (code.includes("uniform global {") &&
                (code = removeUBO(code, "global")),
              code.includes("uniform ubo {") && (code = removeUBO(code, "ubo")),
              code.includes("uniform lights {") &&
                (code = removeUBO(code, "lights"))),
          code
        );
      },
    };
  });
class UBO {
  constructor(location, gl = Renderer.context) {
    (this.gl = gl), (this.arrays = []);
    for (let i = 0; i < 30; i++) this.arrays.push([]);
    (this.arrayIndex = 0),
      (this.objects = []),
      (this.location = location),
      (this.data = null),
      (this.lastUpdate = 0);
  }
  _getSize(uniform) {
    let obj = uniform.value;
    return Array.isArray(obj)
      ? uniform.components
        ? (obj.length / uniform.components) * 16
        : 16 * obj.length
      : obj instanceof Vector2
      ? 8
      : obj instanceof Vector3 || obj instanceof Vector4 || obj instanceof Color
      ? 16
      : obj instanceof Matrix4
      ? 64
      : obj instanceof Matrix3
      ? 48
      : obj instanceof Quaternion
      ? 16
      : 4;
  }
  _getValues(uniform) {
    let obj = uniform.value;
    return Array.isArray(obj)
      ? obj
      : obj instanceof Vector2
      ? this._array(obj.x, obj.y)
      : obj instanceof Vector3
      ? this._array(obj.x, obj.y, obj.z)
      : obj instanceof Matrix4 || obj instanceof Matrix3
      ? obj.elements
      : obj instanceof Color
      ? this._array(obj.r, obj.g, obj.b)
      : obj instanceof Quaternion
      ? this._array(obj.x, obj.y, obj.z, obj.w)
      : this._array(obj);
  }
  _array() {
    this.arrayIndex++ >= this.arrays.length - 1 && (this.arrayIndex = 0);
    let array = this.arrays[this.arrayIndex];
    return (array.length = 0), array.push.apply(array, arguments), array;
  }
  clear() {
    for (let i = 0; i < this.arrays.length; i++) this.arrays[i].length = 0;
  }
  calculate() {
    let len = this.objects.length,
      chunk = 16,
      tsize = 0,
      offset = 0,
      size = 0;
    for (let i = 0; i < len; i++) {
      let obj = this.objects[i];
      (size = this._getSize(obj)),
        (tsize = chunk - size),
        tsize < 0 && chunk < 16
          ? ((offset += chunk),
            i > 0 && (this.objects[i - 1].chunkLen += chunk),
            (chunk = 16))
          : (tsize < 0 && 16 == chunk) ||
            (0 == tsize ? (chunk = 16) : (chunk -= size)),
        (obj.offset = offset / 4),
        (obj.chunkLen = size / 4),
        (obj.dataLen = size / 4),
        (offset += size);
    }
    return (
      offset % 16 != 0 &&
        ((this.objects[this.objects.length - 1].chunkLen += chunk / 4),
        (offset += chunk)),
      offset / 4
    );
  }
  compileData() {
    let i,
      array = this._array(),
      len = this.calculate();
    for (i = 0; i < len; i++) array[i] = 0;
    for (i = 0; i < this.objects.length; i++) {
      let obj = this.objects[i],
        values = this._getValues(obj);
      for (let j = 0; j < values.length; j++) array[obj.offset + j] = values[j];
    }
    return array;
  }
  upload() {
    if (this.data) return;
    let gl = Renderer.context,
      array = this.compileData();
    array.length &&
      ((this.data = new Float32Array(array)),
      (this.buffer = gl.createBuffer()),
      gl.bindBuffer(gl.UNIFORM_BUFFER, this.buffer),
      gl.bufferData(gl.UNIFORM_BUFFER, this.data, gl.DYNAMIC_DRAW),
      gl.bindBuffer(gl.UNIFORM_BUFFER, null),
      gl.bindBufferBase(gl.UNIFORM_BUFFER, this.location, this.buffer));
  }
  bind(program, name) {
    this.data || this.upload(), this.needsUpdate && this.update();
    let location,
      gl = Renderer.context;
    (location =
      program == this.lastProgram &&
      name == this.lastName &&
      void 0 !== this.lastLocation
        ? this.lastLocation
        : gl.getUniformBlockIndex(program, name)),
      location > 99999 ||
        -1 == location ||
        (gl.uniformBlockBinding(program, location, this.location),
        gl.bindBufferBase(gl.UNIFORM_BUFFER, this.location, this.buffer),
        (this.lastProgram = program),
        (this.lastName = name),
        (this.lastLocation = location));
  }
  update() {
    if ((this.data || this.upload(), !this.data)) return;
    let gl = Renderer.context,
      array = this.compileData();
    array.length != this.data.length &&
      ((this.data = new Float32Array(array)), this.upload()),
      this.data.set(array),
      gl.bindBuffer(gl.UNIFORM_BUFFER, this.buffer),
      gl.bufferSubData(gl.UNIFORM_BUFFER, 0, this.data),
      gl.bindBuffer(gl.UNIFORM_BUFFER, null),
      (this.needsUpdate = !1);
  }
  unbind() {}
  push() {
    if (this.data) throw "Can't modify UBO after initial upload!";
    for (let i = 0; i < arguments.length; i++) this.objects.push(arguments[i]);
  }
  destroy() {
    this.gl.deleteBuffer(this.buffer);
  }
}
class VAO {
  constructor(gl) {
    (this.gl = gl),
      (this.WEBGL2 = Renderer.type == Renderer.WEBGL2),
      this.WEBGL2
        ? (this.vao = gl.createVertexArray())
        : (this.vao = Renderer.extensions.VAO.createVertexArrayOES());
  }
  bind() {
    const gl = this.gl;
    this.WEBGL2
      ? gl.bindVertexArray(this.vao)
      : Renderer.extensions.VAO.bindVertexArrayOES(this.vao);
  }
  unbind() {
    const gl = this.gl;
    this.WEBGL2
      ? gl.bindVertexArray(null)
      : Renderer.extensions.VAO.bindVertexArrayOES(null);
  }
  destroy() {
    const gl = this.gl;
    this.WEBGL2
      ? gl.deleteVertexArray(this.vao)
      : Renderer.extensions.VAO.deleteVertexArrayOES(this.vao),
      (this.vao = null);
  }
}
class BoxGeometry extends Geometry {
  constructor(
    width = 1,
    height = 1,
    depth = 1,
    widthSegments = 1,
    heightSegments = 1,
    depthSegments = 1
  ) {
    super(),
      (widthSegments = Math.floor(widthSegments)),
      (heightSegments = Math.floor(heightSegments)),
      (depthSegments = Math.floor(depthSegments));
    let indices = [],
      vertices = [],
      normals = [],
      uvs = [],
      numberOfVertices = 0;
    function buildPlane(
      u,
      v,
      w,
      udir,
      vdir,
      width,
      height,
      depth,
      gridX,
      gridY,
      materialIndex
    ) {
      let ix,
        iy,
        segmentWidth = width / gridX,
        segmentHeight = height / gridY,
        widthHalf = width / 2,
        heightHalf = height / 2,
        depthHalf = depth / 2,
        gridX1 = gridX + 1,
        gridY1 = gridY + 1,
        vertexCounter = 0,
        vector = new Vector3();
      for (iy = 0; iy < gridY1; iy++) {
        let y = iy * segmentHeight - heightHalf;
        for (ix = 0; ix < gridX1; ix++) {
          let x = ix * segmentWidth - widthHalf;
          (vector[u] = x * udir),
            (vector[v] = y * vdir),
            (vector[w] = depthHalf),
            vertices.push(vector.x, vector.y, vector.z),
            (vector[u] = 0),
            (vector[v] = 0),
            (vector[w] = depth > 0 ? 1 : -1),
            normals.push(vector.x, vector.y, vector.z),
            uvs.push(ix / gridX),
            uvs.push(1 - iy / gridY),
            (vertexCounter += 1);
        }
      }
      for (iy = 0; iy < gridY; iy++)
        for (ix = 0; ix < gridX; ix++) {
          let a = numberOfVertices + ix + gridX1 * iy,
            b = numberOfVertices + ix + gridX1 * (iy + 1),
            c = numberOfVertices + (ix + 1) + gridX1 * (iy + 1),
            d = numberOfVertices + (ix + 1) + gridX1 * iy;
          indices.push(a, b, d), indices.push(b, c, d);
        }
      numberOfVertices += vertexCounter;
    }
    buildPlane(
      "z",
      "y",
      "x",
      -1,
      -1,
      depth,
      height,
      width,
      depthSegments,
      heightSegments,
      0
    ),
      buildPlane(
        "z",
        "y",
        "x",
        1,
        -1,
        depth,
        height,
        -width,
        depthSegments,
        heightSegments,
        1
      ),
      buildPlane(
        "x",
        "z",
        "y",
        1,
        1,
        width,
        depth,
        height,
        widthSegments,
        depthSegments,
        2
      ),
      buildPlane(
        "x",
        "z",
        "y",
        1,
        -1,
        width,
        depth,
        -height,
        widthSegments,
        depthSegments,
        3
      ),
      buildPlane(
        "x",
        "y",
        "z",
        1,
        -1,
        width,
        height,
        depth,
        widthSegments,
        heightSegments,
        4
      ),
      buildPlane(
        "x",
        "y",
        "z",
        -1,
        -1,
        width,
        height,
        -depth,
        widthSegments,
        heightSegments,
        5
      ),
      (this.index = new (
        Geometry.arrayNeedsUint32(indices) ? Uint32Array : Uint16Array
      )(indices)),
      this.addAttribute(
        "position",
        new GeometryAttribute(new Float32Array(vertices), 3)
      ),
      this.addAttribute(
        "normal",
        new GeometryAttribute(new Float32Array(normals), 3)
      ),
      this.addAttribute("uv", new GeometryAttribute(new Float32Array(uvs), 2));
  }
}
class CircleGeometry extends Geometry {
  constructor(
    radius = 1,
    segments = 8,
    thetaStart = 0,
    thetaLength = 2 * Math.PI
  ) {
    super();
    var i,
      s,
      indices = [],
      vertices = [],
      normals = [],
      uvs = [],
      vertex = new Vector3(),
      uv = new Vector2();
    for (
      vertices.push(0, 0, 0),
        normals.push(0, 0, 1),
        uvs.push(0.5, 0.5),
        s = 0,
        i = 3;
      s <= segments;
      s++, i += 3
    ) {
      var segment = thetaStart + (s / segments) * thetaLength;
      (vertex.x = radius * Math.cos(segment)),
        (vertex.y = radius * Math.sin(segment)),
        vertices.push(vertex.x, vertex.y, vertex.z),
        normals.push(0, 0, 1),
        (uv.x = (vertices[i] / radius + 1) / 2),
        (uv.y = (vertices[i + 1] / radius + 1) / 2),
        uvs.push(uv.x, uv.y);
    }
    for (i = 1; i <= segments; i++) indices.push(i, i + 1, 0);
    (this.index = new (
      Geometry.arrayNeedsUint32(indices) ? Uint32Array : Uint16Array
    )(indices)),
      this.addAttribute(
        "position",
        new GeometryAttribute(new Float32Array(vertices), 3)
      ),
      this.addAttribute(
        "normal",
        new GeometryAttribute(new Float32Array(normals), 3)
      ),
      this.addAttribute("uv", new GeometryAttribute(new Float32Array(uvs), 2));
  }
}
class CylinderGeometry extends Geometry {
  constructor(
    radiusTop = 1,
    radiusBottom = 1,
    height = 1,
    radialSegments = 8,
    heightSegments = 1,
    openEnded = !1,
    thetaStart = 0,
    thetaLength = 2 * Math.PI,
    planarMapping = !1
  ) {
    super(),
      (radialSegments = Math.floor(radialSegments)),
      (heightSegments = Math.floor(heightSegments));
    let indices = [],
      vertices = [],
      normals = [],
      uvs = [],
      index = 0,
      indexArray = [],
      halfHeight = height / 2;
    function generateCap(top) {
      let x,
        centerIndexStart,
        centerIndexEnd,
        uv = new Vector2(),
        vertex = new Vector3(),
        radius = !0 === top ? radiusTop : radiusBottom,
        sign = !0 === top ? 1 : -1,
        signV = planarMapping ? 1 : sign;
      for (centerIndexStart = index, x = 1; x <= radialSegments; x++)
        vertices.push(0, halfHeight * sign, 0),
          normals.push(0, sign, 0),
          uvs.push(0.5, 0.5),
          index++;
      for (centerIndexEnd = index, x = 0; x <= radialSegments; x++) {
        let theta = (x / radialSegments) * thetaLength + thetaStart,
          cosTheta = Math.cos(theta),
          sinTheta = Math.sin(theta);
        (vertex.x = radius * sinTheta),
          (vertex.y = halfHeight * sign),
          (vertex.z = radius * cosTheta),
          vertices.push(vertex.x, vertex.y, vertex.z),
          normals.push(0, sign, 0),
          (uv.x = 0.5 * cosTheta + 0.5),
          (uv.y = 0.5 * sinTheta * signV + 0.5),
          uvs.push(uv.x, uv.y),
          index++;
      }
      for (x = 0; x < radialSegments; x++) {
        let c = centerIndexStart + x,
          i = centerIndexEnd + x;
        !0 === top ? indices.push(i, i + 1, c) : indices.push(i + 1, i, c);
      }
    }
    !(function generateTorso() {
      let x,
        y,
        uv = new Vector2(),
        normal = new Vector3(),
        vertex = new Vector3(),
        slope = (radiusBottom - radiusTop) / height;
      for (y = 0; y <= heightSegments; y++) {
        let indexRow = [],
          v = y / heightSegments,
          radius = v * (radiusBottom - radiusTop) + radiusTop;
        for (x = 0; x <= radialSegments; x++) {
          let u = x / radialSegments,
            theta = u * thetaLength + thetaStart,
            sinTheta = Math.sin(theta),
            cosTheta = Math.cos(theta);
          (vertex.x = radius * sinTheta),
            (vertex.y = -v * height + halfHeight),
            (vertex.z = radius * cosTheta),
            vertices.push(vertex.x, vertex.y, vertex.z),
            normal.set(sinTheta, slope, cosTheta).normalize(),
            normals.push(normal.x, normal.y, normal.z),
            planarMapping
              ? ((uv.x = 0.5 * cosTheta + 0.5),
                (uv.y = 0.5 * sinTheta + 0.5),
                uvs.push(uv.x, uv.y))
              : uvs.push(u, 1 - v),
            indexRow.push(index++);
        }
        indexArray.push(indexRow);
      }
      for (x = 0; x < radialSegments; x++)
        for (y = 0; y < heightSegments; y++) {
          let a = indexArray[y][x],
            b = indexArray[y + 1][x],
            c = indexArray[y + 1][x + 1],
            d = indexArray[y][x + 1];
          indices.push(a, b, d), indices.push(b, c, d);
        }
    })(),
      !1 === openEnded &&
        (radiusTop > 0 && generateCap(!0), radiusBottom > 0 && generateCap(!1)),
      (this.index = new (
        Geometry.arrayNeedsUint32(indices) ? Uint32Array : Uint16Array
      )(indices)),
      this.addAttribute(
        "position",
        new GeometryAttribute(new Float32Array(vertices), 3)
      ),
      this.addAttribute(
        "normal",
        new GeometryAttribute(new Float32Array(normals), 3)
      ),
      this.addAttribute("uv", new GeometryAttribute(new Float32Array(uvs), 2));
  }
}
class ConeGeometry extends CylinderGeometry {
  constructor(
    radius,
    height,
    radialSegments,
    heightSegments,
    openEnded,
    thetaStart,
    thetaLength
  ) {
    super(
      0,
      radius,
      height,
      radialSegments,
      heightSegments,
      openEnded,
      thetaStart,
      thetaLength
    );
  }
}
class PlaneGeometry extends Geometry {
  constructor(width = 1, height = 1, widthSegments = 1, heightSegments = 1) {
    super();
    let ix,
      iy,
      width_half = width / 2,
      height_half = height / 2,
      gridX = Math.floor(widthSegments) || 1,
      gridY = Math.floor(heightSegments) || 1,
      gridX1 = gridX + 1,
      gridY1 = gridY + 1,
      segment_width = width / gridX,
      segment_height = height / gridY,
      indices = [],
      vertices = [],
      normals = [],
      uvs = [];
    for (iy = 0; iy < gridY1; iy++) {
      let y = iy * segment_height - height_half;
      for (ix = 0; ix < gridX1; ix++) {
        let x = ix * segment_width - width_half;
        vertices.push(x, -y, 0),
          normals.push(0, 0, 1),
          uvs.push(ix / gridX),
          uvs.push(1 - iy / gridY);
      }
    }
    for (iy = 0; iy < gridY; iy++)
      for (ix = 0; ix < gridX; ix++) {
        let a = ix + gridX1 * iy,
          b = ix + gridX1 * (iy + 1),
          c = ix + 1 + gridX1 * (iy + 1),
          d = ix + 1 + gridX1 * iy;
        indices.push(a, b, d), indices.push(b, c, d);
      }
    (this.index = new (
      Geometry.arrayNeedsUint32(indices) ? Uint32Array : Uint16Array
    )(indices)),
      this.addAttribute(
        "position",
        new GeometryAttribute(new Float32Array(vertices), 3)
      ),
      this.addAttribute(
        "normal",
        new GeometryAttribute(new Float32Array(normals), 3)
      ),
      this.addAttribute("uv", new GeometryAttribute(new Float32Array(uvs), 2));
  }
}
class PolyhedronGeometry extends Geometry {
  constructor(vertices, indices = [], radius = 1, detail = 0) {
    super();
    let vertexBuffer = [],
      uvBuffer = [];
    function subdivideFace(a, b, c, detail) {
      var i,
        j,
        cols = Math.pow(2, detail),
        v = [];
      for (i = 0; i <= cols; i++) {
        v[i] = [];
        var aj = a.clone().lerp(c, i / cols),
          bj = b.clone().lerp(c, i / cols),
          rows = cols - i;
        for (j = 0; j <= rows; j++)
          v[i][j] = 0 === j && i === cols ? aj : aj.clone().lerp(bj, j / rows);
      }
      for (i = 0; i < cols; i++)
        for (j = 0; j < 2 * (cols - i) - 1; j++) {
          var k = Math.floor(j / 2);
          j % 2 == 0
            ? (pushVertex(v[i][k + 1]),
              pushVertex(v[i + 1][k]),
              pushVertex(v[i][k]))
            : (pushVertex(v[i][k + 1]),
              pushVertex(v[i + 1][k + 1]),
              pushVertex(v[i + 1][k]));
        }
    }
    function pushVertex(vertex) {
      vertexBuffer.push(vertex.x, vertex.y, vertex.z);
    }
    function getVertexByIndex(index, vertex) {
      let stride = 3 * index;
      (vertex.x = vertices[stride + 0]),
        (vertex.y = vertices[stride + 1]),
        (vertex.z = vertices[stride + 2]);
    }
    function correctUV(uv, stride, vector, azimuth) {
      azimuth < 0 && 1 === uv.x && (uvBuffer[stride] = uv.x - 1),
        0 === vector.x &&
          0 === vector.z &&
          (uvBuffer[stride] = azimuth / 2 / Math.PI + 0.5);
    }
    function azimuth(vector) {
      return Math.atan2(vector.z, -vector.x);
    }
    !(function subdivide(detail) {
      let a = new Vector3(),
        b = new Vector3(),
        c = new Vector3();
      for (let i = 0; i < indices.length; i += 3)
        getVertexByIndex(indices[i + 0], a),
          getVertexByIndex(indices[i + 1], b),
          getVertexByIndex(indices[i + 2], c),
          subdivideFace(a, b, c, detail);
    })(detail),
      (function appplyRadius(radius) {
        for (var vertex = new Vector3(), i = 0; i < vertexBuffer.length; i += 3)
          (vertex.x = vertexBuffer[i + 0]),
            (vertex.y = vertexBuffer[i + 1]),
            (vertex.z = vertexBuffer[i + 2]),
            vertex.normalize().multiplyScalar(radius),
            (vertexBuffer[i + 0] = vertex.x),
            (vertexBuffer[i + 1] = vertex.y),
            (vertexBuffer[i + 2] = vertex.z);
      })(radius),
      (function generateUVs() {
        let vertex = new Vector3();
        for (let i = 0; i < vertexBuffer.length; i += 3) {
          (vertex.x = vertexBuffer[i + 0]),
            (vertex.y = vertexBuffer[i + 1]),
            (vertex.z = vertexBuffer[i + 2]);
          let u = azimuth(vertex) / 2 / Math.PI + 0.5,
            v =
              ((vector = vertex),
              Math.atan2(
                -vector.y,
                Math.sqrt(vector.x * vector.x + vector.z * vector.z)
              ) /
                Math.PI +
                0.5);
          uvBuffer.push(u, 1 - v);
        }
        var vector;
        (function correctUVs() {
          let a = new Vector3(),
            b = new Vector3(),
            c = new Vector3(),
            centroid = new Vector3(),
            uvA = new Vector2(),
            uvB = new Vector2(),
            uvC = new Vector2();
          for (let i = 0, j = 0; i < vertexBuffer.length; i += 9, j += 6) {
            a.set(
              vertexBuffer[i + 0],
              vertexBuffer[i + 1],
              vertexBuffer[i + 2]
            ),
              b.set(
                vertexBuffer[i + 3],
                vertexBuffer[i + 4],
                vertexBuffer[i + 5]
              ),
              c.set(
                vertexBuffer[i + 6],
                vertexBuffer[i + 7],
                vertexBuffer[i + 8]
              ),
              uvA.set(uvBuffer[j + 0], uvBuffer[j + 1]),
              uvB.set(uvBuffer[j + 2], uvBuffer[j + 3]),
              uvC.set(uvBuffer[j + 4], uvBuffer[j + 5]),
              centroid.copy(a).add(b).add(c).divideScalar(3);
            let azi = azimuth(centroid);
            correctUV(uvA, j + 0, a, azi),
              correctUV(uvB, j + 2, b, azi),
              correctUV(uvC, j + 4, c, azi);
          }
        })(),
          (function correctSeam() {
            for (let i = 0; i < uvBuffer.length; i += 6) {
              let x0 = uvBuffer[i + 0],
                x1 = uvBuffer[i + 2],
                x2 = uvBuffer[i + 4],
                max = Math.max(x0, x1, x2),
                min = Math.min(x0, x1, x2);
              max > 0.9 &&
                min < 0.1 &&
                (x0 < 0.2 && (uvBuffer[i + 0] += 1),
                x1 < 0.2 && (uvBuffer[i + 2] += 1),
                x2 < 0.2 && (uvBuffer[i + 4] += 1));
            }
          })();
      })(),
      this.addAttribute(
        "position",
        new GeometryAttribute(new Float32Array(vertexBuffer), 3)
      ),
      this.addAttribute(
        "normal",
        new GeometryAttribute(new Float32Array(vertexBuffer.slice()), 3)
      ),
      this.addAttribute(
        "uv",
        new GeometryAttribute(new Float32Array(uvBuffer), 2)
      ),
      0 === detail ? this.computeVertexNormals() : this.normalizeNormals();
  }
}
class IcosahedronGeometry extends PolyhedronGeometry {
  constructor(radius, detail) {
    let t = (1 + Math.sqrt(5)) / 2;
    super(
      [
        -1,
        t,
        0,
        1,
        t,
        0,
        -1,
        -t,
        0,
        1,
        -t,
        0,
        0,
        -1,
        t,
        0,
        1,
        t,
        0,
        -1,
        -t,
        0,
        1,
        -t,
        t,
        0,
        -1,
        t,
        0,
        1,
        -t,
        0,
        -1,
        -t,
        0,
        1,
      ],
      [
        0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11,
        10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9,
        4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1,
      ],
      radius,
      detail
    );
  }
}
class OctahedronGeometry extends PolyhedronGeometry {
  constructor(radius = 1, detail = 0) {
    super(
      [1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1],
      [0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2],
      radius,
      detail
    ),
      (this.type = "OctahedronGeometry"),
      (this.parameters = { radius: radius, detail: detail });
  }
}
OctahedronGeometry.fromJSON = function (data) {
  return new OctahedronGeometry(data.radius, data.detail);
};
class RingGeometry extends Geometry {
  constructor(
    innerRadius = 0.5,
    outerRadius = 1,
    thetaSegments = 8,
    phiSegments = 1,
    thetaStart = 0,
    thetaLength = 2 * Math.PI
  ) {
    super();
    var segment,
      j,
      i,
      indices = [],
      vertices = [],
      normals = [],
      uvs = [],
      radius = innerRadius,
      radiusStep = (outerRadius - innerRadius) / phiSegments,
      vertex = new Vector3(),
      uv = new Vector2();
    for (j = 0; j <= phiSegments; j++) {
      for (i = 0; i <= thetaSegments; i++)
        (segment = thetaStart + (i / thetaSegments) * thetaLength),
          (vertex.x = radius * Math.cos(segment)),
          (vertex.y = radius * Math.sin(segment)),
          vertices.push(vertex.x, vertex.y, vertex.z),
          normals.push(0, 0, 1),
          (uv.x = (vertex.x / outerRadius + 1) / 2),
          (uv.y = (vertex.y / outerRadius + 1) / 2),
          uvs.push(uv.x, uv.y);
      radius += radiusStep;
    }
    for (j = 0; j < phiSegments; j++) {
      var thetaSegmentLevel = j * (thetaSegments + 1);
      for (i = 0; i < thetaSegments; i++) {
        var a = (segment = i + thetaSegmentLevel),
          b = segment + thetaSegments + 1,
          c = segment + thetaSegments + 2,
          d = segment + 1;
        indices.push(a, b, d), indices.push(b, c, d);
      }
    }
    (this.index = new (
      Geometry.arrayNeedsUint32(indices) ? Uint32Array : Uint16Array
    )(indices)),
      this.addAttribute(
        "position",
        new GeometryAttribute(new Float32Array(vertices), 3)
      ),
      this.addAttribute(
        "normal",
        new GeometryAttribute(new Float32Array(normals), 3)
      ),
      this.addAttribute("uv", new GeometryAttribute(new Float32Array(uvs), 2));
  }
}
class SphereGeometry extends Geometry {
  constructor(
    radius = 1,
    widthSegments = 8,
    heightSegments = 6,
    phiStart = 0,
    phiLength = 2 * Math.PI,
    thetaStart = 0,
    thetaLength = Math.PI
  ) {
    super(),
      (widthSegments = Math.max(3, Math.floor(widthSegments))),
      (heightSegments = Math.max(2, Math.floor(heightSegments)));
    let ix,
      iy,
      thetaEnd = thetaStart + thetaLength,
      index = 0,
      grid = [],
      vertex = new Vector3(),
      normal = new Vector3(),
      indices = [],
      vertices = [],
      normals = [],
      uvs = [];
    for (iy = 0; iy <= heightSegments; iy++) {
      let verticesRow = [],
        v = iy / heightSegments;
      for (ix = 0; ix <= widthSegments; ix++) {
        let u = ix / widthSegments;
        (vertex.x =
          -radius *
          Math.cos(phiStart + u * phiLength) *
          Math.sin(thetaStart + v * thetaLength)),
          (vertex.y = radius * Math.cos(thetaStart + v * thetaLength)),
          (vertex.z =
            radius *
            Math.sin(phiStart + u * phiLength) *
            Math.sin(thetaStart + v * thetaLength)),
          vertices.push(vertex.x, vertex.y, vertex.z),
          normal.set(vertex.x, vertex.y, vertex.z).normalize(),
          normals.push(normal.x, normal.y, normal.z),
          uvs.push(u, 1 - v),
          verticesRow.push(index++);
      }
      grid.push(verticesRow);
    }
    for (iy = 0; iy < heightSegments; iy++)
      for (ix = 0; ix < widthSegments; ix++) {
        let a = grid[iy][ix + 1],
          b = grid[iy][ix],
          c = grid[iy + 1][ix],
          d = grid[iy + 1][ix + 1];
        (0 !== iy || thetaStart > 0) && indices.push(a, b, d),
          (iy !== heightSegments - 1 || thetaEnd < Math.PI) &&
            indices.push(b, c, d);
      }
    (this.index = new (
      Geometry.arrayNeedsUint32(indices) ? Uint32Array : Uint16Array
    )(indices)),
      this.addAttribute(
        "position",
        new GeometryAttribute(new Float32Array(vertices), 3)
      ),
      this.addAttribute(
        "normal",
        new GeometryAttribute(new Float32Array(normals), 3)
      ),
      this.addAttribute("uv", new GeometryAttribute(new Float32Array(uvs), 2));
  }
}
class TorusKnotGeometry extends Geometry {
  constructor(
    radius = 1,
    tube = 0.4,
    tubularSegments = 64,
    radialSegments = 8,
    p = 2,
    q = 3
  ) {
    super();
    let i,
      j,
      indices = [],
      vertices = [],
      normals = [],
      uvs = [],
      vertex = new Vector3(),
      normal = new Vector3(),
      P1 = new Vector3(),
      P2 = new Vector3(),
      B = new Vector3(),
      T = new Vector3(),
      N = new Vector3();
    for (i = 0; i <= tubularSegments; ++i) {
      let u = (i / tubularSegments) * p * Math.PI * 2;
      for (
        calculatePositionOnCurve(u, p, q, radius, P1),
          calculatePositionOnCurve(u + 0.01, p, q, radius, P2),
          T.subVectors(P2, P1),
          N.addVectors(P2, P1),
          B.crossVectors(T, N),
          N.crossVectors(B, T),
          B.normalize(),
          N.normalize(),
          j = 0;
        j <= radialSegments;
        ++j
      ) {
        let v = (j / radialSegments) * Math.PI * 2,
          cx = -tube * Math.cos(v),
          cy = tube * Math.sin(v);
        (vertex.x = P1.x + (cx * N.x + cy * B.x)),
          (vertex.y = P1.y + (cx * N.y + cy * B.y)),
          (vertex.z = P1.z + (cx * N.z + cy * B.z)),
          vertices.push(vertex.x, vertex.y, vertex.z),
          normal.subVectors(vertex, P1).normalize(),
          normals.push(normal.x, normal.y, normal.z),
          uvs.push(i / tubularSegments),
          uvs.push(j / radialSegments);
      }
    }
    for (j = 1; j <= tubularSegments; j++)
      for (i = 1; i <= radialSegments; i++) {
        let a = (radialSegments + 1) * (j - 1) + (i - 1),
          b = (radialSegments + 1) * j + (i - 1),
          c = (radialSegments + 1) * j + i,
          d = (radialSegments + 1) * (j - 1) + i;
        indices.push(a, b, d), indices.push(b, c, d);
      }
    function calculatePositionOnCurve(u, p, q, radius, position) {
      let cu = Math.cos(u),
        su = Math.sin(u),
        quOverP = (q / p) * u,
        cs = Math.cos(quOverP);
      (position.x = radius * (2 + cs) * 0.5 * cu),
        (position.y = radius * (2 + cs) * su * 0.5),
        (position.z = radius * Math.sin(quOverP) * 0.5);
    }
    (this.index = new (
      Geometry.arrayNeedsUint32(indices) ? Uint32Array : Uint16Array
    )(indices)),
      this.addAttribute(
        "position",
        new GeometryAttribute(new Float32Array(vertices), 3)
      ),
      this.addAttribute(
        "normal",
        new GeometryAttribute(new Float32Array(normals), 3)
      ),
      this.addAttribute("uv", new GeometryAttribute(new Float32Array(uvs), 2));
  }
}
Class(
  function Interaction3D(_camera) {
    Inherit(this, Component);
    const _this = this;
    let _hover, _click;
    var _lastOnUpdate,
      _maximumVRHitDistance,
      _v3 = new Vector3(),
      _plane = new Plane(),
      _input = {},
      _cacheHits = [],
      _enabled = !0;
    (_this.ID = Utils.timestamp()), (_camera = _camera || World.CAMERA);
    var _ray = _this.initClass(Raycaster, _camera),
      _meshes = [],
      _test = [],
      _event = {};
    const PROHIBITED_ELEMENTS = ["hit", "prevent_interaction3d"];
    function checkIfProhibited(element) {
      let el = element;
      for (; el; ) {
        if (el.classList)
          for (let i = 0; i < PROHIBITED_ELEMENTS.length; i++)
            if (el.classList.contains(PROHIBITED_ELEMENTS[i])) return !0;
        el = el.parentNode;
      }
      return !1;
    }
    function parseMeshes(meshes) {
      Array.isArray(meshes) || (meshes = [meshes]);
      let output = [];
      return (
        meshes.forEach(function checkMesh(obj) {
          if (obj.isOcclusionMesh) return;
          (obj.hitArea || obj.hitMesh) &&
            (obj = (function initHitMesh(obj) {
              obj.hitMesh || (obj.hitMesh = new Mesh(obj.hitArea));
              return (
                obj.add(obj.hitMesh),
                (obj = obj.hitMesh),
                (obj.isHitMesh = !0),
                (obj.shader.neverRender = !0),
                obj
              );
            })(obj));
          "boolean" == typeof obj.isHitMesh
            ? ((obj.mouseEnabled = function (visible) {
                visible
                  ? ~_meshes.indexOf(obj) || _meshes.push(obj)
                  : _meshes.remove(obj);
              }),
              output.push(obj))
            : output.push(obj);
          obj.children.length && obj.children.forEach(checkMesh);
        }),
        output
      );
    }
    function testObjects() {
      _test.length = 0;
      for (let i = _meshes.length - 1; i > -1; i--) {
        let obj = _meshes[i];
        obj.determineVisible() && _test.push(obj);
      }
      return _test;
    }
    function start(e) {
      if ("2d" == _input.type) {
        let element = document.elementFromPoint(
          Math.clamp(e.x || 0, 0, Stage.width),
          Math.clamp(e.y || 0, 0, Stage.height)
        );
        if ((element && checkIfProhibited(element)) || GLUI.HIT) return;
      }
      if (!_enabled) return;
      let hit = move(e);
      "3d" == _input.type && _this.events.fire(Interaction3D.EXTERNAL_PRESS),
        hit
          ? ((_click = hit.object), (_click.time = Render.TIME))
          : (_click = null);
    }
    function moveHand(e) {
      if (!_enabled) return;
      _cacheHits.length = 0;
      for (let i = 0; i < _input.obj.length; i++) {
        let obj = _input.obj[i];
        _v3.set(0, 0, -1).applyQuaternion(obj.quaternion);
        let hit = _ray.checkFromValues(testObjects(), obj.position, _v3)[0];
        hit && _cacheHits.push(hit);
      }
      _cacheHits.sort((a, b) => a.distance - b.distance);
      let hit = _cacheHits[0];
      if (
        ((hit && hit.object == _lastOnUpdate) ||
          (_lastOnUpdate &&
            _lastOnUpdate.onMissUpdate &&
            _lastOnUpdate.onMissUpdate(),
          (_lastOnUpdate = null)),
        hit)
      ) {
        let mesh = hit.object;
        if (mesh.onHitUpdate)
          return (
            (hit.usingFinger = !0),
            (_lastOnUpdate = mesh),
            mesh.onHitUpdate(hit),
            !1
          );
        !mesh._debounceFingerClick ||
        Render.TIME - mesh._debounceFingerClick > 1e3
          ? hit.distance < 0.01
            ? ((_click = mesh),
              triggerClick(mesh, hit),
              (mesh._debounceFingerClick = Render.TIME))
            : _hover || ((_hover = mesh), triggerHover("over", mesh, hit))
          : _hover && (triggerHover("out", _hover), (_hover = null));
      } else _hover && (triggerHover("out", _hover), (_hover = null));
    }
    function move(e) {
      if ("2d" == _input.type) {
        let element = document.elementFromPoint(
          Math.clamp(e.x || 0, 0, Stage.width),
          Math.clamp(e.y || 0, 0, Stage.height)
        );
        if (element && checkIfProhibited(element)) return;
      }
      if (!_enabled) return void Interaction3D.requestCursor("auto", _this);
      let hit;
      if (
        ("2d" == _input.type
          ? (hit = _ray.checkHit(
              testObjects(),
              _input.position,
              _input.rect || Stage
            )[0])
          : (_input.obj.hideBeam(),
            _v3
              .set(0, 0, -1)
              .applyQuaternion(_input.obj.group.getWorldQuaternion()),
            (hit = _ray.checkFromValues(
              testObjects(),
              _input.obj.group.getWorldPosition(),
              _v3
            )[0])),
        (hit && hit.object == _lastOnUpdate) ||
          (_lastOnUpdate &&
            _lastOnUpdate.onMissUpdate &&
            _lastOnUpdate.onMissUpdate(),
          (_lastOnUpdate = null)),
        hit)
      ) {
        _this.intersecting = !0;
        let mesh = hit.object;
        if ("3d" == _input.type) {
          let max = _maximumVRHitDistance || Interaction3D.maximumVRHitDistance;
          if (
            ("number" == typeof mesh.maximumVRHitDistance &&
              mesh.maximumVRHitDistance > 0 &&
              (max = mesh.maximumVRHitDistance),
            mesh.onHitUpdate && hit.distance > max)
          )
            return !1;
          _input.obj.showBeam(),
            _input.obj.setHitPosition && _input.obj.setHitPosition(hit);
        }
        return mesh.onHitUpdate
          ? (mesh.onHitUpdate(hit), (_lastOnUpdate = mesh), !1)
          : (_hover !== mesh
              ? (_hover && triggerHover("out", _hover, hit),
                (_hover = mesh),
                triggerHover("over", _hover, hit),
                _hover.__clickCallback
                  ? Interaction3D.requestCursor("pointer", _this)
                  : Interaction3D.requestCursor("auto", _this))
              : (function triggerMove(mesh, hit) {
                  (_event.action = "move"),
                    (_event.mesh = mesh),
                    (_event.hit = hit),
                    _this.events.fire(Interaction3D.MOVE, _event, !0),
                    mesh["__moveCallback" + _this.ID] &&
                      mesh["__moveCallback" + _this.ID](_event);
                })(_hover, hit),
            hit);
      }
      return (
        (_this.intersecting = !1),
        end(),
        _input.obj &&
          _input.obj.setHitPosition &&
          _input.obj.setHitPosition(!1),
        !1
      );
    }
    function end() {
      _hover &&
        (triggerHover("out", _hover, null),
        (_hover = null),
        Interaction3D.requestCursor(_this.cursor, _this));
    }
    function click(e) {
      if (
        ("3d" == _input.type &&
          _this.events.fire(Interaction3D.EXTERNAL_RELEASE),
        !_this.enabled)
      )
        return;
      if (!_click) return;
      let hit,
        element = document.elementFromPoint(
          Math.clamp(e.x || 0, 0, Stage.width),
          Math.clamp(e.y || 0, 0, Stage.height)
        );
      if (!element || !checkIfProhibited(element)) {
        if ("2d" == _input.type) {
          if (GLUI.HIT) return;
          hit = _ray.checkHit(testObjects(), _input.position, _input.rect)[0];
        } else
          _v3
            .set(0, 0, -1)
            .applyQuaternion(_input.obj.group.getWorldQuaternion()),
            (hit = _ray.checkFromValues(
              testObjects(),
              _input.obj.group.getWorldPosition(),
              _v3
            )[0]);
        hit && hit.object === _click && triggerClick(_click, hit),
          (_click = null);
      }
    }
    function triggerHover(action, mesh, hit) {
      (_event.action = action),
        (_event.mesh = mesh),
        (_event.hit = hit),
        _this.events.fire(Interaction3D.HOVER, _event, !0),
        _hover.__hoverCallback && _hover.__hoverCallback(_event);
    }
    function triggerClick(mesh, hit) {
      (_event.action = "click"),
        (_event.mesh = mesh),
        (_event.hit = hit),
        _this.events.fire(Interaction3D.CLICK, _event, !0),
        _click.__clickCallback && _click.__clickCallback(_event);
    }
    function vrInputButton(e) {
      "trigger" == e.label && (e.pressed ? start(e) : click(e));
    }
    (this.cursor = "auto"),
      (_ray.testVisibility = !0),
      this.set("camera", (c) => {
        _ray.camera = c;
      }),
      (this.add = function (meshes, hover, click, move, seo) {
        let seoRoot;
        Array.isArray(meshes) || (meshes = parseMeshes(meshes)),
          move && "function" != typeof move && ((seo = move), (move = null)),
          seo && seo.root && ((seoRoot = seo.root), (seo = seo.seo)),
          meshes.forEach((mesh, i) => {
            if (seo)
              try {
                (mesh._divFocus = (_) =>
                  hover({ action: "over", seo: !0, mesh: mesh })),
                  (mesh._divBlur = (_) =>
                    hover({ action: "out", seo: !0, mesh: mesh })),
                  (mesh._divSelect = (_) =>
                    click({ action: "click", seo: !0, mesh: mesh }));
                let {
                  url: url,
                  label: label,
                  ...options
                } = Array.isArray(seo) ? seo[i] : seo;
                GLSEO.objectNode(mesh, seoRoot),
                  mesh.seo.aLink(url, label, options);
              } catch (e) {
                Hydra.LOCAL &&
                  console.warn("Could not add SEO to Interaction3D meshes", e);
              }
            (mesh.hitDestroy = (_) => _meshes.remove(mesh)),
              hover && (mesh.__hoverCallback = hover),
              click && (mesh.__clickCallback = click),
              move && (mesh["__moveCallback" + _this.ID] = move),
              _meshes.push(mesh);
          });
      }),
      (this.remove = function (meshes) {
        Array.isArray(meshes) || (meshes = parseMeshes(meshes)),
          meshes.forEach((mesh) => {
            mesh === _hover &&
              ((_hover = null),
              Interaction3D.requestCursor(_this.cursor, _this)),
              mesh.seo && mesh.seo.unlink();
            for (let i = _meshes.length - 1; i >= 0; i--)
              mesh === _meshes[i] && _meshes.splice(i, 1);
          });
      }),
      this.set("testVisibility", (v) => (_ray.testVisibility = v)),
      this.set("input", (obj) => {
        _input &&
          _input.obj &&
          (_input.obj.isVrController &&
            _this.events.unsub(_input.obj, VRInput.BUTTON, vrInputButton),
          _input.obj.setHitPosition && _input.obj.setHitPosition(!1),
          _input.obj.hideBeam && _input.obj.hideBeam()),
          ((_input = {}).obj = obj),
          (_input.position = obj.group ? obj.group.position : obj),
          (_input.quaternion = obj.group ? obj.group.quaternion : null),
          (_input.type =
            "number" == typeof _input.position.z || Array.isArray(obj)
              ? "3d"
              : "2d"),
          (_input.rect = obj.rect),
          "3d" == _input.type
            ? (new Vector3(), new Vector3())
            : (new Vector2(), new Vector2()),
          obj == Mouse
            ? (function addHandlers() {
                _this.events.sub(Mouse.input, Interaction.START, start),
                  Device.mobile &&
                    _this.events.sub(Mouse.input, Interaction.END, end),
                  _this.events.sub(Mouse.input, Interaction.MOVE, move),
                  _this.events.sub(Mouse.input, Interaction.CLICK, click);
              })()
            : (!(function removeHandlers() {
                _this.events.unsub(Mouse.input, Interaction.START, start),
                  Device.mobile &&
                    _this.events.unsub(Mouse.input, Interaction.END, end),
                  _this.events.unsub(Mouse.input, Interaction.MOVE, move),
                  _this.events.unsub(Mouse.input, Interaction.CLICK, click);
              })(),
              Array.isArray(obj)
                ? (_this.startRender(moveHand), _this.stopRender(move))
                : (_this.events.sub(obj, VRInput.BUTTON, vrInputButton),
                  _this.startRender(move),
                  _this.stopRender(moveHand)));
      }),
      this.get("input", (_) => _input),
      this.get("enabled", (_) => _enabled),
      this.set("enabled", (v) => {
        (_enabled = v) ||
          (_hover && triggerHover("out", _hover, null),
          (_hover = null),
          _input &&
            _input.obj &&
            (_input.obj.setHitPosition && _input.obj.setHitPosition(!1),
            _input.obj.hideBeam && _input.obj.hideBeam()));
      }),
      (this.checkObjectHit = function (object, mouse, rect = Stage) {
        return _ray.checkHit(object, mouse, rect)[0];
      }),
      (this.checkObjectFromValues = function (object, origin, direction) {
        return _ray.checkFromValues(object, origin, direction)[0];
      }),
      (this.getObjectHitLocalCoords = function (
        v,
        object,
        mouse,
        rect = Stage
      ) {
        let hit = _this.checkObjectHit(object, mouse, rect);
        return hit
          ? (v.copy(hit.point), hit.object.worldToLocal(v))
          : (_plane.normal
              .set(0, 0, 1)
              .applyQuaternion(object.getWorldQuaternion()),
            (_plane.constant = -object.getWorldPosition().dot(_plane.normal)),
            _ray.ray.intersectPlane(_plane, v),
            object.worldToLocal(v));
      }),
      this.get("maximumVRHitDistance", () => _maximumVRHitDistance),
      this.set("maximumVRHitDistance", (value) => {
        value
          ? "number" == typeof value &&
            value > 0 &&
            (_maximumVRHitDistance = value)
          : (_maximumVRHitDistance = void 0);
      });
  },
  () => {
    (Interaction3D.HOVER = "interaction3d_hover"),
      (Interaction3D.CLICK = "interaction3d_click"),
      (Interaction3D.MOVE = "interaction3d_move"),
      (Interaction3D.EXTERNAL_PRESS = "interaction3d_ext_press"),
      (Interaction3D.EXTERNAL_RELEASE = "interaction3d_ext_release");
    var _cursorObj,
      _map = new Map(),
      _input = Mouse,
      _maximumVRHitDistance = 5;
    (Interaction3D.find = function (camera) {
      if (((camera = camera.camera || camera), !_map.has(camera))) {
        let interaction = new Interaction3D(camera);
        (interaction.input = _input), _map.set(camera, interaction);
      }
      return _map.get(camera);
    }),
      (Interaction3D.useInput = function (obj) {
        if (_input != obj) {
          for (let [camera, interaction] of _map) interaction.input = obj;
          _input = obj;
        }
      }),
      (Interaction3D.requestCursor = function (cursor, obj) {
        obj.forceCursor && (cursor = obj.forceCursor),
          "pointer" == cursor && ((_cursorObj = obj), Stage.cursor(cursor)),
          "auto" == cursor &&
            _cursorObj == obj &&
            (Stage.cursor(cursor), (_cursorObj = null));
      }),
      Object.defineProperty(Interaction3D, "maximumVRHitDistance", {
        get: () => _maximumVRHitDistance,
        set(value) {
          value
            ? "number" == typeof value &&
              value > 0 &&
              (_maximumVRHitDistance = value)
            : (_maximumVRHitDistance = 5);
        },
      });
  }
),
  Class(function Lighting() {
    Inherit(this, Component);
    const _this = this;
    var _activeScene,
      _scenes = {};
    function loop() {
      if ((decomposeLights(_activeScene.lights), _this.UBO)) {
        let shader = _activeScene.shaders.start();
        shader &&
          (updateArrays(shader),
          _activeScene.ubo.created
            ? _activeScene.ubo.update()
            : createUBO(shader.uniforms));
      } else {
        let shader = _activeScene.shaders.start();
        for (; shader; )
          updateArrays(shader), (shader = _activeScene.shaders.next());
      }
    }
    function createUBO(uniforms) {
      uniforms.lightPos &&
        ((_activeScene.ubo.created = !0),
        _activeScene.ubo.push(uniforms.lightPos),
        _activeScene.ubo.push(uniforms.lightColor),
        _activeScene.ubo.push(uniforms.lightData),
        _activeScene.ubo.push(uniforms.lightData2),
        _activeScene.ubo.push(uniforms.lightData3),
        _activeScene.ubo.push(uniforms.lightProperties),
        _activeScene.ubo.upload());
    }
    function decomposeLights(lights) {
      for (let i = lights.length - 1; i > -1; i--) {
        let light = lights[i];
        (light._decomposedTime && Render.TIME - light._decomposedTime < 8) ||
          ((light._decomposedTime = Render.TIME),
          light._parent || light.updateMatrixWorld(),
          light._world || (light._world = new Vector3()),
          light.lockToLocal
            ? light._world.copy(light.position)
            : light.getWorldPosition(light._world));
      }
    }
    function updateArrays(shader) {
      let lighting = shader.__lighting;
      (lighting.position.length = 0),
        (lighting.color.length = 0),
        (lighting.data.length = 0),
        (lighting.data2.length = 0),
        (lighting.data3.length = 0),
        (lighting.properties.length = 0);
      for (let i = 0; i < _activeScene.lights.length; i++) {
        let light = _activeScene.lights[i];
        light._world || decomposeLights(_activeScene.lights),
          lighting.position.push(
            light._world.x,
            light._world.y,
            light._world.z,
            0
          ),
          lighting.color.push(light.color.r, light.color.g, light.color.b, 0),
          lighting.data.push(
            light.data.x,
            light.data.y,
            light.data.z,
            light.data.w
          ),
          lighting.data2.push(
            light.data2.x,
            light.data2.y,
            light.data2.z,
            light.data2.w
          ),
          lighting.data3.push(
            light.data3.x,
            light.data3.y,
            light.data3.z,
            light.data3.w
          ),
          lighting.properties.push(
            light.properties.x,
            light.properties.y,
            light.properties.z,
            light.properties.w
          );
      }
    }
    function findParentScene(obj3d) {
      if (!obj3d) return _activeScene;
      if (obj3d._lightingData) return obj3d._lightingData;
      let scene,
        p = obj3d._parent;
      for (; p; )
        p instanceof Scene && p._lightingData && (scene = p._lightingData),
          (p = p._parent);
      return scene || (scene = _activeScene), scene;
    }
    (this.fallbackAreaToPoint = !1),
      (this.scenes = _scenes),
      (async function () {
        await Hydra.ready(),
          _this.createScene("default"),
          _this.useScene("default");
      })(),
      (this.createScene = function (name, scene) {
        if (_scenes[name]) return this;
        let obj = {
          lights: [],
          renderShadows: [],
          ubo: new (window.Metal ? MetalUBO : UBO)(2),
          shaders: new LinkedList(),
          name: name,
        };
        return (
          scene && (scene._lightingData = obj), (_scenes[name] = obj), this
        );
      }),
      (this.useScene = function (name) {
        if (!(_activeScene = _scenes[name])) throw `Scene ${name} not found`;
        return loop(), this;
      }),
      (this.destroyScene = function (name) {
        delete _scenes[name];
      }),
      (this.push = this.add =
        function (light) {
          (_this.UBO =
            Renderer.UBO &&
            !(window.AURA || RenderManager.type == RenderManager.WEBVR)),
            window.Metal && (_this.UBO = !0);
          let scene = findParentScene(light);
          scene.lights.push(light),
            light.isAreaLight && (scene.hasAreaLight = !0),
            _this.startedLoop ||
              ((_this.startedLoop = !0),
              RenderManager.type == RenderManager.WEBVR
                ? _this.startRender(loop, World.NUKE)
                : Render.onDrawFrame(loop));
        }),
      (this.remove = function (light) {
        _activeScene.lights.remove(light);
      }),
      (this.getLighting = function (shader, force) {
        if (shader.__lighting && !force) return shader.__lighting;
        let scene = findParentScene(shader.mesh);
        scene.shaders.push(shader),
          window.AreaLightUtil &&
            scene.hasAreaLight &&
            AreaLightUtil.append(shader);
        let lighting = (shader.__lighting = {
          position: [],
          color: [],
          data: [],
          data2: [],
          data3: [],
          properties: [],
        });
        if (!scene.lights.length) return shader.__lighting;
        let lightUBO = _this.UBO;
        return (
          (shader.uniforms.lightPos = {
            type: "v4v",
            value: lighting.position,
            ignoreUIL: !0,
            lightUBO: lightUBO,
            components: 4,
            metalIgnore: !0,
          }),
          (shader.uniforms.lightColor = {
            type: "v4v",
            value: lighting.color,
            ignoreUIL: !0,
            lightUBO: lightUBO,
            components: 4,
            metalIgnore: !0,
          }),
          (shader.uniforms.lightData = {
            type: "v4v",
            value: lighting.data,
            ignoreUIL: !0,
            lightUBO: lightUBO,
            components: 4,
            metalIgnore: !0,
          }),
          (shader.uniforms.lightData2 = {
            type: "v4v",
            value: lighting.data2,
            ignoreUIL: !0,
            lightUBO: lightUBO,
            components: 4,
            metalIgnore: !0,
          }),
          (shader.uniforms.lightData3 = {
            type: "v4v",
            value: lighting.data3,
            ignoreUIL: !0,
            lightUBO: lightUBO,
            components: 4,
            metalIgnore: !0,
          }),
          (shader.uniforms.lightProperties = {
            type: "v4v",
            value: lighting.properties,
            ignoreUIL: !0,
            lightUBO: lightUBO,
            components: 4,
            metalIgnore: !0,
          }),
          updateArrays(shader),
          _this.UBO && !_activeScene.ubo.created && createUBO(shader.uniforms),
          shader.__lighting
        );
      }),
      (this.destroyShader = function (shader) {
        findParentScene(shader.mesh);
        _activeScene.shaders.remove(shader);
      }),
      (this.sort = function (callback) {
        _activeScene.lights.sort(callback);
      }),
      (this.addToShadowGroup = function (light) {
        findParentScene(light).renderShadows.push(light);
      }),
      (this.removeFromShadowGroup = function (light) {
        findParentScene(light);
        _activeScene.renderShadows.remove(light);
      }),
      (this.getShadowLights = function () {
        return _activeScene.renderShadows;
      }),
      (this.getShadowCount = function () {
        return _activeScene.renderShadows.length;
      }),
      (this.initShadowShader = function (object, mesh) {
        let scene,
          shader = object.shader || object;
        if (shader.mesh) {
          let p = shader.mesh._parent;
          for (; p; )
            p instanceof Scene && p._lightingData && (scene = p._lightingData),
              (p = p._parent);
        }
        if (
          (scene || (scene = _activeScene),
          !World.RENDERER.shadows || 0 == scene.renderShadows.length)
        )
          return "";
        shader._gl || shader.upload();
        let vsName = shader.vsName,
          fsName = "ShadowDepth";
        shader.customShadowShader && (fsName = shader.customShadowShader),
          (shader.shadow = new Shader(vsName, fsName, {
            receiveLight: shader.receiveLight,
            UILPrefix: shader.UILPrefix,
            precision: "high",
          })),
          shader.vertexShader &&
            (shader.shadow.vertexShader = shader.vertexShader),
          shader.restoreVS && (shader.shadow.vertexShader = shader.restoreVS),
          shader.customCompile &&
            (shader.shadow.customCompile = shader.customCompile + "_shadow"),
          shader.defines &&
            ((shader.shadow.defines = shader.defines),
            shader.shadow.resetProgram()),
          (shader.shadow.lights = shader.lights),
          (shader.shadow.isShadow = !0),
          shader.copyUniformsTo(shader.shadow, !0),
          shader.shadow.upload();
      }),
      (this.getShadowUniforms = function (shader) {
        let scene;
        if (shader.mesh) {
          let p = shader.mesh._parent;
          for (; p; )
            p instanceof Scene && p._lightingData && (scene = p._lightingData),
              (p = p._parent);
        }
        return (
          scene || (scene = _activeScene),
          World.RENDERER.shadows && 0 != scene.renderShadows.length
            ? [
                `\n#define SHADOW_MAPS ${scene.renderShadows.length}`,
                World.RENDERER.shadows == Renderer.SHADOWS_LOW
                  ? "#define SHADOWS_LOW"
                  : "",
                World.RENDERER.shadows == Renderer.SHADOWS_MED
                  ? "#define SHADOWS_MED"
                  : "",
                World.RENDERER.shadows == Renderer.SHADOWS_HIGH
                  ? "#define SHADOWS_HIGH"
                  : "",
                `uniform sampler2D shadowMap[${scene.renderShadows.length}];`,
                `uniform mat4 shadowMatrix[${scene.renderShadows.length}];`,
                `uniform vec3 shadowLightPos[${scene.renderShadows.length}];`,
                `uniform float shadowSize[${scene.renderShadows.length}];`,
              ].join("\n")
            : ""
        );
      }),
      (this.bindUBO = function (shader) {
        _activeScene.ubo.created && _activeScene.ubo.bind(shader, "lights");
      }),
      (this.fallbackAreaToPointTest = function () {
        return _this.fallbackAreaToPoint;
      }),
      this.get("activeScene", (_) => _activeScene),
      (this.renderShadowsAllowLight = function (object, light) {
        if (!object._renderShadowsAllowLights) {
          let allowed = new WeakMap();
          object._renderShadowsAllowLights = allowed;
          let prevOnBeforeRenderShadow = object.onBeforeRenderShadow;
          object.onBeforeRenderShadow = function (renderLight) {
            let result =
              prevOnBeforeRenderShadow &&
              prevOnBeforeRenderShadow.apply(this, arguments);
            return !allowed.has(renderLight) || result;
          };
        }
        object._renderShadowsAllowLights.set(light.light || light, !0);
      });
  }, "static");
class Shadow {
  constructor(light) {
    (this.light = light),
      (this.camera = new PerspectiveCamera(60, 1, 0.1, 50)),
      (this.target = new Vector3()),
      (this.rt = new RenderTarget(1024, 1024)),
      this.rt.createDepthTexture(),
      (this.enabled = !0),
      (this._size = 1024),
      (this._fov = 60),
      (this._far = 50),
      (this._near = 0.1),
      light.add(this.camera);
  }
  destroy() {
    this.rt.destroy();
  }
  set fov(value) {
    (this._fov = value),
      (this.camera.fov = value),
      this.camera.updateProjectionMatrix(),
      -1 == value &&
        (this.camera = new OrthographicCamera(-5, 5, 5, -5, 0.1, 50));
  }
  get fov() {
    return this._fov;
  }
  set area(value) {
    (this._area = value),
      (this.camera.left = -value),
      (this.camera.right = value),
      (this.camera.top = value),
      (this.camera.bottom = -value),
      this.camera.updateProjectionMatrix();
  }
  get area() {
    return this._area;
  }
  set far(value) {
    (this._far = value),
      (this.camera.far = value),
      this.camera.updateProjectionMatrix();
  }
  get far() {
    return this._far;
  }
  set near(value) {
    (this._near = value),
      (this.camera.near = value),
      this.camera.updateProjectionMatrix();
  }
  get near() {
    return this._near;
  }
  set size(value) {
    (this._size = value), this.rt.setSize(value, value);
  }
  get size() {
    return this._size;
  }
}
class Box2 {
  constructor(min, max) {
    (this.min = void 0 !== min ? min : new Vector2(1 / 0, 1 / 0)),
      (this.max = void 0 !== max ? max : new Vector2(-1 / 0, -1 / 0));
  }
  set(min, max) {
    return this.min.copy(min), this.max.copy(max), this;
  }
  setFromPoints(points) {
    this.makeEmpty();
    for (let i = 0, il = points.length; i < il; i++)
      this.expandByPoint(points[i]);
    return this;
  }
  setFromCenterAndSize(center, size) {
    let v1 = this.V1 || new Vector2();
    this.V1 = v1;
    let halfSize = v1.copy(size).multiplyScalar(0.5);
    return (
      this.min.copy(center).sub(halfSize),
      this.max.copy(center).add(halfSize),
      this
    );
  }
  clone() {
    return new Box2().copy(this);
  }
  copy(box) {
    return this.min.copy(box.min), this.max.copy(box.max), this;
  }
  makeEmpty() {
    return (
      (this.min.x = this.min.y = 1 / 0),
      (this.max.x = this.max.y = -1 / 0),
      this
    );
  }
  isEmpty() {
    return this.max.x < this.min.x || this.max.y < this.min.y;
  }
  getCenter(target) {
    return this.isEmpty()
      ? target.set(0, 0)
      : target.addVectors(this.min, this.max).multiplyScalar(0.5);
  }
  getSize(target) {
    return this.isEmpty()
      ? target.set(0, 0)
      : target.subVectors(this.max, this.min);
  }
  expandByPoint(point) {
    return this.min.min(point), this.max.max(point), this;
  }
  expandByVector(vector) {
    return this.min.sub(vector), this.max.add(vector), this;
  }
  expandByScalar(scalar) {
    return this.min.addScalar(-scalar), this.max.addScalar(scalar), this;
  }
  containsPoint(point) {
    return !(
      point.x < this.min.x ||
      point.x > this.max.x ||
      point.y < this.min.y ||
      point.y > this.max.y
    );
  }
  containsBox(box) {
    return (
      this.min.x <= box.min.x &&
      box.max.x <= this.max.x &&
      this.min.y <= box.min.y &&
      box.max.y <= this.max.y
    );
  }
  getParameter(point, target) {
    return target.set(
      (point.x - this.min.x) / (this.max.x - this.min.x),
      (point.y - this.min.y) / (this.max.y - this.min.y)
    );
  }
  intersectsBox(box) {
    return !(
      box.max.x < this.min.x ||
      box.min.x > this.max.x ||
      box.max.y < this.min.y ||
      box.min.y > this.max.y
    );
  }
  clampPoint(point, target) {
    return target.copy(point).clamp(this.min, this.max);
  }
  distanceToPoint(point) {
    let v1 = this.V1 || new Vector2();
    return (
      (this.V1 = v1),
      v1.copy(point).clamp(this.min, this.max).sub(point).length()
    );
  }
  intersect(box) {
    return this.min.max(box.min), this.max.min(box.max), this;
  }
  union(box) {
    return this.min.min(box.min), this.max.max(box.max), this;
  }
  translate(offset) {
    return this.min.add(offset), this.max.add(offset), this;
  }
  equals(box) {
    return box.min.equals(this.min) && box.max.equals(this.max);
  }
}
class Box3 {
  constructor(min, max) {
    (this.min = void 0 !== min ? min : new Vector3(1 / 0, 1 / 0, 1 / 0)),
      (this.max = void 0 !== max ? max : new Vector3(-1 / 0, -1 / 0, -1 / 0));
  }
  set(min, max) {
    return this.min.copy(min), this.max.copy(max), this;
  }
  setFromArray(array) {
    let minX = 1 / 0,
      minY = 1 / 0,
      minZ = 1 / 0,
      maxX = -1 / 0,
      maxY = -1 / 0,
      maxZ = -1 / 0;
    for (let i = 0, l = array.length; i < l; i += 3) {
      let x = array[i],
        y = array[i + 1],
        z = array[i + 2];
      x < minX && (minX = x),
        y < minY && (minY = y),
        z < minZ && (minZ = z),
        x > maxX && (maxX = x),
        y > maxY && (maxY = y),
        z > maxZ && (maxZ = z);
    }
    return this.min.set(minX, minY, minZ), this.max.set(maxX, maxY, maxZ), this;
  }
  setFromBufferAttribute(attribute) {
    let minX = 1 / 0,
      minY = 1 / 0,
      minZ = 1 / 0,
      maxX = -1 / 0,
      maxY = -1 / 0,
      maxZ = -1 / 0;
    for (let i = 0, l = attribute.count; i < l; i++) {
      let x = attribute.array[3 * i + 0],
        y = attribute.array[3 * i + 1],
        z = attribute.array[3 * i + 2];
      x < minX && (minX = x),
        y < minY && (minY = y),
        z < minZ && (minZ = z),
        x > maxX && (maxX = x),
        y > maxY && (maxY = y),
        z > maxZ && (maxZ = z);
    }
    return this.min.set(minX, minY, minZ), this.max.set(maxX, maxY, maxZ), this;
  }
  setFromPoints(points) {
    this.makeEmpty();
    for (let i = 0, il = points.length; i < il; i++)
      this.expandByPoint(points[i]);
    return this;
  }
  setFromCenterAndSize(center, size) {
    let v1 = this.V1 || new Vector3();
    this.V1 = v1;
    let halfSize = v1.copy(size).multiplyScalar(0.5);
    return (
      this.min.copy(center).sub(halfSize),
      this.max.copy(center).add(halfSize),
      this
    );
  }
  setFromObject(object) {
    return this.makeEmpty(), this.expandByObject(object);
  }
  clone() {
    return new Box3().copy(this);
  }
  copy(box) {
    return this.min.copy(box.min), this.max.copy(box.max), this;
  }
  makeEmpty() {
    return (
      (this.min.x = this.min.y = this.min.z = 1 / 0),
      (this.max.x = this.max.y = this.max.z = -1 / 0),
      this
    );
  }
  isEmpty() {
    return (
      this.max.x < this.min.x ||
      this.max.y < this.min.y ||
      this.max.z < this.min.z
    );
  }
  getCenter(target) {
    return this.isEmpty()
      ? target.set(0, 0, 0)
      : target.addVectors(this.min, this.max).multiplyScalar(0.5);
  }
  getSize(target) {
    return this.isEmpty()
      ? target.set(0, 0, 0)
      : target.subVectors(this.max, this.min);
  }
  expandByPoint(point) {
    return this.min.min(point), this.max.max(point), this;
  }
  expandByVector(vector) {
    return this.min.sub(vector), this.max.add(vector), this;
  }
  expandByScalar(scalar) {
    return this.min.addScalar(-scalar), this.max.addScalar(scalar), this;
  }
  expandByObject(object, local, onlyvisible) {
    let scope,
      i,
      l,
      v1 = this.V1 || new Vector3();
    return (
      (this.V1 = v1),
      (scope = this),
      object.updateMatrixWorld(!0),
      object.traverse((node) => {
        if (onlyvisible && !node.visible) return;
        if (node.isGizmo) return;
        let geometry = node.geometry;
        if (!geometry) return;
        let attribute = geometry.attributes.position;
        if (void 0 !== attribute)
          for (i = 0, l = attribute.count; i < l; i++)
            v1
              .fromBufferAttribute(attribute, i)
              .applyMatrix4(local ? node.matrix : node.matrixWorld),
              scope.expandByPoint(v1);
      }),
      this
    );
  }
  containsPoint(point) {
    return !(
      point.x < this.min.x ||
      point.x > this.max.x ||
      point.y < this.min.y ||
      point.y > this.max.y ||
      point.z < this.min.z ||
      point.z > this.max.z
    );
  }
  containsBox(box) {
    return (
      this.min.x <= box.min.x &&
      box.max.x <= this.max.x &&
      this.min.y <= box.min.y &&
      box.max.y <= this.max.y &&
      this.min.z <= box.min.z &&
      box.max.z <= this.max.z
    );
  }
  getParameter(point, target) {
    return target.set(
      (point.x - this.min.x) / (this.max.x - this.min.x),
      (point.y - this.min.y) / (this.max.y - this.min.y),
      (point.z - this.min.z) / (this.max.z - this.min.z)
    );
  }
  intersectsBox(box) {
    return !(
      box.max.x < this.min.x ||
      box.min.x > this.max.x ||
      box.max.y < this.min.y ||
      box.min.y > this.max.y ||
      box.max.z < this.min.z ||
      box.min.z > this.max.z
    );
  }
  intersectsSphere(sphere) {
    let closestPoint = this.V1 || new Vector3();
    return (
      (this.V1 = closestPoint),
      this.clampPoint(sphere.center, closestPoint),
      closestPoint.distanceToSquared(sphere.center) <=
        sphere.radius * sphere.radius
    );
  }
  intersectsPlane(plane) {
    let min, max;
    return (
      plane.normal.x > 0
        ? ((min = plane.normal.x * this.min.x),
          (max = plane.normal.x * this.max.x))
        : ((min = plane.normal.x * this.max.x),
          (max = plane.normal.x * this.min.x)),
      plane.normal.y > 0
        ? ((min += plane.normal.y * this.min.y),
          (max += plane.normal.y * this.max.y))
        : ((min += plane.normal.y * this.max.y),
          (max += plane.normal.y * this.min.y)),
      plane.normal.z > 0
        ? ((min += plane.normal.z * this.min.z),
          (max += plane.normal.z * this.max.z))
        : ((min += plane.normal.z * this.max.z),
          (max += plane.normal.z * this.min.z)),
      min <= plane.constant && max >= plane.constant
    );
  }
  intersectsTriangle(triangle) {
    let v0 = this.V0 || new Vector3();
    this.V0 = v0;
    let v1 = this.V1 || new Vector3();
    this.V1 = v1;
    let v2 = this.V2 || new Vector3();
    this.V2 = v2;
    let f0 = this.F0 || new Vector3();
    this.F0 = f0;
    let f1 = this.F1 || new Vector3();
    this.F1 = f1;
    let f2 = this.F2 || new Vector3();
    this.F2 = f2;
    let testAxis = this.V3 || new Vector3();
    this.V3 = testAxis;
    let center = this.V4 || new Vector3();
    this.V4 = center;
    let extents = this.V5 || new Vector3();
    this.V5 = extents;
    let triangleNormal = this.V6 || new Vector3();
    function satForAxes(axes) {
      let i, j;
      for (i = 0, j = axes.length - 3; i <= j; i += 3) {
        testAxis.fromArray(axes, i);
        let r =
            extents.x * Math.abs(testAxis.x) +
            extents.y * Math.abs(testAxis.y) +
            extents.z * Math.abs(testAxis.z),
          p0 = v0.dot(testAxis),
          p1 = v1.dot(testAxis),
          p2 = v2.dot(testAxis);
        if (Math.max(-Math.max(p0, p1, p2), Math.min(p0, p1, p2)) > r)
          return !1;
      }
      return !0;
    }
    if (((this.V6 = triangleNormal), this.isEmpty())) return !1;
    this.getCenter(center),
      extents.subVectors(this.max, center),
      v0.subVectors(triangle.a, center),
      v1.subVectors(triangle.b, center),
      v2.subVectors(triangle.c, center),
      f0.subVectors(v1, v0),
      f1.subVectors(v2, v1),
      f2.subVectors(v0, v2);
    let axes = [
      0,
      -f0.z,
      f0.y,
      0,
      -f1.z,
      f1.y,
      0,
      -f2.z,
      f2.y,
      f0.z,
      0,
      -f0.x,
      f1.z,
      0,
      -f1.x,
      f2.z,
      0,
      -f2.x,
      -f0.y,
      f0.x,
      0,
      -f1.y,
      f1.x,
      0,
      -f2.y,
      f2.x,
      0,
    ];
    return (
      !!satForAxes(axes) &&
      ((axes = [1, 0, 0, 0, 1, 0, 0, 0, 1]),
      !!satForAxes(axes) &&
        (triangleNormal.crossVectors(f0, f1),
        (axes = [triangleNormal.x, triangleNormal.y, triangleNormal.z]),
        satForAxes(axes)))
    );
  }
  clampPoint(point, target) {
    return target.copy(point).clamp(this.min, this.max);
  }
  distanceToPoint(point) {
    let v1 = this.V1 || new Vector3();
    return (
      (this.V1 = v1),
      v1.copy(point).clamp(this.min, this.max).sub(point).length()
    );
  }
  getBoundingSphere(target = new Sphere()) {
    let v1 = this.V1 || new Vector3();
    return (
      (this.V1 = v1),
      this.getCenter(target.center),
      (target.radius = 0.5 * this.getSize(v1).length()),
      target
    );
  }
  intersect(box) {
    return (
      this.min.max(box.min),
      this.max.min(box.max),
      this.isEmpty() && this.makeEmpty(),
      this
    );
  }
  union(box) {
    return this.min.min(box.min), this.max.max(box.max), this;
  }
  applyMatrix4(matrix) {
    if (this.isEmpty()) return this;
    let m = matrix.elements,
      xax = m[0] * this.min.x,
      xay = m[1] * this.min.x,
      xaz = m[2] * this.min.x,
      xbx = m[0] * this.max.x,
      xby = m[1] * this.max.x,
      xbz = m[2] * this.max.x,
      yax = m[4] * this.min.y,
      yay = m[5] * this.min.y,
      yaz = m[6] * this.min.y,
      ybx = m[4] * this.max.y,
      yby = m[5] * this.max.y,
      ybz = m[6] * this.max.y,
      zax = m[8] * this.min.z,
      zay = m[9] * this.min.z,
      zaz = m[10] * this.min.z,
      zbx = m[8] * this.max.z,
      zby = m[9] * this.max.z,
      zbz = m[10] * this.max.z;
    return (
      (this.min.x =
        Math.min(xax, xbx) + Math.min(yax, ybx) + Math.min(zax, zbx) + m[12]),
      (this.min.y =
        Math.min(xay, xby) + Math.min(yay, yby) + Math.min(zay, zby) + m[13]),
      (this.min.z =
        Math.min(xaz, xbz) + Math.min(yaz, ybz) + Math.min(zaz, zbz) + m[14]),
      (this.max.x =
        Math.max(xax, xbx) + Math.max(yax, ybx) + Math.max(zax, zbx) + m[12]),
      (this.max.y =
        Math.max(xay, xby) + Math.max(yay, yby) + Math.max(zay, zby) + m[13]),
      (this.max.z =
        Math.max(xaz, xbz) + Math.max(yaz, ybz) + Math.max(zaz, zbz) + m[14]),
      this
    );
  }
  translate(offset) {
    return this.min.add(offset), this.max.add(offset), this;
  }
  equals(box) {
    return box.min.equals(this.min) && box.max.equals(this.max);
  }
  setFromBufferAttribute(attribute) {
    let minX = 1 / 0,
      minY = 1 / 0,
      minZ = 1 / 0,
      maxX = -1 / 0,
      maxY = -1 / 0,
      maxZ = -1 / 0;
    for (let i = 0, l = attribute.count; i < l; i++) {
      let x = attribute.array[3 * i + 0],
        y = attribute.array[3 * i + 1],
        z = attribute.array[3 * i + 2];
      x < minX && (minX = x),
        y < minY && (minY = y),
        z < minZ && (minZ = z),
        x > maxX && (maxX = x),
        y > maxY && (maxY = y),
        z > maxZ && (maxZ = z);
    }
    return this.min.set(minX, minY, minZ), this.max.set(maxX, maxY, maxZ), this;
  }
}
class Color {
  constructor(r, g, b) {
    return null == r && null == g && null == b
      ? this.setRGB(1, 1, 1)
      : void 0 === g && void 0 === b
      ? this.set(r)
      : void this.setRGB(r, g, b);
  }
  set(value) {
    return (
      value && value instanceof Color
        ? this.copy(value)
        : "number" == typeof value
        ? this.setHex(value)
        : "string" == typeof value && this.setStyle(value),
      this
    );
  }
  setScalar(scalar) {
    return (this.r = scalar), (this.g = scalar), (this.b = scalar), this;
  }
  setHex(hex) {
    return (
      (hex = Math.floor(hex)),
      (this.r = ((hex >> 16) & 255) / 255),
      (this.g = ((hex >> 8) & 255) / 255),
      (this.b = (255 & hex) / 255),
      this
    );
  }
  setStyle(string) {
    return this.setHex(Number(string.replace("#", "0x")));
  }
  setRGB(r, g, b) {
    return (this.r = r), (this.g = g), (this.b = b), this;
  }
  setHSL(h, s, l) {
    return h instanceof ColorHSL
      ? h.getRGB(this)
      : this.target
      ? void this.target.setHSL(h, s, l).getRGB(this)
      : (this.target = new ColorHSL(h, s, l));
  }
  clone() {
    return new Color(this.r, this.g, this.b);
  }
  copy(color) {
    return (this.r = color.r), (this.g = color.g), (this.b = color.b), this;
  }
  copyGammaToLinear(color, gammaFactor) {
    return (
      void 0 === gammaFactor && (gammaFactor = 2),
      (this.r = Math.pow(color.r, gammaFactor)),
      (this.g = Math.pow(color.g, gammaFactor)),
      (this.b = Math.pow(color.b, gammaFactor)),
      this
    );
  }
  copyLinearToGamma(color, gammaFactor) {
    void 0 === gammaFactor && (gammaFactor = 2);
    let safeInverse = gammaFactor > 0 ? 1 / gammaFactor : 1;
    return (
      (this.r = Math.pow(color.r, safeInverse)),
      (this.g = Math.pow(color.g, safeInverse)),
      (this.b = Math.pow(color.b, safeInverse)),
      this
    );
  }
  convertGammaToLinear(gammaFactor) {
    return this.copyGammaToLinear(this, gammaFactor), this;
  }
  convertLinearToGamma(gammaFactor) {
    return this.copyLinearToGamma(this, gammaFactor), this;
  }
  getHex() {
    return (
      ((255 * this.r) << 16) ^ ((255 * this.g) << 8) ^ ((255 * this.b) << 0)
    );
  }
  getHexString() {
    return "#" + ("000000" + this.getHex().toString(16)).slice(-6);
  }
  getHSL() {
    return this.target
      ? this.target.setRGB(this.r, this.g, this.b)
      : (this.target = new ColorHSL(this));
  }
  tween(color, time, ease, delay) {
    const _this = this;
    _this.tweenObj || (_this.tweenObj = { v: 0 }), (_this.tweenObj.v = 0);
    let clone = this.clone();
    return TweenManager.tween(
      _this.tweenObj,
      { v: 1 },
      time,
      ease,
      delay
    ).onUpdate((_) => {
      _this.copy(clone).lerp(color, _this.tweenObj.v);
    });
  }
  offsetHSL(h, s, l) {
    return (
      this.target
        ? this.target.setRGB(this.r, this.g, this.b)
        : (this.target = new ColorHSL(this)),
      (this.target.h += h),
      (this.target.s += s),
      (this.target.l += l),
      this.target.getRGB(this)
    );
  }
  add(color) {
    return (this.r += color.r), (this.g += color.g), (this.b += color.b), this;
  }
  addColors(color1, color2) {
    return (
      (this.r = color1.r + color2.r),
      (this.g = color1.g + color2.g),
      (this.b = color1.b + color2.b),
      this
    );
  }
  addScalar(s) {
    return (this.r += s), (this.g += s), (this.b += s), this;
  }
  sub(color) {
    return (
      (this.r = Math.max(0, this.r - color.r)),
      (this.g = Math.max(0, this.g - color.g)),
      (this.b = Math.max(0, this.b - color.b)),
      this
    );
  }
  multiply(color) {
    return (this.r *= color.r), (this.g *= color.g), (this.b *= color.b), this;
  }
  multiplyScalar(s) {
    return (this.r *= s), (this.g *= s), (this.b *= s), this;
  }
  invert() {
    return (
      (this.r = 1 - this.r), (this.g = 1 - this.g), (this.b = 1 - this.b), this
    );
  }
  lerp(color, alpha, hz) {
    return (
      (this.r = Math.lerp(color.r, this.r, alpha, hz)),
      (this.g = Math.lerp(color.g, this.g, alpha, hz)),
      (this.b = Math.lerp(color.b, this.b, alpha, hz)),
      this
    );
  }
  equals(c) {
    return c.r === this.r && c.g === this.g && c.b === this.b;
  }
  fromArray(array, offset) {
    return (
      void 0 === offset && (offset = 0),
      (this.r = array[offset]),
      (this.g = array[offset + 1]),
      (this.b = array[offset + 2]),
      this
    );
  }
  toArray(array, offset) {
    return (
      void 0 === array && (array = []),
      void 0 === offset && (offset = 0),
      (array[offset] = this.r),
      (array[offset + 1] = this.g),
      (array[offset + 2] = this.b),
      array
    );
  }
  toRGBA(alpha = 1) {
    return `rgba(${Math.floor(255 * this.r)}, ${Math.floor(
      255 * this.g
    )}, ${Math.floor(255 * this.b)}, ${alpha})`;
  }
}
class ColorHSL {
  constructor(h, s, l) {
    return void 0 === h && void 0 === s && void 0 === l
      ? this.setHSL(0, 0, 1)
      : void 0 === s && void 0 === l
      ? this.set(h)
      : void this.setHSL(h, s, l);
  }
  copy(colorHSL) {
    return (
      (this.h = colorHSL.h), (this.s = colorHSL.s), (this.l = colorHSL.l), this
    );
  }
  getRGB(target = new Color()) {
    function hue2rgb(p, q, t) {
      return (
        t < 0 && (t += 1),
        t > 1 && (t -= 1),
        t < 1 / 6
          ? p + 6 * (q - p) * t
          : t < 0.5
          ? q
          : t < 2 / 3
          ? p + 6 * (q - p) * (2 / 3 - t)
          : p
      );
    }
    let h = Math.euclideanModulo(this.h, 1),
      s = Math.clamp(this.s, 0, 1),
      l = Math.clamp(this.l, 0, 1);
    if (0 === s) target.r = target.g = target.b = l;
    else {
      let p = l <= 0.5 ? l * (1 + s) : l + s - l * s,
        q = 2 * l - p;
      (target.r = hue2rgb(q, p, h + 1 / 3)),
        (target.g = hue2rgb(q, p, h)),
        (target.b = hue2rgb(q, p, h - 1 / 3));
    }
    return target;
  }
  set(value) {
    return (
      value && value instanceof ColorHSL
        ? this.copy(value)
        : value && value instanceof Color
        ? this.setRGB(value.r, value.g, value.b)
        : "number" == typeof value
        ? this.setHex(value)
        : "string" == typeof value && this.setStyle(value),
      this
    );
  }
  setHex(hex) {
    const r = (((hex = Math.floor(hex)) >> 16) & 255) / 255,
      g = ((hex >> 8) & 255) / 255,
      b = (255 & hex) / 255;
    return this.setRGB(r, g, b);
  }
  setStyle(string) {
    return this.setHex(Number(string.replace("#", "0x")));
  }
  setRGB(r, g, b) {
    let hue,
      saturation,
      max = Math.max(r, g, b),
      min = Math.min(r, g, b),
      lightness = (min + max) / 2;
    if (min === max) (hue = 0), (saturation = 0);
    else {
      let delta = max - min;
      switch (
        ((saturation =
          lightness <= 0.5 ? delta / (max + min) : delta / (2 - max - min)),
        max)
      ) {
        case r:
          hue = (g - b) / delta + (g < b ? 6 : 0);
          break;
        case g:
          hue = (b - r) / delta + 2;
          break;
        case b:
          hue = (r - g) / delta + 4;
      }
      hue /= 6;
    }
    return (this.h = hue), (this.s = saturation), (this.l = lightness), this;
  }
  setHSL(h, s, l) {
    return (this.h = h), (this.s = s), (this.l = l), this;
  }
}
class ColorLAB {
  constructor(l, a, b) {
    return void 0 === l && void 0 === a && void 0 === b
      ? this.setLAB(100, 0, 0)
      : void 0 === a && void 0 === b
      ? this.set(l)
      : void this.setLAB(l, a, b);
  }
  copy(colorLAB) {
    return (
      (this.l = colorLAB.l), (this.a = colorLAB.a), (this.b = colorLAB.b), this
    );
  }
  deltaECIE94(colorLAB) {
    var deltaL = this.l - colorLAB.l,
      deltaA = this.a - colorLAB.a,
      deltaB = this.b - colorLAB.b,
      c1 = Math.sqrt(this.a * this.a + this.b * this.b),
      deltaC =
        c1 - Math.sqrt(colorLAB.a * colorLAB.a + colorLAB.b * colorLAB.b),
      deltaH = deltaA * deltaA + deltaB * deltaB - deltaC * deltaC,
      deltaLKlsl = deltaL / 1,
      deltaCkcsc = deltaC / (1 + 0.045 * c1),
      deltaHkhsh =
        (deltaH = deltaH < 0 ? 0 : Math.sqrt(deltaH)) / (1 + 0.015 * c1),
      i =
        deltaLKlsl * deltaLKlsl +
        deltaCkcsc * deltaCkcsc +
        deltaHkhsh * deltaHkhsh;
    return i < 0 ? 0 : Math.sqrt(i);
  }
  getRGB(target = new Color()) {
    let y = (this.l + 16) / 116,
      x = this.a / 500 + y,
      z = y - this.b / 200;
    return (
      (x =
        0.95047 * (x * x * x > 0.008856 ? x * x * x : (x - 16 / 116) / 7.787)),
      (y = y * y * y > 0.008856 ? y * y * y : (y - 16 / 116) / 7.787),
      (z =
        1.08883 * (z * z * z > 0.008856 ? z * z * z : (z - 16 / 116) / 7.787)),
      (target.r = 3.2406 * x + -1.5372 * y + -0.4986 * z),
      (target.g = -0.9689 * x + 1.8758 * y + 0.0415 * z),
      (target.b = 0.0557 * x + -0.204 * y + 1.057 * z),
      (target.r = Math.clamp(
        target.r > 0.0031308
          ? 1.055 * Math.pow(target.r, 1 / 2.4) - 0.055
          : 12.92 * target.r
      )),
      (target.g = Math.clamp(
        target.g > 0.0031308
          ? 1.055 * Math.pow(target.g, 1 / 2.4) - 0.055
          : 12.92 * target.g
      )),
      (target.b = Math.clamp(
        target.b > 0.0031308
          ? 1.055 * Math.pow(target.b, 1 / 2.4) - 0.055
          : 12.92 * target.b
      )),
      target
    );
  }
  set(value) {
    return (
      value && value instanceof ColorLAB
        ? this.copy(value)
        : value && value instanceof Color
        ? this.setRGB(value.r, value.g, value.b)
        : "number" == typeof value
        ? this.setHex(value)
        : "string" == typeof value && this.setStyle(value),
      this
    );
  }
  setHex(hex) {
    const r = (((hex = Math.floor(hex)) >> 16) & 255) / 255,
      g = ((hex >> 8) & 255) / 255,
      b = (255 & hex) / 255;
    return this.setRGB(r, g, b);
  }
  setStyle(string) {
    return this.setHex(Number(string.replace("#", "0x")));
  }
  setRGB(r, g, b) {
    let x, y, z;
    return (
      (x =
        (0.4124 *
          (r = r > 0.04045 ? Math.pow((r + 0.055) / 1.055, 2.4) : r / 12.92) +
          0.3576 *
            (g = g > 0.04045 ? Math.pow((g + 0.055) / 1.055, 2.4) : g / 12.92) +
          0.1805 *
            (b =
              b > 0.04045 ? Math.pow((b + 0.055) / 1.055, 2.4) : b / 12.92)) /
        0.95047),
      (y = 0.2126 * r + 0.7152 * g + 0.0722 * b),
      (z = (0.0193 * r + 0.1192 * g + 0.9505 * b) / 1.08883),
      (x = x > 0.008856 ? Math.pow(x, 1 / 3) : 7.787 * x + 16 / 116),
      (y = y > 0.008856 ? Math.pow(y, 1 / 3) : 7.787 * y + 16 / 116),
      (z = z > 0.008856 ? Math.pow(z, 1 / 3) : 7.787 * z + 16 / 116),
      (this.l = 116 * y - 16),
      (this.a = 500 * (x - y)),
      (this.b = 200 * (y - z)),
      this
    );
  }
  setLAB(l, a, b) {
    return (this.l = l), (this.a = a), (this.b = b), this;
  }
}
class Cylindrical {
  constructor(radius = 1, theta = 0, y = 0) {
    (this.radius = radius), (this.theta = theta), (this.y = y);
  }
  set(radius, theta, y) {
    return (this.radius = radius), (this.theta = theta), (this.y = y), this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(other) {
    return (
      (this.radius = other.radius),
      (this.theta = other.theta),
      (this.y = other.y),
      this
    );
  }
  setFromVector3(vec3) {
    return (
      (this.radius = Math.sqrt(vec3.x * vec3.x + vec3.z * vec3.z)),
      (this.theta = Math.atan2(vec3.x, vec3.z)),
      (this.y = vec3.y),
      this
    );
  }
}
class Euler {
  constructor(x, y, z, order) {
    (this._x = x || 0),
      (this._y = y || 0),
      (this._z = z || 0),
      (this._order = order || "XYZ"),
      (this.isEuler = !0);
  }
  get x() {
    return this._x;
  }
  set x(v) {
    if (zUtils3D.LOCAL && isNaN(v)) return console.trace("Euler::NaN");
    let dirty = Math.abs(this._x - v) > Base3D.DIRTY_EPSILON;
    (this._x = v), dirty && this.onChangeCallback();
  }
  get y() {
    return this._y;
  }
  set y(v) {
    if (zUtils3D.LOCAL && isNaN(v)) return console.trace("Euler::NaN");
    let dirty = Math.abs(this._y - v) > Base3D.DIRTY_EPSILON;
    (this._y = v), dirty && this.onChangeCallback();
  }
  get z() {
    return this._z;
  }
  set z(v) {
    if (zUtils3D.LOCAL && isNaN(v)) return console.trace("Euler::NaN");
    let dirty = Math.abs(this._z - v) > Base3D.DIRTY_EPSILON;
    (this._z = v), dirty && this.onChangeCallback();
  }
  set order(value) {
    (this._order = value), this.onChangeCallback();
  }
  get order() {
    return this._order;
  }
  set(x, y, z, order) {
    return (
      (this._x = x),
      (this._y = y),
      (this._z = z),
      (this._order = order || this._order),
      this.onChangeCallback(),
      this
    );
  }
  clone() {
    return new Euler(this._x, this._y, this._z, this._order);
  }
  copy(euler) {
    return (
      (this._x = euler.x),
      (this._y = euler.y),
      (this._z = euler.z),
      euler._order && (this._order = euler._order),
      this.onChangeCallback(),
      this
    );
  }
  setFromRotationMatrix(m, order, update) {
    let clamp = Math.clamp,
      te = m.elements,
      m11 = te[0],
      m12 = te[4],
      m13 = te[8],
      m21 = te[1],
      m22 = te[5],
      m23 = te[9],
      m31 = te[2],
      m32 = te[6],
      m33 = te[10];
    return (
      "XYZ" === (order = order || this._order)
        ? ((this._y = Math.asin(clamp(m13, -1, 1))),
          Math.abs(m13) < 1 - Base3D.DIRTY_EPSILON
            ? ((this._x = Math.atan2(-m23, m33)),
              (this._z = Math.atan2(-m12, m11)))
            : ((this._x = Math.atan2(m32, m22)), (this._z = 0)))
        : "YXZ" === order
        ? ((this._x = Math.asin(-clamp(m23, -1, 1))),
          Math.abs(m23) < 1 - Base3D.DIRTY_EPSILON
            ? ((this._y = Math.atan2(m13, m33)),
              (this._z = Math.atan2(m21, m22)))
            : ((this._y = Math.atan2(-m31, m11)), (this._z = 0)))
        : "ZXY" === order
        ? ((this._x = Math.asin(clamp(m32, -1, 1))),
          Math.abs(m32) < 1 - Base3D.DIRTY_EPSILON
            ? ((this._y = Math.atan2(-m31, m33)),
              (this._z = Math.atan2(-m12, m22)))
            : ((this._y = 0), (this._z = Math.atan2(m21, m11))))
        : "ZYX" === order
        ? ((this._y = Math.asin(-clamp(m31, -1, 1))),
          Math.abs(m31) < 1 - Base3D.DIRTY_EPSILON
            ? ((this._x = Math.atan2(m32, m33)),
              (this._z = Math.atan2(m21, m11)))
            : ((this._x = 0), (this._z = Math.atan2(-m12, m22))))
        : "YZX" === order
        ? ((this._z = Math.asin(clamp(m21, -1, 1))),
          Math.abs(m21) < 1 - Base3D.DIRTY_EPSILON
            ? ((this._x = Math.atan2(-m23, m22)),
              (this._y = Math.atan2(-m31, m11)))
            : ((this._x = 0), (this._y = Math.atan2(m13, m33))))
        : "XZY" === order &&
          ((this._z = Math.asin(-clamp(m12, -1, 1))),
          Math.abs(m12) < 1 - Base3D.DIRTY_EPSILON
            ? ((this._x = Math.atan2(m32, m22)),
              (this._y = Math.atan2(m13, m11)))
            : ((this._x = Math.atan2(-m23, m33)), (this._y = 0))),
      (this._order = order),
      !1 !== update && this.onChangeCallback(),
      this
    );
  }
  setFromQuaternion(q, order, update) {
    let matrix = this.M1 || new Matrix4();
    return (
      (this.M1 = matrix),
      matrix.makeRotationFromQuaternion(q),
      this.setFromRotationMatrix(matrix, order, update)
    );
  }
  setFromVector3(v, order) {
    return this.set(v.x, v.y, v.z, order || this._order);
  }
  reorder(newOrder) {
    let q = this.Q1 || new Quaternion();
    return (
      (this.Q1 = q), q.setFromEuler(this), this.setFromQuaternion(q, newOrder)
    );
  }
  lerp(euler, alpha) {
    (this._x += (euler._x - this._x) * alpha),
      (this._y += (euler._y - this._y) * alpha),
      (this._z += (euler._z - this._z) * alpha),
      this.onChangeCallback();
  }
  equals(euler) {
    return (
      euler._x === this._x &&
      euler._y === this._y &&
      euler._z === this._z &&
      euler._order === this._order
    );
  }
  fromArray(array) {
    return (
      (this._x = array[0]),
      (this._y = array[1]),
      (this._z = array[2]),
      void 0 !== array[3] && (this._order = array[3]),
      this.onChangeCallback(),
      this
    );
  }
  toArray(array, offset) {
    return (
      void 0 === array && (array = []),
      void 0 === offset && (offset = 0),
      (array[offset] = this._x),
      (array[offset + 1] = this._y),
      (array[offset + 2] = this._z),
      (array[offset + 3] = this._order),
      array
    );
  }
  toVector3(optionalResult) {
    return optionalResult
      ? optionalResult.set(this._x, this._y, this._z)
      : new Vector3(this._x, this._y, this._z);
  }
  onChange(callback) {
    this.onChangeCallback = callback;
  }
  onChangeCallback() {}
}
(Euler.DefaultOrder = "XYZ"),
  (Euler.RotationOrders = ["XYZ", "YZX", "ZXY", "XZY", "YXZ", "ZYX"]);
class Frustum {
  constructor(p0, p1, p2, p3, p4, p5) {
    this.planes = [
      void 0 !== p0 ? p0 : new Plane(),
      void 0 !== p1 ? p1 : new Plane(),
      void 0 !== p2 ? p2 : new Plane(),
      void 0 !== p3 ? p3 : new Plane(),
      void 0 !== p4 ? p4 : new Plane(),
      void 0 !== p5 ? p5 : new Plane(),
    ];
  }
  set(p0, p1, p2, p3, p4, p5) {
    let planes = this.planes;
    return (
      planes[0].copy(p0),
      planes[1].copy(p1),
      planes[2].copy(p2),
      planes[3].copy(p3),
      planes[4].copy(p4),
      planes[5].copy(p5),
      this
    );
  }
  clone() {
    return new Frustum().copy(this);
  }
  copy(frustum) {
    let planes = this.planes;
    for (let i = 0; i < 6; i++) planes[i].copy(frustum.planes[i]);
    return this;
  }
  setFromMatrix(m) {
    let planes = this.planes,
      me = m.elements,
      me0 = me[0],
      me1 = me[1],
      me2 = me[2],
      me3 = me[3],
      me4 = me[4],
      me5 = me[5],
      me6 = me[6],
      me7 = me[7],
      me8 = me[8],
      me9 = me[9],
      me10 = me[10],
      me11 = me[11],
      me12 = me[12],
      me13 = me[13],
      me14 = me[14],
      me15 = me[15];
    return (
      planes[0]
        .setComponents(me3 - me0, me7 - me4, me11 - me8, me15 - me12)
        .normalize(),
      planes[1]
        .setComponents(me3 + me0, me7 + me4, me11 + me8, me15 + me12)
        .normalize(),
      planes[2]
        .setComponents(me3 + me1, me7 + me5, me11 + me9, me15 + me13)
        .normalize(),
      planes[3]
        .setComponents(me3 - me1, me7 - me5, me11 - me9, me15 - me13)
        .normalize(),
      planes[4]
        .setComponents(me3 - me2, me7 - me6, me11 - me10, me15 - me14)
        .normalize(),
      planes[5]
        .setComponents(me3 + me2, me7 + me6, me11 + me10, me15 + me14)
        .normalize(),
      this
    );
  }
  setFromCamera(camera) {
    let matrix = this.M1 || new Matrix4();
    return (
      (this.M1 = matrix),
      matrix.multiplyMatrices(
        camera.projectionMatrix,
        camera.matrixWorldInverse
      ),
      this.setFromMatrix(matrix)
    );
  }
  intersectsObject(object, setAsBoolean = !0) {
    let sphere = this.S1 || new Sphere();
    this.S1 = sphere;
    let geometry = object.geometry;
    return (
      !!geometry &&
      (null === geometry.boundingSphere && geometry.computeBoundingSphere(),
      sphere.copy(geometry.boundingSphere).applyMatrix4(object.matrixWorld),
      this.intersectsSphere(sphere, setAsBoolean))
    );
  }
  intersectsSphere(sphere, setAsBoolean = !0) {
    let planes = this.planes,
      center = sphere.center,
      negRadius = -sphere.radius,
      insides = 0;
    for (let i = 0; i < 6; i++) {
      let distance = planes[i].distanceToPoint(center);
      if (distance < negRadius) return !setAsBoolean && -1;
      !setAsBoolean && distance >= 0 && insides++;
    }
    return !!setAsBoolean || (6 === insides ? 1 : 0);
  }
  intersectsBox(box) {
    let p1 = this.V1 || new Vector3(),
      p2 = this.V2 || new Vector3();
    (this.V1 = p1), (this.V2 = p2);
    let planes = this.planes;
    for (let i = 0; i < 6; i++) {
      let plane = planes[i];
      (p1.x = plane.normal.x > 0 ? box.min.x : box.max.x),
        (p2.x = plane.normal.x > 0 ? box.max.x : box.min.x),
        (p1.y = plane.normal.y > 0 ? box.min.y : box.max.y),
        (p2.y = plane.normal.y > 0 ? box.max.y : box.min.y),
        (p1.z = plane.normal.z > 0 ? box.min.z : box.max.z),
        (p2.z = plane.normal.z > 0 ? box.max.z : box.min.z);
      let d1 = plane.distanceToPoint(p1),
        d2 = plane.distanceToPoint(p2);
      if (d1 < 0 && d2 < 0) return !1;
    }
    return !0;
  }
  containsPoint(point) {
    let planes = this.planes;
    for (let i = 0; i < 6; i++)
      if (planes[i].distanceToPoint(point) < 0) return !1;
    return !0;
  }
}
class Line3 {
  constructor(start = new Vector3(), end = new Vector3()) {
    (this.start = start), (this.end = end);
  }
  set(start, end) {
    return this.start.copy(start), this.end.copy(end), this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(line) {
    return this.start.copy(line.start), this.end.copy(line.end), this;
  }
  getCenter(target = new Vector3()) {
    return target.addVectors(this.start, this.end).multiplyScalar(0.5);
  }
  delta(target = new Vector3()) {
    return target.subVectors(this.end, this.start);
  }
  distanceSq() {
    return this.start.distanceToSquared(this.end);
  }
  distance() {
    return this.start.distanceTo(this.end);
  }
  at(t, target = new Vector3()) {
    return this.delta(target).multiplyScalar(t).add(this.start);
  }
  closestPointToPointParameter(point, clampToLine) {
    let startP = this.V1 || new Vector3(),
      startEnd = this.V2 || new Vector3();
    (this.V1 = startP),
      (this.V2 = startEnd),
      startP.subVectors(point, this.start),
      startEnd.subVectors(this.end, this.start);
    let startEnd2 = startEnd.dot(startEnd),
      t = startEnd.dot(startP) / startEnd2;
    return clampToLine && (t = Math.clamp(t, 0, 1)), t;
  }
  closestPointToPoint(point, clampToLine, target = new Vector3()) {
    let t = this.closestPointToPointParameter(point, clampToLine);
    return this.delta(target).multiplyScalar(t).add(this.start);
  }
  applyMatrix4(matrix) {
    return this.start.applyMatrix4(matrix), this.end.applyMatrix4(matrix), this;
  }
  equals(line) {
    return line.start.equals(this.start) && line.end.equals(this.end);
  }
}
class Matrix3 {
  constructor() {
    this.elements = new Float32Array([1, 0, 0, 0, 1, 0, 0, 0, 1]);
  }
  set(n11, n12, n13, n21, n22, n23, n31, n32, n33) {
    let te = this.elements;
    return (
      (te[0] = n11),
      (te[1] = n21),
      (te[2] = n31),
      (te[3] = n12),
      (te[4] = n22),
      (te[5] = n32),
      (te[6] = n13),
      (te[7] = n23),
      (te[8] = n33),
      this
    );
  }
  identity() {
    return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this;
  }
  clone() {
    return new Matrix3().fromArray(this.elements);
  }
  copy(m) {
    let te = this.elements,
      me = m.elements;
    return (
      (te[0] = me[0]),
      (te[1] = me[1]),
      (te[2] = me[2]),
      (te[3] = me[3]),
      (te[4] = me[4]),
      (te[5] = me[5]),
      (te[6] = me[6]),
      (te[7] = me[7]),
      (te[8] = me[8]),
      this
    );
  }
  setFromMatrix4(m) {
    let me = m.elements;
    return (
      this.set(me[0], me[4], me[8], me[1], me[5], me[9], me[2], me[6], me[10]),
      this
    );
  }
  multiply(m) {
    return this.multiplyMatrices(this, m);
  }
  premultiply(m) {
    return this.multiplyMatrices(m, this);
  }
  multiplyMatrices(a, b) {
    let ae = a.elements,
      be = b.elements,
      te = this.elements,
      a11 = ae[0],
      a12 = ae[3],
      a13 = ae[6],
      a21 = ae[1],
      a22 = ae[4],
      a23 = ae[7],
      a31 = ae[2],
      a32 = ae[5],
      a33 = ae[8],
      b11 = be[0],
      b12 = be[3],
      b13 = be[6],
      b21 = be[1],
      b22 = be[4],
      b23 = be[7],
      b31 = be[2],
      b32 = be[5],
      b33 = be[8];
    return (
      (te[0] = a11 * b11 + a12 * b21 + a13 * b31),
      (te[3] = a11 * b12 + a12 * b22 + a13 * b32),
      (te[6] = a11 * b13 + a12 * b23 + a13 * b33),
      (te[1] = a21 * b11 + a22 * b21 + a23 * b31),
      (te[4] = a21 * b12 + a22 * b22 + a23 * b32),
      (te[7] = a21 * b13 + a22 * b23 + a23 * b33),
      (te[2] = a31 * b11 + a32 * b21 + a33 * b31),
      (te[5] = a31 * b12 + a32 * b22 + a33 * b32),
      (te[8] = a31 * b13 + a32 * b23 + a33 * b33),
      this
    );
  }
  multiplyScalar(s) {
    let te = this.elements;
    return (
      (te[0] *= s),
      (te[3] *= s),
      (te[6] *= s),
      (te[1] *= s),
      (te[4] *= s),
      (te[7] *= s),
      (te[2] *= s),
      (te[5] *= s),
      (te[8] *= s),
      this
    );
  }
  determinant() {
    let te = this.elements,
      a = te[0],
      b = te[1],
      c = te[2],
      d = te[3],
      e = te[4],
      f = te[5],
      g = te[6],
      h = te[7],
      i = te[8];
    return (
      a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g
    );
  }
  getInverse(matrix, throwOnDegenerate) {
    let me = matrix.elements,
      te = this.elements,
      n11 = me[0],
      n21 = me[1],
      n31 = me[2],
      n12 = me[3],
      n22 = me[4],
      n32 = me[5],
      n13 = me[6],
      n23 = me[7],
      n33 = me[8],
      t11 = n33 * n22 - n32 * n23,
      t12 = n32 * n13 - n33 * n12,
      t13 = n23 * n12 - n22 * n13,
      det = n11 * t11 + n21 * t12 + n31 * t13;
    if (0 === det) {
      if (!0 === throwOnDegenerate)
        throw new Error(".getInverse() can't invert matrix, determinant is 0");
      return this.identity();
    }
    let detInv = 1 / det;
    return (
      (te[0] = t11 * detInv),
      (te[1] = (n31 * n23 - n33 * n21) * detInv),
      (te[2] = (n32 * n21 - n31 * n22) * detInv),
      (te[3] = t12 * detInv),
      (te[4] = (n33 * n11 - n31 * n13) * detInv),
      (te[5] = (n31 * n12 - n32 * n11) * detInv),
      (te[6] = t13 * detInv),
      (te[7] = (n21 * n13 - n23 * n11) * detInv),
      (te[8] = (n22 * n11 - n21 * n12) * detInv),
      this
    );
  }
  transpose() {
    let tmp,
      m = this.elements;
    return (
      (tmp = m[1]),
      (m[1] = m[3]),
      (m[3] = tmp),
      (tmp = m[2]),
      (m[2] = m[6]),
      (m[6] = tmp),
      (tmp = m[5]),
      (m[5] = m[7]),
      (m[7] = tmp),
      this
    );
  }
  getNormalMatrix(matrix4) {
    return this.setFromMatrix4(matrix4).getInverse(this).transpose();
  }
  setUvTransform(tx, ty, sx, sy, rotation, cx, cy) {
    let c = Math.cos(rotation),
      s = Math.sin(rotation);
    this.set(
      sx * c,
      sx * s,
      -sx * (c * cx + s * cy) + cx + tx,
      -sy * s,
      sy * c,
      -sy * (-s * cx + c * cy) + cy + ty,
      0,
      0,
      1
    );
  }
  scale(sx, sy) {
    let te = this.elements;
    return (
      (te[0] *= sx),
      (te[3] *= sx),
      (te[6] *= sx),
      (te[1] *= sy),
      (te[4] *= sy),
      (te[7] *= sy),
      this
    );
  }
  rotate(theta) {
    let c = Math.cos(theta),
      s = Math.sin(theta),
      te = this.elements,
      a11 = te[0],
      a12 = te[3],
      a13 = te[6],
      a21 = te[1],
      a22 = te[4],
      a23 = te[7];
    return (
      (te[0] = c * a11 + s * a21),
      (te[3] = c * a12 + s * a22),
      (te[6] = c * a13 + s * a23),
      (te[1] = -s * a11 + c * a21),
      (te[4] = -s * a12 + c * a22),
      (te[7] = -s * a13 + c * a23),
      this
    );
  }
  translate(tx, ty) {
    let te = this.elements;
    return (
      (te[0] += tx * te[2]),
      (te[3] += tx * te[5]),
      (te[6] += tx * te[8]),
      (te[1] += ty * te[2]),
      (te[4] += ty * te[5]),
      (te[7] += ty * te[8]),
      this
    );
  }
  equals(matrix) {
    let te = this.elements,
      me = matrix.elements;
    for (let i = 0; i < 9; i++) if (te[i] !== me[i]) return !1;
    return !0;
  }
  fromArray(array, offset) {
    void 0 === offset && (offset = 0);
    for (let i = 0; i < 9; i++) this.elements[i] = array[i + offset];
    return this;
  }
  toArray(array, offset) {
    void 0 === array && (array = []), void 0 === offset && (offset = 0);
    let te = this.elements;
    return (
      (array[offset] = te[0]),
      (array[offset + 1] = te[1]),
      (array[offset + 2] = te[2]),
      (array[offset + 3] = te[3]),
      (array[offset + 4] = te[4]),
      (array[offset + 5] = te[5]),
      (array[offset + 6] = te[6]),
      (array[offset + 7] = te[7]),
      (array[offset + 8] = te[8]),
      array
    );
  }
  applyToBufferAttribute(attribute) {
    let v1 = this.V1 || new Vector3();
    this.V1 = v1;
    for (let i = 0, l = attribute.count; i < l; i++)
      (v1.x = attribute.array[3 * i + 0]),
        (v1.y = attribute.array[3 * i + 1]),
        (v1.z = attribute.array[3 * i + 2]),
        v1.applyMatrix3(this),
        (attribute.array[3 * i + 0] = v1.x),
        (attribute.array[3 * i + 1] = v1.y),
        (attribute.array[3 * i + 2] = v1.z);
    return attribute;
  }
}
class Matrix4 {
  constructor() {
    this.elements = new Float32Array([
      1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1,
    ]);
  }
  set(
    n11,
    n12,
    n13,
    n14,
    n21,
    n22,
    n23,
    n24,
    n31,
    n32,
    n33,
    n34,
    n41,
    n42,
    n43,
    n44
  ) {
    let te = this.elements;
    return (
      (te[0] = n11),
      (te[4] = n12),
      (te[8] = n13),
      (te[12] = n14),
      (te[1] = n21),
      (te[5] = n22),
      (te[9] = n23),
      (te[13] = n24),
      (te[2] = n31),
      (te[6] = n32),
      (te[10] = n33),
      (te[14] = n34),
      (te[3] = n41),
      (te[7] = n42),
      (te[11] = n43),
      (te[15] = n44),
      this
    );
  }
  identity() {
    return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
  }
  clone() {
    return new Matrix4().fromArray(this.elements);
  }
  copy(m) {
    let te = this.elements,
      me = m.elements;
    return (
      (te[0] = me[0]),
      (te[1] = me[1]),
      (te[2] = me[2]),
      (te[3] = me[3]),
      (te[4] = me[4]),
      (te[5] = me[5]),
      (te[6] = me[6]),
      (te[7] = me[7]),
      (te[8] = me[8]),
      (te[9] = me[9]),
      (te[10] = me[10]),
      (te[11] = me[11]),
      (te[12] = me[12]),
      (te[13] = me[13]),
      (te[14] = me[14]),
      (te[15] = me[15]),
      this
    );
  }
  copyPosition(m) {
    let te = this.elements,
      me = m.elements;
    return (te[12] = me[12]), (te[13] = me[13]), (te[14] = me[14]), this;
  }
  extractBasis(xAxis, yAxis, zAxis) {
    return (
      xAxis.setFromMatrixColumn(this, 0),
      yAxis.setFromMatrixColumn(this, 1),
      zAxis.setFromMatrixColumn(this, 2),
      this
    );
  }
  makeBasis(xAxis, yAxis, zAxis) {
    return (
      this.set(
        xAxis.x,
        yAxis.x,
        zAxis.x,
        0,
        xAxis.y,
        yAxis.y,
        zAxis.y,
        0,
        xAxis.z,
        yAxis.z,
        zAxis.z,
        0,
        0,
        0,
        0,
        1
      ),
      this
    );
  }
  extractRotation(m) {
    let v1 = this.V1 || new Vector3();
    this.V1 = v1;
    let te = this.elements,
      me = m.elements,
      scaleX = 1 / v1.setFromMatrixColumn(m, 0).length(),
      scaleY = 1 / v1.setFromMatrixColumn(m, 1).length(),
      scaleZ = 1 / v1.setFromMatrixColumn(m, 2).length();
    return (
      (te[0] = me[0] * scaleX),
      (te[1] = me[1] * scaleX),
      (te[2] = me[2] * scaleX),
      (te[4] = me[4] * scaleY),
      (te[5] = me[5] * scaleY),
      (te[6] = me[6] * scaleY),
      (te[8] = me[8] * scaleZ),
      (te[9] = me[9] * scaleZ),
      (te[10] = me[10] * scaleZ),
      this
    );
  }
  makeRotationFromEuler(euler) {
    let te = this.elements,
      x = euler.x,
      y = euler.y,
      z = euler.z,
      a = Math.cos(x),
      b = Math.sin(x),
      c = Math.cos(y),
      d = Math.sin(y),
      e = Math.cos(z),
      f = Math.sin(z);
    if ("XYZ" === euler.order) {
      let ae = a * e,
        af = a * f,
        be = b * e,
        bf = b * f;
      (te[0] = c * e),
        (te[4] = -c * f),
        (te[8] = d),
        (te[1] = af + be * d),
        (te[5] = ae - bf * d),
        (te[9] = -b * c),
        (te[2] = bf - ae * d),
        (te[6] = be + af * d),
        (te[10] = a * c);
    } else if ("YXZ" === euler.order) {
      let ce = c * e,
        cf = c * f,
        de = d * e,
        df = d * f;
      (te[0] = ce + df * b),
        (te[4] = de * b - cf),
        (te[8] = a * d),
        (te[1] = a * f),
        (te[5] = a * e),
        (te[9] = -b),
        (te[2] = cf * b - de),
        (te[6] = df + ce * b),
        (te[10] = a * c);
    } else if ("ZXY" === euler.order) {
      let ce = c * e,
        cf = c * f,
        de = d * e,
        df = d * f;
      (te[0] = ce - df * b),
        (te[4] = -a * f),
        (te[8] = de + cf * b),
        (te[1] = cf + de * b),
        (te[5] = a * e),
        (te[9] = df - ce * b),
        (te[2] = -a * d),
        (te[6] = b),
        (te[10] = a * c);
    } else if ("ZYX" === euler.order) {
      let ae = a * e,
        af = a * f,
        be = b * e,
        bf = b * f;
      (te[0] = c * e),
        (te[4] = be * d - af),
        (te[8] = ae * d + bf),
        (te[1] = c * f),
        (te[5] = bf * d + ae),
        (te[9] = af * d - be),
        (te[2] = -d),
        (te[6] = b * c),
        (te[10] = a * c);
    } else if ("YZX" === euler.order) {
      let ac = a * c,
        ad = a * d,
        bc = b * c,
        bd = b * d;
      (te[0] = c * e),
        (te[4] = bd - ac * f),
        (te[8] = bc * f + ad),
        (te[1] = f),
        (te[5] = a * e),
        (te[9] = -b * e),
        (te[2] = -d * e),
        (te[6] = ad * f + bc),
        (te[10] = ac - bd * f);
    } else if ("XZY" === euler.order) {
      let ac = a * c,
        ad = a * d,
        bc = b * c,
        bd = b * d;
      (te[0] = c * e),
        (te[4] = -f),
        (te[8] = d * e),
        (te[1] = ac * f + bd),
        (te[5] = a * e),
        (te[9] = ad * f - bc),
        (te[2] = bc * f - ad),
        (te[6] = b * e),
        (te[10] = bd * f + ac);
    }
    return (
      (te[3] = 0),
      (te[7] = 0),
      (te[11] = 0),
      (te[12] = 0),
      (te[13] = 0),
      (te[14] = 0),
      (te[15] = 1),
      this
    );
  }
  makeRotationFromQuaternion(q) {
    let te = this.elements,
      x = q._x,
      y = q._y,
      z = q._z,
      w = q._w,
      x2 = x + x,
      y2 = y + y,
      z2 = z + z,
      xx = x * x2,
      xy = x * y2,
      xz = x * z2,
      yy = y * y2,
      yz = y * z2,
      zz = z * z2,
      wx = w * x2,
      wy = w * y2,
      wz = w * z2;
    return (
      (te[0] = 1 - (yy + zz)),
      (te[4] = xy - wz),
      (te[8] = xz + wy),
      (te[1] = xy + wz),
      (te[5] = 1 - (xx + zz)),
      (te[9] = yz - wx),
      (te[2] = xz - wy),
      (te[6] = yz + wx),
      (te[10] = 1 - (xx + yy)),
      (te[3] = 0),
      (te[7] = 0),
      (te[11] = 0),
      (te[12] = 0),
      (te[13] = 0),
      (te[14] = 0),
      (te[15] = 1),
      this
    );
  }
  lookAt(eye, target, up) {
    let x = this.V1 || new Vector3(),
      y = this.V2 || new Vector3(),
      z = this.V3 || new Vector3();
    (this.V1 = x), (this.V2 = y), (this.V3 = z);
    let te = this.elements;
    return (
      z.subVectors(eye, target),
      0 === z.lengthSq() && (z.z = 1),
      z.normalize(),
      x.crossVectors(up, z),
      0 === x.lengthSq() &&
        (1 === Math.abs(up.z) ? (z.x += 1e-4) : (z.z += 1e-4),
        z.normalize(),
        x.crossVectors(up, z)),
      x.normalize(),
      y.crossVectors(z, x),
      (te[0] = x.x),
      (te[4] = y.x),
      (te[8] = z.x),
      (te[1] = x.y),
      (te[5] = y.y),
      (te[9] = z.y),
      (te[2] = x.z),
      (te[6] = y.z),
      (te[10] = z.z),
      this
    );
  }
  multiply(m) {
    return this.multiplyMatrices(this, m);
  }
  premultiply(m) {
    return this.multiplyMatrices(m, this);
  }
  multiplyMatrices(ae, be) {
    let a = ae.elements,
      b = be.elements,
      out = this.elements,
      a00 = a[0],
      a01 = a[1],
      a02 = a[2],
      a03 = a[3],
      a10 = a[4],
      a11 = a[5],
      a12 = a[6],
      a13 = a[7],
      a20 = a[8],
      a21 = a[9],
      a22 = a[10],
      a23 = a[11],
      a30 = a[12],
      a31 = a[13],
      a32 = a[14],
      a33 = a[15],
      b0 = b[0],
      b1 = b[1],
      b2 = b[2],
      b3 = b[3];
    return (
      (out[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30),
      (out[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31),
      (out[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32),
      (out[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33),
      (b0 = b[4]),
      (b1 = b[5]),
      (b2 = b[6]),
      (b3 = b[7]),
      (out[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30),
      (out[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31),
      (out[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32),
      (out[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33),
      (b0 = b[8]),
      (b1 = b[9]),
      (b2 = b[10]),
      (b3 = b[11]),
      (out[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30),
      (out[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31),
      (out[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32),
      (out[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33),
      (b0 = b[12]),
      (b1 = b[13]),
      (b2 = b[14]),
      (b3 = b[15]),
      (out[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30),
      (out[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31),
      (out[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32),
      (out[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33),
      this
    );
  }
  multiplyScalar(s) {
    let te = this.elements;
    return (
      (te[0] *= s),
      (te[4] *= s),
      (te[8] *= s),
      (te[12] *= s),
      (te[1] *= s),
      (te[5] *= s),
      (te[9] *= s),
      (te[13] *= s),
      (te[2] *= s),
      (te[6] *= s),
      (te[10] *= s),
      (te[14] *= s),
      (te[3] *= s),
      (te[7] *= s),
      (te[11] *= s),
      (te[15] *= s),
      this
    );
  }
  determinant() {
    let te = this.elements,
      n11 = te[0],
      n12 = te[4],
      n13 = te[8],
      n14 = te[12],
      n21 = te[1],
      n22 = te[5],
      n23 = te[9],
      n24 = te[13],
      n31 = te[2],
      n32 = te[6],
      n33 = te[10],
      n34 = te[14];
    return (
      te[3] *
        (+n14 * n23 * n32 -
          n13 * n24 * n32 -
          n14 * n22 * n33 +
          n12 * n24 * n33 +
          n13 * n22 * n34 -
          n12 * n23 * n34) +
      te[7] *
        (+n11 * n23 * n34 -
          n11 * n24 * n33 +
          n14 * n21 * n33 -
          n13 * n21 * n34 +
          n13 * n24 * n31 -
          n14 * n23 * n31) +
      te[11] *
        (+n11 * n24 * n32 -
          n11 * n22 * n34 -
          n14 * n21 * n32 +
          n12 * n21 * n34 +
          n14 * n22 * n31 -
          n12 * n24 * n31) +
      te[15] *
        (-n13 * n22 * n31 -
          n11 * n23 * n32 +
          n11 * n22 * n33 +
          n13 * n21 * n32 -
          n12 * n21 * n33 +
          n12 * n23 * n31)
    );
  }
  transpose() {
    let tmp,
      te = this.elements;
    return (
      (tmp = te[1]),
      (te[1] = te[4]),
      (te[4] = tmp),
      (tmp = te[2]),
      (te[2] = te[8]),
      (te[8] = tmp),
      (tmp = te[6]),
      (te[6] = te[9]),
      (te[9] = tmp),
      (tmp = te[3]),
      (te[3] = te[12]),
      (te[12] = tmp),
      (tmp = te[7]),
      (te[7] = te[13]),
      (te[13] = tmp),
      (tmp = te[11]),
      (te[11] = te[14]),
      (te[14] = tmp),
      this
    );
  }
  setPosition(v) {
    let te = this.elements;
    return (te[12] = v.x), (te[13] = v.y), (te[14] = v.z), this;
  }
  getInverse(m, throwOnDegenerate) {
    let te = this.elements,
      me = m.elements,
      n11 = me[0],
      n21 = me[1],
      n31 = me[2],
      n41 = me[3],
      n12 = me[4],
      n22 = me[5],
      n32 = me[6],
      n42 = me[7],
      n13 = me[8],
      n23 = me[9],
      n33 = me[10],
      n43 = me[11],
      n14 = me[12],
      n24 = me[13],
      n34 = me[14],
      n44 = me[15],
      t11 =
        n23 * n34 * n42 -
        n24 * n33 * n42 +
        n24 * n32 * n43 -
        n22 * n34 * n43 -
        n23 * n32 * n44 +
        n22 * n33 * n44,
      t12 =
        n14 * n33 * n42 -
        n13 * n34 * n42 -
        n14 * n32 * n43 +
        n12 * n34 * n43 +
        n13 * n32 * n44 -
        n12 * n33 * n44,
      t13 =
        n13 * n24 * n42 -
        n14 * n23 * n42 +
        n14 * n22 * n43 -
        n12 * n24 * n43 -
        n13 * n22 * n44 +
        n12 * n23 * n44,
      t14 =
        n14 * n23 * n32 -
        n13 * n24 * n32 -
        n14 * n22 * n33 +
        n12 * n24 * n33 +
        n13 * n22 * n34 -
        n12 * n23 * n34,
      det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;
    if (0 === det) {
      if (!0 === throwOnDegenerate)
        throw new Error(".getInverse() can't invert matrix, determinant is 0");
      return this.identity();
    }
    let detInv = 1 / det;
    return (
      (te[0] = t11 * detInv),
      (te[1] =
        (n24 * n33 * n41 -
          n23 * n34 * n41 -
          n24 * n31 * n43 +
          n21 * n34 * n43 +
          n23 * n31 * n44 -
          n21 * n33 * n44) *
        detInv),
      (te[2] =
        (n22 * n34 * n41 -
          n24 * n32 * n41 +
          n24 * n31 * n42 -
          n21 * n34 * n42 -
          n22 * n31 * n44 +
          n21 * n32 * n44) *
        detInv),
      (te[3] =
        (n23 * n32 * n41 -
          n22 * n33 * n41 -
          n23 * n31 * n42 +
          n21 * n33 * n42 +
          n22 * n31 * n43 -
          n21 * n32 * n43) *
        detInv),
      (te[4] = t12 * detInv),
      (te[5] =
        (n13 * n34 * n41 -
          n14 * n33 * n41 +
          n14 * n31 * n43 -
          n11 * n34 * n43 -
          n13 * n31 * n44 +
          n11 * n33 * n44) *
        detInv),
      (te[6] =
        (n14 * n32 * n41 -
          n12 * n34 * n41 -
          n14 * n31 * n42 +
          n11 * n34 * n42 +
          n12 * n31 * n44 -
          n11 * n32 * n44) *
        detInv),
      (te[7] =
        (n12 * n33 * n41 -
          n13 * n32 * n41 +
          n13 * n31 * n42 -
          n11 * n33 * n42 -
          n12 * n31 * n43 +
          n11 * n32 * n43) *
        detInv),
      (te[8] = t13 * detInv),
      (te[9] =
        (n14 * n23 * n41 -
          n13 * n24 * n41 -
          n14 * n21 * n43 +
          n11 * n24 * n43 +
          n13 * n21 * n44 -
          n11 * n23 * n44) *
        detInv),
      (te[10] =
        (n12 * n24 * n41 -
          n14 * n22 * n41 +
          n14 * n21 * n42 -
          n11 * n24 * n42 -
          n12 * n21 * n44 +
          n11 * n22 * n44) *
        detInv),
      (te[11] =
        (n13 * n22 * n41 -
          n12 * n23 * n41 -
          n13 * n21 * n42 +
          n11 * n23 * n42 +
          n12 * n21 * n43 -
          n11 * n22 * n43) *
        detInv),
      (te[12] = t14 * detInv),
      (te[13] =
        (n13 * n24 * n31 -
          n14 * n23 * n31 +
          n14 * n21 * n33 -
          n11 * n24 * n33 -
          n13 * n21 * n34 +
          n11 * n23 * n34) *
        detInv),
      (te[14] =
        (n14 * n22 * n31 -
          n12 * n24 * n31 -
          n14 * n21 * n32 +
          n11 * n24 * n32 +
          n12 * n21 * n34 -
          n11 * n22 * n34) *
        detInv),
      (te[15] =
        (n12 * n23 * n31 -
          n13 * n22 * n31 +
          n13 * n21 * n32 -
          n11 * n23 * n32 -
          n12 * n21 * n33 +
          n11 * n22 * n33) *
        detInv),
      this
    );
  }
  invert() {
    const te = this.elements,
      n11 = te[0],
      n21 = te[1],
      n31 = te[2],
      n41 = te[3],
      n12 = te[4],
      n22 = te[5],
      n32 = te[6],
      n42 = te[7],
      n13 = te[8],
      n23 = te[9],
      n33 = te[10],
      n43 = te[11],
      n14 = te[12],
      n24 = te[13],
      n34 = te[14],
      n44 = te[15],
      t11 =
        n23 * n34 * n42 -
        n24 * n33 * n42 +
        n24 * n32 * n43 -
        n22 * n34 * n43 -
        n23 * n32 * n44 +
        n22 * n33 * n44,
      t12 =
        n14 * n33 * n42 -
        n13 * n34 * n42 -
        n14 * n32 * n43 +
        n12 * n34 * n43 +
        n13 * n32 * n44 -
        n12 * n33 * n44,
      t13 =
        n13 * n24 * n42 -
        n14 * n23 * n42 +
        n14 * n22 * n43 -
        n12 * n24 * n43 -
        n13 * n22 * n44 +
        n12 * n23 * n44,
      t14 =
        n14 * n23 * n32 -
        n13 * n24 * n32 -
        n14 * n22 * n33 +
        n12 * n24 * n33 +
        n13 * n22 * n34 -
        n12 * n23 * n34,
      det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;
    if (0 === det)
      return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    const detInv = 1 / det;
    return (
      (te[0] = t11 * detInv),
      (te[1] =
        (n24 * n33 * n41 -
          n23 * n34 * n41 -
          n24 * n31 * n43 +
          n21 * n34 * n43 +
          n23 * n31 * n44 -
          n21 * n33 * n44) *
        detInv),
      (te[2] =
        (n22 * n34 * n41 -
          n24 * n32 * n41 +
          n24 * n31 * n42 -
          n21 * n34 * n42 -
          n22 * n31 * n44 +
          n21 * n32 * n44) *
        detInv),
      (te[3] =
        (n23 * n32 * n41 -
          n22 * n33 * n41 -
          n23 * n31 * n42 +
          n21 * n33 * n42 +
          n22 * n31 * n43 -
          n21 * n32 * n43) *
        detInv),
      (te[4] = t12 * detInv),
      (te[5] =
        (n13 * n34 * n41 -
          n14 * n33 * n41 +
          n14 * n31 * n43 -
          n11 * n34 * n43 -
          n13 * n31 * n44 +
          n11 * n33 * n44) *
        detInv),
      (te[6] =
        (n14 * n32 * n41 -
          n12 * n34 * n41 -
          n14 * n31 * n42 +
          n11 * n34 * n42 +
          n12 * n31 * n44 -
          n11 * n32 * n44) *
        detInv),
      (te[7] =
        (n12 * n33 * n41 -
          n13 * n32 * n41 +
          n13 * n31 * n42 -
          n11 * n33 * n42 -
          n12 * n31 * n43 +
          n11 * n32 * n43) *
        detInv),
      (te[8] = t13 * detInv),
      (te[9] =
        (n14 * n23 * n41 -
          n13 * n24 * n41 -
          n14 * n21 * n43 +
          n11 * n24 * n43 +
          n13 * n21 * n44 -
          n11 * n23 * n44) *
        detInv),
      (te[10] =
        (n12 * n24 * n41 -
          n14 * n22 * n41 +
          n14 * n21 * n42 -
          n11 * n24 * n42 -
          n12 * n21 * n44 +
          n11 * n22 * n44) *
        detInv),
      (te[11] =
        (n13 * n22 * n41 -
          n12 * n23 * n41 -
          n13 * n21 * n42 +
          n11 * n23 * n42 +
          n12 * n21 * n43 -
          n11 * n22 * n43) *
        detInv),
      (te[12] = t14 * detInv),
      (te[13] =
        (n13 * n24 * n31 -
          n14 * n23 * n31 +
          n14 * n21 * n33 -
          n11 * n24 * n33 -
          n13 * n21 * n34 +
          n11 * n23 * n34) *
        detInv),
      (te[14] =
        (n14 * n22 * n31 -
          n12 * n24 * n31 -
          n14 * n21 * n32 +
          n11 * n24 * n32 +
          n12 * n21 * n34 -
          n11 * n22 * n34) *
        detInv),
      (te[15] =
        (n12 * n23 * n31 -
          n13 * n22 * n31 +
          n13 * n21 * n32 -
          n11 * n23 * n32 -
          n12 * n21 * n33 +
          n11 * n22 * n33) *
        detInv),
      this
    );
  }
  scale(v) {
    let te = this.elements,
      x = v.x,
      y = v.y,
      z = v.z;
    return (
      (te[0] *= x),
      (te[4] *= y),
      (te[8] *= z),
      (te[1] *= x),
      (te[5] *= y),
      (te[9] *= z),
      (te[2] *= x),
      (te[6] *= y),
      (te[10] *= z),
      (te[3] *= x),
      (te[7] *= y),
      (te[11] *= z),
      this
    );
  }
  getMaxScaleOnAxis() {
    let te = this.elements,
      scaleXSq = te[0] * te[0] + te[1] * te[1] + te[2] * te[2],
      scaleYSq = te[4] * te[4] + te[5] * te[5] + te[6] * te[6],
      scaleZSq = te[8] * te[8] + te[9] * te[9] + te[10] * te[10];
    return Math.sqrt(Math.max(scaleXSq, scaleYSq, scaleZSq));
  }
  makeTranslation(x, y, z) {
    return this.set(1, 0, 0, x, 0, 1, 0, y, 0, 0, 1, z, 0, 0, 0, 1), this;
  }
  makeRotationX(theta) {
    let c = Math.cos(theta),
      s = Math.sin(theta);
    return this.set(1, 0, 0, 0, 0, c, -s, 0, 0, s, c, 0, 0, 0, 0, 1), this;
  }
  makeRotationY(theta) {
    let c = Math.cos(theta),
      s = Math.sin(theta);
    return this.set(c, 0, s, 0, 0, 1, 0, 0, -s, 0, c, 0, 0, 0, 0, 1), this;
  }
  makeRotationZ(theta) {
    let c = Math.cos(theta),
      s = Math.sin(theta);
    return this.set(c, -s, 0, 0, s, c, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
  }
  makeRotationAxis(axis, angle) {
    let c = Math.cos(angle),
      s = Math.sin(angle),
      t = 1 - c,
      x = axis.x,
      y = axis.y,
      z = axis.z,
      tx = t * x,
      ty = t * y;
    return (
      this.set(
        tx * x + c,
        tx * y - s * z,
        tx * z + s * y,
        0,
        tx * y + s * z,
        ty * y + c,
        ty * z - s * x,
        0,
        tx * z - s * y,
        ty * z + s * x,
        t * z * z + c,
        0,
        0,
        0,
        0,
        1
      ),
      this
    );
  }
  makeScale(x, y, z) {
    return this.set(x, 0, 0, 0, 0, y, 0, 0, 0, 0, z, 0, 0, 0, 0, 1), this;
  }
  makeShear(x, y, z) {
    return this.set(1, y, z, 0, x, 1, z, 0, x, y, 1, 0, 0, 0, 0, 1), this;
  }
  compose(position, quaternion, scale) {
    return (
      this.makeRotationFromQuaternion(quaternion),
      this.scale(scale),
      this.setPosition(position),
      this
    );
  }
  decompose(position, quaternion, scale) {
    let vector = this.V1 || new Vector3();
    this.V1 = vector;
    let matrix = this.M1 || new Matrix4();
    this.M1 = matrix;
    let te = this.elements,
      sx = vector.set(te[0], te[1], te[2]).length(),
      sy = vector.set(te[4], te[5], te[6]).length(),
      sz = vector.set(te[8], te[9], te[10]).length();
    this.determinant() < 0 && (sx = -sx),
      (position.x = te[12]),
      (position.y = te[13]),
      (position.z = te[14]),
      matrix.copy(this);
    let invSX = 1 / sx,
      invSY = 1 / sy,
      invSZ = 1 / sz;
    return (
      (matrix.elements[0] *= invSX),
      (matrix.elements[1] *= invSX),
      (matrix.elements[2] *= invSX),
      (matrix.elements[4] *= invSY),
      (matrix.elements[5] *= invSY),
      (matrix.elements[6] *= invSY),
      (matrix.elements[8] *= invSZ),
      (matrix.elements[9] *= invSZ),
      (matrix.elements[10] *= invSZ),
      quaternion.setFromRotationMatrix(matrix),
      (scale.x = sx),
      (scale.y = sy),
      (scale.z = sz),
      this
    );
  }
  makePerspective(left, right, top, bottom, near, far) {
    let te = this.elements,
      x = (2 * near) / (right - left),
      y = (2 * near) / (top - bottom),
      a = (right + left) / (right - left),
      b = (top + bottom) / (top - bottom),
      c = -(far + near) / (far - near),
      d = (-2 * far * near) / (far - near);
    return (
      (te[0] = x),
      (te[4] = 0),
      (te[8] = a),
      (te[12] = 0),
      (te[1] = 0),
      (te[5] = y),
      (te[9] = b),
      (te[13] = 0),
      (te[2] = 0),
      (te[6] = 0),
      (te[10] = c),
      (te[14] = d),
      (te[3] = 0),
      (te[7] = 0),
      (te[11] = -1),
      (te[15] = 0),
      this
    );
  }
  makeOrthographic(left, right, top, bottom, near, far) {
    let te = this.elements,
      w = 1 / (right - left),
      h = 1 / (top - bottom),
      p = 1 / (far - near),
      x = (right + left) * w,
      y = (top + bottom) * h,
      z = (far + near) * p;
    return (
      (te[0] = 2 * w),
      (te[4] = 0),
      (te[8] = 0),
      (te[12] = -x),
      (te[1] = 0),
      (te[5] = 2 * h),
      (te[9] = 0),
      (te[13] = -y),
      (te[2] = 0),
      (te[6] = 0),
      (te[10] = -2 * p),
      (te[14] = -z),
      (te[3] = 0),
      (te[7] = 0),
      (te[11] = 0),
      (te[15] = 1),
      this
    );
  }
  equals(matrix) {
    let te = this.elements,
      me = matrix.elements;
    return (
      te[0] == me[0] &&
      te[1] == me[1] &&
      te[2] == me[2] &&
      te[3] == me[3] &&
      te[4] == me[4] &&
      te[5] == me[5] &&
      te[6] == me[6] &&
      te[7] == me[7] &&
      te[8] == me[8] &&
      te[9] == me[9] &&
      te[10] == me[10] &&
      te[11] == me[11] &&
      te[12] == me[12] &&
      te[13] == me[13] &&
      te[14] == me[14] &&
      te[15] == me[15]
    );
  }
  fromArray(array, offset = 0) {
    let te = this.elements;
    return (
      (te[0] = array[0 + offset]),
      (te[1] = array[1 + offset]),
      (te[2] = array[2 + offset]),
      (te[3] = array[3 + offset]),
      (te[4] = array[4 + offset]),
      (te[5] = array[5 + offset]),
      (te[6] = array[6 + offset]),
      (te[7] = array[7 + offset]),
      (te[8] = array[8 + offset]),
      (te[9] = array[9 + offset]),
      (te[10] = array[10 + offset]),
      (te[11] = array[11 + offset]),
      (te[12] = array[12 + offset]),
      (te[13] = array[13 + offset]),
      (te[14] = array[14 + offset]),
      (te[15] = array[15 + offset]),
      this
    );
  }
  toArray(array, offset) {
    void 0 === array && (array = []), void 0 === offset && (offset = 0);
    let te = this.elements;
    return (
      (array[offset] = te[0]),
      (array[offset + 1] = te[1]),
      (array[offset + 2] = te[2]),
      (array[offset + 3] = te[3]),
      (array[offset + 4] = te[4]),
      (array[offset + 5] = te[5]),
      (array[offset + 6] = te[6]),
      (array[offset + 7] = te[7]),
      (array[offset + 8] = te[8]),
      (array[offset + 9] = te[9]),
      (array[offset + 10] = te[10]),
      (array[offset + 11] = te[11]),
      (array[offset + 12] = te[12]),
      (array[offset + 13] = te[13]),
      (array[offset + 14] = te[14]),
      (array[offset + 15] = te[15]),
      array
    );
  }
  applyToBufferAttribute(attribute) {
    let v1 = this.V1 || new Vector3();
    this.V1 = v1;
    for (let i = 0, l = attribute.count; i < l; i++)
      (v1.x = attribute.array[3 * i + 0]),
        (v1.y = attribute.array[3 * i + 1]),
        (v1.z = attribute.array[3 * i + 2]),
        v1.applyMatrix4(this),
        (attribute.array[3 * i + 0] = v1.x),
        (attribute.array[3 * i + 1] = v1.y),
        (attribute.array[3 * i + 2] = v1.z);
    return attribute;
  }
  isIdentity() {
    let te = this.elements;
    return (
      1 == te[0] &&
      0 == te[1] &&
      0 == te[2] &&
      0 == te[3] &&
      0 == te[4] &&
      1 == te[5] &&
      0 == te[6] &&
      0 == te[7] &&
      0 == te[8] &&
      0 == te[9] &&
      1 == te[10] &&
      0 == te[11] &&
      0 == te[12] &&
      0 == te[13] &&
      0 == te[14] &&
      1 == te[15]
    );
  }
}
Matrix4.__IDENTITY__ = new Matrix4();
class Plane {
  constructor(normal, constant) {
    (this.normal = void 0 !== normal ? normal : new Vector3(1, 0, 0)),
      (this.constant = void 0 !== constant ? constant : 0);
  }
  set(normal, constant) {
    return this.normal.copy(normal), (this.constant = constant), this;
  }
  setComponents(x, y, z, w) {
    return this.normal.set(x, y, z), (this.constant = w), this;
  }
  setFromNormalAndCoplanarPoint(normal, point) {
    return (
      this.normal.copy(normal), (this.constant = -point.dot(this.normal)), this
    );
  }
  setFromCoplanarPoints(a, b, c) {
    let v1 = this.V1 || new Vector3(),
      v2 = this.V2 || new Vector3();
    (this.V1 = v1), (this.V2 = v2);
    var normal = v1.subVectors(c, b).cross(v2.subVectors(a, b)).normalize();
    return this.setFromNormalAndCoplanarPoint(normal, a), this;
  }
  clone() {
    return new Plane().copy(this);
  }
  copy(plane) {
    return (
      this.normal.copy(plane.normal), (this.constant = plane.constant), this
    );
  }
  normalize() {
    var inverseNormalLength = 1 / this.normal.length();
    return (
      this.normal.multiplyScalar(inverseNormalLength),
      (this.constant *= inverseNormalLength),
      this
    );
  }
  negate() {
    return (this.constant *= -1), this.normal.negate(), this;
  }
  distanceToPoint(point) {
    return this.normal.dot(point) + this.constant;
  }
  distanceToSphere(sphere) {
    return this.distanceToPoint(sphere.center) - sphere.radius;
  }
  projectPoint(point, target) {
    return target
      .copy(this.normal)
      .multiplyScalar(-this.distanceToPoint(point))
      .add(point);
  }
  intersectLine(line, target) {
    let v1 = this.V1 || new Vector3();
    this.V1 = v1;
    var direction = line.delta(v1),
      denominator = this.normal.dot(direction);
    if (0 === denominator)
      return 0 === this.distanceToPoint(line.start)
        ? target.copy(line.start)
        : void 0;
    var t = -(line.start.dot(this.normal) + this.constant) / denominator;
    return t < 0 || t > 1
      ? void 0
      : target.copy(direction).multiplyScalar(t).add(line.start);
  }
  intersectsLine(line) {
    var startSign = this.distanceToPoint(line.start),
      endSign = this.distanceToPoint(line.end);
    return (startSign < 0 && endSign > 0) || (endSign < 0 && startSign > 0);
  }
  intersectsBox(box) {
    return box.intersectsPlane(this);
  }
  intersectsSphere(sphere) {
    return sphere.intersectsPlane(this);
  }
  coplanarPoint(target) {
    return target.copy(this.normal).multiplyScalar(-this.constant);
  }
  applyMatrix4(matrix, optionalNormalMatrix) {
    let v1 = this.V1 || new Vector3();
    this.V1 = v1;
    let m1 = this.M1 || new Matrix3();
    this.M1 = m1;
    var normalMatrix = optionalNormalMatrix || m1.getNormalMatrix(matrix),
      referencePoint = this.coplanarPoint(v1).applyMatrix4(matrix),
      normal = this.normal.applyMatrix3(normalMatrix).normalize();
    return (this.constant = -referencePoint.dot(normal)), this;
  }
  translate(offset) {
    return (this.constant -= offset.dot(this.normal)), this;
  }
  equals(plane) {
    return plane.normal.equals(this.normal) && plane.constant === this.constant;
  }
}
class Quaternion {
  constructor(x, y, z, w) {
    (this._x = x || 0),
      (this._y = y || 0),
      (this._z = z || 0),
      (this._w = void 0 !== w ? w : 1),
      (this.isQuaternion = !0);
  }
  get x() {
    return this._x;
  }
  set x(v) {
    if (zUtils3D.LOCAL && isNaN(v)) return console.trace("Quaternion::NaN");
    let dirty = Math.abs(this._x - v) > Base3D.DIRTY_EPSILON;
    (this._x = v), dirty && this.onChangeCallback();
  }
  get y() {
    return this._y;
  }
  set y(v) {
    if (zUtils3D.LOCAL && isNaN(v)) return console.trace("Quaternion::NaN");
    let dirty = Math.abs(this._y - v) > Base3D.DIRTY_EPSILON;
    (this._y = v), dirty && this.onChangeCallback();
  }
  get z() {
    return this._z;
  }
  set z(v) {
    if (zUtils3D.LOCAL && isNaN(v)) return console.trace("Quaternion::NaN");
    let dirty = Math.abs(this._z - v) > Base3D.DIRTY_EPSILON;
    (this._z = v), dirty && this.onChangeCallback();
  }
  get w() {
    return this._w;
  }
  set w(v) {
    if (zUtils3D.LOCAL && isNaN(v)) return console.trace("Quaternion::NaN");
    let dirty = Math.abs(this._w - v) > Base3D.DIRTY_EPSILON;
    (this._w = v), dirty && this.onChangeCallback();
  }
  clone() {
    return new Quaternion(this._x, this._y, this._z, this._w);
  }
  copy(quaternion) {
    const abs = Math.abs;
    let dirty =
      abs(this._x - quaternion.x) > Base3D.DIRTY_EPSILON ||
      abs(this._y - quaternion.y) > Base3D.DIRTY_EPSILON ||
      abs(this._z - quaternion.z) > Base3D.DIRTY_EPSILON ||
      abs(this._w - quaternion.w) > Base3D.DIRTY_EPSILON;
    return (
      (this._x = quaternion.x),
      (this._y = quaternion.y),
      (this._z = quaternion.z),
      (this._w = quaternion.w),
      dirty && this.onChangeCallback(),
      this
    );
  }
  set(x, y, z, w) {
    const abs = Math.abs;
    let dirty =
      abs(this._x - x) > Base3D.DIRTY_EPSILON ||
      abs(this._y - y) > Base3D.DIRTY_EPSILON ||
      abs(this._z - z) > Base3D.DIRTY_EPSILON ||
      abs(this._w - w) > Base3D.DIRTY_EPSILON;
    (this._x = x),
      (this._y = y),
      (this._z = z),
      (this._w = w),
      dirty && this.onChangeCallback();
  }
  setFromEuler(euler, update) {
    let x = euler._x,
      y = euler._y,
      z = euler._z,
      order = euler.order,
      cos = Math.cos,
      sin = Math.sin,
      c1 = cos(x / 2),
      c2 = cos(y / 2),
      c3 = cos(z / 2),
      s1 = sin(x / 2),
      s2 = sin(y / 2),
      s3 = sin(z / 2);
    return (
      "XYZ" === order
        ? ((this._x = s1 * c2 * c3 + c1 * s2 * s3),
          (this._y = c1 * s2 * c3 - s1 * c2 * s3),
          (this._z = c1 * c2 * s3 + s1 * s2 * c3),
          (this._w = c1 * c2 * c3 - s1 * s2 * s3))
        : "YXZ" === order
        ? ((this._x = s1 * c2 * c3 + c1 * s2 * s3),
          (this._y = c1 * s2 * c3 - s1 * c2 * s3),
          (this._z = c1 * c2 * s3 - s1 * s2 * c3),
          (this._w = c1 * c2 * c3 + s1 * s2 * s3))
        : "ZXY" === order
        ? ((this._x = s1 * c2 * c3 - c1 * s2 * s3),
          (this._y = c1 * s2 * c3 + s1 * c2 * s3),
          (this._z = c1 * c2 * s3 + s1 * s2 * c3),
          (this._w = c1 * c2 * c3 - s1 * s2 * s3))
        : "ZYX" === order
        ? ((this._x = s1 * c2 * c3 - c1 * s2 * s3),
          (this._y = c1 * s2 * c3 + s1 * c2 * s3),
          (this._z = c1 * c2 * s3 - s1 * s2 * c3),
          (this._w = c1 * c2 * c3 + s1 * s2 * s3))
        : "YZX" === order
        ? ((this._x = s1 * c2 * c3 + c1 * s2 * s3),
          (this._y = c1 * s2 * c3 + s1 * c2 * s3),
          (this._z = c1 * c2 * s3 - s1 * s2 * c3),
          (this._w = c1 * c2 * c3 - s1 * s2 * s3))
        : "XZY" === order &&
          ((this._x = s1 * c2 * c3 - c1 * s2 * s3),
          (this._y = c1 * s2 * c3 - s1 * c2 * s3),
          (this._z = c1 * c2 * s3 + s1 * s2 * c3),
          (this._w = c1 * c2 * c3 + s1 * s2 * s3)),
      !1 !== update && this.onChangeCallback(),
      this
    );
  }
  setFromAxisAngle(axis, angle) {
    let halfAngle = angle / 2,
      s = Math.sin(halfAngle);
    return (
      (this._x = axis.x * s),
      (this._y = axis.y * s),
      (this._z = axis.z * s),
      (this._w = Math.cos(halfAngle)),
      this.onChangeCallback(),
      this
    );
  }
  setFromRotationMatrix(m) {
    let s,
      te = m.elements,
      m11 = te[0],
      m12 = te[4],
      m13 = te[8],
      m21 = te[1],
      m22 = te[5],
      m23 = te[9],
      m31 = te[2],
      m32 = te[6],
      m33 = te[10],
      trace = m11 + m22 + m33;
    return (
      trace > 0
        ? ((s = 0.5 / Math.sqrt(trace + 1)),
          (this._w = 0.25 / s),
          (this._x = (m32 - m23) * s),
          (this._y = (m13 - m31) * s),
          (this._z = (m21 - m12) * s))
        : m11 > m22 && m11 > m33
        ? ((s = 2 * Math.sqrt(1 + m11 - m22 - m33)),
          (this._w = (m32 - m23) / s),
          (this._x = 0.25 * s),
          (this._y = (m12 + m21) / s),
          (this._z = (m13 + m31) / s))
        : m22 > m33
        ? ((s = 2 * Math.sqrt(1 + m22 - m11 - m33)),
          (this._w = (m13 - m31) / s),
          (this._x = (m12 + m21) / s),
          (this._y = 0.25 * s),
          (this._z = (m23 + m32) / s))
        : ((s = 2 * Math.sqrt(1 + m33 - m11 - m22)),
          (this._w = (m21 - m12) / s),
          (this._x = (m13 + m31) / s),
          (this._y = (m23 + m32) / s),
          (this._z = 0.25 * s)),
      this.onChangeCallback(),
      this
    );
  }
  setFromUnitVectors(vFrom, vTo) {
    let v1 = this.V1 || new Vector3();
    this.V1 = v1;
    let r = vFrom.dot(vTo) + 1;
    return (
      r < 1e-6
        ? ((r = 0),
          Math.abs(vFrom.x) > Math.abs(vFrom.z)
            ? v1.set(-vFrom.y, vFrom.x, 0)
            : v1.set(0, -vFrom.z, vFrom.y))
        : v1.crossVectors(vFrom, vTo),
      (this._x = v1.x),
      (this._y = v1.y),
      (this._z = v1.z),
      (this._w = r),
      this.normalize()
    );
  }
  inverse() {
    return this.conjugate();
  }
  conjugate() {
    return (
      (this._x *= -1),
      (this._y *= -1),
      (this._z *= -1),
      this.onChangeCallback(),
      this
    );
  }
  dot(v) {
    const w = void 0 === v._w ? 1 : v._w;
    return this._x * v._x + this._y * v._y + this._z * v._z + this._w * w;
  }
  lengthSq() {
    return (
      this._x * this._x +
      this._y * this._y +
      this._z * this._z +
      this._w * this._w
    );
  }
  length() {
    return Math.sqrt(
      this._x * this._x +
        this._y * this._y +
        this._z * this._z +
        this._w * this._w
    );
  }
  normalize() {
    let l = this.length();
    return (
      0 === l
        ? ((this._x = 0), (this._y = 0), (this._z = 0), (this._w = 1))
        : ((l = 1 / l),
          (this._x = this._x * l),
          (this._y = this._y * l),
          (this._z = this._z * l),
          (this._w = this._w * l)),
      this.onChangeCallback(),
      this
    );
  }
  multiply(q) {
    return this.multiplyQuaternions(this, q);
  }
  premultiply(q) {
    return this.multiplyQuaternions(q, this);
  }
  multiplyQuaternions(a, b) {
    let qax = a._x,
      qay = a._y,
      qaz = a._z,
      qaw = a._w,
      qbx = b._x,
      qby = b._y,
      qbz = b._z,
      qbw = b._w;
    return (
      (this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby),
      (this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz),
      (this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx),
      (this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz),
      this.onChangeCallback(),
      this
    );
  }
  slerp(qb, t, hz = !0) {
    if (0 === (t = hz ? Math.framerateNormalizeLerpAlpha(t) : Math.clamp(t)))
      return this;
    if (1 === t) return this.copy(qb);
    let x = this._x,
      y = this._y,
      z = this._z,
      w = this._w,
      cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;
    if (
      (cosHalfTheta < 0
        ? ((this._w = -qb._w),
          (this._x = -qb._x),
          (this._y = -qb._y),
          (this._z = -qb._z),
          (cosHalfTheta = -cosHalfTheta))
        : this.copy(qb),
      cosHalfTheta >= 1)
    )
      return (this._w = w), (this._x = x), (this._y = y), (this._z = z), this;
    let sinHalfTheta = Math.sqrt(1 - cosHalfTheta * cosHalfTheta);
    if (Math.abs(sinHalfTheta) < 0.001)
      return (
        (this._w = 0.5 * (w + this._w)),
        (this._x = 0.5 * (x + this._x)),
        (this._y = 0.5 * (y + this._y)),
        (this._z = 0.5 * (z + this._z)),
        this
      );
    let halfTheta = Math.atan2(sinHalfTheta, cosHalfTheta),
      ratioA = Math.sin((1 - t) * halfTheta) / sinHalfTheta,
      ratioB = Math.sin(t * halfTheta) / sinHalfTheta;
    return (
      (this._w = w * ratioA + this._w * ratioB),
      (this._x = x * ratioA + this._x * ratioB),
      (this._y = y * ratioA + this._y * ratioB),
      (this._z = z * ratioA + this._z * ratioB),
      this.onChangeCallback(),
      this
    );
  }
  equals(quaternion) {
    return (
      quaternion._x === this._x &&
      quaternion._y === this._y &&
      quaternion._z === this._z &&
      quaternion._w === this._w
    );
  }
  fromArray(array, offset) {
    return (
      void 0 === offset && (offset = 0),
      (this._x = array[offset]),
      (this._y = array[offset + 1]),
      (this._z = array[offset + 2]),
      (this._w = array[offset + 3]),
      this.onChangeCallback(),
      this
    );
  }
  toArray(array, offset) {
    return (
      void 0 === array && (array = []),
      void 0 === offset && (offset = 0),
      (array[offset] = this._x),
      (array[offset + 1] = this._y),
      (array[offset + 2] = this._z),
      (array[offset + 3] = this._w),
      array
    );
  }
  onChange(callback) {
    this.onChangeCallback = callback;
  }
  onChangeCallback() {}
}
class RayManager {
  constructor(origin, direction, near = 0, far = 1 / 0) {
    (this.ray = new Ray(origin, direction)),
      (this.near = near),
      (this.far = far),
      (this.params = { Mesh: {}, Points: { threshold: 1 } });
  }
  set(origin, direction) {
    return this.ray.set(origin, direction), this;
  }
  setFromCamera(coords, camera) {
    camera.isPerspective
      ? (this.ray.origin.setFromMatrixPosition(camera.matrixWorld),
        this.ray.direction
          .set(coords.x, coords.y, 0.5)
          .unproject(camera)
          .sub(this.ray.origin)
          .normalize())
      : (this.ray.origin
          .set(
            coords.x,
            coords.y,
            (camera.near + camera.far) / (camera.near - camera.far)
          )
          .unproject(camera),
        this.ray.direction
          .set(0, 0, -1)
          .transformDirection(camera.matrixWorld));
  }
  _ascSort(a, b) {
    return a.distance - b.distance;
  }
  _intersectObject(object, raycaster, intersects, recursive, forceAllVisible) {
    if (
      (!1 !== object.visible || forceAllVisible) &&
      (object.raycast && object.raycast(raycaster, intersects),
      !0 === recursive)
    ) {
      let children = object.children;
      for (let i = 0, l = children.length; i < l; i++)
        this._intersectObject(children[i], raycaster, intersects, !0);
    }
  }
  intersectObject(object, recursive, optionalTarget, forceAllVisible) {
    let intersects = optionalTarget || [];
    return (
      this._intersectObject(
        object,
        this,
        intersects,
        recursive,
        forceAllVisible
      ),
      intersects.sort(this._ascSort),
      intersects
    );
  }
  intersectObjects(objects, recursive, optionalTarget) {
    let intersects = optionalTarget || [];
    for (let i = 0, l = objects.length; i < l; i++)
      this._intersectObject(objects[i], this, intersects, recursive);
    return intersects.sort(this._ascSort), intersects;
  }
}
class Ray {
  constructor(origin = new Vector3(), direction = new Vector3()) {
    (this.origin = origin), (this.direction = direction);
  }
  set(origin, direction) {
    return this.origin.copy(origin), this.direction.copy(direction), this;
  }
  clone() {
    return new Ray().copy(this);
  }
  copy(ray) {
    return (
      this.origin.copy(ray.origin), this.direction.copy(ray.direction), this
    );
  }
  at(t, target = new Vector3()) {
    return target.copy(this.direction).multiplyScalar(t).add(this.origin);
  }
  lookAt(v) {
    return this.direction.copy(v).sub(this.origin).normalize(), this;
  }
  recast(t) {
    let v1 = this.V1 || new Vector3();
    (this.V1 = v1), this.origin.copy(this.at(t, v1));
  }
  closestPointToPoint(point, target = new Vector3()) {
    target.subVectors(point, this.origin);
    let directionDistance = target.dot(this.direction);
    return directionDistance < 0
      ? target.copy(this.origin)
      : target
          .copy(this.direction)
          .multiplyScalar(directionDistance)
          .add(this.origin);
  }
  distanceToPoint(point) {
    return Math.sqrt(this.distanceSqToPoint(point));
  }
  distanceSqToPoint(point) {
    let v1 = this.V1 || new Vector3();
    this.V1 = v1;
    let directionDistance = v1
      .subVectors(point, this.origin)
      .dot(this.direction);
    return directionDistance < 0
      ? this.origin.distanceToSquared(point)
      : (v1
          .copy(this.direction)
          .multiplyScalar(directionDistance)
          .add(this.origin),
        v1.distanceToSquared(point));
  }
  distanceSqToSegment(v0, v1, optionalPointOnRay, optionalPointOnSegment) {
    let segCenter = this.V1 || new Vector3(),
      segDir = this.V2 || new Vector3(),
      diff = this.V3 || new Vector3();
    (this.V1 = segCenter),
      (this.V2 = segDir),
      (this.V3 = diff),
      segCenter.copy(v0).add(v1).multiplyScalar(0.5),
      segDir.copy(v1).sub(v0).normalize(),
      diff.copy(this.origin).sub(segCenter);
    let s0,
      s1,
      sqrDist,
      extDet,
      segExtent = 0.5 * v0.distanceTo(v1),
      a01 = -this.direction.dot(segDir),
      b0 = diff.dot(this.direction),
      b1 = -diff.dot(segDir),
      c = diff.lengthSq(),
      det = Math.abs(1 - a01 * a01);
    if (det > 0)
      if (
        ((s0 = a01 * b1 - b0),
        (s1 = a01 * b0 - b1),
        (extDet = segExtent * det),
        s0 >= 0)
      )
        if (s1 >= -extDet)
          if (s1 <= extDet) {
            let invDet = 1 / det;
            (s0 *= invDet),
              (s1 *= invDet),
              (sqrDist =
                s0 * (s0 + a01 * s1 + 2 * b0) +
                s1 * (a01 * s0 + s1 + 2 * b1) +
                c);
          } else
            (s1 = segExtent),
              (s0 = Math.max(0, -(a01 * s1 + b0))),
              (sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c);
        else
          (s1 = -segExtent),
            (s0 = Math.max(0, -(a01 * s1 + b0))),
            (sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c);
      else
        s1 <= -extDet
          ? ((s0 = Math.max(0, -(-a01 * segExtent + b0))),
            (s1 =
              s0 > 0
                ? -segExtent
                : Math.min(Math.max(-segExtent, -b1), segExtent)),
            (sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c))
          : s1 <= extDet
          ? ((s0 = 0),
            (s1 = Math.min(Math.max(-segExtent, -b1), segExtent)),
            (sqrDist = s1 * (s1 + 2 * b1) + c))
          : ((s0 = Math.max(0, -(a01 * segExtent + b0))),
            (s1 =
              s0 > 0
                ? segExtent
                : Math.min(Math.max(-segExtent, -b1), segExtent)),
            (sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c));
    else
      (s1 = a01 > 0 ? -segExtent : segExtent),
        (s0 = Math.max(0, -(a01 * s1 + b0))),
        (sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c);
    return (
      optionalPointOnRay &&
        optionalPointOnRay
          .copy(this.direction)
          .multiplyScalar(s0)
          .add(this.origin),
      optionalPointOnSegment &&
        optionalPointOnSegment.copy(segDir).multiplyScalar(s1).add(segCenter),
      sqrDist
    );
  }
  intersectSphere(sphere, target) {
    let v1 = this.V1 || new Vector3();
    (this.V1 = v1), v1.subVectors(sphere.center, this.origin);
    let tca = v1.dot(this.direction),
      d2 = v1.dot(v1) - tca * tca,
      radius2 = sphere.radius * sphere.radius;
    if (d2 > radius2) return null;
    let thc = Math.sqrt(radius2 - d2),
      t0 = tca - thc,
      t1 = tca + thc;
    return t0 < 0 && t1 < 0
      ? null
      : t0 < 0
      ? this.at(t1, target)
      : this.at(t0, target);
  }
  intersectsSphere(sphere) {
    return (
      this.distanceSqToPoint(sphere.center) <= sphere.radius * sphere.radius
    );
  }
  distanceToPlane(plane) {
    let denominator = plane.normal.dot(this.direction);
    if (0 === denominator)
      return 0 === plane.distanceToPoint(this.origin) ? 0 : null;
    let t = -(this.origin.dot(plane.normal) + plane.constant) / denominator;
    return t >= 0 ? t : null;
  }
  intersectPlane(plane, target) {
    let t = this.distanceToPlane(plane);
    return null === t ? null : this.at(t, target);
  }
  intersectsPlane(plane) {
    let distToPoint = plane.distanceToPoint(this.origin);
    return (
      0 === distToPoint || plane.normal.dot(this.direction) * distToPoint < 0
    );
  }
  intersectBox(box, target) {
    let tmin,
      tmax,
      tymin,
      tymax,
      tzmin,
      tzmax,
      invdirx = 1 / this.direction.x,
      invdiry = 1 / this.direction.y,
      invdirz = 1 / this.direction.z,
      origin = this.origin;
    return (
      invdirx >= 0
        ? ((tmin = (box.min.x - origin.x) * invdirx),
          (tmax = (box.max.x - origin.x) * invdirx))
        : ((tmin = (box.max.x - origin.x) * invdirx),
          (tmax = (box.min.x - origin.x) * invdirx)),
      invdiry >= 0
        ? ((tymin = (box.min.y - origin.y) * invdiry),
          (tymax = (box.max.y - origin.y) * invdiry))
        : ((tymin = (box.max.y - origin.y) * invdiry),
          (tymax = (box.min.y - origin.y) * invdiry)),
      tmin > tymax || tymin > tmax
        ? null
        : ((tymin > tmin || tmin != tmin) && (tmin = tymin),
          (tymax < tmax || tmax != tmax) && (tmax = tymax),
          invdirz >= 0
            ? ((tzmin = (box.min.z - origin.z) * invdirz),
              (tzmax = (box.max.z - origin.z) * invdirz))
            : ((tzmin = (box.max.z - origin.z) * invdirz),
              (tzmax = (box.min.z - origin.z) * invdirz)),
          tmin > tzmax || tzmin > tmax
            ? null
            : ((tzmin > tmin || tmin != tmin) && (tmin = tzmin),
              (tzmax < tmax || tmax != tmax) && (tmax = tzmax),
              tmax < 0 ? null : this.at(tmin >= 0 ? tmin : tmax, target)))
    );
  }
  intersectsBox(box) {
    let v = this.V1 || new Vector3();
    return (this.V1 = v), null !== this.intersectBox(box, v);
  }
  intersectsTriangle(a, b, c, backfaceCulling, target) {
    let diff = this.V1 || new Vector3(),
      edge1 = this.V2 || new Vector3(),
      edge2 = this.V3 || new Vector3(),
      normal = this.V4 || new Vector3();
    (this.V1 = diff),
      (this.V2 = edge1),
      (this.V3 = edge2),
      (this.V4 = normal),
      edge1.subVectors(b, a),
      edge2.subVectors(c, a),
      normal.crossVectors(edge1, edge2);
    let sign,
      DdN = this.direction.dot(normal);
    if (DdN > 0) {
      if (backfaceCulling) return null;
      sign = 1;
    } else {
      if (!(DdN < 0)) return null;
      (sign = -1), (DdN = -DdN);
    }
    diff.subVectors(this.origin, a);
    let DdQxE2 = sign * this.direction.dot(edge2.crossVectors(diff, edge2));
    if (DdQxE2 < 0) return null;
    let DdE1xQ = sign * this.direction.dot(edge1.cross(diff));
    if (DdE1xQ < 0) return null;
    if (DdQxE2 + DdE1xQ > DdN) return null;
    let QdN = -sign * diff.dot(normal);
    return QdN < 0 ? null : this.at(QdN / DdN, target);
  }
  applyMatrix4(matrix4) {
    return (
      this.origin.applyMatrix4(matrix4),
      this.direction.transformDirection(matrix4),
      this
    );
  }
  equals(ray) {
    return (
      ray.origin.equals(this.origin) && ray.direction.equals(this.direction)
    );
  }
}
class Sphere {
  constructor(center = new Vector3(), radius = 0) {
    (this.center = center), (this.radius = radius);
  }
  set(center, radius) {
    return this.center.copy(center), (this.radius = radius), this;
  }
  setFromPoints(points, optionalCenter) {
    let box = this.V1 || new Box3();
    this.V1 = box;
    let center = this.center;
    void 0 !== optionalCenter
      ? center.copy(optionalCenter)
      : box.setFromPoints(points).getCenter(center);
    let maxRadiusSq = 0;
    for (let i = 0, il = points.length; i < il; i++)
      maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(points[i]));
    return (this.radius = Math.sqrt(maxRadiusSq)), this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(sphere) {
    return this.center.copy(sphere.center), (this.radius = sphere.radius), this;
  }
  empty() {
    return this.radius <= 0;
  }
  containsPoint(point) {
    return point.distanceToSquared(this.center) <= this.radius * this.radius;
  }
  distanceToPoint(point) {
    return point.distanceTo(this.center) - this.radius;
  }
  intersectsSphere(sphere) {
    let radiusSum = this.radius + sphere.radius;
    return (
      sphere.center.distanceToSquared(this.center) <= radiusSum * radiusSum
    );
  }
  intersectsBox(box) {
    return box.intersectsSphere(this);
  }
  intersectsPlane(plane) {
    return Math.abs(plane.distanceToPoint(this.center)) <= this.radius;
  }
  clampPoint(point, target = new Vector3()) {
    let deltaLengthSq = this.center.distanceToSquared(point);
    return (
      target.copy(point),
      deltaLengthSq > this.radius * this.radius &&
        (target.sub(this.center).normalize(),
        target.multiplyScalar(this.radius).add(this.center)),
      target
    );
  }
  getBoundingBox(target = new Box3()) {
    return (
      target.set(this.center, this.center),
      target.expandByScalar(this.radius),
      target
    );
  }
  applyMatrix4(matrix) {
    return (
      this.center.applyMatrix4(matrix),
      (this.radius = this.radius * matrix.getMaxScaleOnAxis()),
      this
    );
  }
  translate(offset) {
    return this.center.add(offset), this;
  }
  equals(sphere) {
    return sphere.center.equals(this.center) && sphere.radius === this.radius;
  }
}
class Spherical {
  constructor(radius = 1, phi = 0, theta = 0) {
    (this.radius = radius), (this.phi = phi), (this.theta = theta);
  }
  set(radius, phi, theta) {
    return (this.radius = radius), (this.phi = phi), (this.theta = theta), this;
  }
  clone() {
    return new Spherical().copy(this);
  }
  copy(other) {
    return (
      (this.radius = other.radius),
      (this.phi = other.phi),
      (this.theta = other.theta),
      this
    );
  }
  makeSafe() {
    return (
      (this.phi = Math.max(1e-6, Math.min(Math.PI - 1e-6, this.phi))), this
    );
  }
  setFromVector3(vec3) {
    return (
      (this.radius = vec3.length()),
      0 === this.radius
        ? ((this.theta = 0), (this.phi = 0))
        : ((this.theta = Math.atan2(vec3.x, vec3.z)),
          (this.phi = Math.acos(Math.clamp(vec3.y / this.radius, -1, 1)))),
      this
    );
  }
}
class Triangle {
  constructor(a = new Vector3(), b = new Vector3(), c = new Vector3()) {
    (this.a = a), (this.b = b), (this.c = c);
  }
  set(a, b, c) {
    return this.a.copy(a), this.b.copy(b), this.c.copy(c), this;
  }
  setFromPointsAndIndices(points, i0, i1, i2) {
    return (
      this.a.copy(points[i0]),
      this.b.copy(points[i1]),
      this.c.copy(points[i2]),
      this
    );
  }
  clone() {
    return new Triangle().copy(this);
  }
  copy(triangle) {
    return (
      this.a.copy(triangle.a),
      this.b.copy(triangle.b),
      this.c.copy(triangle.c),
      this
    );
  }
  getArea() {
    let v0 = this.V0 || new Vector3(),
      v1 = this.V1 || new Vector3();
    return (
      (this.V0 = v0),
      (this.V1 = v1),
      v0.subVectors(this.c, this.b),
      v1.subVectors(this.a, this.b),
      0.5 * v0.cross(v1).length()
    );
  }
  getMidpoint(target = new Vector3()) {
    return target
      .addVectors(this.a, this.b)
      .add(this.c)
      .multiplyScalar(1 / 3);
  }
  getNormal(target) {
    return Triangle.getNormal(this.a, this.b, this.c, target);
  }
  getPlane(target = new Vector3()) {
    return target.setFromCoplanarPoints(this.a, this.b, this.c);
  }
  getBarycoord(point, target) {
    return Triangle.getBarycoord(point, this.a, this.b, this.c, target);
  }
  containsPoint(point) {
    return Triangle.containsPoint(point, this.a, this.b, this.c);
  }
  intersectsBox(box) {
    return box.intersectsTriangle(this);
  }
  equals(triangle) {
    return (
      triangle.a.equals(this.a) &&
      triangle.b.equals(this.b) &&
      triangle.c.equals(this.c)
    );
  }
}
class Vector2 {
  constructor(x = 0, y = 0) {
    (this.x = x), (this.y = y);
  }
  set(x, y) {
    return (this.x = x), (this.y = y), this;
  }
  get width() {
    return this.x;
  }
  get height() {
    return this.y;
  }
  setScalar(s) {
    return (this.x = this.y = s), this;
  }
  clone() {
    return new Vector2(this.x, this.y);
  }
  copy(v) {
    return (this.x = v.x), (this.y = v.y), this;
  }
  add(v) {
    return (this.x += v.x), (this.y += v.y), this;
  }
  addScalar(s) {
    return (this.x += s), (this.y += s), this;
  }
  addVectors(a, b) {
    return (this.x = a.x + b.x), (this.y = a.y + b.y), this;
  }
  addScaledVector(v, s) {
    return (this.x += v.x * s), (this.y += v.y * s), this;
  }
  sub(v) {
    return (this.x -= v.x), (this.y -= v.y), this;
  }
  subScalar(s) {
    return (this.x -= s), (this.y -= s), this;
  }
  subVectors(a, b) {
    return (this.x = a.x - b.x), (this.y = a.y - b.y), this;
  }
  multiply(v) {
    return (this.x *= v.x), (this.y *= v.y), this;
  }
  multiplyScalar(scalar) {
    return (this.x *= scalar), (this.y *= scalar), this;
  }
  divide(v) {
    return (this.x /= v.x), (this.y /= v.y), this;
  }
  divideScalar(scalar) {
    return this.multiplyScalar(1 / scalar);
  }
  applyMatrix3(m) {
    let x = this.x,
      y = this.y,
      e = m.elements;
    return (
      (this.x = e[0] * x + e[3] * y + e[6]),
      (this.y = e[1] * x + e[4] * y + e[7]),
      this
    );
  }
  min(v) {
    return (
      (this.x = Math.min(this.x, v.x)), (this.y = Math.min(this.y, v.y)), this
    );
  }
  max(v) {
    return (
      (this.x = Math.max(this.x, v.x)), (this.y = Math.max(this.y, v.y)), this
    );
  }
  clamp(min, max) {
    return (
      (this.x = Math.max(min.x, Math.min(max.x, this.x))),
      (this.y = Math.max(min.y, Math.min(max.y, this.y))),
      this
    );
  }
  clampScalar(minVal, maxVal) {
    let min = new Vector2(),
      max = new Vector2();
    return (
      min.set(minVal, minVal), max.set(maxVal, maxVal), this.clamp(min, max)
    );
  }
  clampLength(min, max) {
    let length = this.length();
    return this.divideScalar(length || 1).multiplyScalar(
      Math.max(min, Math.min(max, length))
    );
  }
  floor() {
    return (this.x = Math.floor(this.x)), (this.y = Math.floor(this.y)), this;
  }
  ceil() {
    return (this.x = Math.ceil(this.x)), (this.y = Math.ceil(this.y)), this;
  }
  round() {
    return (this.x = Math.round(this.x)), (this.y = Math.round(this.y)), this;
  }
  roundToZero() {
    return (
      (this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x)),
      (this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y)),
      this
    );
  }
  negate() {
    return (this.x = -this.x), (this.y = -this.y), this;
  }
  dot(v) {
    return this.x * v.x + this.y * v.y;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  angle() {
    let angle = Math.atan2(this.y, this.x);
    return angle < 0 && (angle += 2 * Math.PI), angle;
  }
  angleTo(a, b) {
    return b || (b = this), Math.atan2(a.y - b.y, a.x - b.x);
  }
  distanceTo(v) {
    return Math.sqrt(this.distanceToSquared(v));
  }
  distanceToSquared(v) {
    let dx = this.x - v.x,
      dy = this.y - v.y;
    return dx * dx + dy * dy;
  }
  manhattanDistanceTo(v) {
    return Math.abs(this.x - v.x) + Math.abs(this.y - v.y);
  }
  setLength(length) {
    return this.normalize().multiplyScalar(length);
  }
  lerp(v, alpha, hz) {
    return (
      (this.x = Math.lerp(v.x, this.x, alpha, hz)),
      (this.y = Math.lerp(v.y, this.y, alpha, hz)),
      this
    );
  }
  lerpVectors(v1, v2, alpha) {
    return this.subVectors(v2, v1).multiplyScalar(alpha).add(v1);
  }
  equals(v) {
    return v.x === this.x && v.y === this.y;
  }
  setAngleRadius(a, r) {
    return (this.x = Math.cos(a) * r), (this.y = Math.sin(a) * r), this;
  }
  addAngleRadius(a, r) {
    return (this.x += Math.cos(a) * r), (this.y += Math.sin(a) * r), this;
  }
  fromArray(array, offset) {
    return (
      void 0 === offset && (offset = 0),
      (this.x = Number(array[offset])),
      (this.y = Number(array[offset + 1])),
      this
    );
  }
  toArray(array, offset) {
    return (
      void 0 === array && (array = []),
      void 0 === offset && (offset = 0),
      (array[offset] = this.x),
      (array[offset + 1] = this.y),
      array
    );
  }
  rotateAround(center, angle) {
    let c = Math.cos(angle),
      s = Math.sin(angle),
      x = this.x - center.x,
      y = this.y - center.y;
    return (
      (this.x = x * c - y * s + center.x),
      (this.y = x * s + y * c + center.y),
      this
    );
  }
  fromBufferAttribute(attribute, index) {
    (this.x = attribute.array[2 * index + 0]),
      (this.y = attribute.array[2 * index + 1]);
  }
}
class Vector3 {
  constructor(x, y, z) {
    (this.x = x || 0), (this.y = y || 0), (this.z = z || 0);
  }
  set(x, y, z) {
    return (this.x = x || 0), (this.y = y || 0), (this.z = z || 0), this;
  }
  setScalar(scalar) {
    return (this.x = scalar), (this.y = scalar), (this.z = scalar), this;
  }
  clone() {
    return new Vector3(this.x, this.y, this.z);
  }
  copy(v) {
    return (this.x = v.x), (this.y = v.y), (this.z = v.z), this;
  }
  add(v) {
    return (this.x += v.x), (this.y += v.y), (this.z += v.z), this;
  }
  addScalar(s) {
    return (this.x += s), (this.y += s), (this.z += s), this;
  }
  addVectors(a, b) {
    return (
      (this.x = a.x + b.x), (this.y = a.y + b.y), (this.z = a.z + b.z), this
    );
  }
  addScaledVector(v, s) {
    return (this.x += v.x * s), (this.y += v.y * s), (this.z += v.z * s), this;
  }
  sub(v) {
    return (this.x -= v.x), (this.y -= v.y), (this.z -= v.z), this;
  }
  subScalar(s) {
    return (this.x -= s), (this.y -= s), (this.z -= s), this;
  }
  subVectors(a, b) {
    return (
      (this.x = a.x - b.x), (this.y = a.y - b.y), (this.z = a.z - b.z), this
    );
  }
  multiply(v) {
    return (this.x *= v.x), (this.y *= v.y), (this.z *= v.z), this;
  }
  multiplyScalar(scalar) {
    return (this.x *= scalar), (this.y *= scalar), (this.z *= scalar), this;
  }
  multiplyVectors(a, b) {
    return (
      (this.x = a.x * b.x), (this.y = a.y * b.y), (this.z = a.z * b.z), this
    );
  }
  applyEuler(euler) {
    let quaternion = this.Q1 || new Quaternion();
    return (
      (this.Q1 = quaternion),
      this.applyQuaternion(quaternion.setFromEuler(euler))
    );
  }
  applyAxisAngle(axis, angle) {
    let quaternion = this.Q1 || new Quaternion();
    return (
      (this.Q1 = quaternion),
      this.applyQuaternion(quaternion.setFromAxisAngle(axis, angle))
    );
  }
  applyMatrix3(m) {
    let x = this.x,
      y = this.y,
      z = this.z,
      e = m.elements;
    return (
      (this.x = e[0] * x + e[3] * y + e[6] * z),
      (this.y = e[1] * x + e[4] * y + e[7] * z),
      (this.z = e[2] * x + e[5] * y + e[8] * z),
      this
    );
  }
  applyMatrix4(m) {
    let x = this.x,
      y = this.y,
      z = this.z,
      e = m.elements,
      w = 1 / (e[3] * x + e[7] * y + e[11] * z + e[15]);
    return (
      (this.x = (e[0] * x + e[4] * y + e[8] * z + e[12]) * w),
      (this.y = (e[1] * x + e[5] * y + e[9] * z + e[13]) * w),
      (this.z = (e[2] * x + e[6] * y + e[10] * z + e[14]) * w),
      this
    );
  }
  applyQuaternion(q) {
    let x = this.x,
      y = this.y,
      z = this.z,
      qx = q.x,
      qy = q.y,
      qz = q.z,
      qw = q.w;
    if (0 == qx && 0 == qy && 0 == qz && 1 == qw) return this;
    let ix = qw * x + qy * z - qz * y,
      iy = qw * y + qz * x - qx * z,
      iz = qw * z + qx * y - qy * x,
      iw = -qx * x - qy * y - qz * z;
    return (
      (this.x = ix * qw + iw * -qx + iy * -qz - iz * -qy),
      (this.y = iy * qw + iw * -qy + iz * -qx - ix * -qz),
      (this.z = iz * qw + iw * -qz + ix * -qy - iy * -qx),
      this
    );
  }
  project(camera) {
    let matrix = this.M1 || new Matrix4();
    return (
      (this.M1 = matrix),
      matrix.multiplyMatrices(
        camera.projectionMatrix,
        matrix.getInverse(camera.matrixWorld)
      ),
      this.applyMatrix4(matrix)
    );
  }
  unproject(camera) {
    let matrix = this.M1 || new Matrix4();
    return (
      (this.M1 = matrix),
      matrix.multiplyMatrices(
        camera.matrixWorld,
        matrix.getInverse(camera.projectionMatrix)
      ),
      this.applyMatrix4(matrix)
    );
  }
  transformDirection(m) {
    let x = this.x,
      y = this.y,
      z = this.z,
      e = m.elements;
    return (
      (this.x = e[0] * x + e[4] * y + e[8] * z),
      (this.y = e[1] * x + e[5] * y + e[9] * z),
      (this.z = e[2] * x + e[6] * y + e[10] * z),
      this.normalize()
    );
  }
  divide(v) {
    return (this.x /= v.x), (this.y /= v.y), (this.z /= v.z), this;
  }
  divideScalar(scalar) {
    return this.multiplyScalar(1 / scalar);
  }
  min(v) {
    return (
      (this.x = Math.min(this.x, v.x)),
      (this.y = Math.min(this.y, v.y)),
      (this.z = Math.min(this.z, v.z)),
      this
    );
  }
  max(v) {
    return (
      (this.x = Math.max(this.x, v.x)),
      (this.y = Math.max(this.y, v.y)),
      (this.z = Math.max(this.z, v.z)),
      this
    );
  }
  clamp(min, max) {
    return (
      (this.x = Math.max(min.x, Math.min(max.x, this.x))),
      (this.y = Math.max(min.y, Math.min(max.y, this.y))),
      (this.z = Math.max(min.z, Math.min(max.z, this.z))),
      this
    );
  }
  clampScalar(minVal, maxVal) {
    let min = new Vector3(),
      max = new Vector3();
    return (
      min.set(minVal, minVal, minVal),
      max.set(maxVal, maxVal, maxVal),
      this.clamp(min, max)
    );
  }
  clampLength(min, max) {
    let length = this.length();
    return this.divideScalar(length || 1).multiplyScalar(
      Math.max(min, Math.min(max, length))
    );
  }
  floor() {
    return (
      (this.x = Math.floor(this.x)),
      (this.y = Math.floor(this.y)),
      (this.z = Math.floor(this.z)),
      this
    );
  }
  ceil() {
    return (
      (this.x = Math.ceil(this.x)),
      (this.y = Math.ceil(this.y)),
      (this.z = Math.ceil(this.z)),
      this
    );
  }
  round() {
    return (
      (this.x = Math.round(this.x)),
      (this.y = Math.round(this.y)),
      (this.z = Math.round(this.z)),
      this
    );
  }
  roundToZero() {
    return (
      (this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x)),
      (this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y)),
      (this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z)),
      this
    );
  }
  negate() {
    return (this.x = -this.x), (this.y = -this.y), (this.z = -this.z), this;
  }
  dot(v) {
    return this.x * v.x + this.y * v.y + this.z * v.z;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y + this.z * this.z;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  setLength(length) {
    return this.normalize().multiplyScalar(length);
  }
  lerp(v, alpha, hz) {
    return (
      (this.x = Math.lerp(v.x, this.x, alpha, hz)),
      (this.y = Math.lerp(v.y, this.y, alpha, hz)),
      (this.z = Math.lerp(v.z, this.z, alpha, hz)),
      this
    );
  }
  lerpVectors(v1, v2, alpha) {
    return this.subVectors(v2, v1).multiplyScalar(alpha).add(v1);
  }
  cross(v) {
    return this.crossVectors(this, v);
  }
  crossVectors(a, b) {
    let ax = a.x,
      ay = a.y,
      az = a.z,
      bx = b.x,
      by = b.y,
      bz = b.z;
    return (
      (this.x = ay * bz - az * by),
      (this.y = az * bx - ax * bz),
      (this.z = ax * by - ay * bx),
      this
    );
  }
  projectOnVector(vector) {
    let scalar = vector.dot(this) / vector.lengthSq();
    return this.copy(vector).multiplyScalar(scalar);
  }
  projectOnPlane(planeNormal) {
    let v1 = this.V1 || new Vector3();
    return (
      (this.V1 = v1), v1.copy(this).projectOnVector(planeNormal), this.sub(v1)
    );
  }
  reflect(normal) {
    let v1 = this.V1 || new Vector3();
    return (
      (this.V1 = v1),
      this.sub(v1.copy(normal).multiplyScalar(2 * this.dot(normal)))
    );
  }
  angleTo(v) {
    let theta = this.dot(v) / Math.sqrt(this.lengthSq() * v.lengthSq());
    return Math.acos(Math.clamp(theta, -1, 1));
  }
  distanceTo(v) {
    return Math.sqrt(this.distanceToSquared(v));
  }
  distanceToSquared(v) {
    let dx = this.x - v.x,
      dy = this.y - v.y,
      dz = this.z - v.z;
    return dx * dx + dy * dy + dz * dz;
  }
  manhattanDistanceTo(v) {
    return (
      Math.abs(this.x - v.x) + Math.abs(this.y - v.y) + Math.abs(this.z - v.z)
    );
  }
  setFromCylindrical(c) {
    return (
      (this.x = c.radius * Math.sin(c.theta)),
      (this.y = c.y),
      (this.z = c.radius * Math.cos(c.theta)),
      this
    );
  }
  setFromMatrixPosition(m) {
    let e = m.elements;
    return (this.x = e[12]), (this.y = e[13]), (this.z = e[14]), this;
  }
  setFromMatrixScale(m) {
    let sx = this.setFromMatrixColumn(m, 0).length(),
      sy = this.setFromMatrixColumn(m, 1).length(),
      sz = this.setFromMatrixColumn(m, 2).length();
    return (this.x = sx), (this.y = sy), (this.z = sz), this;
  }
  setFromMatrixColumn(m, index) {
    return this.fromArray(m.elements, 4 * index);
  }
  setAngleRadius(a, r, dir = "xy") {
    return (
      (this[dir[0]] = Math.cos(a) * r), (this[dir[1]] = Math.sin(a) * r), this
    );
  }
  addAngleRadius(a, r, dir = "xy") {
    return (
      (this[dir[0]] += Math.cos(a) * r), (this[dir[1]] += Math.sin(a) * r), this
    );
  }
  equals(v) {
    return v.x === this.x && v.y === this.y && v.z === this.z;
  }
  fromArray(array, offset) {
    return (
      void 0 === offset && (offset = 0),
      (this.x = Number(array[offset])),
      (this.y = Number(array[offset + 1])),
      (this.z = Number(array[offset + 2])),
      this
    );
  }
  setFromSpherical(s) {
    this.setFromSphericalCoords(s.radius, s.phi, s.theta);
  }
  setFromSphericalCoords(radius, phi, theta) {
    let sinPhiRadius = Math.sin(phi) * radius;
    return (
      (this.x = sinPhiRadius * Math.sin(theta)),
      (this.y = Math.cos(phi) * radius),
      (this.z = sinPhiRadius * Math.cos(theta)),
      this
    );
  }
  toArray(array, offset) {
    return (
      void 0 === array && (array = []),
      void 0 === offset && (offset = 0),
      (array[offset] = this.x),
      (array[offset + 1] = this.y),
      (array[offset + 2] = this.z),
      array
    );
  }
  fromBufferAttribute(attribute, index) {
    return (
      (this.x = attribute.array[3 * index + 0]),
      (this.y = attribute.array[3 * index + 1]),
      (this.z = attribute.array[3 * index + 2]),
      this
    );
  }
}
class Vector3D {
  constructor(x, y, z) {
    (this._x = x || 0), (this._y = y || 0), (this._z = z || 0);
  }
  get x() {
    return this._x;
  }
  set x(v) {
    if (zUtils3D.LOCAL && isNaN(v)) return console.trace("Vector3D::NaN");
    let dirty = Math.abs(this._x - v) > Base3D.DIRTY_EPSILON;
    (this._x = v), dirty && this.onChangeCallback();
  }
  get y() {
    return this._y;
  }
  set y(v) {
    if (zUtils3D.LOCAL && isNaN(v)) return console.trace("Vector3D::NaN");
    let dirty = Math.abs(this._y - v) > Base3D.DIRTY_EPSILON;
    (this._y = v), dirty && this.onChangeCallback();
  }
  get z() {
    return this._z;
  }
  set z(v) {
    if (zUtils3D.LOCAL && isNaN(v)) return console.trace("Vector3D::NaN");
    let dirty = Math.abs(this._z - v) > Base3D.DIRTY_EPSILON;
    (this._z = v), dirty && this.onChangeCallback();
  }
  onChangeCallback() {}
  set(x = 0, y = 0, z = 0) {
    const abs = Math.abs;
    let dirty =
      abs(this._x - x) > Base3D.DIRTY_EPSILON ||
      abs(this._y - y) > Base3D.DIRTY_EPSILON ||
      abs(this._z - z) > Base3D.DIRTY_EPSILON;
    return (
      (this._x = x),
      (this._y = y),
      (this._z = z),
      dirty && this.onChangeCallback(),
      this
    );
  }
  setScalar(scalar) {
    const abs = Math.abs;
    let dirty =
      abs(this._x - scalar) > Base3D.DIRTY_EPSILON ||
      abs(this._y - scalar) > Base3D.DIRTY_EPSILON ||
      abs(this._z - scalar) > Base3D.DIRTY_EPSILON;
    return (
      (this._x = scalar),
      (this._y = scalar),
      (this._z = scalar),
      dirty && this.onChangeCallback(),
      this
    );
  }
  clone() {
    return new Vector3(this._x, this._y, this._z);
  }
  copy(v) {
    const abs = Math.abs;
    let dirty =
      abs(this._x - v.x) > Base3D.DIRTY_EPSILON ||
      abs(this._y - v.y) > Base3D.DIRTY_EPSILON ||
      abs(this._z - v.z) > Base3D.DIRTY_EPSILON;
    return (
      (this._x = v.x),
      (this._y = v.y),
      (this._z = v.z),
      dirty && this.onChangeCallback(),
      this
    );
  }
  add(v) {
    let nx = this._x + v.x,
      ny = this._y + v.y,
      nz = this._z + v.z;
    const abs = Math.abs;
    let dirty =
      abs(this._x - nx) > Base3D.DIRTY_EPSILON ||
      abs(this._y - ny) > Base3D.DIRTY_EPSILON ||
      abs(this._z - nz) > Base3D.DIRTY_EPSILON;
    return (
      (this._x = nx),
      (this._y = ny),
      (this._z = nz),
      dirty && this.onChangeCallback(),
      this
    );
  }
  addScalar(s) {
    let nx = this._x + s,
      ny = this._y + s,
      nz = this._z + s;
    const abs = Math.abs;
    let dirty =
      abs(this._x - nx) > Base3D.DIRTY_EPSILON ||
      abs(this._y - ny) > Base3D.DIRTY_EPSILON ||
      abs(this._z - nz) > Base3D.DIRTY_EPSILON;
    return (
      (this._x = nx),
      (this._y = ny),
      (this._z = nz),
      dirty && this.onChangeCallback(),
      this
    );
  }
  addVectors(a, b) {
    return (
      (this._x = a.x + b.x),
      (this._y = a.y + b.y),
      (this._z = a.z + b.z),
      this.onChangeCallback(),
      this
    );
  }
  addScaledVector(v) {
    return (
      (this._x += v.x * s),
      (this._y += v.y * s),
      (this._z += v.z * s),
      this.onChangeCallback(),
      this
    );
  }
  sub(v) {
    let nx = this._x - v.x,
      ny = this._y - v.y,
      nz = this._z - v.z;
    const abs = Math.abs;
    let dirty =
      abs(this._x - nx) > Base3D.DIRTY_EPSILON ||
      abs(this._y - ny) > Base3D.DIRTY_EPSILON ||
      abs(this._z - nz) > Base3D.DIRTY_EPSILON;
    return (
      (this._x = nx),
      (this._y = ny),
      (this._z = nz),
      dirty && this.onChangeCallback(),
      this
    );
  }
  subScalar(s) {
    let nx = this._x - s,
      ny = this._y - s,
      nz = this._z - s;
    const abs = Math.abs;
    let dirty =
      abs(this._x - nx) > Base3D.DIRTY_EPSILON ||
      abs(this._y - ny) > Base3D.DIRTY_EPSILON ||
      abs(this._z - nz) > Base3D.DIRTY_EPSILON;
    return (
      (this._x = nx),
      (this._y = ny),
      (this._z = nz),
      dirty && this.onChangeCallback(),
      this
    );
  }
  subVectors(a, b) {
    return (
      (this._x = a.x - b.x),
      (this._y = a.y - b.y),
      (this._z = a.z - b.z),
      this.onChangeCallback(),
      this
    );
  }
  multiply(v) {
    let nx = this._x * v.x,
      ny = this._y * v.y,
      nz = this._z * v.z;
    const abs = Math.abs;
    let dirty =
      abs(this._x - nx) > Base3D.DIRTY_EPSILON ||
      abs(this._y - ny) > Base3D.DIRTY_EPSILON ||
      abs(this._z - nz) > Base3D.DIRTY_EPSILON;
    return (
      (this._x = nx),
      (this._y = ny),
      (this._z = nz),
      dirty && this.onChangeCallback(),
      this
    );
  }
  multiplyScalar(scalar) {
    let nx = this._x * scalar,
      ny = this._y * scalar,
      nz = this._z * scalar;
    const abs = Math.abs;
    let dirty =
      abs(this._x - nx) > Base3D.DIRTY_EPSILON ||
      abs(this._y - ny) > Base3D.DIRTY_EPSILON ||
      abs(this._z - nz) > Base3D.DIRTY_EPSILON;
    return (
      (this._x = nx),
      (this._y = ny),
      (this._z = nz),
      dirty && this.onChangeCallback(),
      this
    );
  }
  multiplyVectors(a, b) {
    return (
      (this._x = a.x * b.x),
      (this._y = a.y * b.y),
      (this._z = a.z * b.z),
      this.onChangeCallback(),
      this
    );
  }
  applyEuler(euler) {
    let quaternion = this.Q1 || new Quaternion();
    return (
      (this.Q1 = quaternion),
      this.applyQuaternion(quaternion.setFromEuler(euler))
    );
  }
  applyAxisAngle(axis, angle) {
    let quaternion = this.Q1 || new Quaternion();
    return (
      (this.Q1 = quaternion),
      this.applyQuaternion(quaternion.setFromAxisAngle(axis, angle))
    );
  }
  applyMatrix3(m) {
    let x = this._x,
      y = this._y,
      z = this._z,
      e = m.elements;
    return (
      (this._x = e[0] * x + e[3] * y + e[6] * z),
      (this._y = e[1] * x + e[4] * y + e[7] * z),
      (this._z = e[2] * x + e[5] * y + e[8] * z),
      this.onChangeCallback(),
      this
    );
  }
  applyMatrix4(m) {
    let x = this._x,
      y = this._y,
      z = this._z,
      e = m.elements,
      w = 1 / (e[3] * x + e[7] * y + e[11] * z + e[15]);
    return (
      (this._x = (e[0] * x + e[4] * y + e[8] * z + e[12]) * w),
      (this._y = (e[1] * x + e[5] * y + e[9] * z + e[13]) * w),
      (this._z = (e[2] * x + e[6] * y + e[10] * z + e[14]) * w),
      this.onChangeCallback(),
      this
    );
  }
  applyQuaternion(q) {
    let x = this._x,
      y = this._y,
      z = this._z,
      qx = q.x,
      qy = q.y,
      qz = q.z,
      qw = q.w,
      ix = qw * x + qy * z - qz * y,
      iy = qw * y + qz * x - qx * z,
      iz = qw * z + qx * y - qy * x,
      iw = -qx * x - qy * y - qz * z;
    return (
      (this._x = ix * qw + iw * -qx + iy * -qz - iz * -qy),
      (this._y = iy * qw + iw * -qy + iz * -qx - ix * -qz),
      (this._z = iz * qw + iw * -qz + ix * -qy - iy * -qx),
      this.onChangeCallback(),
      this
    );
  }
  project(camera) {
    let matrix = this.M1 || new Matrix4();
    return (
      (this.M1 = matrix),
      matrix.multiplyMatrices(
        camera.projectionMatrix,
        matrix.getInverse(camera.matrixWorld)
      ),
      this.applyMatrix4(matrix)
    );
  }
  unproject(camera) {
    let matrix = this.M1 || new Matrix4();
    return (
      (this.M1 = matrix),
      matrix.multiplyMatrices(
        camera.matrixWorld,
        matrix.getInverse(camera.projectionMatrix)
      ),
      this.applyMatrix4(matrix)
    );
  }
  transformDirection(m) {
    let x = this._x,
      y = this._y,
      z = this._z,
      e = m.elements;
    return (
      (this._x = e[0] * x + e[4] * y + e[8] * z),
      (this._y = e[1] * x + e[5] * y + e[9] * z),
      (this._z = e[2] * x + e[6] * y + e[10] * z),
      this.onChangeCallback(),
      this.normalize()
    );
  }
  divide(v) {
    return (
      (this._x /= v.x),
      (this._y /= v.y),
      (this._z /= v.z),
      this.onChangeCallback(),
      this
    );
  }
  divideScalar(scalar) {
    return this.multiplyScalar(1 / scalar);
  }
  min(v) {
    return (
      (this._x = Math.min(this._x, v.x)),
      (this._y = Math.min(this._y, v.y)),
      (this._z = Math.min(this._z, v.z)),
      this.onChangeCallback(),
      this
    );
  }
  max(v) {
    return (
      (this._x = Math.max(this._x, v.x)),
      (this._y = Math.max(this._y, v.y)),
      (this._z = Math.max(this._z, v.z)),
      this
    );
  }
  clamp(min, max) {
    return (
      (this._x = Math.max(min.x, Math.min(max.x, this._x))),
      (this._y = Math.max(min.y, Math.min(max.y, this._y))),
      (this._z = Math.max(min.z, Math.min(max.z, this._z))),
      this
    );
  }
  clampScalar(minVal, maxVal) {
    let min = new Vector3(),
      max = new Vector3();
    return (
      min.set(minVal, minVal, minVal),
      max.set(maxVal, maxVal, maxVal),
      this.clamp(min, max)
    );
  }
  clampLength(min, max) {
    let length = this.length();
    return this.divideScalar(length || 1).multiplyScalar(
      Math.max(min, Math.min(max, length))
    );
  }
  floor() {
    return (
      (this._x = Math.floor(this._x)),
      (this._y = Math.floor(this._y)),
      (this._z = Math.floor(this._z)),
      this.onChangeCallback(),
      this
    );
  }
  ceil() {
    return (
      (this._x = Math.ceil(this._x)),
      (this._y = Math.ceil(this._y)),
      (this._z = Math.ceil(this._z)),
      this.onChangeCallback(),
      this
    );
  }
  round() {
    return (
      (this._x = Math.round(this._x)),
      (this._y = Math.round(this._y)),
      (this._z = Math.round(this._z)),
      this.onChangeCallback(),
      this
    );
  }
  roundToZero() {
    return (
      (this._x = this._x < 0 ? Math.ceil(this._x) : Math.floor(this._x)),
      (this._y = this._y < 0 ? Math.ceil(this._y) : Math.floor(this._y)),
      (this._z = this._z < 0 ? Math.ceil(this._z) : Math.floor(this._z)),
      this.onChangeCallback(),
      this
    );
  }
  negate() {
    return (
      (this._x = -this._x),
      (this._y = -this._y),
      (this._z = -this._z),
      this.onChangeCallback(),
      this
    );
  }
  dot(v) {
    return this._x * v.x + this._y * v.y + this._z * v.z;
  }
  lengthSq() {
    return this._x * this._x + this._y * this._y + this._z * this._z;
  }
  length() {
    return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z);
  }
  manhattanLength() {
    return Math.abs(this._x) + Math.abs(this._y) + Math.abs(this._z);
  }
  normalize() {
    return this.onChangeCallback(), this.divideScalar(this.length() || 1);
  }
  setLength(length) {
    return this.onChangeCallback(), this.normalize().multiplyScalar(length);
  }
  lerp(v, alpha, hz) {
    return (
      (this._x = Math.lerp(v.x, this._x, alpha, hz)),
      (this._y = Math.lerp(v.y, this._y, alpha, hz)),
      (this._z = Math.lerp(v.z, this._z, alpha, hz)),
      this.onChangeCallback(),
      this
    );
  }
  lerpVectors(v1, v2, alpha) {
    return (
      this.onChangeCallback(),
      this.subVectors(v2, v1).multiplyScalar(alpha).add(v1)
    );
  }
  cross(v) {
    return this.crossVectors(this, v);
  }
  crossVectors(a, b) {
    let ax = a.x,
      ay = a.y,
      az = a.z,
      bx = b.x,
      by = b.y,
      bz = b.z;
    return (
      (this._x = ay * bz - az * by),
      (this._y = az * bx - ax * bz),
      (this._z = ax * by - ay * bx),
      this.onChangeCallback(),
      this
    );
  }
  projectOnVector(vector) {
    let scalar = vector.dot(this) / vector.lengthSq();
    return this.copy(vector).multiplyScalar(scalar);
  }
  projectOnPlane(planeNormal) {
    let v1 = this.V1 || new Vector3();
    return (
      (this.V1 = v1),
      this.onChangeCallback(),
      v1.copy(this).projectOnVector(planeNormal),
      this.sub(v1)
    );
  }
  reflect(normal) {
    let v1 = this.V1 || new Vector3();
    return (
      (this.V1 = v1),
      this.onChangeCallback(),
      this.sub(v1.copy(normal).multiplyScalar(2 * this.dot(normal)))
    );
  }
  angleTo(v) {
    let theta = this.dot(v) / Math.sqrt(this.lengthSq() * v.lengthSq());
    return Math.acos(Math.clamp(theta, -1, 1));
  }
  distanceTo(v) {
    return Math.sqrt(this.distanceToSquared(v));
  }
  distanceToSquared(v) {
    let dx = this._x - v.x,
      dy = this._y - v.y,
      dz = this._z - v.z;
    return dx * dx + dy * dy + dz * dz;
  }
  manhattanDistanceTo(v) {
    return (
      Math.abs(this._x - v.x) +
      Math.abs(this._y - v.y) +
      Math.abs(this._z - v.z)
    );
  }
  setFromSpherical(s) {
    let sinPhiRadius = Math.sin(s.phi) * s.radius;
    return (
      (this._x = sinPhiRadius * Math.sin(s.theta)),
      (this._y = Math.cos(s.phi) * s.radius),
      (this._z = sinPhiRadius * Math.cos(s.theta)),
      this.onChangeCallback(),
      this
    );
  }
  setFromCylindrical(c) {
    return (
      (this._x = c.radius * Math.sin(c.theta)),
      (this._y = c.y),
      (this._z = c.radius * Math.cos(c.theta)),
      this.onChangeCallback(),
      this
    );
  }
  setFromMatrixPosition(m) {
    let e = m.elements;
    return (
      (this._x = e[12]),
      (this._y = e[13]),
      (this._z = e[14]),
      this.onChangeCallback(),
      this
    );
  }
  setFromMatrixScale(m) {
    let sx = this.setFromMatrixColumn(m, 0).length(),
      sy = this.setFromMatrixColumn(m, 1).length(),
      sz = this.setFromMatrixColumn(m, 2).length();
    return (
      this.onChangeCallback(),
      (this._x = sx),
      (this._y = sy),
      (this._z = sz),
      this
    );
  }
  setFromMatrixColumn(m, index) {
    return this.onChangeCallback(), this.fromArray(m.elements, 4 * index);
  }
  equals(v) {
    return v.x === this._x && v.y === this._y && v.z === this._z;
  }
  fromArray(array, offset) {
    return (
      void 0 === offset && (offset = 0),
      (this._x = Number(array[offset])),
      (this._y = Number(array[offset + 1])),
      (this._z = Number(array[offset + 2])),
      this.onChangeCallback(),
      this
    );
  }
  toArray(array, offset) {
    return (
      void 0 === array && (array = []),
      void 0 === offset && (offset = 0),
      (array[offset] = Number(this._x)),
      (array[offset + 1] = Number(this._y)),
      (array[offset + 2] = Number(this._z)),
      array
    );
  }
  fromBufferAttribute(attribute, index) {
    (this._x = attribute.array[3 * index + 0]),
      (this._y = attribute.array[3 * index + 1]),
      (this._z = attribute.array[3 * index + 2]),
      this.onChangeCallback();
  }
  onChange(callback) {
    this.onChangeCallback = callback;
  }
  onChangeCallback() {}
}
class Vector4 {
  constructor(x = 0, y = 0, z = 0, w = 0) {
    (this.x = x), (this.y = y), (this.z = z), (this.w = w);
  }
  multiplyScalar(s) {
    return (this.x *= s), (this.y *= s), (this.z *= s), (this.w *= s), this;
  }
  set(x, y, z, w) {
    return (this.x = x), (this.y = y), (this.z = z), (this.w = w), this;
  }
  copy(v) {
    return (this.x = v.x), (this.y = v.y), (this.z = v.z), (this.w = v.w), this;
  }
  dot(v) {
    return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;
  }
  length() {
    return Math.sqrt(
      this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
    );
  }
  lengthSq() {
    return (
      this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
    );
  }
  equals(v) {
    return v.x === this.x && v.y === this.y && v.z === this.z && v.w === this.w;
  }
  lerp(v, alpha, hz) {
    return (
      (this.x = Math.lerp(v.x, this.x, alpha, hz)),
      (this.y = Math.lerp(v.y, this.y, alpha, hz)),
      (this.z = Math.lerp(v.z, this.z, alpha, hz)),
      (this.w = Math.lerp(v.w, this.w, alpha, hz)),
      this
    );
  }
  applyMatrix4(m) {
    let x = this.x,
      y = this.y,
      z = this.z,
      w = this.w,
      e = m.elements;
    return (
      (this.x = e[0] * x + e[4] * y + e[8] * z + e[12] * w),
      (this.y = e[1] * x + e[5] * y + e[9] * z + e[13] * w),
      (this.z = e[2] * x + e[6] * y + e[10] * z + e[14] * w),
      (this.w = e[3] * x + e[7] * y + e[11] * z + e[15] * w),
      this
    );
  }
  toArray(array, offset) {
    return (
      void 0 === array && (array = []),
      void 0 === offset && (offset = 0),
      (array[offset] = this.x),
      (array[offset + 1] = this.y),
      (array[offset + 2] = this.z),
      (array[offset + 3] = this.w),
      array
    );
  }
  fromArray(array, offset) {
    return (
      void 0 === offset && (offset = 0),
      (this.x = Number(array[offset])),
      (this.y = Number(array[offset + 1])),
      (this.z = Number(array[offset + 2])),
      (this.w = Number(array[offset + 3])),
      this
    );
  }
  set width(v) {
    this.z = v;
  }
  set height(v) {
    this.w = v;
  }
  get width() {
    return this.z;
  }
  get height() {
    return this.w;
  }
  clone() {
    return new Vector4(this.x, this.y, this.z, this.w);
  }
}
class Face3 {
  constructor(a, b, c, normal = new Vector3()) {
    (this.a = a), (this.b = b), (this.c = c), (this.normal = normal);
  }
}
function NoGLPolyfill() {
  (this.activeTexture =
    this.attachShader =
    this.bindAttribLocation =
    this.bindBuffer =
    this.bindFramebuffer =
    this.bindRenderbuffer =
    this.bindTexture =
    this.blendColor =
    this.blendEquation =
    this.blendEquationSeparate =
    this.blendFunc =
    this.blendFuncSeparate =
    this.bufferData =
    this.bufferSubData =
    this.checkFramebufferStatus =
    this.clear =
    this.clearColor =
    this.clearDepthf =
    this.clearStencil =
    this.colorMask =
    this.compileShader =
    this.compressedTexImage2D =
    this.compressedTexSubImage2D =
    this.copyTexImage2D =
    this.copyTexSubImage2D =
    this.createProgram =
    this.createShader =
    this.cullFace =
    this.deleteBuffers =
    this.deleteFramebuffers =
    this.deleteProgram =
    this.deleteRenderbuffers =
    this.deleteShader =
    this.deleteTextures =
    this.depthFunc =
    this.depthMask =
    this.depthRangef =
    this.detachShader =
    this.disable =
    this.disableVertexAttribArray =
    this.drawArrays =
    this.drawElements =
    this.enable =
    this.enableVertexAttribArray =
    this.finish =
    this.flush =
    this.framebufferRenderbuffer =
    this.framebufferTexture2D =
    this.frontFace =
    this.generateMipmap =
    this.getActiveAttrib =
    this.getActiveUniform =
    this.getAttachedShaders =
    this.getAttribLocation =
    this.getBooleanv =
    this.getBufferParameteriv =
    this.getError =
    this.getFloatv =
    this.getFramebufferAttachmentParameteriv =
    this.getIntegerv =
    this.getProgramiv =
    this.getProgramInfoLog =
    this.getRenderbufferParameteriv =
    this.getShaderiv =
    this.getShaderInfoLog =
    this.getShaderPrecisionFormat =
    this.getShaderSource =
    this.getString =
    this.getTexParameterfv =
    this.getTexParameteriv =
    this.getUniformfv =
    this.getUniformiv =
    this.getUniformLocation =
    this.getVertexAttribfv =
    this.getVertexAttribiv =
    this.getVertexAttribPointerv =
    this.isBuffer =
    this.isEnabled =
    this.isFramebuffer =
    this.isProgram =
    this.isRenderbuffer =
    this.isShader =
    this.isTexture =
    this.lineWidth =
    this.linkProgram =
    this.pixelStorei =
    this.polygonOffset =
    this.readPixels =
    this.releaseShaderCompiler =
    this.renderbufferStorage =
    this.sampleCoverage =
    this.scissor =
    this.shaderBinary =
    this.shaderSource =
    this.stencilFunc =
    this.stencilFuncSeparate =
    this.stencilMask =
    this.stencilMaskSeparate =
    this.stencilOp =
    this.stencilOpSeparate =
    this.texParameterf =
    this.texParameterfv =
    this.texParameteri =
    this.texParameteriv =
    this.texSubImage2D =
    this.uniform1f =
    this.uniform1fv =
    this.uniform1i =
    this.uniform1iv =
    this.uniform2f =
    this.uniform2fv =
    this.uniform2i =
    this.uniform2iv =
    this.uniform3f =
    this.uniform3fv =
    this.uniform3i =
    this.uniform3iv =
    this.uniform4f =
    this.uniform4fv =
    this.uniform4i =
    this.uniform4iv =
    this.uniformMatrix2fv =
    this.uniformMatrix3fv =
    this.uniformMatrix4fv =
    this.useProgram =
    this.validateProgram =
    this.vertexAttrib1f =
    this.vertexAttrib1fv =
    this.vertexAttrib2f =
    this.vertexAttrib2fv =
    this.vertexAttrib3f =
    this.vertexAttrib3fv =
    this.vertexAttrib4f =
    this.vertexAttrib4fv =
    this.vertexAttribPointer =
    this.viewport =
    this.getParameter =
    this.getExtension =
    this.drawElementsInstanced =
    this.drawArraysInstanced =
    this.vertexAttribDivisor =
    this.getUniformBlockIndex =
    this.uniformBlockBinding =
    this.bindBufferBase =
    this.createVertexArray =
    this.bindVertexArray =
    this.deleteVertexArray =
    this.drawBuffers =
    this.blitFramebuffer =
    this.texImage2D =
    this.getContextAttributes =
    this.isContextLost =
    this.clearDepth =
    this.depthRange =
    this.createTexture =
    this.createBuffer =
    this.createFramebuffer =
    this.createRenderbuffer =
    this.deleteTexture =
    this.deleteBuffer =
    this.deleteFramebuffer =
    this.getBufferParameter =
    this.getRenderbufferParameter =
    this.getProgramParameter =
    this.getVertexAttribOffset =
    this.getFramebufferAttachmentParemeter =
    this.getUniform =
    this.getTexParameter =
    this.getShaderParameter =
    this.getSupportedExtensions =
    this.activeTexture =
    this.attachShader =
      (_) => {}),
    (this.getShaderParameter = this.getProgramParameter =
      function () {
        return !0;
      });
}
Class(function zUtils3D() {
  var diff, edge1, edge2, normal, v1, v0;
  (Math.euclideanModulo = function (n, m) {
    return ((n % m) + m) % m;
  }),
    (Math.isPowerOf2 = function (w, h) {
      let test = (value) => 0 == (value & (value - 1));
      return test(w) && test(h);
    }),
    (Math.floorPowerOf2 = function (value) {
      return Math.pow(2, Math.floor(Math.log(value) / Math.LN2));
    }),
    (Math.ceilPowerOf2 = function (value) {
      return Math.pow(2, Math.ceil(Math.log(value) / Math.LN2));
    }),
    (this.LOCAL = window.Hydra && Hydra.LOCAL),
    (Geometry.createAttributes = function (geom) {
      let attributes = {},
        handler = {
          set(target, property, value) {
            (target[property] = value),
              (geom._attributeKeys.length = 0),
              (geom._attributeValues.length = 0);
            for (let key in attributes)
              geom._attributeKeys.push(key),
                geom._attributeValues.push(attributes[key]);
            return !0;
          },
        };
      return (
        (geom._attributeKeys = []),
        (geom._attributeValues = []),
        new Proxy(attributes, handler)
      );
    }),
    (Geometry.TYPED_ARRAYS = {
      Int8Array: Int8Array,
      Uint8Array: Uint8Array,
      Uint8ClampedArray: Uint8ClampedArray,
      Int16Array: Int16Array,
      Uint16Array: Uint16Array,
      Int32Array: Int32Array,
      Uint32Array: Uint32Array,
      Float32Array: Float32Array,
      Float64Array: Float64Array,
    }),
    (Geometry.arrayNeedsUint32 = function (array) {
      for (let i = array.length - 1; i >= 0; --i)
        if (array[i] > 65535) return !0;
      return !1;
    }),
    (Geometry.TYPES = {
      SphereGeometry: SphereGeometry,
      IcosahedronGeometry: IcosahedronGeometry,
      BoxGeometry: BoxGeometry,
      PlaneGeometry: PlaneGeometry,
      CylinderGeometry: CylinderGeometry,
    }),
    (Matrix4.prototype.isMatrix4 = !0),
    (Matrix3.prototype.isMatrix3 = !0),
    (Vector3.prototype.isVector3 = !0),
    (Vector3D.prototype.isVector3 = !0),
    (Vector2.prototype.isVector2 = !0),
    (CameraBase3D.prototype.isCamera = !0),
    (PerspectiveCamera.prototype.isPerspective = !0),
    (Scene.FRONT_TO_BACK = "sort_front_to_back"),
    (Scene.FRONT_TO_BACK_BOUNDING = "sort_front_to_back_bounding"),
    window.THREAD &&
      (Shader = {
        FRONT_SIDE: "shader_front_side",
        BACK_SIDE: "shader_back_side",
        DOUBLE_SIDE: "shader_double_side",
      }),
    (Ray.prototype.intersectTriangle =
      ((diff = new Vector3()),
      (edge1 = new Vector3()),
      (edge2 = new Vector3()),
      (normal = new Vector3()),
      function intersectTriangle(a, b, c, backfaceCulling, target) {
        edge1.subVectors(b, a),
          edge2.subVectors(c, a),
          normal.crossVectors(edge1, edge2);
        var sign,
          DdN = this.direction.dot(normal);
        if (DdN > 0) {
          if (backfaceCulling) return null;
          sign = 1;
        } else {
          if (!(DdN < 0)) return null;
          (sign = -1), (DdN = -DdN);
        }
        diff.subVectors(this.origin, a);
        var DdQxE2 = sign * this.direction.dot(edge2.crossVectors(diff, edge2));
        if (DdQxE2 < 0) return null;
        var DdE1xQ = sign * this.direction.dot(edge1.cross(diff));
        if (DdE1xQ < 0) return null;
        if (DdQxE2 + DdE1xQ > DdN) return null;
        var QdN = -sign * diff.dot(normal);
        return QdN < 0 ? null : this.at(QdN / DdN, target);
      })),
    (Mesh.prototype.raycast = (function () {
      let inverseMatrix = new Matrix4(),
        ray = new Ray(),
        sphere = new Sphere(),
        vA = new Vector3(),
        vB = new Vector3(),
        vC = new Vector3(),
        uvA =
          (new Vector3(),
          new Vector3(),
          new Vector3(),
          new Vector3(),
          new Vector2()),
        uvB = new Vector2(),
        uvC = new Vector2(),
        barycoord = new Vector3(),
        intersectionPoint = new Vector3(),
        intersectionPointWorld = new Vector3();
      function checkBufferGeometryIntersection(
        object,
        raycaster,
        ray,
        position,
        uv,
        a,
        b,
        c
      ) {
        if (
          (vA.fromBufferAttribute(position, a),
          vB.fromBufferAttribute(position, b),
          vC.fromBufferAttribute(position, c),
          object.raycastLimit)
        ) {
          let { radiusSq: radiusSq, position: position } = object.raycastLimit;
          if (vA.distanceToSquared(position) > radiusSq) return;
        }
        let intersection = (function checkIntersection(
          object,
          shader,
          raycaster,
          ray,
          pA,
          pB,
          pC,
          point
        ) {
          let intersect;
          if (
            ((intersect =
              shader.side === Shader.BACK_SIDE
                ? ray.intersectTriangle(pC, pB, pA, !0, point)
                : ray.intersectTriangle(
                    pA,
                    pB,
                    pC,
                    shader.side !== Shader.DOUBLE_SIDE,
                    point
                  )),
            null === intersect)
          )
            return null;
          intersectionPointWorld.copy(point),
            intersectionPointWorld.applyMatrix4(object.matrixWorld);
          let distance = raycaster.ray.origin.distanceTo(
            intersectionPointWorld
          );
          return distance < raycaster.near || distance > raycaster.far
            ? null
            : {
                distance: distance,
                point: intersectionPointWorld.clone(),
                object: object,
              };
        })(
          object,
          object.shader,
          raycaster,
          ray,
          vA,
          vB,
          vC,
          intersectionPoint
        );
        if (intersection) {
          uv &&
            (uvA.fromBufferAttribute(uv, a),
            uvB.fromBufferAttribute(uv, b),
            uvC.fromBufferAttribute(uv, c),
            (intersection.uv = (function uvIntersection(
              point,
              p1,
              p2,
              p3,
              uv1,
              uv2,
              uv3
            ) {
              return (
                Triangle.getBarycoord(point, p1, p2, p3, barycoord),
                uv1.multiplyScalar(barycoord.x),
                uv2.multiplyScalar(barycoord.y),
                uv3.multiplyScalar(barycoord.z),
                uv1.add(uv2).add(uv3),
                uv1.clone()
              );
            })(intersectionPoint, vA, vB, vC, uvA, uvB, uvC)));
          let face = new Face3(a, b, c);
          Triangle.getNormal(vA, vB, vC, face.normal),
            (intersection.face = face);
        }
        return intersection;
      }
      return function raycast(raycaster, intersects) {
        let intersection,
          a,
          b,
          c,
          geometry = this.geometry,
          shader = this.shader,
          matrixWorld = this.matrixWorld;
        if (void 0 === shader) return;
        if (
          (null === geometry.boundingSphere && geometry.computeBoundingSphere(),
          0 == this.scale.x)
        )
          return;
        if (this.staticRaycast) {
          if (
            (this.raySphere ||
              ((this.raySphere = new Sphere()),
              this.raySphere.copy(geometry.boundingSphere),
              this.raySphere.applyMatrix4(matrixWorld)),
            this.raycastNeedsUpdate &&
              (this.raySphere.copy(geometry.boundingSphere),
              this.raySphere.applyMatrix4(matrixWorld),
              (this.raycastNeedsUpdate = !1)),
            !1 === raycaster.ray.intersectsSphere(this.raySphere))
          )
            return;
        } else if (
          (sphere.copy(geometry.boundingSphere),
          sphere.applyMatrix4(matrixWorld),
          !1 === raycaster.ray.intersectsSphere(sphere))
        )
          return;
        if (
          (inverseMatrix.getInverse(matrixWorld),
          ray.copy(raycaster.ray).applyMatrix4(inverseMatrix),
          null !== geometry.boundingBox &&
            !1 === ray.intersectsBox(geometry.boundingBox))
        )
          return;
        let i,
          l,
          index = geometry.index,
          position = geometry.attributes.position,
          uv = geometry.attributes.uv;
        if (null !== index)
          for (i = 0, l = index.length; i < l; i += 3)
            (a = index[i]),
              (b = index[i + 1]),
              (c = index[i + 2]),
              (intersection = checkBufferGeometryIntersection(
                this,
                raycaster,
                ray,
                position,
                uv,
                a,
                b,
                c
              )),
              intersection &&
                ((intersection.faceIndex = Math.floor(i / 3)),
                intersects.push(intersection));
        else if (void 0 !== position)
          for (i = 0, l = position.count; i < l; i += 3)
            (a = i),
              (b = i + 1),
              (c = i + 2),
              (intersection = checkBufferGeometryIntersection(
                this,
                raycaster,
                ray,
                position,
                uv,
                a,
                b,
                c
              )),
              intersection &&
                ((intersection.faceIndex = Math.floor(i / 3)),
                intersects.push(intersection));
      };
    })()),
    (Triangle.prototype.closestPointToPoint = (function () {
      let plane = new Plane(),
        edgeList = [new Line3(), new Line3(), new Line3()],
        projectedPoint = new Vector3(),
        closestPoint = new Vector3();
      return function closestPointToPoint(point, target = new Vector3()) {
        let minDistance = 1 / 0;
        if (
          (plane.setFromCoplanarPoints(this.a, this.b, this.c),
          plane.projectPoint(point, projectedPoint),
          !0 === this.containsPoint(projectedPoint))
        )
          target.copy(projectedPoint);
        else {
          edgeList[0].set(this.a, this.b),
            edgeList[1].set(this.b, this.c),
            edgeList[2].set(this.c, this.a);
          for (let i = 0; i < edgeList.length; i++) {
            edgeList[i].closestPointToPoint(projectedPoint, !0, closestPoint);
            let distance = projectedPoint.distanceToSquared(closestPoint);
            distance < minDistance &&
              ((minDistance = distance), target.copy(closestPoint));
          }
        }
        return target;
      };
    })()),
    (Points.prototype.raycast = (function () {
      let inverseMatrix = new Matrix4(),
        ray = new Ray(),
        sphere = new Sphere();
      return function raycast(raycaster, intersects) {
        let object = this,
          geometry = this.geometry,
          matrixWorld = this.matrixWorld,
          threshold = raycaster.params.Points.threshold;
        if (
          (null === geometry.boundingSphere && geometry.computeBoundingSphere(),
          sphere.copy(geometry.boundingSphere),
          sphere.applyMatrix4(matrixWorld),
          (sphere.radius += threshold),
          !1 === raycaster.ray.intersectsSphere(sphere))
        )
          return;
        inverseMatrix.getInverse(matrixWorld),
          ray.copy(raycaster.ray).applyMatrix4(inverseMatrix);
        let localThreshold =
            threshold / ((this.scale.x + this.scale.y + this.scale.z) / 3),
          localThresholdSq = localThreshold * localThreshold,
          position = new Vector3(),
          intersectPoint = new Vector3();
        function testPoint(point, index) {
          let rayPointDistanceSq = ray.distanceSqToPoint(point);
          if (rayPointDistanceSq < localThresholdSq) {
            ray.closestPointToPoint(point, intersectPoint),
              intersectPoint.applyMatrix4(matrixWorld);
            let distance = raycaster.ray.origin.distanceTo(intersectPoint);
            if (distance < raycaster.near || distance > raycaster.far) return;
            intersects.push({
              distance: distance,
              distanceToRay: Math.sqrt(rayPointDistanceSq),
              point: intersectPoint.clone(),
              index: index,
              face: null,
              object: object,
            });
          }
        }
        let index = geometry.index,
          positions = geometry.attributes.position.array;
        if (null !== index) {
          let indices = index.array;
          for (let i = 0, il = indices.length; i < il; i++) {
            let a = indices[i];
            position.fromArray(positions, 3 * a), testPoint(position, a);
          }
        } else
          for (let i = 0, l = positions.length / 3; i < l; i++)
            position.fromArray(positions, 3 * i), testPoint(position, i);
      };
    })()),
    Object.assign(Triangle, {
      getNormal:
        ((v0 = new Vector3()),
        function getNormal(a, b, c, target = new Vector3()) {
          target.subVectors(c, b), v0.subVectors(a, b), target.cross(v0);
          var targetLengthSq = target.lengthSq();
          return targetLengthSq > 0
            ? target.multiplyScalar(1 / Math.sqrt(targetLengthSq))
            : target.set(0, 0, 0);
        }),
      getBarycoord: (function () {
        var v0 = new Vector3(),
          v1 = new Vector3(),
          v2 = new Vector3();
        return function getBarycoord(point, a, b, c, target = new Vector3()) {
          v0.subVectors(c, a), v1.subVectors(b, a), v2.subVectors(point, a);
          var dot00 = v0.dot(v0),
            dot01 = v0.dot(v1),
            dot02 = v0.dot(v2),
            dot11 = v1.dot(v1),
            dot12 = v1.dot(v2),
            denom = dot00 * dot11 - dot01 * dot01;
          if (0 === denom) return target.set(-2, -1, -1);
          var invDenom = 1 / denom,
            u = (dot11 * dot02 - dot01 * dot12) * invDenom,
            v = (dot00 * dot12 - dot01 * dot02) * invDenom;
          return target.set(1 - u - v, v, u);
        };
      })(),
      getUV: (function () {
        let _v3 = new Vector3();
        return function getUV(point, p1, p2, p3, uv1, uv2, uv3, target) {
          return (
            this.getBarycoord(point, p1, p2, p3, _v3),
            target.set(0, 0),
            target.addScaledVector(uv1, _v3.x),
            target.addScaledVector(uv2, _v3.y),
            target.addScaledVector(uv3, _v3.z),
            target
          );
        };
      })(),
      containsPoint:
        ((v1 = new Vector3()),
        function containsPoint(point, a, b, c) {
          return (
            Triangle.getBarycoord(point, a, b, c, v1),
            v1.x >= 0 && v1.y >= 0 && v1.x + v1.y <= 1
          );
        }),
    });
}, "static"),
  Class(function FXLayer(_parentNuke, _type, _preventDrawBuffers = !1) {
    Inherit(this, Component);
    var _nuke,
      _rt,
      _this = this,
      _scene = new Scene(),
      _objects = [],
      _textureIndex = -1,
      _visible = !0,
      _id = Utils.timestamp(),
      _name = Utils.getConstructorName(_this),
      _useDrawBuffers = !_preventDrawBuffers;
    (this.resolution = 1), (this.enabled = !0), (this.renderShadows = !0);
    const CLEAR_COLOR = [0, 0, 0, 1];
    function resizeHandler() {
      _rt.setSize &&
        _rt.setSize(
          _nuke.stage.width * _this.resolution * _nuke.dpr,
          _nuke.stage.height * _this.resolution * _nuke.dpr
        );
    }
    (FXLayer.exists = !0),
      this.set("visible", (v) => (_this.scene.visible = _visible = v)),
      this.get("visible", (_) => _visible),
      (this.onInvisible = function () {
        _this.scene.visible = !1;
      }),
      (this.onVisible = function () {
        _this.scene.visible = !0;
      }),
      (this.create = function (nuke = World.NUKE, type, rt) {
        if (!nuke) return;
        let format, manualRender, mipmaps;
        (_useDrawBuffers = nuke.useDrawBuffers),
          type &&
            "object" == typeof type &&
            ("boolean" == typeof type.useDrawBuffers &&
              (_useDrawBuffers = type.useDrawBuffers),
            (format = type.format),
            (manualRender = type.manualRender),
            (mipmaps = type.mipmaps),
            rt || (rt = type.rt),
            (type = type.type)),
          (_this.rtType = type || Texture.UNSIGNED_BYTE),
          (_this.rtFormat = format || Texture.RGBFormat),
          (_this.rtMipmaps = mipmaps),
          ((_this = this).scene = _scene),
          ((_nuke = _this.initClass(Nuke, nuke.stage, {
            renderer: nuke.renderer,
            camera: nuke.camera,
            scene: _scene,
            dpr: nuke.dpr,
            useDrawBuffers: !1,
          })).parentNuke = nuke),
          (_parentNuke = nuke),
          (_this.nuke = _nuke),
          (function initRT(rt) {
            if (_useDrawBuffers) {
              let texture = new Texture();
              (texture.minFilter = Texture.LINEAR),
                (texture.magFilter = Texture.LINEAR),
                (texture.format = Texture.RGBAFormat),
                _this.rtType && (texture.type = _this.rtType),
                _this.rtFormat && (texture.format = _this.rtFormat),
                _this.rtMipmaps
                  ? ((texture.generateMipmaps = !0),
                    (texture.minFilter = texture.magFilter =
                      Texture.LINEAR_MIPMAP))
                  : (texture.generateMipmaps = !1),
                texture.type == Texture.FLOAT &&
                  (texture.format = Texture.RGBAFormat),
                (texture.wrapS = texture.wrapT = Texture.CLAMP_TO_EDGE),
                (texture.fxLayer = _this),
                (_this.textureIndex = _textureIndex =
                  _parentNuke.attachDrawBuffer(texture)),
                (_rt = { texture: texture });
            } else
              _this.rtType &&
                _this.rtType == Texture.FLOAT &&
                "ios" == Device.system.os &&
                (_this.rtType = Texture.HALF_FLOAT),
                (_rt =
                  rt ||
                  Utils3D.createRT(
                    Math.round(
                      _nuke.stage.width * _this.resolution * _nuke.dpr
                    ),
                    Math.round(
                      _nuke.stage.height * _this.resolution * _nuke.dpr
                    ),
                    _this.rtType,
                    _this.rtFormat
                  )),
                _this.rtMipmaps
                  ? ((_rt.texture.minFilter = _rt.texture.magFilter =
                      Texture.LINEAR_MIPMAP),
                    (_rt.texture.generateMipmaps = !0))
                  : (_rt.texture.generateMipmaps = !1);
            (_this.rt = _rt), _this.nuke.setSize(_rt.width, _rt.height);
          })(rt),
          (function addListeners() {
            _this.events.sub(Events.RESIZE, resizeHandler);
          })(),
          manualRender ||
            FXScene.manualRender ||
            _this.startRender((_) => _this.draw(), nuke);
      }),
      (this.addObject = this.add =
        function (object) {
          if (_nuke) {
            if (!_useDrawBuffers) {
              let clone = object.clone();
              for (
                object["clone_" + _id] = clone,
                  _scene.add(clone),
                  _objects.push(object),
                  object.shader &&
                    (function editShader(mesh) {
                      let modifyShader = (shader, name) => {
                          let fs = shader._fragmentShader;
                          if (!fs) return;
                          let marker = "#drawbuffer " + name;
                          if (fs.includes(marker)) {
                            let split = fs.split(marker + " ");
                            fs = split.join("");
                          }
                          for (; fs.includes("#drawbuffer"); ) {
                            fs = fs.split("\n");
                            for (let i = 0; i < fs.length; i++)
                              fs[i].includes("#drawbuffer") && (fs[i] = "");
                            fs = fs.join("\n");
                          }
                          shader.fragmentShader = fs;
                        },
                        applyShadow = (shader, bool) => {
                          let fs = shader.fragmentShader;
                          if (fs) {
                            for (; fs.includes("#applyShadow"); ) {
                              fs = fs.split("\n");
                              for (let i = 0; i < fs.length; i++)
                                bool
                                  ? fs[i].includes("#applyShadow") &&
                                    (fs[i] = fs[i].replace("#applyShadow", ""))
                                  : fs[i].includes("#applyShadow") &&
                                    (fs[i] = "");
                              fs = fs.join("\n");
                            }
                            shader.fragmentShader = fs;
                          }
                        };
                      mesh.shader._fragmentShader ||
                        (mesh.shader._fragmentShader =
                          mesh.shader.fragmentShader),
                        modifyShader(mesh.shader, "Color");
                      let shader = mesh.shader.clone(
                        !_this.renderShadows,
                        `-${_this.name || _name}`
                      );
                      modifyShader(shader, _this.name || _name),
                        applyShadow(shader, _this.renderShadows),
                        applyShadow(mesh.shader, !0),
                        mesh.shader.copyUniformsTo(shader, !0),
                        (mesh.shader = shader);
                    })(clone);
                clone.children.length;

              )
                clone.remove(clone.children[0]);
              return clone;
            }
            object.shader &&
              object.shader.fragmentShader &&
              (!(function editDBShader(mesh) {
                const WEBGL2 = Renderer.type == Renderer.WEBGL2;
                let modifyMarker = (fs, name, index) => {
                    if (WEBGL2) {
                      if (
                        fs.includes(
                          "layout(location=0) out vec4 reflectionsData"
                        )
                      )
                        return fs;
                      if (!fs.includes(`layout(location=${index})`)) {
                        let mainAt = (fs = fs.replace(
                            "out vec4 FragColor;",
                            ""
                          )).indexOf("void main()"),
                          before = fs.slice(0, mainAt),
                          after = fs.slice(mainAt);
                        fs =
                          before +
                          `layout(location=${index}) out vec4 ${name};\n` +
                          after;
                      }
                    }
                    let marker = "#drawbuffer " + name;
                    if (fs.includes(marker)) {
                      let split = fs.split(marker + " "),
                        finalOut = WEBGL2 ? name : `gl_FragData[${index}]`;
                      for (let i = 1; i < split.length; ++i)
                        split[i] = split[i].replace("gl_FragColor", finalOut);
                      fs = split.join("");
                    }
                    for (; fs.includes("#applyShadow"); ) {
                      fs = fs.split("\n");
                      for (let i = 0; i < fs.length; i++)
                        fs[i].includes("#applyShadow") &&
                          (fs[i] = fs[i].replace("#applyShadow", ""));
                      fs = fs.join("\n");
                    }
                    return fs;
                  },
                  shader = mesh.shader,
                  fs = shader.fragmentShader,
                  name = _this.name || _name;
                (WEBGL2 && fs.includes("location=0")) ||
                  (fs = modifyMarker(fs, "Color", 0)),
                  (fs = modifyMarker(fs, name, _textureIndex)),
                  (shader.fragmentShader = fs);
              })(object),
              (object.shader._attachmentData = {
                format: _this.rtFormat,
                type: _this.rtType,
                attachments: _parentNuke.attachments,
              }));
          }
        }),
      (this.removeObject = function (object) {
        _nuke &&
          (_scene.remove(object["clone_" + _id]),
          _objects.remove(object),
          delete object["clone_" + _id]);
      }),
      (this.render = this.draw =
        function (stage, camera) {
          if (!_nuke || !_this.enabled || _useDrawBuffers) return;
          if (!_parentNuke.enabled || !_objects.length) return;
          const oldClear = Renderer.CLEAR;
          (Renderer.CLEAR = CLEAR_COLOR),
            stage &&
              ((_nuke.stage = stage), _this.setSize(stage.width, stage.height)),
            (_nuke.camera = camera || _nuke.parentNuke.camera),
            _this.renderShadows || (_nuke.renderer.overridePreventShadows = !0);
          for (let i = _objects.length - 1; i > -1; i--) {
            let obj = _objects[i],
              clone = obj["clone_" + _id];
            _this.forceVisible
              ? (clone.visible = !0)
              : (clone.visible = obj.determineVisible()),
              clone.visible &&
                (obj.updateMatrixWorld(),
                obj.ignoreMatrix || Utils3D.decompose(obj, clone));
          }
          (_nuke.rtt = _rt),
            _nuke.render(),
            RenderStats.update("FXLayer"),
            (_nuke.renderer.overridePreventShadows = !1),
            (Renderer.CLEAR = oldClear);
        }),
      (this.addPass = function (pass) {
        _nuke && _nuke.add(pass);
      }),
      (this.removePass = function (pass) {
        _nuke && _nuke.remove(pass);
      }),
      (this.setSize = function (width, height) {
        _nuke &&
          ((_rt.width == width && _rt.height == height) ||
            (_this.events.unsub(Events.RESIZE, resizeHandler),
            _rt &&
              _rt.setSize(
                width * _this.resolution * _nuke.dpr,
                height * _this.resolution * _nuke.dpr
              ),
            _nuke.setSize(
              width * _this.resolution * _nuke.dpr,
              height * _this.resolution * _nuke.dpr
            )));
      }),
      (this.setDPR = function (dpr) {
        _nuke && ((_nuke.dpr = dpr), resizeHandler());
      }),
      (this.setResolution = function (res) {
        (_this.resolution = res), resizeHandler();
      }),
      (this.getObjects = function () {
        return _objects;
      }),
      (this.useRT = function (rt) {
        _rt = _this.rt = rt;
      }),
      (this.getName = function () {
        return _this.name || _name;
      }),
      _parentNuke instanceof Nuke && this.create(_parentNuke, _type);
  }),
  Namespace("FX"),
  Class(function FXScene(_parentNuke, _type, ...rest) {
    Inherit(this, Component);
    var _nuke,
      _rt,
      _rtPool,
      _showManualRenderWarning,
      _this = this,
      _scene = new Scene(),
      _id = Utils.timestamp(),
      _objects = [],
      _renderTime = Render.TIME,
      _visible = !0;
    function resizeHandler() {
      _rt.setSize &&
        _rt.setSize(
          _nuke.stage.width * _this.resolution * _nuke.dpr,
          _nuke.stage.height * _this.resolution * _nuke.dpr
        ),
        _this.nuke.setSize(_rt.width, _rt.height),
        (_this.width = _rt.width),
        (_this.height = _rt.height);
    }
    (this.resolution = 1),
      (this.autoVisible = !0),
      (this.enabled = !0),
      (this.scene = _scene),
      (this.renderShadows = !0),
      this.set("visible", (v) => {
        _this.scene &&
          ((_this.scene.visible = _visible = v),
          _this.onFXSceneVisibility?.(v));
      }),
      this.get("visible", (_) => _visible),
      (this.onInvisible = this.fxInvisible =
        function () {
          this.scene.visible &&
            ((this.scene.visible = !1), _this.flag("needsOnVisible", !0)),
            _rtPool && _rtPool.putRT(_this.rt);
        }),
      this._bindOnDestroy(function () {
        _rtPool && _rtPool.putRT(_this.rt);
      }),
      (this.onVisible = this.fxVisible =
        function () {
          _this.flag("needsOnVisible") &&
            ((this.scene.visible = !0), _this.flag("needsOnVisible", !1)),
            _rtPool && (_this.useRT(_rtPool.getRT()), resizeHandler());
        }),
      (this.create = function (nuke = World.NUKE, rt, options) {
        _this.nuke ||
          (rt instanceof RTPool && (rt = (_rtPool = rt).nullRT),
          nuke instanceof RTPool
            ? ((options = rt),
              (rt = (_rtPool = nuke).nullRT),
              (nuke = World.NUKE))
            : rt && "object" == typeof rt
            ? rt.isRT || ((options = rt), (rt = void 0))
            : !nuke ||
              nuke instanceof Nuke ||
              ((options = nuke), (nuke = World.NUKE)),
          options || (options = {}),
          (_this.rtFormat = options.format || Texture.RGBFormat),
          (_this.rtType = options.type || Texture.UNSIGNED_BYTE),
          options.vr && (_this.vrRT = RenderManager.type == RenderManager.VR),
          options.parentNuke && (nuke = options.parentNuke),
          ((_this = this).scene = _scene),
          (_this.nuke = _nuke =
            _this.initClass(Nuke, nuke.stage, {
              renderer: nuke.renderer,
              camera: nuke.camera,
              scene: _scene,
              dpr: nuke.dpr,
              format: options.format,
              vrRT: _this.vrRT,
              multisample: options.multisample,
              samplesAmount: options.samplesAmount,
            })),
          (_scene.nuke = _nuke),
          (function initRT(rt, options = {}) {
            options.type == Texture.FLOAT &&
              ((options.format = Texture.RGBAFormat),
              "ios" == Device.system.os &&
                ((options.type = Texture.HALF_FLOAT),
                (options.minFilter = Texture.NEAREST),
                (options.magFilter = Texture.NEAREST)));
            const RT =
              _this.nuke.useDrawBuffers && options.multiRenderTarget
                ? MultiRenderTarget
                : RenderTarget;
            (_this.width = _nuke.stage.width * _this.resolution * _nuke.dpr),
              (_this.height =
                _nuke.stage.height * _this.resolution * _nuke.dpr);
            let magFilter = Texture.LINEAR,
              minFilter = options.mipmaps
                ? Texture.LINEAR_MIPMAP
                : Texture.LINEAR;
            (_rt =
              rt ||
              new RT(
                _this.width,
                _this.height,
                Object.assign(
                  {
                    minFilter: minFilter,
                    magFilter: magFilter,
                    generateMipmaps: options.mipmaps || !1,
                  },
                  options
                )
              )),
              (_nuke.rtt = _this.rt = _rt),
              (_rt.fxscene = _this),
              _this.vrRT && (_rt.vrRT = !0);
          })(rt, options),
          rt
            ? _this.flag("recycle_rt", !0)
            : (function addListeners() {
                _this.events.sub(Events.RESIZE, resizeHandler);
              })(),
          FXScene.onCreate && FXScene.onCreate(_this),
          options.manualRender ||
            _this.manualRender ||
            FXScene.manualRender ||
            (Hydra.LOCAL && (_showManualRenderWarning = !0),
            _this.vrRT
              ? _this.startRender(({ view: view }) => {
                  0 === view && _this.draw();
                }, RenderManager.EYE_RENDER)
              : _this.startRender((_) => {
                  _this.draw();
                }, nuke)));
      }),
      (this.onDestroy = this.fxDestroy =
        function () {
          (_this.scene.deleted = !0),
            _this.flag("recycle_rt")
              ? _rtPool && _rt && _rtPool.putRT(_rt)
              : _rt && _rt.destroy && _rt.destroy();
        }),
      (this.setSize = function (width, height, exact) {
        _nuke &&
          (exact ||
            ((width = width * _this.resolution * _nuke.dpr),
            (height = height * _this.resolution * _nuke.dpr)),
          (_rt.width == width && _rt.height == height) ||
            (_this.events.unsub(Events.RESIZE, resizeHandler),
            (_this.width = width),
            (_this.height = height),
            _rt && _rt.setSize(_this.width, _this.height),
            _nuke.setSize(_this.width, _this.height)));
      }),
      (this.add = this.addObject =
        function (object) {
          if (!object) return console.error("FXScene addObject undefined!");
          let clone = object.clone();
          for (
            object["clone_" + _id] = clone,
              _scene.add(clone),
              _objects.push(object),
              object.shader._attachmentData = {
                format: _this.rtFormat,
                type: _this.rtType,
                attachments: 1,
              };
            clone.children.length;

          )
            clone.remove(clone.children[0]);
          return clone;
        }),
      (this.removeObject = function (object) {
        _scene.remove(object["clone_" + _id]),
          _objects.remove(object),
          delete object["clone_" + _id];
      }),
      (this.setScissor = function (x, y, w, h) {
        this.scissor || (this.scissor = new Vector4()),
          (this.scissor.x = x * _this.width),
          (this.scissor.y = _this.height - h * _this.height - y * _this.height),
          (this.scissor.width = w * _this.width),
          (this.scissor.height = h * _this.height),
          (this.rt.scissor = this.scissor);
      }),
      (this.render = this.draw =
        function (stage, camera) {
          if (_this.preventRender) return;
          if (_this.isVrWorldMode)
            return void (_this.onBeforeRender && _this.onBeforeRender());
          if (
            (_showManualRenderWarning &&
              Render.TIME - _renderTime < 1e3 / Render.REFRESH_RATE / 2 &&
              (console.warn(
                `FXScene ${Utils.getConstructorName(
                  _this
                )} rendering early (${Math.round(
                  Render.TIME - _renderTime,
                  3
                )}ms elapsed, expected ~${Math.round(
                  1e3 / Render.REFRESH_RATE,
                  3
                )}ms. Set manualRender option if using own render loop.`
              ),
              (_showManualRenderWarning = !1)),
            (_renderTime = Render.TIME),
            _this.isVrSceneMode)
          ) {
            let rt =
                World.NUKE.enabled && World.NUKE.passes.length
                  ? World.NUKE.rttBuffer
                  : void 0,
              autoClear = _nuke.renderer.autoClear;
            return (
              (_nuke.renderer.autoClear = !1),
              _nuke.renderer.clearDepth(rt),
              _this.onBeforeRender && _this.onBeforeRender(),
              _nuke.renderer.render(_scene, _nuke.camera, rt),
              void (_nuke.renderer.autoClear = autoClear)
            );
          }
          stage &&
            (_this.events.unsub(Events.RESIZE, resizeHandler),
            (_this.nuke.stage = stage),
            _this.setSize(stage.width, stage.height)),
            camera && (_this.nuke.camera = camera);
          let clearColor = null,
            alpha = 1;
          _this.clearColor &&
            ((clearColor = _nuke.renderer.getClearColor().getHex()),
            _nuke.renderer.setClearColor(_this.clearColor)),
            _this.clearAlpha > -1 &&
              ((alpha = _nuke.renderer.getClearAlpha()),
              _nuke.renderer.setClearAlpha(_this.clearAlpha)),
            _this.renderShadows || (_nuke.renderer.overridePreventShadows = !0);
          for (let i = _objects.length - 1; i > -1; i--) {
            let obj = _objects[i],
              clone = obj["clone_" + _id];
            _this.forceVisible || obj.cloneVisible
              ? (clone.visible =
                  "boolean" != typeof clone.isVisible || clone.isVisible)
              : (clone.visible = obj.determineVisible()),
              clone.visible &&
                (obj.updateMatrixWorld(!1 === obj.visible || void 0),
                obj.ignoreMatrix ||
                  (Utils3D.decompose(obj, clone),
                  clone.overrideScale &&
                    clone.scale.setScalar(clone.overrideScale)));
          }
          _this.preventRTDraw ||
            (RenderStats.update("FXScene", 1, _this),
            _this.onBeforeRender && _this.onBeforeRender(),
            (_nuke.rtt = _rt),
            _nuke.render()),
            (_nuke.renderer.overridePreventShadows = !1),
            _this.clearColor && _nuke.renderer.setClearColor(clearColor),
            _this.clearAlpha > -1 &&
              _nuke.renderer.setClearAlpha(_this.clearAlpha),
            RenderManager.fire(_this);
        }),
      (this.setDPR = function (dpr) {
        return _nuke ? ((_nuke.dpr = dpr), resizeHandler(), _this) : _this;
      }),
      (this.addPass = function (pass) {
        _nuke && _nuke.add(pass);
      }),
      (this.removePass = function (pass) {
        _nuke && _nuke.remove(pass);
      }),
      (this.setResolution = function (res) {
        return (_this.resolution = res), resizeHandler(), this;
      }),
      (this.useRT = function (rt) {
        (_rt = _this.rt = rt), _this.vrRT && (rt.vrRT = !0);
      }),
      (this.upload = function () {
        _rt && _rt.upload();
      }),
      (this.useCamera = function (camera) {
        _this.nuke.camera = camera.camera || camera;
      }),
      (this.useScene = function (scene) {
        _this.nuke.scene = scene;
      }),
      (this.vrWorldMode = function () {
        (_this.isVrWorldMode = !0), (_this.group = new Group());
        for (let i = 0; i < this.scene.children.length; i++)
          this.group.add(this.scene.children[i]);
        (_scene = _this.scene = _this.group), World.SCENE.add(_this.group);
      }),
      (this.vrSceneMode = function () {
        (_this.isVrSceneMode = !0),
          (World.NUKE.autoClear = !1),
          (RenderManager.renderer.autoClear = !1);
      }),
      (this.createDepthTexture = function (useRTTBuffer) {
        return (
          _this.depthTexture ||
            (_this.nuke.passes.length || useRTTBuffer
              ? (_this.nuke.rttBuffer.createDepthTexture(),
                (_this.depthTexture = _this.nuke.rttBuffer.depth))
              : (_this.rt.createDepthTexture(),
                (_this.depthTexture = _this.rt.depth))),
          _this.depthTexture
        );
      }),
      _parentNuke instanceof Nuke && this.create(_parentNuke, _type, ...rest);
  }),
  Class(function FXSceneCompositor(_shader, _options = {}) {
    Inherit(this, Object3D);
    const _this = this;
    var _basicShader;
    function decorateShader(shader) {
      shader.addUniforms({
        tFrom: { value: null },
        tTo: { value: null },
        uTransition: { value: 0 },
      });
    }
    function loop() {
      (_this.mesh.shader =
        _shader.uniforms.uTransition.value > 0 ? _shader : _basicShader),
        _shader.uniforms.uTransition.value >= 1 &&
          ((_this.mesh.shader = _basicShader),
          _basicShader.set("tMap", _shader.get("tTo")),
          _basicShader.set("tFrom", _shader.get("tTo")),
          _shader.set("uTransition", 0));
    }
    !(function initOptions() {
      (null === _options ||
        _options instanceof Texture ||
        _options.texture ||
        (_options.rt && _options.rt.texture)) &&
        (_options = { startTexture: _options });
    })(),
      decorateShader(_shader),
      (function initMesh() {
        let uniforms = { tMap: { value: _shader.get("tTo") } };
        _options.basicShader
          ? (_basicShader = _options.basicShader).addUniforms(uniforms)
          : (_basicShader = _this.initClass(Shader, "ScreenQuad", uniforms)),
          (_this.mesh = new Mesh(World.QUAD, _basicShader)),
          (_this.mesh.frustumCulled = !1),
          _this.add(_this.mesh);
      })(),
      _this.startRender(loop),
      (this.useShader = function (shader) {
        (_shader = shader), decorateShader(shader);
      }),
      (this.useBasicShader = function (shader) {
        _basicShader.copyUniformsTo(shader, !0), (_basicShader = shader);
      }),
      (this.swap = function (showTransition) {
        showTransition
          ? (_this.mesh.shader = _shader)
          : (_basicShader.set("tMap", _shader.get("tTo")),
            (_this.mesh.shader = _basicShader),
            _shader.set("tFrom", _basicShader.get("tMap")));
      }),
      this.set("manual", (v) => {
        v ? _this.stopRender(loop) : _this.startRender(loop);
      }),
      (this.transition = async function (texture, time, ease, delay) {
        let from = _shader.get("tFrom");
        _shader.set("tTo", texture),
          (texture.visible = !0),
          from
            ? await _shader.tween("uTransition", 1, time, ease, delay).promise()
            : _shader.set("uTransition", 1),
          from && (from.visible = !1),
          _shader.set("tFrom", texture);
      });
  }),
  Class(function FXStencil() {
    Inherit(this, Component);
    const _this = this;
    var _nuke;
    function render() {
      _nuke ||
        (_nuke = (function findNuke() {
          let p = _this.mesh._parent;
          for (; p; ) {
            if (p instanceof Scene) return p.nuke;
            p = p._parent;
          }
        })());
      let autoClear = World.RENDERER.autoClear;
      (World.RENDERER.autoClear = !1),
        _this.enabled &&
          (_this.onBeforeMaskRendered && _this.onBeforeMaskRendered(),
          World.RENDERER.setupStencilMask(),
          World.RENDERER.render(_this.mask, _nuke.camera, "stencil"),
          _this.onAfterMaskRendered && _this.onAfterMaskRendered(),
          World.RENDERER.setupStencilDraw(_this.mode)),
        World.RENDERER.render(_this.scene, _nuke.camera, "stencil"),
        (World.RENDERER.autoClear = autoClear),
        World.RENDERER.clearStencil();
    }
    (this.mesh = new Mesh(World.PLANE, Utils3D.getTestShader())),
      (this.scene = new Scene()),
      (this.mask = new Scene()),
      (this.mode = "inside"),
      (this.enabled = !0),
      (_this.mesh.shader.neverRender = !0),
      (_this.mesh.shader.transparent = !0),
      (_this.mesh.renderOrder = 99999),
      (_this.mesh.onBeforeRender = render),
      (this.onDestroy = function () {
        _this.group._parent.remove(_this.mesh);
      });
  }),
  Class(function FragCompositor() {
    Inherit(this, Component);
    const _this = this;
    this._initCompositor = function (obj) {
      (_this.shader = _this.initClass(
        Shader,
        obj.shader,
        _this.parent[obj.uniforms.slice(1)]
      )),
        (_this.basicShader = _this.initClass(
          Shader,
          obj.basicShader || "ScreenQuad",
          _this.parent[obj.uniforms.slice(1)]
        )),
        (_this.compositor = _this.initClass(FXSceneCompositor, _this.shader, {
          basicShader: _this.basicShader,
        })),
        (obj.scene || World.SCENE).add(_this.compositor.mesh);
    };
  }),
  Class(function BlitPass(_forceNuke) {
    Inherit(this, NukePass);
    (this.uniforms = {}),
      this.init("BlitPass"),
      _forceNuke || (this.blitFramebuffer = !0);
  }),
  Class(
    function Nuke(_stage, _params) {
      Inherit(this, Component);
      var _width,
        _height,
        _nukeMesh,
        _this = this;
      _params.renderer || console.error("Nuke :: Must define renderer"),
        (_this.stage = _stage),
        (_this.renderer = _params.renderer),
        (_this.camera = _params.camera),
        (_this.scene = _params.scene),
        (_this.rtt = _params.rtt),
        (_this.enabled = 0 != _params.enabled),
        (_this.passes = _params.passes || []),
        (_this.format = _params.format || Texture.RGBFormat),
        (_this.useDrawBuffers =
          !Utils.query("noDrawBuffers") &&
          !Nuke.NO_DRAWBUFFERS &&
          (void 0 !== _params.useDrawBuffers
            ? _params.useDrawBuffers
            : !(Renderer.type != Renderer.WEBGL2 && !window.Metal)));
      var _rttPing,
        _rttPong,
        _rttBuffer,
        _dpr = _params.dpr || 1,
        _drawBuffers = [],
        _enabledPasses = [],
        _multisample = _params.multisample || !1,
        _samplesAmount = _params.samplesAmount || 4;
      function resizeHandler() {
        var width = _this.stage.width * _dpr,
          height = _this.stage.height * _dpr;
        _rttPing.setSize(width, height),
          _rttPong.setSize(width, height),
          _rttBuffer.setSize(width, height),
          Nuke.renameRT(
            _width,
            _height,
            width,
            height,
            !1,
            1,
            _this.format,
            !1,
            _samplesAmount
          ),
          Nuke.renameRT(
            _width,
            _height,
            width,
            height,
            !1,
            2,
            _this.format,
            !1,
            _samplesAmount
          ),
          Nuke.renameRT(
            _width,
            _height,
            width,
            height,
            _this.useDrawBuffers,
            -1,
            _this.format,
            _multisample,
            _samplesAmount
          ),
          (_width = width),
          (_height = height);
      }
      (_this.scene.nuke = _this),
        (function initDefaultPass() {
          if (Nuke.defaultPass) return;
          let upload = (Nuke.defaultPass = new BlitPass()).upload;
          Nuke.defaultPass.upload = function () {
            upload.apply(this, arguments), (Nuke.defaultPass.uploaded = !0);
          };
        })(),
        (function initNuke() {
          let width = _this.stage.width * _dpr,
            height = _this.stage.height * _dpr;
          (_rttPing = Nuke.getRT(
            width,
            height,
            !1,
            1,
            _this.format,
            !1,
            _samplesAmount
          )),
            (_rttPong = Nuke.getRT(
              width,
              height,
              !1,
              2,
              _this.format,
              !1,
              _samplesAmount
            )),
            (_rttBuffer = Nuke.getRT(
              width,
              height,
              _this.useDrawBuffers,
              -1,
              _this.format,
              _multisample,
              _samplesAmount
            )),
            ((_nukeMesh = new Mesh(World.QUAD, null)).frustumCulled = !1),
            (_nukeMesh.noMatrices = !0),
            (_nukeMesh.transient = !0),
            (_width = width),
            (_height = height),
            _params.vrRT && ((_this.vrRT = !0), (_rttBuffer.vrRT = !0));
        })(),
        (function addListeners() {
          _this.events.sub(Events.RESIZE, resizeHandler);
        })(),
        (_this.forceResize = resizeHandler),
        (_this.onBeforeShaderCompile = function (obj) {
          if (!obj) return;
          let shader = obj.shader;
          if (
            !(
              shader &&
              shader.fragmentShader &&
              _this.useDrawBuffers &&
              _drawBuffers.length
            )
          )
            return;
          if (shader.fragmentShader.includes("layout(location")) return;
          const WEBGL2 = Renderer.type == Renderer.WEBGL2;
          let matched = !1;
          if (
            (_drawBuffers.forEach((t, i) => {
              let name = t.fxLayer.getName(),
                keyExpr = WEBGL2
                  ? new RegExp(`\\b${name}\\s*=`)
                  : new RegExp(`\\bgl_FragData\\[${i + 1}\\]\\s*=`),
                defaultOutput = t.fxLayer.defaultOutputColor || "vec4(0.0)";
              if (
                ("Color" === defaultOutput && (defaultOutput = "tmpFragColor"),
                !keyExpr.test(shader.fragmentShader) && _this.useDrawBuffers)
              ) {
                let fs = shader.fragmentShader;
                if (!fs.includes(`#drawbuffer ${name} gl_FragColor`)) {
                  let idx = fs.lastIndexOf("}");
                  (fs =
                    fs.slice(0, idx) +
                    `#drawbuffer ${name} gl_FragColor = ${defaultOutput};\n` +
                    fs.slice(idx)),
                    (shader.fragmentShader = fs);
                }
                t.fxLayer.add(obj), (matched = !0);
              }
            }),
            !(WEBGL2 ? /\bColor\s*=/ : /\bgl_FragData\[0\]\s*=/).test(
              shader.fragmentShader
            ))
          ) {
            let fs = shader.fragmentShader;
            if (!fs.includes("layout(location=0) out vec4 reflectionsData")) {
              WEBGL2 ||
                (fs = "#extension GL_EXT_draw_buffers : require\n" + fs),
                (fs = fs.split("void main() {")),
                (fs = fs[0] + "void main() {\nvec4 tmpFragColor;\n" + fs[1]),
                (fs = fs.replace(/gl_FragColor/g, "tmpFragColor"));
              let idx = fs.lastIndexOf("}");
              fs = matched
                ? WEBGL2
                  ? fs.slice(0, idx) + "Color = tmpFragColor;\n" + fs.slice(idx)
                  : fs.slice(0, idx) +
                    "gl_FragData[0] = tmpFragColor;\n" +
                    fs.slice(idx)
                : fs.slice(0, idx) +
                  "#drawbuffer Color gl_FragColor = tmpFragColor;\n" +
                  fs.slice(idx);
            }
            shader.fragmentShader = fs;
          }
          shader.onBeforePrecompilePromise.resolve();
        }),
        (_this.add = function (pass, index) {
          "number" != typeof index
            ? _this.passes.push(pass)
            : _this.passes.splice(index, 0, pass);
        }),
        (_this.remove = function (pass) {
          "number" == typeof pass
            ? _this.passes.splice(pass)
            : _this.passes.remove(pass);
        }),
        (_this.render = function (directCallback) {
          if (_this.paused) return;
          RenderStats.update("Nuke"),
            RenderManager.fire(_this),
            _this.events.fire(Nuke.RENDER, _this, !0),
            _this.onBeforeRender && _this.onBeforeRender();
          let count = _this.passes.length;
          _enabledPasses.length = 0;
          for (let i = 0; i < count; i++) {
            let pass = _this.passes[i];
            pass.disabled || _enabledPasses.push(pass);
          }
          if (
            (_this.enabled &&
              0 === _enabledPasses.length &&
              !_this.rtt &&
              (_dpr !== Device.pixelRatio || _multisample) &&
              Nuke.defaultPass &&
              _enabledPasses.push(Nuke.defaultPass),
            !_this.enabled || !_enabledPasses.length)
          ) {
            let autoClear = _this.renderer.autoClear;
            return (
              0 == _this.autoClear && (_this.renderer.autoClear = !1),
              _this.renderer.render(
                _this.scene,
                _this.camera,
                _this.rtt,
                null,
                directCallback
              ),
              _this.onBeforeProcess && _this.onBeforeProcess(),
              _this.events.fire(Nuke.BEFORE_PASSES, _this, !0),
              _this.events.fire(Nuke.BEFORE_POST_RENDER, _this, !0),
              _this.postRender && _this.postRender(),
              _this.events.fire(Nuke.POST_RENDER, _this, !0),
              void (
                0 == _this.autoClear &&
                ((_this.renderer.autoClear = autoClear),
                _this.renderer.clearColor())
              )
            );
          }
          RenderStats.update("NukePass", _enabledPasses.length),
            (_this.hasRendered = !0),
            _this.onBeforeProcess && _this.onBeforeProcess();
          let autoClear = _this.renderer.autoClear;
          0 == _this.autoClear && (_this.renderer.autoClear = !1),
            _this.preventNewRender ||
              _this.renderer.render(_this.scene, _this.camera, _rttBuffer),
            0 == _this.autoClear && (_this.renderer.autoClear = autoClear),
            _this.onBeforePasses && _this.onBeforePasses(_rttBuffer);
          let pingPong = !0,
            skipMultisample = _this.rtt && _this.rtt.multisample;
          skipMultisample && (_this.rtt.multisample = !1),
            (count = _enabledPasses.length),
            _this.events.fire(Nuke.BEFORE_PASSES, _this, !0);
          for (var i = 0; i < count; i++) {
            let shader = _enabledPasses[i].pass,
              inTexture =
                0 === i
                  ? _rttBuffer.texture
                  : pingPong
                  ? _rttPing.texture
                  : _rttPong.texture,
              outTexture = pingPong ? _rttPong : _rttPing;
            i === count - 1 && (outTexture = _this.rtt),
              (_nukeMesh.shader = shader),
              (_nukeMesh.shader.depthTest = !1),
              (_nukeMesh.shader.depthWrite = !1),
              (_nukeMesh.shader.uniforms.tDiffuse.value = inTexture),
              _this.renderer.renderSingle(
                _nukeMesh,
                _this.camera || World.CAMERA,
                outTexture,
                i === count - 1 ? directCallback : null
              ),
              _enabledPasses[i]?.onRenderCallBack?.(),
              (pingPong = !pingPong);
          }
          skipMultisample && (_this.rtt.multisample = !0),
            _this.events.fire(Nuke.BEFORE_POST_RENDER, _this, !0),
            _this.postRender && _this.postRender(),
            _this.events.fire(Nuke.POST_RENDER, _this, !0),
            0 == _this.autoClear && _this.renderer.clearColor(_rttBuffer);
        }),
        (_this.setSize = function (width, height) {
          (width == _width && height == _height) ||
            ((_width = width),
            (_height = height),
            resizeHandler(),
            _this.events.unsub(Events.RESIZE, resizeHandler));
        }),
        (_this.attachDrawBuffer = function (texture) {
          if (
            (_this.hasRendered &&
              console.warn(
                "Attempt to attach draw buffer after first render! Create FXLayer instance before first render."
              ),
            _drawBuffers.push(texture),
            _rttBuffer && _rttBuffer.attachments)
          ) {
            _rttBuffer.attachments = [
              _this.rtt && _this.rtt.attachments
                ? _this.rtt.attachments[0]
                : _rttBuffer.attachments[0],
            ];
            for (let i = 0; i < _drawBuffers.length; i++)
              _rttBuffer.attachments.push(_drawBuffers[i]),
                _this.rtt &&
                  _this.rtt.attachments &&
                  _this.rtt.attachments.push(_drawBuffers[i]);
          }
          return _drawBuffers.length;
        }),
        (_this.upload = function () {
          _this.passes.length &&
            _this.enabled &&
            (_rttPing.upload(), _rttPong.upload(), _rttBuffer.upload()),
            _rttBuffer.depth && _rttBuffer.depth.upload(),
            _this.rtt && _this.rtt.upload();
        }),
        _this.set("dpr", function (v) {
          (_dpr = v), resizeHandler();
        }),
        _this.get("dpr", function () {
          return _dpr;
        }),
        _this.get("output", function () {
          return _nukeMesh.shader && _nukeMesh.shader.uniforms
            ? _nukeMesh.shader.uniforms.tDiffuse.value
            : null;
        }),
        _this.get("rttBuffer", function () {
          return _rttBuffer;
        }),
        this.set("rttBuffer", function (v) {
          _rttBuffer = v;
        }),
        _this.get("prevFrameRT", function () {
          return _rttBuffer && _rttBuffer.texture ? _rttBuffer.texture : null;
        }),
        _this.get("nukeScene", function () {
          return _nukeScene;
        }),
        _this.get("ping", function () {
          return _rttPing;
        }),
        _this.get("pong", function () {
          return _rttPong;
        }),
        _this.get("attachments", function () {
          return _rttBuffer.attachments ? _rttBuffer.attachments.length : 0;
        }),
        (_this.disable = function () {
          (_this.enabled = !1),
            _this.passes.forEach((pass) => {
              pass.enabled = !1;
            });
        }),
        (this.onDestroy = function () {
          _rttBuffer.destroy();
        }),
        (this.clearMemory = function () {
          _rttBuffer.destroy(), _rttPing.destroy(), _rttPong.destroy();
        });
    },
    function () {
      (Nuke.RENDER = "nuke_render"),
        (Nuke.BEFORE_PASSES = "nuke_before_passes"),
        (Nuke.BEFORE_POST_RENDER = "nuke_before_post_render"),
        (Nuke.POST_RENDER = "nuke_post_render");
      var _rts = {};
      (Nuke.getRT = function (
        width,
        height,
        multi,
        index,
        format,
        multisample,
        samplesAmount
      ) {
        let rt,
          exists =
            _rts[
              `${width}_${height}_${multi}_${index}_${format}_${multisample}_${samplesAmount}`
            ];
        return (
          exists ||
          ((rt = multi
            ? Utils3D.createMultiRT(
                width,
                height,
                void 0,
                format,
                multisample,
                samplesAmount
              )
            : Utils3D.createRT(
                width,
                height,
                void 0,
                format,
                multisample,
                samplesAmount
              )),
          Nuke.recyclePingPong &&
            (_rts[
              `${width}_${height}_${multi}_${index}_${format}_${multisample}_${samplesAmount}`
            ] = rt),
          rt)
        );
      }),
        (Nuke.renameRT = function (
          prevWidth,
          prevHeight,
          width,
          height,
          multi,
          index,
          format,
          multisample,
          samplesAmount
        ) {
          _rts[
            `${width}_${height}_${multi}_${index}_${format}_${multisample}_${samplesAmount}`
          ] =
            _rts[
              `${prevWidth}_${prevHeight}_${multi}_${index}_${format}_${multisample}_${samplesAmount}`
            ];
        });
    }
  ),
  Class(function NukePass(_fs, _uniforms, _pass) {
    Inherit(this, Component);
    var _this = this;
    if ("object" == typeof _fs) {
      let shader = _fs.shader;
      (_uniforms = _fs.uniforms), (_fs = shader);
    }
    (this.UILPrefix =
      "string" == typeof _fs ? _fs : Utils.getConstructorName(_fs)),
      (this.init = function (fs, vs) {
        if (_this.pass) return;
        _this = this;
        fs || this.constructor.toString().match(/function ([^\(]+)/)[1],
          Array.isArray(fs) && fs.join("");
        if (
          ((_this.uniforms = _uniforms || _this.uniforms || {}),
          (_this.uniforms.tDiffuse = { type: "t", value: null, ignoreUIL: !0 }),
          _this.uniforms.unique &&
            (_this.UILPrefix += "_" + _this.uniforms.unique + "_"),
          window.UILStorage)
        )
          for (let key in _this.uniforms)
            "unique" !== key &&
              (_this.uniforms[key] =
                UILStorage.parse(
                  _this.UILPrefix + key,
                  _this.uniforms[key].value
                ) || _this.uniforms[key]);
        (_this.pass = _this.initClass(
          Shader,
          vs || "NukePass",
          fs,
          Utils.mergeObject(_this.uniforms, { precision: "high" }),
          (code, type) =>
            "fs" == type
              ? (function prefix(code) {
                  if (!code) throw `No shader ${_fs} found`;
                  let pre = "";
                  return (
                    code.includes("uniform sampler2D tDiffuse") ||
                      ((pre += "uniform sampler2D tDiffuse;\n"),
                      (pre += "varying vec2 vUv;\n")),
                    pre + code
                  );
                })(code)
              : code
        )),
          (_this.uniforms = _this.pass.uniforms);
      }),
      (this.set = function (key, value) {
        TweenManager.clearTween(_this.uniforms[key]),
          (_this.uniforms[key].value = value);
      }),
      (this.get = function (key) {
        return void 0 === _this.uniforms[key]
          ? null
          : _this.uniforms[key].value;
      }),
      (this.tween = function (key, value, time, ease, delay, callback, update) {
        return tween(
          _this.uniforms[key],
          { value: value },
          time,
          ease,
          delay,
          callback,
          update
        );
      }),
      (this.clone = function () {
        return (
          _this.pass || _this.init(_fs),
          new NukePass(null, null, _this.pass.clone())
        );
      }),
      (this.upload = function () {
        _this.pass.upload();
      }),
      (this.addUniforms = function (obj) {
        for (let key in obj) _this.uniforms[key] = obj[key];
      }),
      "string" == typeof _fs
        ? _this.init(_fs)
        : _pass && ((_this.pass = _pass), (_this.uniforms = _pass.uniforms));
  }),
  Class(
    function Raycaster(_camera) {
      Inherit(this, Component);
      const _this = this;
      let _mouse = new Vector3(),
        _raycaster = new RayManager();
      function ascSort(a, b) {
        return a.distance - b.distance;
      }
      function intersectObject(object, raycaster, intersects, recursive) {
        let obj = object;
        for (; obj && _this.testVisibility; ) {
          if (
            !1 === obj.visible &&
            !obj.forceRayVisible &&
            !1 !== obj.testVisibility
          )
            return;
          obj = obj.parent;
        }
        if (
          object.raycast &&
          (object.raycast(raycaster, intersects), !0 === recursive)
        ) {
          let children = object.children;
          for (let i = 0, l = children.length; i < l; i++)
            intersectObject(children[i], raycaster, intersects, !0);
        }
      }
      function intersect(objects) {
        Array.isArray(objects) || (objects = [objects]);
        let intersects = [];
        return (
          objects.forEach((object) => {
            intersectObject(object, _raycaster, intersects, !1);
          }),
          intersects.sort(ascSort),
          intersects
        );
      }
      (this.testVisibility = !0),
        this.set("camera", function (camera) {
          _camera = camera;
        }),
        this.set("pointsThreshold", function (value) {
          _raycaster.params.Points.threshold = value;
        }),
        this.get("ray", () => _raycaster.ray),
        (this.checkHit = function (objects, mouse, rect = Stage) {
          return (
            (mouse = mouse || Mouse),
            (_mouse.x = (mouse.x / rect.width) * 2 - 1),
            (_mouse.y = (-mouse.y / rect.height) * 2 + 1),
            _raycaster.setFromCamera(_mouse, _camera),
            intersect(objects)
          );
        }),
        (this.checkFromValues = function (objects, origin, direction) {
          return (
            _raycaster.set(origin, direction, 0, Number.POSITIVE_INFINITY),
            intersect(objects)
          );
        });
    },
    (_) => {
      var _ray,
        _map = new WeakMap();
      (Raycaster.checkHit = function (objects, mouse) {
        return (
          _ray || (_ray = new Raycaster(World.CAMERA)),
          _ray.checkHit(objects, mouse)
        );
      }),
        (Raycaster.checkFromValues = function (objects, origin, direction) {
          return (
            _ray || (_ray = new Raycaster(World.CAMERA)),
            _ray.checkFromValues(objects, origin, direction)
          );
        }),
        (Raycaster.find = function (camera) {
          if (!_map.has(camera)) {
            let ray = new Raycaster(camera);
            _map.set(camera, ray);
          }
          return _map.get(camera);
        });
    }
  ),
  Class(
    function ScreenProjection(_camera) {
      Inherit(this, Component);
      var _v3 = new Vector3(),
        _v32 = new Vector3(),
        _value = new Vector3();
      (_camera = _camera.camera || _camera),
        this.set("camera", function (v) {
          _camera = v.camera || v;
        }),
        this.get("camera", (_) => _camera),
        (this.unproject = function (mouse, rect = Stage, distance = 1) {
          "number" == typeof rect && ((distance = rect), (rect = Stage)),
            _v3.set(
              (mouse.x / rect.width) * 2 - 1,
              (-mouse.y / rect.height) * 2 + 1,
              0.5
            ),
            _v3.unproject(_camera);
          let pos = _camera.getWorldPosition();
          return (
            _v3.sub(pos).normalize().multiplyScalar(distance),
            _value.copy(pos).add(_v3),
            _value
          );
        }),
        (this.project = function (pos, screen) {
          return (
            (screen = screen || Stage),
            pos instanceof Base3D
              ? (pos.updateMatrixWorld(),
                _v32.set(0, 0, 0).setFromMatrixPosition(pos.matrixWorld))
              : _v32.copy(pos),
            _v32.project(_camera),
            (_v32.x = ((_v32.x + 1) / 2) * screen.width),
            (_v32.y = (-(_v32.y - 1) / 2) * screen.height),
            _v32
          );
        });
    },
    (_) => {
      var _screen,
        _map = new WeakMap();
      (ScreenProjection.unproject = function (mouse, distance) {
        return (
          _screen || (_screen = new ScreenProjection(World.CAMERA)),
          _screen.unproject(mouse, distance)
        );
      }),
        (ScreenProjection.project = function (pos, screen) {
          return (
            _screen || (_screen = new ScreenProjection(World.CAMERA)),
            _screen.project(pos, screen)
          );
        }),
        (ScreenProjection.find = function (camera) {
          if (!_map.has(camera)) {
            let projection = new ScreenProjection(camera);
            _map.set(camera, projection);
          }
          return _map.get(camera);
        });
    }
  ),
  Class(function Object3D() {
    Inherit(this, Component);
    var _this = this,
      _visible = !0;
    (this.__element = !0),
      (this.group = new Group()),
      (this.group.classRef = this),
      (this.add = function (child) {
        this.group.add(child.group || child);
      }),
      (this.remove = function (child) {
        child && this.group.remove(child.group || child);
      }),
      (this.onDestroy = function () {
        (this.group.deleted = !0),
          (this.group.classRef = null),
          this.group &&
            this.group._parent &&
            this.group._parent.remove(this.group);
      }),
      this.set("visible", (v) => (_this.group.visible = _visible = v)),
      this.get("visible", (_) => _visible);
  }),
  Class(function OrbitTargetHelper() {
    Inherit(this, Object3D);
    const _this = this;
    var _velocity = new (function VelocityTracker(_vector) {
      var Vector = "number" == typeof _vector.z ? Vector3 : Vector2,
        _velocity = new Vector(),
        _last = new Vector();
      (this.value = _velocity),
        (this.update = function loop(time, delta) {
          _velocity
            .subVectors(_vector, _last)
            .divideScalar((delta || Render.DELTA) / (1e3 / 60)),
            _last.copy(_vector);
        });
    })(_this.group.position);
    function set() {
      _this.flag("needsReset", !1),
        Playground.instance().orbitControls.target.copy(_this.group.position),
        _this.events.unsub(Mouse.input, Interaction.END, set);
    }
    !(async function () {
      Global.PLAYGROUND &&
        (await defer(),
        Playground.instance().orbitControls.target.copy(_this.group.position),
        _this.startRender((_) => {
          _velocity.update(),
            _velocity.value.length() > 0 &&
              (_this.flag("needsReset", !0),
              _this.events.sub(Mouse.input, Interaction.END, set));
        }));
    })();
  }),
  Class(function Utils3D() {
    const _this = this;
    var _emptyTexture,
      _q,
      _v3,
      _v3b,
      _v3c,
      _m4,
      _v4,
      _supportsKtx1,
      _textures = {},
      _restorable = {},
      _dominantColors = {};
    function getTexture(key, params, loadTexture) {
      if (!Device.graphics.webgl && !window.AURA) {
        let texture = params.isTexture3D ? new Texture3D() : new Texture();
        return (
          (texture.promise = Promise.resolve()),
          (texture.dimensions = params.isTexture3D
            ? { width: 0, height: 0, depth: 0 }
            : { width: 0, height: 0 }),
          texture
        );
      }
      let restorable = _restorable[key];
      if (
        (restorable &&
          ((restorable = restorable.deref()), delete _restorable[key]),
        restorable)
      )
        restorable.restore();
      else if (!_textures[key] || params.forceNewTexture) {
        let texture = params.isTexture3D ? new Texture3D() : new Texture();
        params.isCubeLUT && (texture.isCubeLUT = !0),
          (texture.exists = 1),
          (texture.loaded = !1),
          (texture.promise = Promise.create()),
          (texture._destroy = texture.destroy),
          (texture.destroy = function (force) {
            (!force && (texture.forcePersist || --texture.exists > 0)) ||
              ((texture.exists ||
                texture._image ||
                texture._gl ||
                _textures[key]) &&
                (delete _textures[key],
                delete _dominantColors[key],
                RenderCount.remove(
                  `tex_${texture?.dimensions?.width}_${texture?.dimensions?.height}`
                ),
                RenderCount.remove(
                  "tex_" + (texture.compressed ? "compressed" : "uncompressed")
                ),
                (_restorable[key] = new WeakRef(this)),
                this._destroy()));
          }),
          (_textures[key] = texture),
          !1 === params.premultiplyAlpha && (texture.premultiplyAlpha = !1),
          _this.onTextureCreated && _this.onTextureCreated(texture);
        let doLoadTexture = async () => {
          try {
            await loadTexture(texture),
              (texture.loaded = !0),
              (texture.needsReupload = !0),
              RenderCount.add(
                `tex_${texture.dimensions.width}_${texture.dimensions.height}`
              ),
              RenderCount.add(
                "tex_" + (texture.compressed ? "compressed" : "uncompressed")
              ),
              texture.onload && (texture.onload(), (texture.onload = null)),
              texture.promise.resolve();
          } catch (e) {
            texture.promise.reject(e);
          }
        };
        doLoadTexture(texture),
          (texture.restore = function () {
            delete _restorable[key],
              texture.exists++,
              _textures[key] ||
                ((texture.promise = Promise.create()),
                (texture.loaded = texture.needsReupload = !1),
                (_textures[key] = texture),
                texture.dominantColors &&
                  !_dominantColors[key] &&
                  (_dominantColors[key] = texture.dominantColors),
                doLoadTexture(texture));
          });
      } else _textures[key].exists++;
      return _textures[key];
    }
    function loadTextureSource(texture, path, params) {
      let promise = Promise.create();
      return (
        ImageDecoder.decode(path, params)
          .then((imgBmp) => {
            (imgBmp.crossOrigin = "anonymous"),
              (texture.dimensions = {
                width: imgBmp.width,
                height: imgBmp.height,
              }),
              (texture.loaded = !0),
              (texture.needsReupload = !0),
              texture.compressed &&
                !imgBmp.compressedData &&
                (texture.compressed = !1),
              World.RENDERER.type === Renderer.WEBGL2 ||
                Math.isPowerOf2(imgBmp.width, imgBmp.height) ||
                ((texture.minFilter = Texture.LINEAR),
                (texture.generateMipmaps = !1)),
              promise.resolve(imgBmp);
          })
          .catch((e) => {
            promise.reject(e);
          }),
        promise
      );
    }
    function parseTexturePath(path) {
      if (path.includes("://")) {
        let guard = path.split("://");
        (guard[1] = guard[1].replace(/\/\//g, "/")), (path = guard.join("://"));
      } else path = path.replace(/\/\//g, "/");
      let compressed, compressedIdentifier, cacheBust;
      if (
        (({
          compressed: compressed,
          compressedIdentifier: compressedIdentifier,
          path: path,
        } = parseCompressed(path)),
        window.URLSearchParams)
      ) {
        if (path.includes("?")) {
          let [withoutQuery, query] = path.split("?"),
            params = new URLSearchParams(query);
          for (const [key, value] of params.entries()) {
            let check = key;
            key.includes("-compressedKtx") &&
              (check = key.substring(0, key.indexOf("-compressedKtx"))),
              Number.isInteger(Number(check)) &&
                Number(check) > 0 &&
                "" === value &&
                (params.delete(key),
                check !== key &&
                  compressed &&
                  (withoutQuery += compressedIdentifier),
                (cacheBust = !0));
          }
          cacheBust &&
            ((path = withoutQuery),
            (query = params.toString()),
            query && (path += `?${query}`));
        }
      } else path.includes("?") && ((cacheBust = !0), (path = path.split("?")[0]));
      Hydra.LOCAL || (cacheBust = !1);
      let imgPath = path;
      return (
        cacheBust &&
          (imgPath += (imgPath.includes("?") ? "&" : "?") + Date.now()),
        compressed &&
          !imgPath.includes("compressed") &&
          (imgPath += compressedIdentifier),
        { plainPath: path, imgPath: imgPath, compressed: compressed }
      );
    }
    function parseCompressed(path) {
      let compressedIdentifier = /-compressedKtx2?/.exec(path)?.[0],
        compressed = !1;
      compressedIdentifier &&
        (Utils.query("noKtx") ||
          (compressedIdentifier.endsWith("2")
            ? "undefined" != typeof Ktx2Transcoder && (compressed = "ktx2")
            : (compressed = "ktx1")),
        (path = path.replace(compressedIdentifier, "")));
      let requiresKtx = !1;
      return (
        /\.ktx2(?:\?|#|$)/.test(path) &&
          ((compressed = "ktx2"),
          (compressedIdentifier = ""),
          (requiresKtx = !0)),
        {
          compressed: compressed,
          compressedIdentifier: compressedIdentifier,
          path: path,
          requiresKtx: requiresKtx,
        }
      );
    }
    function splitCubemapPath(url) {
      let path = url.replace(/-compressedKtx2?/, "").split(/[#?]/)[0],
        match = /(\d+)(?!.*\d+)/.exec(path);
      if (!match)
        throw new Error("Cubemap texture path must include a numeric pattern");
      let prefix = url.substring(0, match.index),
        pattern = match[1];
      return {
        prefix: prefix,
        pattern: pattern,
        suffix: url.substring(match.index + pattern.length),
        start: +pattern,
      };
    }
    function getCubemapFacePaths(pathinfo) {
      let padChar,
        {
          prefix: prefix,
          pattern: pattern,
          suffix: suffix,
          start: start,
        } = pathinfo;
      return (
        pattern.length > String(start).length && (padChar = pattern.charAt(0)),
        Array.from(Array(6).keys(), (i) => {
          let n = String(start + i);
          return (
            padChar && (n = n.padStart(pattern.length, padChar)),
            `${prefix}${n}${suffix}`
          );
        })
      );
    }
    async function doFindDominantColors(texOrImageOrPath, numColors) {
      let image;
      if (texOrImageOrPath.isTexture)
        if (texOrImageOrPath.image) {
          if (
            texOrImageOrPath.image.compressedData &&
            0 === texOrImageOrPath.image.compressedData.length
          ) {
            let { path: path, ...params } = texOrImageOrPath.decodeParams;
            (params.hintUsingPixelData = !0),
              (image = await ImageDecoder.decode(path, params));
          }
        } else image = texOrImageOrPath.src;
      return (
        (image = image || texOrImageOrPath.image || texOrImageOrPath),
        "string" == typeof image && (image = await Assets.decodeImage(image)),
        ImageDecoder.parseColors(image, numColors)
      );
    }
    (window.Vec2 = window.Vector2),
      (window.Vec3 = window.Vector3),
      (this.localDebug = window.Hydra && Hydra.LOCAL),
      (async function () {
        await Hydra.ready();
        let threads = Thread.shared(!0);
        for (let i = 0; i < threads.array.length; i++)
          _this.loadEngineOnThread(threads.array[i]);
      })(),
      (this.decompose = function (local, world) {
        local.decomposeCache ||
          (local.decomposeCache = {
            position: new Vector3(),
            quaternion: new Quaternion(),
            scale: new Vector3(),
          }),
          local.decomposeDirty &&
            (local.matrixWorld.decompose(
              local.decomposeCache.position,
              local.decomposeCache.quaternion,
              local.decomposeCache.scale
            ),
            (local.decomposeDirty = !1)),
          world.position.copy(local.decomposeCache.position),
          world.quaternion.copy(local.decomposeCache.quaternion),
          world.scale.copy(local.decomposeCache.scale);
      }),
      (this.createDebug = function (size = 1, color) {
        return new Mesh(
          new IcosahedronGeometry(size, 1),
          _this.getTestShader(color)
        );
      }),
      (this.getTestShader = function (color) {
        return color
          ? new Shader("ColorMaterial", {
              color: {
                value: color instanceof Color ? color : new Color(color),
              },
              alpha: { value: 1 },
            })
          : new Shader("TestMaterial");
      }),
      (this.createMultiRT = function (
        width,
        height,
        type,
        format,
        multisample = !1,
        samplesAmount = 4
      ) {
        let rt = new MultiRenderTarget(width, height, {
          minFilter: Texture.LINEAR,
          magFilter: Texture.LINEAR,
          format: format || Texture.RGBFormat,
          type: type,
          multisample: multisample,
          samplesAmount: samplesAmount,
        });
        return (rt.texture.generateMipmaps = !1), rt;
      }),
      (this.createRT = function (
        width,
        height,
        type,
        format,
        multisample = !1,
        samplesAmount = 4
      ) {
        let rt = new RenderTarget(width, height, {
          minFilter: Texture.LINEAR,
          magFilter: Texture.LINEAR,
          format: format || Texture.RGBFormat,
          type: type,
          multisample: multisample,
          samplesAmount: samplesAmount,
        });
        return (rt.texture.generateMipmaps = !1), rt;
      }),
      (this.getFloatType = function () {
        return "android" == Device.system.os
          ? Texture.FLOAT
          : Texture.HALF_FLOAT;
      }),
      (this.findNuke = function (obj) {
        if (!obj) return;
        let p = obj.parent;
        for (; p; ) {
          if (p.nuke) return p.nuke;
          p = p.parent;
        }
        for (p = obj.parent; p; ) {
          if (p.nuke) return p.nuke;
          p = p.group ? p.group._parent : p.parent || p._parent;
        }
        for (p = obj._parent; p; ) {
          if (p.nuke) return p.nuke;
          p = p._parent;
        }
        return World.NUKE;
      }),
      (this.getTexture = function (path, params = {}) {
        let {
            imgPath: imgPath,
            plainPath: plainPath,
            compressed: compressed,
          } = parseTexturePath(path),
          texture = getTexture(plainPath, params, async (texture) => {
            (texture.compressed = compressed),
              (texture.format = plainPath.match(/\.jpe?g/)
                ? Texture.RGBFormat
                : Texture.RGBAFormat),
              (texture.src = plainPath),
              (texture.decodeParams = { path: imgPath, ...params });
            let imgBmp = await loadTextureSource(texture, imgPath, params);
            (texture.image = imgBmp),
              imgBmp.sizes &&
                1 === imgBmp.sizes.length &&
                (texture.minFilter = Texture.LINEAR),
              (texture.onUpdate = function () {
                !params.preserveData &&
                  imgBmp.close &&
                  (imgBmp.close(), (texture.image = null)),
                  (texture.onUpdate = null);
              });
          });
        return (
          texture.promise.then((_) => {
            params.findDominantColors &&
              "number" === (params.findDominantColors, !1) &&
              (params.findDominantColors = 4),
              params.findDominantColors &&
                _this.findDominantColors(texture, params.findDominantColors);
          }),
          texture
        );
      }),
      (this.getCubeLUT = function (path, params) {
        let { imgPath: imgPath, plainPath: plainPath } = parseTexturePath(path);
        return (
          (params = { ...params, isTexture3D: !0, isCubeLUT: !0 }),
          getTexture(plainPath, params, async (texture) => {
            let { imgBmp: imgBmp, cubesize: cubesize } =
              await (function loadCubeLUTSource(path, params) {
                let promise = Promise.create(),
                  {
                    compressed: compressed,
                    compressedIdentifier: compressedIdentifier,
                    newpath: newpath,
                    requiresKtx: requiresKtx,
                  } = parseCompressed(path);
                return (
                  compressed
                    ? ImageDecoder.decode(path, params)
                        .then((result) => {
                          promise.resolve({
                            imgBmp: result.compressedData[0],
                            cubesize: result.width,
                          });
                        })
                        .catch((e) => {
                          promise.reject(e);
                        })
                    : ImageDecoder.decodeCubeLUT(path, params).then(
                        (result) => {
                          promise.resolve({
                            imgBmp: result.imgBmp,
                            cubesize: result.cubesize,
                          });
                        }
                      ),
                  promise
                );
              })(imgPath, params);
            (texture.format = Texture.RGBAFormat),
              (texture.image = imgBmp),
              (texture.src = plainPath),
              (texture.minFilter = texture.magFilter = Texture.LINEAR),
              (texture.type = Texture.UNSIGNED_BYTE),
              (texture.width = texture.height = texture.depth = cubesize),
              (texture.dimensions = {
                width: cubesize,
                height: cubesize,
                depth: cubesize,
              }),
              (texture.generateMipmaps = !1),
              (texture.onUpdate = function () {
                !params.preserveData &&
                  imgBmp.close &&
                  (imgBmp.close(), (texture.image = null)),
                  (texture.onUpdate = null);
              });
          })
        );
      }),
      (this.getCubeTexture = function (paths, params = {}) {
        let parsed = (paths = (function getCubePaths(url) {
          if (Array.isArray(url)) return url;
          let {
            compressed: compressed,
            compressedIdentifier: compressedIdentifier,
            path: path,
            requiresKtx: requiresKtx,
          } = parseCompressed(url);
          if (requiresKtx) return [path];
          "ktx1" === compressed &&
            (void 0 === _supportsKtx1 &&
              (_supportsKtx1 = !!(
                Renderer.extensions.s3tc ||
                Renderer.extensions.etc1 ||
                Renderer.extensions.pvrtc ||
                Renderer.extensions.astc
              )),
            _supportsKtx1 || (compressed = !1));
          !compressed &&
            compressedIdentifier &&
            (url = url.replace(compressedIdentifier, ""));
          let info = splitCubemapPath(url);
          if (compressed) return [`${info.prefix}${info.suffix}`];
          return getCubemapFacePaths(info);
        })(paths)).map(parseTexturePath);
        return getTexture(
          `cube:${parsed
            .map(({ plainPath: plainPath }) => plainPath)
            .join("|")}`,
          params,
          async (texture) => {
            (texture.cube = await Promise.all(
              parsed.map(
                ({ imgPath: imgPath, compressed: compressed }) => (
                  (texture.compressed = compressed),
                  (texture.format = imgPath.match(/\.jpe?g/)
                    ? Texture.RGBFormat
                    : Texture.RGBAFormat),
                  loadTextureSource(texture, imgPath, params)
                )
              )
            )),
              texture.compressed ||
                1 !== texture.cube.length ||
                (texture.cube = [...Array(6).keys()].map(
                  (_) => texture.cube[0]
                )),
              texture.compressed &&
                1 === texture.cube[0].sizes.length &&
                (texture.minFilter = Texture.LINEAR),
              (texture.onUpdate = function () {
                params.preserveData ||
                  texture.cube.forEach((imgBmp, i) => {
                    imgBmp.close && (imgBmp.close(), (texture.cube[i] = null));
                  }),
                  (texture.onUpdate = null);
              });
          }
        );
      }),
      (this.splitCubemapPath = splitCubemapPath),
      (this.getCubemapFacePaths = getCubemapFacePaths),
      (this.getLookupTexture = function (path) {
        let texture = _this.getTexture(path);
        return (
          (texture.minFilter = texture.magFilter = Texture.NEAREST),
          (texture.generateMipmaps = !1),
          texture
        );
      }),
      (this.clearTextureCache = function (path, force) {
        if (path) {
          let key = parseTexturePath(path).plainPath,
            cached = _textures[key];
          cached
            ? (cached.destroy(force),
              delete _textures[key],
              delete _restorable[key])
            : _restorable[key] && delete _restorable[key],
            delete _dominantColors[key];
        } else {
          for (let key in _textures) _textures[key].destroy(force);
          (_textures = {}), (_dominantColors = {});
        }
      }),
      (this.makeDataTexturePowerOf2 = function (texture, itemSize) {
        let [maxDimension, minDimension] = [
          texture.width,
          texture.height,
        ].sort();
        maxDimension = Math.ceilPowerOf2(maxDimension);
        const totalLength = maxDimension * maxDimension * itemSize,
          remainder = [];
        let j;
        for (let i = 0; i < totalLength - texture.data.length; i++)
          (j = i % texture.data.length), remainder.push(texture.data[j]);
        const totalData = new Float32Array(totalLength);
        totalData.set(texture.data),
          totalData.set(remainder, texture.data.length),
          (texture.data = totalData),
          (texture.width = texture.height = maxDimension),
          (texture.powerOfTwoScale = minDimension / maxDimension);
      }),
      (this.loadCurve = function (obj) {
        "string" == typeof obj &&
          ((obj = Assets.JSON[obj]).curves = obj.curves[0]);
        let data = obj.curves,
          points = [];
        for (let j = 0; j < data.length; j += 3)
          points.push(new Vector3(data[j + 0], data[j + 1], data[j + 2]));
        if ("undefined" == typeof CatmullRomCurve)
          throw "loadCurve requires curve3d module";
        return new CatmullRomCurve(points);
      }),
      (this.getEmptyTexture = function () {
        return _emptyTexture || (_emptyTexture = new Texture()), _emptyTexture;
      }),
      (this.getRepeatTexture = function (src, scale) {
        let texture = _this.getTexture(src, scale);
        return (
          texture.promise.then((_) => {
            Math.isPowerOf2(
              texture.dimensions.width,
              texture.dimensions.height
            ) || console.warn(`getRepeatTexture :: ${src} not power of two!`);
          }),
          (texture.wrapS = texture.wrapT = Texture.REPEAT),
          texture
        );
      }),
      (this.findTexturesByPath = function (path) {
        let array = [];
        for (let key in _textures)
          key.includes(path) && array.push(_textures[key]);
        return array;
      }),
      (this.getHeightFromCamera = function (camera, dist) {
        (camera = camera.camera || camera),
          dist || (dist = camera.position.length());
        let fov = camera.fov;
        return 2 * dist * Math.tan(0.5 * Math.radians(fov));
      }),
      (this.getWidthFromCamera = function (camera, dist) {
        camera = camera.camera || camera;
        return _this.getHeightFromCamera(camera, dist) * camera.aspect;
      }),
      (this.getPositionFromCameraSize = function (camera, size) {
        camera = camera.camera || camera;
        let fov = Math.radians(camera.fov);
        return Math.abs(size / Math.sin(fov / 2));
      }),
      (this.loadEngineOnThread = function (thread) {
        [
          "Base3D",
          "CameraBase3D",
          "Mesh",
          "OrthographicCamera",
          "PerspectiveCamera",
          "Geometry",
          "GeometryAttribute",
          "Points",
          "Scene",
          "BoxGeometry",
          "CylinderGeometry",
          "PlaneGeometry",
          "PolyhedronGeometry",
          "IcosahedronGeometry",
          "SphereGeometry",
          "Box2",
          "Box3",
          "Face3",
          "Color",
          "ColorLAB",
          "ColorHSL",
          "Cylindrical",
          "Euler",
          "Frustum",
          "Line3",
          "Matrix3",
          "Matrix4",
          "Plane",
          "Quaternion",
          "Ray",
          "Sphere",
          "Spherical",
          "Triangle",
          "Vector2",
          "Vector3",
          "Vector4",
          "RayManager",
          "Vector3D",
          "Group",
        ].forEach((name) => {
          thread.importES6Class(name);
        }),
          thread.importCode(
            `Class(${zUtils3D.constructor.toString()}, 'static')`
          );
      }),
      (this.billboard = function (mesh, camera = World.CAMERA) {
        _q || (_q = new Quaternion()),
          _q.copy(camera.quaternion),
          mesh.customRotation && mesh.quaternion.multiply(mesh.customRotation),
          mesh._parent &&
            _q.premultiply(mesh._parent.getWorldQuaternion().inverse()),
          mesh.quaternion.copy(_q);
      }),
      (this.billboardYAxis = function (mesh, camera = World.CAMERA) {
        _q || (_q = new Quaternion()), _q.copy(camera.quaternion);
        let angle = Math.atan2(_q.y, _q.w) + Math.PI;
        (angle = -angle),
          _q.set(0, Math.sin(angle), 0, Math.cos(angle)),
          mesh.customRotation && mesh.quaternion.multiply(mesh.customRotation),
          mesh._parent &&
            _q.premultiply(mesh._parent.getWorldQuaternion().inverse()),
          mesh.quaternion.copy(_q);
      }),
      (this.positionInFrontOfCamera = function (
        object,
        distance,
        alpha = 1,
        camera = World.CAMERA
      ) {
        _v3 || (_v3 = new Vector3()),
          _v3b || (_v3b = new Vector3()),
          _m4 || (_m4 = new Matrix4()),
          _q || (_q = new Quaternion());
        let cameraPosition = _v3b,
          cameraQuaternion = _q;
        camera.updateMatrixWorld(),
          camera.matrixWorld.decompose(cameraPosition, cameraQuaternion, _v3),
          _v3
            .set(0, 0, -distance)
            .applyQuaternion(cameraQuaternion)
            .add(cameraPosition),
          _m4.lookAt(cameraPosition, _v3, object.up),
          _q.setFromRotationMatrix(_m4),
          object.position.lerp(_v3, alpha),
          object.quaternion.slerp(_q, alpha);
      }),
      (this.getSignedQuaternionAngleToPlane = function (
        quaternion,
        direction,
        planeNormal,
        axis
      ) {
        _v3c || (_v3c = new Vector3());
        let vector = _v3c.copy(direction).applyQuaternion(quaternion);
        return _this.getSignedAngleToPlane(vector, planeNormal, axis);
      }),
      (this.getSignedAngleToPlane = function (vector, planeNormal, axis) {
        _v3 || (_v3 = new Vector3()), _v3b || (_v3b = new Vector3());
        let projected = _v3
          .copy(vector)
          .projectOnPlane(planeNormal)
          .normalize();
        if (0 === projected.length()) return Math.PI / 2;
        axis
          ? (vector = _v3b.copy(vector).projectOnPlane(axis).normalize())
          : (axis = _v3b.crossVectors(projected, planeNormal));
        let dot = vector.dot(projected),
          det = axis.dot(projected.cross(vector));
        return Math.atan2(det, dot);
      }),
      (this.getQuad = function () {
        let geom = new Geometry(),
          position = new Float32Array([-1, -1, 0, 3, -1, 0, -1, 3, 0]),
          uv = new Float32Array([0, 0, 2, 0, 0, 2]);
        return (
          geom.addAttribute("position", new GeometryAttribute(position, 3)),
          geom.addAttribute("uv", new GeometryAttribute(uv, 2)),
          geom
        );
      }),
      (this.findParentCamera = function (group) {
        let parent = group.parent;
        for (; parent; ) {
          if (parent.nuke) return parent.nuke.camera;
          parent = parent.parent;
        }
        return World.CAMERA;
      }),
      (this.cameraIntrinsicsToObject = function (camera, object) {
        (object.fov = camera.fov),
          (object.aspect = camera.aspect),
          (object.near = camera.near),
          (object.far = camera.far),
          object.p ||
            ((object.p = []), (object.q = []), (object.projectionMatrix = [])),
          camera.getWorldPosition().toArray(object.p),
          camera.getWorldQuaternion().toArray(object.q),
          camera.projectionMatrix.toArray(object.projectionMatrix),
          (object.width = Stage.width),
          (object.height = Stage.height);
      }),
      (this.createFXLayer = function (name, nuke = World.NUKE, options) {
        let layer = new FXLayer(nuke, options);
        return (layer.name = name), layer;
      }),
      (this.ensureAttributes = function (mesh) {
        const vs = Shaders.getShader(`${mesh.shader.vsName}.vs`),
          attrib_regex = /attribute (\w+) (\w+);/g,
          attribs = mesh.geometry.attributes,
          firstCount = attribs[Object.keys(attribs)[0]].count;
        let attrib;
        for (; null !== (attrib = attrib_regex.exec(vs)); ) {
          const name = attrib[2];
          if (name && !attribs[name]) {
            const size = parseInt(attrib[1][attrib[1].length - 1]) || 1;
            mesh.geometry.addAttribute(
              name,
              new GeometryAttribute(new Float32Array(size * firstCount), size)
            ),
              (mesh.geometry.needsUpdate = !0);
          }
        }
      }),
      (this.findDominantColors = function (texOrImageOrPath, numColors = 4) {
        let path;
        if (
          ((path =
            "string" == typeof texOrImageOrPath
              ? texOrImageOrPath
              : texOrImageOrPath.src ||
                texOrImageOrPath.path ||
                texOrImageOrPath.image?.src ||
                texOrImageOrPath.image?.path),
          !path)
        )
          throw new Error("Couldn’t find image asset path");
        let { plainPath: plainPath } = parseTexturePath(path),
          colors = _dominantColors[plainPath];
        if (colors)
          if (colors.promise) {
            if (colors.numColors >= numColors) return colors.promise;
          } else if (colors.length >= numColors) return colors;
        return (
          (colors = {
            promise: doFindDominantColors(texOrImageOrPath, numColors),
            numColors: numColors,
          }),
          (_dominantColors[plainPath] = colors),
          (async () => {
            try {
              let result = await colors.promise;
              _dominantColors[plainPath] === colors &&
                ((_dominantColors[plainPath] = result),
                texOrImageOrPath.isTexture &&
                  (texOrImageOrPath.dominantColors = result),
                _textures[plainPath] &&
                  (_textures[plainPath].dominantColors = result));
            } catch (e) {
              _dominantColors[plainPath] === colors &&
                delete _dominantColors[plainPath];
            }
          })(),
          colors.promise
        );
      }),
      (this.renderToTexture3D = function (texture, shader) {
        if (void 0 === texture._renderTargets) {
          let depth = texture.depth / 4;
          texture._renderTargets = [];
          let offset = 0;
          for (let i = 0; i < depth; i++) {
            offset = 4 * i;
            let renderTarget = new RenderTarget(texture.width, texture.height);
            (renderTarget.texture = texture),
              (renderTarget.indices = [
                offset,
                offset + 1,
                offset + 2,
                offset + 3,
              ]),
              texture._renderTargets.push(renderTarget);
          }
          let mesh = new Mesh(World.QUAD, shader);
          texture._meshFor3D = mesh;
        }
        try {
          _v4 || (_v4 = new Vector4()),
            texture._renderTargets.forEach((rt) => {
              shader.set("indices", _v4.set(...rt.indices)),
                World.RENDERER.renderSingle(
                  texture._meshFor3D,
                  World.CAMERA,
                  rt
                );
            });
        } catch (e) {
          console.warn(
            "the 3d texture can not be updated correctly, the shader requires the indices uniform to be declared"
          );
        }
      }),
      (this.cloneTransform = function (object, target = new Base3D()) {
        if (!target || !target.position || !target.position.copy)
          throw new Error("Target of cloneTransform must be a Base3D.");
        let group = object.group || object;
        return (
          target.position.copy(group.position),
          target.scale.copy(group.scale),
          target.quaternion.copy(group.quaternion),
          target
        );
      }),
      (this.cloneUniforms = function (object, target = {}) {
        let shader = object.shader || object,
          uniforms = shader.uniforms || shader;
        if (uniforms && !uniforms.group) {
          let origin = {};
          for (let key in uniforms) {
            let value = uniforms[key].value,
              ignoreUIL = uniforms[key].ignoreUIL || null === value;
            !ignoreUIL && value.clone && (value = value.clone()),
              (origin[key] = {
                type: uniforms[key].type,
                value: value,
                ignoreUIL: ignoreUIL,
              });
          }
          return Object.assign(target.shader || target, origin);
        }
      });
  }, "static"),
  window.WebGLRenderingContext &&
    (function () {
      "use strict";
      var e = {};
      function r(r, t) {
        var i;
        (e[r] = !0),
          void 0 !== t &&
            ((i = t),
            window.console && window.console.error && window.console.error(i));
      }
      var t = function e(r) {
        var t = r.gl;
        (this.ext = r),
          (this.isAlive = !0),
          (this.hasBeenBound = !1),
          (this.elementArrayBuffer = null),
          (this.attribs = new Array(r.maxVertexAttribs));
        for (var i = 0; i < this.attribs.length; i++) {
          var a = new e.VertexAttrib(t);
          this.attribs[i] = a;
        }
        this.maxAttrib = 0;
      };
      (t.VertexAttrib = function (e) {
        (this.enabled = !1),
          (this.buffer = null),
          (this.size = 4),
          (this.type = e.FLOAT),
          (this.normalized = !1),
          (this.stride = 16),
          (this.offset = 0),
          (this.cached = ""),
          this.recache();
      }).prototype.recache = function () {
        this.cached = [
          this.size,
          this.type,
          this.normalized,
          this.stride,
          this.offset,
        ].join(":");
      };
      var i = function (r) {
        var t,
          i,
          a = this;
        (this.gl = r),
          (i = (t = r).getError),
          (t.getError = function () {
            do {
              (r = i.apply(t)) != t.NO_ERROR && (e[r] = !0);
            } while (r != t.NO_ERROR);
            for (var r in e) if (e[r]) return delete e[r], parseInt(r);
            return t.NO_ERROR;
          });
        var n = (this.original = {
          getParameter: r.getParameter,
          enableVertexAttribArray: r.enableVertexAttribArray,
          disableVertexAttribArray: r.disableVertexAttribArray,
          bindBuffer: r.bindBuffer,
          getVertexAttrib: r.getVertexAttrib,
          vertexAttribPointer: r.vertexAttribPointer,
        });
        (r.getParameter = function (e) {
          return e == a.VERTEX_ARRAY_BINDING_OES
            ? a.currentVertexArrayObject == a.defaultVertexArrayObject
              ? null
              : a.currentVertexArrayObject
            : n.getParameter.apply(this, arguments);
        }),
          (r.enableVertexAttribArray = function (e) {
            var r = a.currentVertexArrayObject;
            return (
              (r.maxAttrib = Math.max(r.maxAttrib, e)),
              (r.attribs[e].enabled = !0),
              n.enableVertexAttribArray.apply(this, arguments)
            );
          }),
          (r.disableVertexAttribArray = function (e) {
            var r = a.currentVertexArrayObject;
            return (
              (r.maxAttrib = Math.max(r.maxAttrib, e)),
              (r.attribs[e].enabled = !1),
              n.disableVertexAttribArray.apply(this, arguments)
            );
          }),
          (r.bindBuffer = function (e, t) {
            switch (e) {
              case r.ARRAY_BUFFER:
                a.currentArrayBuffer = t;
                break;
              case r.ELEMENT_ARRAY_BUFFER:
                a.currentVertexArrayObject.elementArrayBuffer = t;
            }
            return n.bindBuffer.apply(this, arguments);
          }),
          (r.getVertexAttrib = function (e, t) {
            var i = a.currentVertexArrayObject.attribs[e];
            switch (t) {
              case r.VERTEX_ATTRIB_ARRAY_BUFFER_BINDING:
                return i.buffer;
              case r.VERTEX_ATTRIB_ARRAY_ENABLED:
                return i.enabled;
              case r.VERTEX_ATTRIB_ARRAY_SIZE:
                return i.size;
              case r.VERTEX_ATTRIB_ARRAY_STRIDE:
                return i.stride;
              case r.VERTEX_ATTRIB_ARRAY_TYPE:
                return i.type;
              case r.VERTEX_ATTRIB_ARRAY_NORMALIZED:
                return i.normalized;
              default:
                return n.getVertexAttrib.apply(this, arguments);
            }
          }),
          (r.vertexAttribPointer = function (e, r, t, i, s, A) {
            var o = a.currentVertexArrayObject;
            o.maxAttrib = Math.max(o.maxAttrib, e);
            var c = o.attribs[e];
            return (
              (c.buffer = a.currentArrayBuffer),
              (c.size = r),
              (c.type = t),
              (c.normalized = i),
              (c.stride = s),
              (c.offset = A),
              c.recache(),
              n.vertexAttribPointer.apply(this, arguments)
            );
          }),
          r.instrumentExtension &&
            r.instrumentExtension(this, "OES_vertex_array_object"),
          r.canvas.addEventListener(
            "webglcontextrestored",
            function () {
              window.console &&
                window.console.log &&
                window.console.log(
                  "OESVertexArrayObject emulation library context restored"
                ),
                a.reset_();
            },
            !0
          ),
          this.reset_();
      };
      (i.prototype.VERTEX_ARRAY_BINDING_OES = 34229),
        (i.prototype.reset_ = function () {
          if (void 0 !== this.vertexArrayObjects)
            for (var e = 0; e < this.vertexArrayObjects.length; ++e)
              this.vertexArrayObjects.isAlive = !1;
          var r = this.gl;
          (this.maxVertexAttribs = r.getParameter(r.MAX_VERTEX_ATTRIBS)),
            (this.defaultVertexArrayObject = new t(this)),
            (this.currentVertexArrayObject = null),
            (this.currentArrayBuffer = null),
            (this.vertexArrayObjects = [this.defaultVertexArrayObject]),
            this.bindVertexArrayOES(null);
        }),
        (i.prototype.createVertexArrayOES = function () {
          var e = new t(this);
          return this.vertexArrayObjects.push(e), e;
        }),
        (i.prototype.deleteVertexArrayOES = function (e) {
          (e.isAlive = !1),
            this.vertexArrayObjects.splice(
              this.vertexArrayObjects.indexOf(e),
              1
            ),
            this.currentVertexArrayObject == e && this.bindVertexArrayOES(null);
        }),
        (i.prototype.isVertexArrayOES = function (e) {
          return !!(e && e instanceof t && e.hasBeenBound && e.ext == this);
        }),
        (i.prototype.bindVertexArrayOES = function (e) {
          var t = this.gl;
          if (!e || e.isAlive) {
            var i = this.original,
              a = this.currentVertexArrayObject;
            (this.currentVertexArrayObject =
              e || this.defaultVertexArrayObject),
              (this.currentVertexArrayObject.hasBeenBound = !0);
            var n = this.currentVertexArrayObject;
            if (a != n) {
              (a && n.elementArrayBuffer == a.elementArrayBuffer) ||
                i.bindBuffer.call(
                  t,
                  t.ELEMENT_ARRAY_BUFFER,
                  n.elementArrayBuffer
                );
              for (
                var s = this.currentArrayBuffer,
                  A = Math.max(a ? a.maxAttrib : 0, n.maxAttrib),
                  o = 0;
                o <= A;
                o++
              ) {
                var c = n.attribs[o],
                  b = a ? a.attribs[o] : null;
                if (
                  ((a && c.enabled == b.enabled) ||
                    (c.enabled
                      ? i.enableVertexAttribArray.call(t, o)
                      : i.disableVertexAttribArray.call(t, o)),
                  c.enabled)
                ) {
                  var u = !1;
                  (a && c.buffer == b.buffer) ||
                    (s != c.buffer &&
                      (i.bindBuffer.call(t, t.ARRAY_BUFFER, c.buffer),
                      (s = c.buffer)),
                    (u = !0)),
                    (u || c.cached != b.cached) &&
                      i.vertexAttribPointer.call(
                        t,
                        o,
                        c.size,
                        c.type,
                        c.normalized,
                        c.stride,
                        c.offset
                      );
                }
              }
              this.currentArrayBuffer != s &&
                i.bindBuffer.call(t, t.ARRAY_BUFFER, this.currentArrayBuffer);
            }
          } else
            r(
              t.INVALID_OPERATION,
              "bindVertexArrayOES: attempt to bind deleted arrayObject"
            );
        }),
        (function () {
          var e = WebGLRenderingContext.prototype.getSupportedExtensions;
          WebGLRenderingContext.prototype.getSupportedExtensions = function () {
            var r = e.call(this) || [];
            return (
              r.indexOf("OES_vertex_array_object") < 0 &&
                r.push("OES_vertex_array_object"),
              r
            );
          };
          var r = WebGLRenderingContext.prototype.getExtension;
          WebGLRenderingContext.prototype.getExtension = function (e) {
            return (
              r.call(this, e) ||
              ("OES_vertex_array_object" !== e
                ? null
                : (this.__OESVertexArrayObject ||
                    (console.log("Setup OES_vertex_array_object polyfill"),
                    (this.__OESVertexArrayObject = new i(this))),
                  this.__OESVertexArrayObject))
            );
          };
        })();
    })(),
  Class(function DracoThread() {
    let decoderConfig, decoderPending;
    function onError(opts) {
      opts.message.preloading && console.warn(opts.er);
      let plane = new PlaneGeometry(1, 1).toNonIndexed(),
        buff = [],
        data = {};
      for (let key in plane.attributes)
        (data[key] = plane.attributes[key].array), buff.push(data[key].buffer);
      computeBounding(data), opts?.resolve(data, opts.id, buff);
    }
    function decodeGeometry(draco, decoder, decoderBuffer, taskConfig) {
      const attributeIDs = taskConfig.attributeIDs,
        attributeTypes = taskConfig.attributeTypes;
      let dracoGeometry, decodingStatus;
      const geometryType = decoder.GetEncodedGeometryType(decoderBuffer);
      if (geometryType === draco.TRIANGULAR_MESH)
        (dracoGeometry = new draco.Mesh()),
          (decodingStatus = decoder.DecodeBufferToMesh(
            decoderBuffer,
            dracoGeometry
          ));
      else {
        if (geometryType !== draco.POINT_CLOUD)
          throw new Error("DRACOLoader: Unexpected geometry type.");
        (dracoGeometry = new draco.PointCloud()),
          (decodingStatus = decoder.DecodeBufferToPointCloud(
            decoderBuffer,
            dracoGeometry
          ));
      }
      if (!decodingStatus.ok() || 0 === dracoGeometry.ptr)
        throw new Error(
          "DRACOLoader: Decoding failed: " + decodingStatus.error_msg()
        );
      const geometry = { index: null, attributes: [] };
      for (const attributeName in attributeIDs) {
        const attributeType = attributeTypes[attributeName];
        let attribute, attributeID;
        if (taskConfig.useUniqueIDs)
          (attributeID = attributeIDs[attributeName]),
            (attribute = decoder.GetAttributeByUniqueId(
              dracoGeometry,
              attributeID
            ));
        else {
          if (
            ((attributeID = decoder.GetAttributeId(
              dracoGeometry,
              draco[attributeIDs[attributeName]]
            )),
            -1 === attributeID)
          )
            continue;
          attribute = decoder.GetAttribute(dracoGeometry, attributeID);
        }
        geometry.attributes.push(
          decodeAttribute(
            draco,
            decoder,
            dracoGeometry,
            attributeName,
            attributeType,
            attribute
          )
        );
      }
      return (
        geometryType === draco.TRIANGULAR_MESH &&
          (geometry.index = decodeIndex(draco, decoder, dracoGeometry)),
        draco.destroy(dracoGeometry),
        geometry
      );
    }
    function decodeIndex(draco, decoder, dracoGeometry) {
      const numIndices = 3 * dracoGeometry.num_faces(),
        byteLength = 4 * numIndices,
        ptr = draco._malloc(byteLength);
      decoder.GetTrianglesUInt32Array(dracoGeometry, byteLength, ptr);
      const index = new Uint32Array(
        draco.HEAPF32.buffer,
        ptr,
        numIndices
      ).slice();
      return draco._free(ptr), { array: index, itemSize: 1 };
    }
    function decodeAttribute(
      draco,
      decoder,
      dracoGeometry,
      attributeName,
      attributeType,
      attribute
    ) {
      const numComponents = attribute.num_components(),
        numValues = dracoGeometry.num_points() * numComponents,
        byteLength = numValues * attributeType.BYTES_PER_ELEMENT,
        dataType = getDracoDataType(draco, attributeType),
        ptr = draco._malloc(byteLength);
      decoder.GetAttributeDataArrayForAllPoints(
        dracoGeometry,
        attribute,
        dataType,
        byteLength,
        ptr
      );
      const array = new attributeType(
        draco.HEAPF32.buffer,
        ptr,
        numValues
      ).slice();
      return (
        draco._free(ptr),
        { name: attributeName, array: array, itemSize: numComponents }
      );
    }
    function getDracoDataType(draco, attributeType) {
      switch (attributeType) {
        case Float32Array:
          return draco.DT_FLOAT32;
        case Int8Array:
          return draco.DT_INT8;
        case Int16Array:
          return draco.DT_INT16;
        case Int32Array:
          return draco.DT_INT32;
        case Uint8Array:
          return draco.DT_UINT8;
        case Uint16Array:
          return draco.DT_UINT16;
        case Uint32Array:
          return draco.DT_UINT32;
      }
    }
    (this.loadDraco = function (e, id) {
      const message = e;
      switch (message.type) {
        case "init":
          (decoderConfig = message.decoderConfig),
            (decoderPending = new Promise(function (pendingResolve) {
              (decoderConfig.onModuleLoaded = function (draco) {
                pendingResolve({ draco: draco }), resolve({}, id);
              }),
                DracoDecoderModule(decoderConfig);
            }));
          break;
        case "decode_buffer_gltf":
          ((dracoBuffer, dataAttrib) => {
            const buffer = dracoBuffer,
              attributeIDs = {},
              attributeTypes = {},
              TYPE_ARRAY = {
                5121: Uint8Array,
                5122: Int16Array,
                5123: Uint16Array,
                5125: Uint32Array,
                5126: Float32Array,
                "image/jpeg": Uint8Array,
                "image/png": Uint8Array,
              };
            dataAttrib.forEach((att) => {
              const name = att.name;
              (attributeIDs[name] = att.id),
                (attributeTypes[name] = TYPE_ARRAY[att.type]);
            });
            const taskConfig = {
              attributeIDs: attributeIDs,
              attributeTypes: attributeTypes,
              useUniqueIDs: !0,
            };
            decoderPending.then((module) => {
              const draco = module.draco,
                decoder = new draco.Decoder(),
                decoderBuffer = new draco.DecoderBuffer();
              decoderBuffer.Init(new Int8Array(buffer), buffer.byteLength);
              try {
                const geometry = decodeGeometry(
                    draco,
                    decoder,
                    decoderBuffer,
                    taskConfig
                  ),
                  buffers = geometry.attributes.map(
                    (attr) => attr.array.buffer
                  );
                geometry.index && buffers.push(geometry.index.array.buffer);
                const response = {};
                geometry.index && (response.index = geometry.index.array),
                  geometry.attributes.forEach((att) => {
                    (response[att.name] = att.array),
                      (response[`${att.name}ItemSize`] = att.itemSize);
                  }),
                  response.position && computeBounding(response),
                  resolve(response, id, buffers);
              } catch (error) {
                onError({
                  message: message,
                  er: `Parsing error on Draco file ${message.path}.`,
                  resolve: resolve,
                  id: id,
                });
              } finally {
                draco.destroy(decoderBuffer), draco.destroy(decoder);
              }
            });
          })(message.buffer, message.dataAttrib);
          break;
        case "decode":
          fetch(message.path)
            .then((res) => {
              if (!res.ok) throw new Error();
              return res.arrayBuffer();
            })
            .then((dracoBuffer) => {
              const decoder = new TextDecoder(),
                jsonSize = parseInt(decoder.decode(dracoBuffer.slice(0, 10))),
                jsonData = JSON.parse(
                  decoder.decode(dracoBuffer.slice(10, 10 + jsonSize))
                ),
                buffer = dracoBuffer.slice(10 + jsonSize),
                TYPED_ARRAYS = Object.values(Geometry.TYPED_ARRAYS),
                attributeIDs = {},
                attributeTypes = {};
              jsonData.attributes.forEach((att, i) => {
                const name = att[0];
                (attributeIDs[name] = i),
                  (attributeTypes[name] = TYPED_ARRAYS[att[1]]);
              });
              const taskConfig = {
                  attributeIDs: attributeIDs,
                  attributeTypes: attributeTypes,
                  useUniqueIDs: !0,
                },
                isMesh = 0 === jsonData.type;
              decoderPending.then((module) => {
                const draco = module.draco,
                  decoder = new draco.Decoder(),
                  decoderBuffer = new draco.DecoderBuffer();
                decoderBuffer.Init(new Int8Array(buffer), buffer.byteLength);
                try {
                  const geometry = decodeGeometry(
                      draco,
                      decoder,
                      decoderBuffer,
                      taskConfig
                    ),
                    buffers = geometry.attributes.map(
                      (attr) => attr.array.buffer
                    );
                  isMesh &&
                    geometry.index &&
                    buffers.push(geometry.index.array.buffer);
                  const response = {
                    _type: "BufferGeometry",
                    userData: jsonData.userData || {},
                  };
                  (response.userData.dracoType = jsonData.type),
                    isMesh &&
                      geometry.index &&
                      (response.index = geometry.index.array),
                    geometry.attributes.forEach((att) => {
                      (response[att.name] = att.array),
                        (response[`${att.name}ItemSize`] = att.itemSize);
                    }),
                    isMesh && response.position && computeBounding(response),
                    resolve(response, id, buffers);
                } catch (error) {
                  onError({
                    message: message,
                    er: `Parsing error on Draco file ${message.path}.`,
                    resolve: resolve,
                    id: id,
                  });
                } finally {
                  draco.destroy(decoderBuffer), draco.destroy(decoder);
                }
              });
            })
            .catch(() => {
              onError({
                message: message,
                er: `Network error: Draco file (${message.path}) could not be loaded.`,
                resolve: resolve,
                id: id,
              });
            });
      }
    }),
      (this.decodeGeometry = decodeGeometry),
      (this.decodeIndex = decodeIndex),
      (this.decodeAttribute = decodeAttribute),
      (this.getDracoDataType = getDracoDataType),
      (this.onError = onError);
  }, "static"),
  Class(function GLTFLoader() {
    Inherit(this, Component);
    const _this = this,
      TYPE_ARRAY = {
        5121: Uint8Array,
        5122: Int16Array,
        5123: Uint16Array,
        5125: Uint32Array,
        5126: Float32Array,
        "image/jpeg": Uint8Array,
        "image/png": Uint8Array,
      },
      TYPE_SIZE = {
        SCALAR: 1,
        VEC2: 2,
        VEC3: 3,
        VEC4: 4,
        MAT2: 4,
        MAT3: 9,
        MAT4: 16,
      },
      ATTRIBUTES = {
        POSITION: "position",
        NORMAL: "normal",
        TANGENT: "tangent",
        TEXCOORD_0: "uv",
        TEXCOORD_1: "uv2",
        COLOR_0: "color",
        WEIGHTS_0: "skinWeight",
        JOINTS_0: "skinIndex",
      };
    let _sceneLayout, _path, _id;
    new Matrix4();
    _this.textures = null;
    let _dracoLoaded = null;
    (_this.parse = async function (path, sceneLayout) {
      let name = (path = Assets.getPath(path)).split("/");
      (name = name[name.length - 1]),
        console.log(name),
        (name = name.split(".")[0]),
        (_id = name),
        (_path = path),
        sceneLayout && (_sceneLayout = _this.initClass(SceneLayout, name));
      let json,
        binary,
        nodes = null;
      if (String(path).indexOf(".glb") > 0) {
        let data = await _this.loadBinary(_path);
        (json = data.json), (binary = data.binary);
      }
      String(path).indexOf(".gltf") > 0 &&
        ((json = await fetch(path).then((res) => res.json())),
        (binary = await Promise.all(
          json.buffers.map((buffer) => {
            const uri = this.resolveURI(buffer.uri);
            return fetch(uri).then((res) => res.arrayBuffer());
          })
        )),
        (binary = binary[0]));
      const desc = json,
        buffers = binary;
      let dracoRequired = !1;
      desc.extensionsRequired &&
        desc.extensionsRequired.forEach((extension) => {
          "KHR_draco_mesh_compression" === extension && (dracoRequired = !0);
        }),
        dracoRequired &&
          (!(function loadDracoLib() {
            _dracoLoaded = Promise.create();
            const useJS = "object" != typeof WebAssembly,
              libFolder = "~assets/js/lib/_draco/",
              libs = useJS
                ? [`${libFolder}draco_decoder.js`]
                : [
                    `${libFolder}draco_wasm_wrapper.js`,
                    `${libFolder}draco_decoder.wasm`,
                  ];
            Promise.all(
              libs.map((url, i) =>
                fetch(Assets.getPath(url)).then((res) => {
                  if (!res.ok) throw new Error();
                  return 0 === i ? res.text() : res.arrayBuffer();
                })
              )
            )
              .then(async (loadedLibs) => {
                Thread.upload(
                  [
                    "function loadDraco() {",
                    "/* draco decoder */",
                    loadedLibs[0],
                    "",
                    "/* worker */",
                    "",
                    "let decoderConfig, decoderPending;",
                    "",
                    DracoThread.onError.toString(),
                    DracoThread.decodeGeometry.toString(),
                    DracoThread.decodeIndex.toString(),
                    DracoThread.decodeAttribute.toString(),
                    DracoThread.getDracoDataType.toString(),
                    "",
                    "return " + DracoThread.loadDraco.toString(),
                    "};",
                  ].join("\n")
                );
                const pool = Thread.shared(!0).array,
                  decoderConfig = useJS ? {} : { wasmBinary: loadedLibs[1] };
                pool.forEach((t) =>
                  t.importCode("self.loadDraco = loadDraco();")
                ),
                  await Promise.all(
                    pool.map((t) =>
                      t.loadDraco({
                        type: "init",
                        decoderConfig: decoderConfig,
                      })
                    )
                  ),
                  _dracoLoaded.resolve();
              })
              .catch(() => {
                console.warn(
                  "Draco libs could not be loaded. Fallback to .json"
                ),
                  _dracoLoaded.reject();
              });
          })(),
          await _dracoLoaded);
      const bufferViews = _this.parseBufferViews(desc, buffers),
        images = await _this.parseImages(desc, bufferViews),
        textures = await _this.parseTextures(desc, images);
      await Promise.all(textures).then((values) => {
        _this.textures = values;
      });
      const materials = await _this.parseMaterials(desc, textures);
      return (
        (meshes = await _this.parseMeshes(desc, bufferViews, materials)),
        (nodes = await _this.parseNodes(desc, meshes)),
        nodes
      );
    }),
      (this.loadBinary = async function (path) {
        let json,
          binary,
          result = Promise.create();
        return (
          fetch(path)
            .then((res) => {
              if (!res.ok) throw new Error();
              return res.arrayBuffer();
            })
            .then(async (gltfBuffer) => {
              const BINARY_EXTENSION_CHUNK_TYPES_JSON = 1313821514,
                BINARY_EXTENSION_CHUNK_TYPES_BIN = 5130562,
                headerView = new DataView(gltfBuffer, 0, 12),
                decoder = new TextDecoder();
              let header_magic = decoder.decode(gltfBuffer.slice(0, 4)),
                header_version = headerView.getUint32(4, !0),
                header_length = headerView.getUint32(8, !0);
              if ("glTF" !== header_magic)
                throw new Error("GLTFLoader: Unsupported glTF-Binary header.");
              if (header_version < 2)
                throw new Error("GLTFLoader: Legacy binary file detected.");
              const chunkContentsLength = header_length - 12,
                chunkView = new DataView(gltfBuffer, 12);
              let chunkIndex = 0,
                _content = null;
              for (; chunkIndex < chunkContentsLength; ) {
                const chunkLength = chunkView.getUint32(chunkIndex, !0);
                chunkIndex += 4;
                const chunkType = chunkView.getUint32(chunkIndex, !0);
                if (
                  ((chunkIndex += 4),
                  chunkType === BINARY_EXTENSION_CHUNK_TYPES_JSON)
                ) {
                  const contentArray = new Uint8Array(
                    gltfBuffer,
                    12 + chunkIndex,
                    chunkLength
                  );
                  _content = decoder.decode(contentArray);
                } else if (chunkType === BINARY_EXTENSION_CHUNK_TYPES_BIN) {
                  const byteOffset = 12 + chunkIndex;
                  binary = gltfBuffer.slice(
                    byteOffset,
                    byteOffset + chunkLength
                  );
                }
                chunkIndex += chunkLength;
              }
              if (null === _content)
                throw new Error("GLTFLoader: JSON content not found.");
              (json = JSON.parse(_content)),
                console.log(json),
                void 0 === json.asset || json.asset.version[0] < 2
                  ? onError &&
                    onError(
                      new Error(
                        "GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported."
                      )
                    )
                  : result.resolve();
            }),
          await result,
          { json: json, binary: binary }
        );
      }),
      (this.parseBufferViews = function (desc, buffers) {
        if (!desc.bufferViews) return null;
        const bufferViews = desc.bufferViews.map((o) => Object.assign({}, o));
        return (
          desc.accessors.forEach(
            ({ bufferView: i, componentType: componentType }) => {
              i < bufferViews.length &&
                (bufferViews[i].componentType = componentType);
            }
          ),
          bufferViews.forEach(
            (
              {
                byteOffset: byteOffset = 0,
                byteLength: byteLength,
                componentType: componentType,
              },
              i
            ) => {
              bufferViews[i].data = buffers.slice(
                byteOffset,
                byteOffset + byteLength
              );
            }
          ),
          bufferViews
        );
      }),
      (this.parseMeshes = function (desc, bufferViews, materials) {
        return desc.meshes
          ? desc.meshes.map(
              ({ name: name, primitives: primitives }, index1) => {
                let shader = Utils3D.getTestShader();
                return (
                  (shader.side = Shader.DOUBLE_SIDE),
                  (primitives = this.parsePrimitives(
                    primitives,
                    desc,
                    bufferViews,
                    materials
                  ).map(
                    async (
                      {
                        geometry: geometry,
                        materialDefinition: materialDefinition,
                      },
                      index2
                    ) => {
                      let setupShader = (el) => {
                        if (!materialDefinition) return;
                        let shader = el.shader;
                        materialDefinition.baseColorTexture &&
                          materialDefinition.baseColorTexture.texture.then(
                            (res) => {
                              shader.get("tMap") && shader.set("tMap", res),
                                shader.get("tBaseColor") &&
                                  shader.set("tBaseColor", res);
                            }
                          ),
                          materialDefinition.normalTexture &&
                            materialDefinition.normalTexture.texture.then(
                              (res) => {
                                shader.get("tNormal") &&
                                  shader.set("tNormal", res);
                              }
                            ),
                          materialDefinition.metallicRoughnessTexture &&
                            materialDefinition.metallicRoughnessTexture.texture.then(
                              (res) => {
                                shader.get("tMRO") && shader.set("tMRO", res);
                              }
                            );
                      };
                      if ((await geometry.ready, _sceneLayout)) {
                        let naming = `${_id}_mesh_${index1}_${index2}`;
                        name && (naming = naming.concat(`_${name}`)),
                          (naming = naming.replace(/ /g, "_"));
                        let mesh =
                          void 0 !== _sceneLayout.exists(naming)
                            ? await _sceneLayout.getLayer(naming)
                            : null;
                        if (mesh) mesh.geometry = geometry;
                        else {
                          let id = await _sceneLayout._createLayer(
                            `${_id}_meshes`,
                            !0
                          );
                          (mesh = await _sceneLayout.getLayer(String(id))),
                            (mesh.geometry = geometry),
                            _sceneLayout._rename(id, String(id), naming);
                        }
                        return setupShader(mesh), mesh;
                      }
                      {
                        let mesh = new Mesh(geometry, shader);
                        return setupShader(mesh), mesh;
                      }
                    }
                  )),
                  primitives
                );
              }
            )
          : null;
      }),
      (this.parsePrimitives = function (
        primitives,
        desc,
        bufferViews,
        materials
      ) {
        return primitives.map(
          ({
            attributes: attributes,
            indices: indices,
            material: materialIndex,
            extensions: extensions,
          }) => {
            let materialDefinition = null;
            void 0 !== materialIndex &&
              (materialDefinition = materials[materialIndex]);
            let geometry = new Geometry();
            if (
              ((geometry.ready = Promise.create()),
              extensions && extensions.KHR_draco_mesh_compression)
            ) {
              const attribs = extensions.KHR_draco_mesh_compression.attributes;
              let dataAttrib = [];
              for (let attribute in attributes) {
                let index = attributes[attribute],
                  id = attribs[attribute],
                  { componentType: componentType } = desc.accessors[index];
                dataAttrib.push({
                  name: attribute,
                  id: id,
                  type: componentType,
                });
              }
              const { data: data } =
                bufferViews[extensions.KHR_draco_mesh_compression.bufferView];
              Thread.shared()
                .loadDraco({
                  type: "decode_buffer_gltf",
                  buffer: data,
                  dataAttrib: dataAttrib,
                })
                .then((res) => {
                  for (let att in res) {
                    if (res[att].length > 0 && "index" !== att) {
                      let attributeName = ATTRIBUTES[att],
                        info = new GeometryAttribute(
                          res[att],
                          res[`${att}ItemSize`]
                        );
                      geometry.addAttribute(attributeName, info);
                    }
                    "index" === att && (geometry.index = res[att]);
                  }
                  geometry.ready.resolve();
                });
            } else {
              for (let attr in attributes) {
                let buffer = this.parseAccessor(
                    attributes[attr],
                    desc,
                    bufferViews
                  ),
                  data = new GeometryAttribute(buffer.data, buffer.size);
                geometry.addAttribute(ATTRIBUTES[attr], data);
              }
              if (void 0 !== indices) {
                let buffer = this.parseAccessor(indices, desc, bufferViews);
                geometry.index = buffer.data;
              }
              geometry.ready.resolve();
            }
            return {
              geometry: geometry,
              materialDefinition: materialDefinition,
            };
          }
        );
      }),
      (this.parseAccessor = function (
        index,
        desc,
        bufferViews,
        _bufferViewIndex = null
      ) {
        let {
          bufferView: bufferViewIndex,
          byteOffset: byteOffset = 0,
          componentType: componentType,
          normalized: normalized = !1,
          count: count,
          type: type,
          min: min,
          max: max,
        } = desc.accessors[index];
        null !== _bufferViewIndex && (bufferViewIndex = _bufferViewIndex);
        const {
            data: data,
            buffer: buffer,
            byteStride: byteStride = 0,
          } = bufferViews[bufferViewIndex],
          size = TYPE_SIZE[type];
        return {
          data: new (0, TYPE_ARRAY[componentType])(data, byteOffset),
          size: size,
          type: componentType,
          normalized: normalized,
          buffer: buffer,
          stride: byteStride,
          offset: byteOffset,
          count: count,
          min: min,
          max: max,
        };
      }),
      (this.parseNodes = async function (desc, meshes) {
        if (!desc.nodes) return null;
        let nodes = desc.nodes.map(
          async (
            {
              matrix: matrix,
              mesh: meshIndex,
              rotation: rotation,
              scale: scale,
              translation: translation,
              name: name,
            },
            index
          ) => {
            let node = new Group();
            if (_sceneLayout) {
              let naming = `${_id}_hierarchy_${index}`;
              name && (naming = naming.concat(`_${name}`)),
                (naming = naming.replace(/ /g, "_"));
              let exists = _sceneLayout.exists(naming);
              if (
                ((node = exists ? await _sceneLayout.getLayer(naming) : null),
                !node)
              ) {
                let ref = await _sceneLayout._createLayer(
                  `${_id}_hierarchy`,
                  !0
                );
                (node = await _sceneLayout.getLayer(String(ref))),
                  _sceneLayout._rename(ref, String(ref), naming);
              }
              (node.geometry = new PlaneGeometry(0, 0, 1, 1)),
                (node._parent = null);
            }
            if ((name && (node.name = name), matrix)) {
              let m = new Matrix4().set(...matrix);
              (m = m.transpose()),
                node.matrix.copy(m),
                node.matrix.decompose(
                  node.position,
                  node.quaternion,
                  node.scale
                );
            } else
              (rotation || scale || translation) &&
                (rotation && node.quaternion.set(...rotation),
                scale && node.scale.set(...scale),
                translation && node.position.set(...translation),
                node.updateMatrix());
            return (
              void 0 !== meshIndex &&
                meshes[meshIndex].forEach(async (mesh) => {
                  mesh.then((res) => {
                    node.add(res);
                  });
                }),
              node
            );
          }
        );
        return (
          await Promise.all(nodes).then((values) => {
            nodes = values;
          }),
          desc.nodes.forEach(({ children: children = [] }, i) => {
            children.forEach((childIndex) => {
              nodes[i].add(nodes[childIndex]);
            });
          }),
          nodes.filter((node) => {
            if (null == node._parent) return node;
          })
        );
      }),
      (this.parseTextures = function (desc, images) {
        return desc.textures
          ? desc.textures.map((textureInfo) =>
              _this.createTexture(desc, images, textureInfo)
            )
          : null;
      }),
      (this.createTexture = async function (
        desc,
        images,
        {
          sampler: samplerIndex,
          source: sourceIndex,
          name: name,
          extensions: extensions,
          extras: extras,
        }
      ) {
        if (void 0 === sourceIndex && extensions)
          return void console.warn("extensions required to load texture");
        const image = images[sourceIndex];
        if (image.texture) return image.texture;
        const sampler =
          void 0 !== samplerIndex ? desc.samplers[samplerIndex] : null;
        let options = {};
        sampler &&
          ["magFilter", "minFilter", "wrapS", "wrapT"].forEach((prop) => {
            sampler[prop] && (options[prop] = sampler[prop]);
          }),
          await image.ready;
        const texture = new Texture(image);
        return (
          (texture.name = name),
          (texture.flipY = !1),
          (texture.wrapS = texture.wrapT = Texture.REPEAT),
          (image.texture = texture),
          texture
        );
      }),
      (this.parseImages = async function (desc, bufferViews) {
        return desc.images
          ? await Promise.all(
              desc.images.map(
                async ({
                  uri: uri,
                  bufferView: bufferViewIndex,
                  mimeType: mimeType,
                  name: name,
                }) => {
                  if ("image/ktx2" === mimeType)
                    return (
                      console.warn(
                        "image type is ktx2, update the loader to support this type"
                      ),
                      null
                    );
                  const image = new Image();
                  if (((image.name = name), uri))
                    image.src = this.resolveURI(uri);
                  else if (void 0 !== bufferViewIndex) {
                    const { data: data } = bufferViews[bufferViewIndex],
                      blob = new Blob([data], { type: mimeType });
                    image.src = URL.createObjectURL(blob);
                  }
                  return (
                    (image.ready = new Promise((res) => {
                      image.onload = () => res();
                    })),
                    image
                  );
                }
              )
            )
          : null;
      }),
      (this.resolveURI = function (uri) {
        let dir = _path.split("/");
        return (
          dir.pop(),
          (dir = dir.join("/")),
          "string" != typeof uri || "" === uri
            ? ""
            : (/^https?:\/\//i.test(dir) &&
                /^\//.test(uri) &&
                (dir = dir.replace(/(^https?:\/\/[^\/]+).*/i, "$1")),
              /^(https?:)?\/\//i.test(uri) ||
              /^data:.*,.*$/i.test(uri) ||
              /^blob:.*$/i.test(uri)
                ? uri
                : dir + "/" + uri)
        );
      }),
      (this.parseMaterials = function (desc, textures) {
        return desc.materials
          ? desc.materials.map(
              ({
                name: name,
                extensions: extensions,
                extras: extras,
                pbrMetallicRoughness: pbrMetallicRoughness = {},
                normalTexture: normalTexture,
                occlusionTexture: occlusionTexture,
                emissiveTexture: emissiveTexture,
                emissiveFactor: emissiveFactor = [0, 0, 0],
                alphaMode: alphaMode = "OPAQUE",
                alphaCutoff: alphaCutoff = 0.5,
                doubleSided: doubleSided = !1,
              }) => {
                const {
                  baseColorFactor: baseColorFactor = [1, 1, 1, 1],
                  baseColorTexture: baseColorTexture,
                  metallicFactor: metallicFactor = 1,
                  roughnessFactor: roughnessFactor = 1,
                  metallicRoughnessTexture: metallicRoughnessTexture,
                } = pbrMetallicRoughness;
                return (
                  baseColorTexture &&
                    (baseColorTexture.texture =
                      textures[baseColorTexture.index]),
                  normalTexture &&
                    (normalTexture.texture = textures[normalTexture.index]),
                  metallicRoughnessTexture &&
                    (metallicRoughnessTexture.texture =
                      textures[metallicRoughnessTexture.index]),
                  occlusionTexture &&
                    (occlusionTexture.texture =
                      textures[occlusionTexture.index]),
                  emissiveTexture &&
                    (emissiveTexture.texture = textures[emissiveTexture.index]),
                  {
                    name: name,
                    extensions: extensions,
                    extras: extras,
                    baseColorFactor: baseColorFactor,
                    baseColorTexture: baseColorTexture,
                    metallicFactor: metallicFactor,
                    roughnessFactor: roughnessFactor,
                    metallicRoughnessTexture: metallicRoughnessTexture,
                    normalTexture: normalTexture,
                    occlusionTexture: occlusionTexture,
                    emissiveTexture: emissiveTexture,
                    emissiveFactor: emissiveFactor,
                    alphaMode: alphaMode,
                    alphaCutoff: alphaCutoff,
                    doubleSided: doubleSided,
                  }
                );
              }
            )
          : null;
      });
  }),
  Class(function GeomThread() {
    Inherit(this, Component);
    const _this = this;
    var _cache = {},
      _cacheWait = {},
      _receive = {},
      _dracoLoaded = null;
    function computeBounding(data) {
      let geom = new Geometry();
      geom.addAttribute("position", new GeometryAttribute(data.position, 3)),
        data.index && geom.setIndex(data.index),
        geom.computeBoundingBox(),
        geom.computeBoundingSphere(),
        (data.boundingBox = geom.boundingBox),
        (data.boundingSphere = geom.boundingSphere);
    }
    function loadGeometry(e, id) {
      get(e.path)
        .then((data) => {
          let buffers = [];
          if (data.data && data.metadata?.type) {
            let bufferList = { _type: data.metadata.type },
              jsonData = data.data;
            jsonData.index &&
              ((bufferList.index = new Geometry.TYPED_ARRAYS[
                jsonData.index.type
              ](jsonData.index.array)),
              buffers.push(bufferList.index.buffer));
            for (let key in jsonData.attributes) {
              let attrib = jsonData.attributes[key];
              (bufferList[key] = new Geometry.TYPED_ARRAYS[attrib.type](
                attrib.array
              )),
                (bufferList[`${key}ItemSize`] = attrib.itemSize),
                buffers.push(bufferList[key].buffer);
            }
            bufferList.position && computeBounding(bufferList),
              data.userData && (bufferList.userData = data.userData),
              resolve(bufferList, id, buffers);
          } else {
            for (let key in data)
              if ("bones" != key)
                if (Array.isArray(data[key])) {
                  const ArrayType =
                    "index" == key
                      ? Geometry.arrayNeedsUint32(data[key])
                        ? Uint32Array
                        : Uint16Array
                      : Float32Array;
                  (data[key] = new ArrayType(data[key])),
                    buffers.push(data[key].buffer);
                } else data[key].length > 0 && buffers.push(data[key].buffer);
            computeBounding(data),
              e.custom && self[e.custom](data),
              resolve(data, id, buffers);
          }
        })
        .catch((er) => {
          e.preloading || console.error(er);
          let plane = new PlaneGeometry(1, 1).toNonIndexed(),
            buffers = [],
            data = {};
          for (let key in plane.attributes)
            (data[key] = plane.attributes[key].array),
              buffers.push(data[key].buffer);
          computeBounding(data), resolve(data, id, buffers);
        });
    }
    function geom_useFn(e) {
      Global.FNS || (Global.FNS = []), Global.FNS.push(e.name);
    }
    function loadDracoLib() {
      _dracoLoaded = Promise.create();
      const useJS = "object" != typeof WebAssembly,
        libFolder = "~assets/js/lib/_draco/",
        libs = useJS
          ? [`${libFolder}draco_decoder.js`]
          : [
              `${libFolder}draco_wasm_wrapper.js`,
              `${libFolder}draco_decoder.wasm`,
            ];
      Promise.all(
        libs.map((url, i) =>
          fetch(Assets.getPath(url)).then((res) => {
            if (!res.ok) throw new Error();
            return 0 === i ? res.text() : res.arrayBuffer();
          })
        )
      )
        .then(async (loadedLibs) => {
          Thread.upload(
            [
              "function loadDraco() {",
              "/* draco decoder */",
              loadedLibs[0],
              "",
              "/* worker */",
              "",
              "let decoderConfig, decoderPending;",
              "",
              DracoThread.onError.toString(),
              DracoThread.decodeGeometry.toString(),
              DracoThread.decodeIndex.toString(),
              DracoThread.decodeAttribute.toString(),
              DracoThread.getDracoDataType.toString(),
              "",
              "return " + DracoThread.loadDraco.toString(),
              "};",
            ].join("\n")
          );
          const pool = Thread.shared(!0).array,
            decoderConfig = useJS ? {} : { wasmBinary: loadedLibs[1] };
          pool.forEach((t) => t.importCode("self.loadDraco = loadDraco();")),
            await Promise.all(
              pool.map((t) =>
                t.loadDraco({ type: "init", decoderConfig: decoderConfig })
              )
            ),
            _dracoLoaded.resolve();
        })
        .catch(() => {
          console.warn("Draco libs could not be loaded. Fallback to .json"),
            _dracoLoaded.reject();
        });
    }
    function parseGeometry(data, path, custom) {
      let geometry;
      if (custom && _receive[custom]) geometry = _receive[custom](data);
      else {
        let geom = new Geometry();
        if (data._type) {
          for (key in data)
            if ("_type" !== key && !key.endsWith("ItemSize"))
              switch (key) {
                case "userData":
                  geom.userData = data.userData;
                  break;
                case "boundingBox":
                  geom.boundingBox = new Box3(
                    new Vector3().set(
                      data.boundingBox.min.x,
                      data.boundingBox.min.y,
                      data.boundingBox.min.z
                    ),
                    new Vector3().set(
                      data.boundingBox.max.x,
                      data.boundingBox.max.y,
                      data.boundingBox.max.z
                    )
                  );
                  break;
                case "boundingSphere":
                  geom.boundingSphere = new Sphere(
                    new Vector3().set(
                      data.boundingSphere.center.x,
                      data.boundingSphere.center.y,
                      data.boundingSphere.center.z
                    ),
                    data.boundingSphere.radius
                  );
                  break;
                case "index":
                  geom.setIndex(data.index);
                  break;
                default:
                  data[`${key}ItemSize`] &&
                    geom.addAttribute(
                      key,
                      new GeometryAttribute(data[key], data[`${key}ItemSize`])
                    );
              }
        } else
          geom.addAttribute(
            "position",
            new GeometryAttribute(data.position, 3)
          ),
            geom.addAttribute(
              "normal",
              new GeometryAttribute(data.normal || data.position.length, 3)
            ),
            geom.addAttribute(
              "uv",
              new GeometryAttribute(
                data.uv || (data.position.length / 3) * 2,
                2
              )
            ),
            data.uv2 &&
              geom.addAttribute("uv2", new GeometryAttribute(data.uv2, 2)),
            data.vdata &&
              geom.addAttribute("vdata", new GeometryAttribute(data.vdata, 3)),
            data.index && geom.setIndex(data.index),
            data.skinIndex &&
              geom.addAttribute(
                "skinIndex",
                new GeometryAttribute(data.skinIndex, 4)
              ),
            data.skinWeight &&
              geom.addAttribute(
                "skinWeight",
                new GeometryAttribute(data.skinWeight, 4)
              ),
            (data.rig || data.bones) &&
              (geom.bones = (data.rig ? data.rig.bones : data.bones).slice(0)),
            (geom.boundingBox = new Box3(
              new Vector3().set(
                data.boundingBox.min.x,
                data.boundingBox.min.y,
                data.boundingBox.min.z
              ),
              new Vector3().set(
                data.boundingBox.max.x,
                data.boundingBox.max.y,
                data.boundingBox.max.z
              )
            )),
            (geom.boundingSphere = new Sphere(
              new Vector3().set(
                data.boundingSphere.center.x,
                data.boundingSphere.center.y,
                data.boundingSphere.center.z
              ),
              data.boundingSphere.radius
            ));
        (geometry = geom), (geom._src = path);
      }
      if (!geometry.attributes.position)
        throw `GeomThread :: Malformed geometry is missing position data. ${path}`;
      _this.caching && (_cache[path] = geometry),
        _cacheWait[path]?.resolve(geometry);
    }
    (this.caching = !0),
      (async function () {
        await Hydra.ready(),
          Thread.upload(loadGeometry, geom_useFn, computeBounding);
      })(),
      (this.loadGeometry = function (path, custom, preloading) {
        if (!Device.graphics.gpu)
          return Promise.resolve(new PlaneGeometry(1, 1));
        if (_cache[path]) return Promise.resolve(_cache[path]);
        let cacheBust = !1;
        path.includes("?") &&
          ((path = path.split("?")[0]), (cacheBust = "?" + Utils.timestamp()));
        let isBinary = path.endsWith(".bin");
        if (
          (path.includes("http") ||
            (Hydra.LOCAL || (cacheBust = !1),
            path.includes("assets/geometry/") ||
              (path = "assets/geometry/" + path),
            path.includes(".") || (path += ".json"),
            cacheBust && (path += cacheBust)),
          (path = Thread.absolutePath(Assets.getPath(path))),
          _this.caching)
        ) {
          if (_cacheWait[path]) return _cacheWait[path];
          _cacheWait[path] = Promise.create();
        }
        return (
          isBinary
            ? (_dracoLoaded || loadDracoLib(),
              _dracoLoaded
                .then(() => {
                  Thread.shared()
                    .loadDraco({
                      type: "decode",
                      path: path,
                      custom: custom,
                      preloading: preloading,
                    })
                    .then((data) => parseGeometry(data, path, custom));
                })
                .catch(() => {
                  (path = path.replace(".bin", ".json")),
                    Thread.shared()
                      .loadGeometry({
                        path: path,
                        custom: custom,
                        preloading: preloading,
                      })
                      .then((data) => parseGeometry(data, path, custom));
                }))
            : Thread.shared()
                .loadGeometry({
                  path: path,
                  custom: custom,
                  preloading: preloading,
                })
                .then((data) => parseGeometry(data, path, custom)),
          _cacheWait[path]
        );
      }),
      (this.removeFromCache = function (path) {
        path.includes("assets/geometry/") || (path = "assets/geometry/" + path),
          path.includes(".") || (path += ".json"),
          (path = Thread.absolutePath(Assets.getPath(path))),
          delete _cache[path],
          delete _cacheWait[path];
      }),
      (this.loadDracoLib = function () {
        return _dracoLoaded || loadDracoLib(), _dracoLoaded;
      }),
      (this.loadSkinnedGeometry = function (path, custom, preloading) {
        return this.loadGeometry(path, custom, preloading);
      }),
      (this.customFunction = function (fn, receive) {
        let name = Thread.upload(fn);
        (name = name[0]),
          t.geom_useFn({ name: name }),
          (_receive[name] = receive);
      });
  }, "static"),
  Class(
    function InstanceMesh(_mesh, _shader, _group, _input) {
      Inherit(this, Component);
      const _this = this;
      var _config,
        _frustumCulled = !1,
        _blankShader,
        _instanceGroup;
      function initHotReload() {
        (_mesh.cacheGeom = _mesh.geometry.clone()),
          _this.events.sub(SceneLayout.HOTLOAD_GEOMETRY, ({ file: file }) => {
            _mesh.geometry?._src?.includes(file) &&
              GeomThread.loadGeometry(file).then((_) => {
                createInstanceMesh(_config.getFilePath("json"));
              }),
              file.includes(_config.getFilePath("json")) &&
                createInstanceMesh(_config.getFilePath("json"));
          });
      }
      async function createInstanceMesh(file) {
        if (!file) return;
        let isBinary = file.includes(".bin"),
          data;
        file.includes("assets/geometry") || (file = `assets/geometry/${file}`),
          isBinary || file.includes(".json") || (file += ".json"),
          _mesh.cacheGeom && (file += "?" + Utils.timestamp()),
          _mesh.instanceMesh && (_mesh.instanceMesh.visible = !1),
          isBinary
            ? (await GeomThread.loadDracoLib(),
              (data = await Thread.shared().loadDraco({
                type: "decode",
                path: Thread.absolutePath(Assets.getPath(file)),
              })))
            : (data = await Thread.shared().parseInstanceMesh({
                url: Thread.absolutePath(Assets.getPath(file)),
              }));
        let isStatic = !_config.get("dynamic");
        if (
          ((_this.batch = _this.initClass(MeshBatch, {
            visibilityCheck: !isStatic,
          })),
          _mesh._parent.add(_this.batch.group),
          (_this.batch.static = isStatic),
          (_this.batch.frustumCulled = _frustumCulled),
          (_this.batch.onMeshCreated = (mesh) => {
            let geom = mesh.geometry;
            for (let key in data) {
              if (
                [
                  "_type",
                  "userData",
                  "offset",
                  "orientation",
                  "scale",
                ].includes(key)
              )
                continue;
              let itemSize = data[`${key}ItemSize`];
              "number" == typeof itemSize &&
                geom.addAttribute(
                  key,
                  new GeometryAttribute(
                    data[key],
                    itemSize,
                    1,
                    _this.batch.useDynamic
                  )
                );
            }
            let instances = [];
            for (let i = 0; i < count; i++) instances.push(i);
            geom.addAttribute(
              "instance",
              new GeometryAttribute(new Float32Array(instances), 1, 1)
            ),
              (_mesh.instanceMesh = mesh),
              mesh.position.copy(_mesh.position),
              mesh.quaternion.copy(_mesh.quaternion),
              mesh.scale.copy(_mesh.scale),
              (mesh.geometry.maxInstancedCount =
                _this.maxInstancedCount * _this.instanceMultiplier),
              _mesh.instanceMeshReady.resolve();
          }),
          !data.offsetItemSize)
        )
          return;
        let count = data.offset.length / data.offsetItemSize;
        for (let i = 0; i < count; ++i) {
          let m = new Mesh(_mesh.cacheGeom || _mesh.geometry, _mesh.shader);
          m.position.fromArray(data.offset, i * data.offsetItemSize),
            data.orientation &&
              m.quaternion.fromArray(
                data.orientation,
                i * data.orientationItemSize
              ),
            data.scale && m.scale.fromArray(data.scale, i * data.scaleItemSize),
            (m.renderOrder = _mesh.renderOrder),
            (m.castShadow = _mesh.castShadow),
            (m.frustumCulled = !1),
            (m.renderOrder = _mesh.renderOrder),
            (m.castShadow = _mesh.castShadow),
            (m.receiveLight = _mesh.receiveLight),
            (m.shader.neverRender = !1),
            _this.batch.add(m),
            (m.shader.neverRender = !1),
            (m.shader = _blankShader),
            _instanceGroup.add(m);
        }
        let test = _config.get("test");
        test && (_this.instanceMultiplier = eval(test)),
          void 0 === _this.maxInstancedCount &&
            (_this.maxInstancedCount = count),
          isStatic &&
            (await _this.batch.staticReady(),
            (_instanceGroup.matrixAutoUpdate = !1));
      }
      function addHandlers() {
        _this.events.sub(MeshUIL.UPDATE, handleMeshUpdate),
          Hydra.LOCAL &&
            UIL.global &&
            (_this.events.sub(
              UILGraphNode.TOGGLE_VISIBILITY,
              handleToggleVisibility
            ),
            _this.events.sub(InputUIL.UPDATE, handleUILUpdate));
      }
      function handleMeshUpdate({ key: key, prefix: prefix, val: val }) {
        if (
          _mesh.instanceMesh &&
          (prefix = prefix.substring(5)) === _mesh.prefix
        )
          switch (key) {
            case "position":
              _mesh.instanceMesh.position.fromArray(val);
              break;
            case "rotation":
              _mesh.instanceMesh.rotation.fromArray(val);
              break;
            case "scale":
              _mesh.instanceMesh.scale.fromArray(val);
          }
      }
      function handleToggleVisibility({ id: id, visible: visible }) {
        _this.batch &&
          id === _mesh.uilGroup.id &&
          (_this.batch.group.visible = visible);
      }
      function handleUILUpdate(e) {
        _this.batch &&
          e.group === _input &&
          "visible" === e.key &&
          (_this.batch.group.visible = _input.get("visible"));
      }
      (this.instanceMultiplier = 1),
        (_config = InputUIL.create("im_" + _input.prefix, _group)).addFile(
          "json",
          { relative: "assets/geometry" }
        ),
        _config.add("test"),
        _config.addToggle("dynamic", !1),
        _config.setLabel("Instance"),
        !1 !== _input.get("visible") &&
          ((_this._config = _config),
          ((_blankShader = Utils3D.getTestShader()).visible = !1),
          ((_instanceGroup = new Group()).doNotProject = !0),
          _mesh._parent.add(_instanceGroup),
          _mesh._parent.remove(_mesh),
          (_mesh.visible = !1),
          (_mesh.instanceMeshReady = Promise.create()),
          (_mesh.instanceMeshBeforeReady = Promise.create()),
          createInstanceMesh(_config.getFilePath("json")),
          (_config.onUpdate = (_) => {
            createInstanceMesh(_config.getFilePath("json"));
          }),
          addHandlers(),
          Hydra.LOCAL && initHotReload()),
        (this.applyToShader = function (shader) {
          _this.batch.applyToShader(shader);
        }),
        this.get("frustumCulled", () =>
          _this.batch ? _this.batch.frustumCulled : _frustumCulled
        ),
        this.set("frustumCulled", async (b) => {
          _this.batch && (_this.batch.frustumCulled = b), (_frustumCulled = b);
        });
    },
    (_) => {
      Thread.upload(function parseInstanceMesh({ url: url }, id) {
        get(url).then((data) => {
          let bufferList = {},
            buffers = [];
          if (data.data && data.metadata?.type) {
            bufferList._type = data.metadata.type;
            let jsonData = data.data;
            for (let key in jsonData.attributes) {
              let attrib = jsonData.attributes[key];
              (bufferList[key] = new Geometry.TYPED_ARRAYS[attrib.type](
                attrib.array
              )),
                (bufferList[`${key}ItemSize`] = attrib.itemSize),
                buffers.push(bufferList[key].buffer);
            }
          } else {
            bufferList._type = "BufferGeometry";
            for (let key in data) {
              let attrib = data[key];
              (bufferList[key] = new Float32Array(attrib.buffer)),
                (bufferList[`${key}ItemSize`] = attrib.components),
                buffers.push(bufferList[key].buffer);
            }
          }
          resolve(bufferList, id, buffers);
        });
      });
    }
  ),
  Class(
    function MeshBatch(_input, _config) {
      Inherit(this, Object3D);
      const _this = this;
      var _geom,
        _shader,
        _mesh,
        _firstRender,
        _shaderKey,
        _availableIndices,
        _packedData,
        _packedTexture,
        _maxIndices,
        _static = !1,
        _renderOrder = 0,
        _objects = [],
        _offset = [],
        _quaternion = [],
        _scale = [],
        _attributes = {},
        _uniformToAttrib = [],
        _uniformNoAttrib = [],
        _frustumCulled = !0,
        _v1 = new Vector3(),
        _v2 = new Vector3(),
        _q = new Quaternion(),
        _list = new LinkedList();
      async function initFromSceneLayout() {
        let wildcard = _input.get("wildcard");
        if (!wildcard || !wildcard.length) return;
        let groupName = wildcard.split("|")[0],
          group = await _this.parent.getLayer(groupName);
        await _this.wait(group.children, "length");
        let children = [...group.children];
        children.sort((a, b) => a.renderOrder - b.renderOrder),
          children.forEach((mesh) => _this.add(mesh)),
          wildcard.includes("static") && (_this.static = !0),
          (_this.group.renderOrder = children[0].renderOrder),
          group.add(_this.group);
      }
      function updateShader(shader, castShadow) {
        let prefetchCode = Shaders.getShader(shader.vsName + ".vs");
        (shader.customCompile = `${shader.vsName}|${shader.fsName}|instance`),
          (shader.castShadow = castShadow),
          shader.resetProgram();
        let cached = MeshBatch.shaders[`${shader.vsName}|${shader.fsName}`];
        if (cached)
          return (
            (shader.fragmentShader = shader.restoreFS = cached.fragment),
            void (shader.vertexShader = shader.restoreVS = cached.vertex)
          );
        let vsSplit = shader.vertexShader.split("__ACTIVE_THEORY_LIGHTS__"),
          fsSplit = shader.fragmentShader.split("__ACTIVE_THEORY_LIGHTS__");
        if (
          !vsSplit[1].includes("vec3 pos = position;") &&
          !vsSplit[1].includes("pos = pos;") &&
          !shader.vertexShader.includes("vec3 transformPosition")
        )
          throw `Shader ${shader.vsName} needs to have "vec3 pos = position;" in order for batching to work`;
        let definitions = [];
        vsSplit[1].split("\n").forEach((line) => {
          if (line.includes("uniform")) {
            if (line.includes("sampler2D")) return;
            let data = line.split(" "),
              uni = data[2].replace(";", "");
            (function uniformToAttrib(key) {
              key = key.trim();
              for (let i = 0; i < _uniformToAttrib.length; i++) {
                let val = _uniformToAttrib[i];
                if (key.includes(val) || val.includes(key))
                  return !_uniformNoAttrib.includes(key);
              }
              return !1;
            })(uni) &&
              (definitions.push(`${uni} = a_${data[2]}`),
              (vsSplit[1] = vsSplit[1].replace(
                line,
                `attribute ${data[1]} a_${data[2]}\nvarying ${data[1]} ${data[2]}`
              )),
              (fsSplit[1] = fsSplit[1].replace(
                line,
                `varying ${data[1]} ${data[2]}`
              )));
          }
        }),
          (vsSplit[1] = vsSplit[1].replace(
            /vec3 pos = position;/g,
            "vec3 pos = transformPosition(position, offset, scale, orientation);"
          )),
          (vsSplit[1] = vsSplit[1].replace(
            /pos = pos;/g,
            "pos = transformPosition(pos, offset, scale, orientation);"
          )),
          (vsSplit[1] = vsSplit[1].replace(
            /vNormal = normalMatrix \* normal;/g,
            "vNormal = normalMatrix * transformNormal(normal, orientation);"
          )),
          (vsSplit[1] = vsSplit[1].replace(
            /vWorldNormal = transpose(inverse(mat3(modelMatrix))) \* normal;/g,
            "vWorldNormal = transpose(inverse(mat3(modelMatrix))) * transformNormal(normal, orientation);"
          )),
          (vsSplit[1] = vsSplit[1].replace(
            /vec3 transformedNormal = normal;/g,
            "vec3 transformedNormal = transformNormal(normal, orientation);"
          ));
        let main = vsSplit[1].split("main() {");
        (main[1] = "\n" + definitions.join("\n") + main[1]),
          (vsSplit[1] = main.join("main() {")),
          (vsSplit[0] += "#define INSTANCED 1\n"),
          (fsSplit[0] += "#define INSTANCED 1\n"),
          (prefetchCode && prefetchCode.includes("attribute vec3 offset")) ||
            ((vsSplit[0] += "\n"),
            (vsSplit[0] += "attribute float instance;\n"),
            (vsSplit[0] += "attribute vec3 offset;\n"),
            (vsSplit[0] += "attribute vec3 scale;\n"),
            (vsSplit[0] += "attribute vec4 orientation;\n")),
          shader.vertexShader.includes("vec3 transformPosition") ||
            (vsSplit[0] += Shaders.getShader("instance.vs") + "\n"),
          _packedData &&
            (vsSplit[0] +=
              "\n            attribute float batchIndex;\n            uniform vec3 uPackedInfo;\n            uniform sampler2D tPackedTexture;\n            vec2 getPackedUV(float index, float offset) {\n                float pixel = (index*uPackedInfo.x) + offset;\n            \n                float size = uPackedInfo.y;\n                float p0 = pixel / size;\n                float y = floor(p0);\n                float x = p0 - y;\n            \n                vec2 uv = vec2(0.0);\n                uv.x = x;\n                uv.y = y / size;\n                return uv;\n            }\n            \n            vec4 getPackedData(float offset) {\n                return texture2D(tPackedTexture, getPackedUV(batchIndex, offset));\n            }\n            "),
          (vsSplit = vsSplit.join("__ACTIVE_THEORY_LIGHTS__")),
          (fsSplit = fsSplit.join("__ACTIVE_THEORY_LIGHTS__")),
          (shader.vertexShader = shader.restoreVS = vsSplit),
          (shader.fragmentShader = shader.restoreFS = fsSplit),
          (_shaderKey = `${shader.vsName}|${shader.fsName}`),
          (MeshBatch.shaders[_shaderKey] = {
            fragment: shader.fragmentShader,
            vertex: shader.vertexShader,
          });
      }
      function modifyGeometry(dir) {
        if (!_geom || !_geom.attributes || !_geom.attributes.offset) return;
        let count = _geom.attributes.offset.count + dir;
        (_offset = new Float32Array(3 * count)),
          (_scale = new Float32Array(3 * count)),
          (_quaternion = new Float32Array(4 * count)),
          _geom.attributes.offset.setArray(new Float32Array(3 * count)),
          _geom.attributes.scale.setArray(new Float32Array(3 * count)),
          _geom.attributes.orientation.setArray(new Float32Array(4 * count));
        for (let key in _attributes) {
          let components = _geom.attributes[key].itemSize;
          (_attributes[key] = new Float32Array(count * components)),
            _geom.attributes[key].setArray(
              new Float32Array(count * components)
            );
        }
        (_geom.maxInstancedCount = _objects.length), loop();
      }
      function dirty(a, b) {
        for (let i = a.length - 1; i > -1; i--) if (a[i] != b[i]) return !0;
        return !1;
      }
      function prepareMesh(mesh, i) {
        let pos = _v1,
          scale = _v2,
          quaternion = _q;
        if (_config.worldCoords)
          try {
            if (_config.parent > 0)
              switch (_config.parent) {
                case 1:
                  pos.copy(mesh._parent.position),
                    scale.copy(mesh._parent.scale),
                    quaternion.copy(mesh._parent.quaternion);
                  break;
                case 2:
                  pos.copy(mesh._parent._parent.position),
                    scale.copy(mesh._parent._parent.scale),
                    quaternion.copy(mesh._parent._parent.quaternion);
              }
            else
              _config.addParentPosition
                ? (pos.copy(mesh.position).add(mesh._parent.position),
                  2 == _config.addParentPosition &&
                    pos.add(mesh._parent._parent.position),
                  scale.copy(mesh.scale),
                  quaternion.copy(mesh.quaternion))
                : (pos.copy(mesh.getWorldPosition()),
                  scale.copy(mesh.getWorldScale()),
                  quaternion.copy(mesh.getWorldQuaternion()));
            _config.bypassVisibilityCheck ||
              mesh.determineVisible() ||
              (scale.x = scale.y = scale.z = 0);
          } catch (e) {
            pos.copy(mesh.position),
              scale.copy(mesh.scale),
              quaternion.copy(mesh.quaternion);
          }
        else
          pos.copy(mesh.position),
            scale.copy(mesh.scale),
            quaternion.copy(mesh.quaternion),
            _config.visibilityCheck &&
              !mesh.determineVisible() &&
              scale.setScalar(0);
        mesh.batchOffsetPos && pos.add(mesh.batchOffsetPos);
        let i3 = 3 * i,
          i4 = 4 * i;
        if (
          ((_offset[i3 + 0] = pos.x),
          (_offset[i3 + 1] = pos.y),
          (_offset[i3 + 2] = pos.z),
          (_scale[i3 + 0] = scale.x),
          (_scale[i3 + 1] = scale.y),
          (_scale[i3 + 2] = scale.z),
          (_quaternion[i4 + 0] = quaternion.x),
          (_quaternion[i4 + 1] = quaternion.y),
          (_quaternion[i4 + 2] = quaternion.z),
          (_quaternion[i4 + 3] = quaternion.w),
          mesh.attributes)
        )
          for (let key in mesh.attributes) {
            let attr = mesh.attributes[key],
              value = void 0 === attr.value ? attr : attr.value;
            value instanceof Color
              ? ((_attributes[key][3 * i + 0] = value.r),
                (_attributes[key][3 * i + 1] = value.g),
                (_attributes[key][3 * i + 2] = value.b))
              : value instanceof Vector3
              ? ((_attributes[key][3 * i + 0] = value.x),
                (_attributes[key][3 * i + 1] = value.y),
                (_attributes[key][3 * i + 2] = value.z))
              : value instanceof Vector4 || value instanceof Quaternion
              ? ((_attributes[key][4 * i + 0] = value.x),
                (_attributes[key][4 * i + 1] = value.y),
                (_attributes[key][4 * i + 2] = value.z),
                (_attributes[key][4 * i + 3] = value.w))
              : value instanceof Vector2
              ? ((_attributes[key][2 * i + 0] = value.x),
                (_attributes[key][2 * i + 1] = value.y))
              : (_attributes[key][i] = value);
          }
        if (_packedTexture) {
          let batchIndex = mesh.batchIndex,
            stride = 4 * _packedTexture.keys;
          for (let key in _packedData) {
            let offset = 4 * _packedData[key],
              value = mesh.packedData[key].value,
              index = batchIndex * stride + offset,
              r = (g = b = a = 1);
            value instanceof Color
              ? ((r = value.r), (g = value.g), (b = value.b))
              : value instanceof Vector3
              ? ((r = value.x), (g = value.y), (b = value.z))
              : value instanceof Vector4 || value instanceof Quaternion
              ? ((r = value.x), (g = value.y), (b = value.z), (a = value.w))
              : value instanceof Vector2
              ? ((r = value.x), (g = value.y))
              : (r = value),
              (_packedTexture.data[index + 0] = r),
              (_packedTexture.data[index + 1] = g),
              (_packedTexture.data[index + 2] = b),
              (_packedTexture.data[index + 3] = a);
          }
          _packedTexture.needsUpdate = !0;
        }
      }
      function updateBuffers() {
        if (_mesh) {
          dirty(_quaternion, _geom.attributes.orientation.array) &&
            (_geom.attributes.orientation.array.set(_quaternion),
            (_geom.attributes.orientation.needsUpdate = !0)),
            dirty(_offset, _geom.attributes.offset.array) &&
              (_geom.attributes.offset.array.set(_offset),
              (_geom.attributes.offset.needsUpdate = !0)),
            dirty(_scale, _geom.attributes.scale.array) &&
              (_geom.attributes.scale.array.set(_scale),
              (_geom.attributes.scale.needsUpdate = !0));
          for (let key in _attributes)
            dirty(_attributes[key], _geom.attributes[key].array) &&
              (_geom.attributes[key].array.set(_attributes[key]),
              (_geom.attributes[key].needsUpdate = !0));
        } else
          !(function initMesh() {
            if (
              (_geom.addAttribute(
                "offset",
                new GeometryAttribute(
                  new Float32Array(_offset),
                  3,
                  1,
                  _this.useDynamic
                )
              ),
              _geom.addAttribute(
                "scale",
                new GeometryAttribute(
                  new Float32Array(_scale),
                  3,
                  1,
                  _this.useDynamic
                )
              ),
              _geom.addAttribute(
                "orientation",
                new GeometryAttribute(
                  new Float32Array(_quaternion),
                  4,
                  1,
                  _this.useDynamic
                )
              ),
              _frustumCulled)
            ) {
              let box = new Box3();
              _objects.forEach((mesh) => box.expandByObject(mesh, !0)),
                (_geom.boundingBox = box),
                (_geom.boundingSphere = box.getBoundingSphere());
            }
            (_mesh = _this.usePoints
              ? new Points(_geom, _shader)
              : new Mesh(_geom, _shader)),
              _shader.castShadow && (_mesh.castShadow = !0),
              (_mesh.asyncPromise = _this.group.asyncPromise),
              _this.group.asyncPromise.resolve(),
              (_this.mesh = _mesh),
              (_this.shader = _mesh.shader),
              (_this.mesh.isMeshBatch = !0),
              _this.group.add(_mesh),
              (_mesh.frustumCulled = _frustumCulled),
              _renderOrder && (_mesh.renderOrder = _renderOrder),
              (_offset = new Float32Array(_offset)),
              (_quaternion = new Float32Array(_quaternion)),
              (_scale = new Float32Array(_scale));
            for (let key in _attributes) {
              _attributes[key] = new Float32Array(_attributes[key]);
              let components = 1,
                attr = _objects[0].attributes[key],
                value = attr.value || attr;
              value instanceof Vector3
                ? (components = 3)
                : value instanceof Vector4 || value instanceof Quaternion
                ? (components = 4)
                : value instanceof Color
                ? (components = 3)
                : value instanceof Vector2 && (components = 2),
                _geom.addAttribute(
                  key,
                  new GeometryAttribute(
                    new Float32Array(_attributes[key]),
                    components,
                    1,
                    _this.useDynamic
                  )
                );
            }
            _this.onMeshCreated && _this.onMeshCreated(_mesh);
          })();
      }
      async function initializeStatic() {
        let wasVisible = _this.group.determineVisible();
        if (
          (await ((_) => {
            let promise = Promise.create(),
              mesh = _list.start(),
              i = 0,
              worker = new Render.Worker((_) => {
                mesh.updateMatrixWorld(!0),
                  prepareMesh(mesh, i),
                  i++,
                  (mesh = _list.next()),
                  mesh || (worker.stop(), promise.resolve());
              }, 1);
            return promise;
          })(),
          updateBuffers(),
          wasVisible)
        ) {
          if (_frustumCulled) {
            let box = new Box3();
            _objects.forEach((mesh) => box.expandByObject(mesh, !0)),
              (_geom.boundingBox = box),
              (_geom.boundingSphere = box.getBoundingSphere());
          }
          _this.flag("isStaticReady", !0);
        } else
          await _this.wait(() => _this.group.determineVisible()),
            _static && initializeStatic();
      }
      function loop() {
        _static && _this.stopRender(loop, RenderManager.AFTER_LOOPS);
        let first = !_firstRender;
        _firstRender = !0;
        let i = 0,
          mesh = _list.start();
        for (; mesh; )
          (!1 !== mesh.batchNeedsUpdate || first) &&
            (first && mesh.updateMatrixWorld(!0), prepareMesh(mesh, i)),
            (mesh = _list.next()),
            i++;
        updateBuffers();
      }
      function firstLoop() {
        _static || _this.startRender(loop, RenderManager.AFTER_LOOPS), loop();
      }
      (_this.usePoints = !1),
        (_this.useDynamic = !1),
        (function () {
          if (
            (_input instanceof InputUILConfig ||
              ((_config = _input), (_input = null)),
            (_config = _config || {}),
            _input && _this.parent.ready(!0).then(initFromSceneLayout),
            (_this.group.asyncPromise = Promise.create()),
            Hydra.LOCAL)
          ) {
            let warning = setTimeout(() => {
              console.log(
                "Problem loading instance",
                _this?.parent?._config?.getFilePath?.("json")
              );
            }, 5e3);
            _this.group.asyncPromise.then(() => {
              clearTimeout(warning);
            });
          }
          Hydra.LOCAL &&
            (function initHotReload() {
              _this.events.sub(
                ShaderUIL.SHADER_UPDATE,
                ({ shader: shader }) => {
                  if (
                    _shader &&
                    _shader.vsName &&
                    shader.includes(_shader.vsName)
                  ) {
                    let newShader = new Shader(_shader.vsName, _shader.fsName);
                    delete MeshBatch.shaders[
                      `${_shader.vsName}|${_shader.fsName}`
                    ],
                      updateShader(newShader),
                      Shader.renderer.hotReloadClearProgram(_shader.vsName),
                      newShader.upload(_mesh, _geom),
                      _shader._gl && (_shader._gl = newShader._gl),
                      _shader._gpu && (_shader._gpu = newShader._gpu),
                      _shader._metal && (_shader._metal = newShader._metal);
                  }
                }
              );
            })();
        })(),
        (this.add = function (mesh) {
          _objects.push(mesh),
            _list.push(mesh),
            (mesh.uploadIgnore = !0),
            (mesh.batch = _this),
            _availableIndices &&
              !mesh.batchIndex &&
              ((mesh.batchIndex = _availableIndices.shift()),
              mesh.attributes || (mesh.attributes = {}),
              (mesh.attributes.batchIndex = { value: mesh.batchIndex }));
          let shader = mesh.shader;
          for (let key in shader.uniforms) {
            let uniform = shader.uniforms[key];
            if (
              uniform.value instanceof Color ||
              uniform.value instanceof Vector2 ||
              uniform.value instanceof Vector3 ||
              uniform.value instanceof Vector4 ||
              uniform.value instanceof Quaternion ||
              "number" == typeof uniform.value
            )
              if (uniform.batchUnique || _config.batchUnique)
                _uniformToAttrib.push(key),
                  mesh.attributes || (mesh.attributes = {}),
                  (mesh.attributes["a_" + key] = uniform);
              else if (
                (_uniformNoAttrib.includes(key) || _uniformNoAttrib.push(key),
                void 0 !== uniform.packedIndex)
              ) {
                if ((_packedData || (_packedData = {}), !_availableIndices))
                  throw "Can't use packedData without first setting .maxIndices";
                _packedData[key] || (_packedData[key] = uniform.packedIndex),
                  mesh.packedData || (mesh.packedData = {}),
                  (mesh.packedData[key] = uniform);
              }
          }
          _geom ||
            (function initGeometry(mesh) {
              if (
                ((_geom = new Geometry().instanceFrom(mesh.geometry)),
                (_this.geom = _geom),
                !_shader)
              ) {
                if (
                  (((_shader = mesh.shader.clone()).debug = !0),
                  _this.usePoints || mesh.shader.replicateUniformsTo(_shader),
                  _packedData)
                ) {
                  let total = Object.keys(_packedData).length,
                    pixels = Math.sqrt(_maxIndices * total),
                    size = Math.pow(
                      2,
                      Math.ceil(Math.log(pixels) / Math.log(2))
                    );
                  ((_packedTexture = new DataTexture(
                    new Float32Array(size * size * 4),
                    size,
                    size,
                    Texture.RGBAFormat,
                    Texture.FLOAT
                  )).keys = total),
                    _shader.addUniforms({
                      tPackedTexture: { value: _packedTexture },
                      uPackedInfo: {
                        value: new Vector3(total, size, _maxIndices),
                      },
                    });
                }
                updateShader(_shader, mesh.castShadow);
              }
              if (mesh.attributes)
                for (let key in mesh.attributes) _attributes[key] = [];
              _static && defer(initializeStatic);
            })(mesh),
            _mesh &&
              (modifyGeometry(1),
              _static &&
                console.error("Don't add more meshes to a static MeshBatch")),
            (mesh.shader.neverRender = !0),
            _static ||
              RenderManager.scheduleOne(firstLoop, RenderManager.AFTER_LOOPS);
        }),
        (this.remove = function (mesh) {
          _objects.includes(mesh) &&
            (_objects.remove(mesh),
            _list.remove(mesh),
            mesh.batchIndex > -1 &&
              !mesh.persistBatchIndex &&
              (_availableIndices.push(mesh.batchIndex),
              _availableIndices.sort((a, b) => a - b)),
            modifyGeometry(-1));
        }),
        (this.onDestroy = function () {
          _this.mesh && _this.mesh.destroy && _this.mesh.destroy(),
            delete MeshBatch.shaders[_shaderKey];
        }),
        (this.loadFromFile = async function (shader, geomFile, instanceFile) {
          geomFile.includes("assets/geometry") ||
            (geomFile = "assets/geometry/" + geomFile),
            geomFile.includes(".json") || (geomFile += ".json"),
            instanceFile.includes("assets/geometry") ||
              (instanceFile = "assets/geometry/" + instanceFile),
            instanceFile.includes(".json") || (instanceFile += ".json");
          let [geom, data] = await Promise.all([
              GeomThread.loadGeometry(Assets.getPath(geomFile)),
              get(Assets.getPath(instanceFile)),
            ]),
            array = [],
            count = data.offset.buffer.length / 3;
          for (let i = 0; i < count; i++) {
            let mesh = new Mesh(geom, shader);
            mesh.position.fromArray(data.offset.buffer, 3 * i),
              mesh.scale.fromArray(data.scale.buffer, 3 * i),
              mesh.quaternion.fromArray(data.orientation.buffer, 4 * i),
              array.push(mesh),
              _this.add(mesh);
          }
          return await _this.ready(), array;
        }),
        (this.ready = function () {
          return _this.wait("mesh");
        }),
        (this.staticReady = function () {
          if (_static) return _this.wait("isStaticReady");
        }),
        (this.getMeshByIndex = function (index) {
          return _objects[index];
        }),
        (this.getMeshCount = function () {
          return _objects.length;
        }),
        this.get("static", () => _static),
        this.set("static", (b) => {
          !!b !== _static &&
            ((_static = !!b),
            _objects.length &&
              (_static &&
                console.warn(
                  "For better initialization performance, set meshBatch.static before adding any meshes"
                ),
              _this.stopRender(loop, RenderManager.AFTER_LOOPS),
              RenderManager.scheduleOne(firstLoop, RenderManager.AFTER_LOOPS)));
        }),
        this.set("maxIndices", (value) => {
          if (
            ((_maxIndices = value),
            !(_availableIndices = _config.availableIndices || []).length)
          )
            for (let i = 0; i < value; i++) _availableIndices[i] = i;
        }),
        this.get("attributes", (_) => _attributes),
        this.get("maxIndices", (_) => _maxIndices),
        this.set("renderOrder", (v) => {
          (_renderOrder = v), _mesh && (_mesh.renderOrder = v);
        }),
        this.get("renderOrder", (_) => _renderOrder),
        this.set("frustumCulled", (b) => {
          (_frustumCulled = b), _mesh && (_mesh.frustumCulled = b);
        }),
        (this.applyToShader = function (
          shader,
          castShadow = shader.mesh?.castShadow ?? !1
        ) {
          updateShader(shader, castShadow);
        });
    },
    (_) => {
      MeshBatch.shaders = {};
    }
  ),
  Class(
    function MeshMerge(_input, _dynamic) {
      Inherit(this, Object3D);
      const _this = this;
      var _mesh,
        _geom,
        _texture,
        _shaderKey,
        _meshes = [],
        _pending = [],
        _index = 0;
      function initDynamic() {
        let array = new Float32Array(1024);
        ((_texture = new DataTexture(
          array,
          16,
          16,
          Texture.RGBAFormat,
          Texture.FLOAT
        )).dynamic = !0),
          (_texture.promise = Promise.resolve()),
          (function updateShader(shader) {
            (shader.customCompile = `${shader.vsName}|${shader.fsName}|dynamicMerge`),
              shader.addUniforms({ tDynamicMerge: { value: _texture } });
            let cached = MeshMerge.shaders[`${shader.vsName}|${shader.fsName}`];
            if (cached)
              return (
                (shader.fragmentShader = cached.fragment), shader.resetProgram()
              );
            shader.resetProgram();
            let vsSplit = shader.vertexShader.split("__ACTIVE_THEORY_LIGHTS__");
            if (!vsSplit[1].includes("vec3 pos = position;"))
              throw `Shader ${shader.vsName} needs to have "vec3 pos = position;" in order for dynamic merging to work`;
            (vsSplit[0] += "attribute float mIndex;\n"),
              (vsSplit[0] += "uniform sampler2D tDynamicMerge;\n"),
              (vsSplit[0] += "vec3 offset;\n"),
              (vsSplit[0] += "vec3 scale;\n"),
              (vsSplit[0] += "vec4 orientation;\n"),
              shader.vertexShader.includes("vec3 transformPosition") ||
                (vsSplit[0] += Shaders.getShader("instance.vs") + "\n");
            (vsSplit[0] +=
              "\n        vec2 getDMUV(float index, float offset) {\n            float pixel = (index*3.0) + offset;\n        \n            float size = 16.0;\n            float p0 = pixel / size;\n            float y = floor(p0);\n            float x = p0 - y;\n        \n            vec2 uv = vec2(0.0);\n            uv.x = x;\n            uv.y = y / size;\n            return uv;\n        }\n        \n"),
              (vsSplit[1] = vsSplit[1].replace(
                /vec3 pos = position;/g,
                "vec3 pos = transformPosition(position, offset, scale, orientation);"
              )),
              (vsSplit[1] = vsSplit[1].replace(
                /vNormal = normalMatrix \* normal;/g,
                "vNormal = normalMatrix * transformNormal(normal, orientation);"
              )),
              (vsSplit[1] = vsSplit[1].replace(
                /vec3 transformedNormal = normal;/g,
                "vec3 transformedNormal = transformNormal(normal, orientation);"
              ));
            let oso =
                "\n        offset = texture2D(tDynamicMerge, getDMUV(mIndex, 0.0)).xyz;\n        scale = texture2D(tDynamicMerge, getDMUV(mIndex, 1.0)).xyz;\n        orientation = texture2D(tDynamicMerge, getDMUV(mIndex, 2.0));\n        ",
              main = vsSplit[1].split("main() {");
            (main[1] = "\n" + oso + main[1]),
              (vsSplit[1] = main.join("main() {")),
              (vsSplit = vsSplit.join("__ACTIVE_THEORY_LIGHTS__")),
              (shader.vertexShader = vsSplit),
              (_shaderKey = `${shader.vsName}|${shader.fsName}`),
              (MeshMerge.shaders[_shaderKey] = { vertex: shader.vertexShader });
          })(_mesh.shader);
        let loop = (_) => {
          for (let i = _meshes.length - 1; i > -1; i--) {
            let mesh = _meshes[i],
              index = mesh.mergeIndex;
            (array[12 * index + 0] = mesh.position.x),
              (array[12 * index + 1] = mesh.position.y),
              (array[12 * index + 2] = mesh.position.z),
              (array[12 * index + 3] = 1),
              (array[12 * index + 4] = mesh.scale.x),
              (array[12 * index + 5] = mesh.scale.y),
              (array[12 * index + 6] = mesh.scale.z),
              (array[12 * index + 7] = 1),
              (array[12 * index + 8] = mesh.quaternion.x),
              (array[12 * index + 9] = mesh.quaternion.y),
              (array[12 * index + 10] = mesh.quaternion.z),
              (array[12 * index + 11] = mesh.quaternion.w);
          }
        };
        defer(loop), _this.startRender(loop);
      }
      function completeMerge() {
        (_mesh.geometry = _geom),
          _mesh.asyncPromise.resolve(),
          _this.onMeshCreated && _this.onMeshCreated(_mesh),
          (_this.mesh = _mesh);
      }
      async function initFromSceneLayout() {
        let wildcard = _input.get("wildcard");
        if (!wildcard || !wildcard.length) return;
        let [groupName, dynamic] = wildcard.split("|");
        await _this.parent.loadedAllLayers();
        let group = await _this.parent.getLayer(groupName);
        _dynamic = "dynamic" == dynamic;
        let children = [...group.children];
        children.sort((a, b) => a.renderOrder - b.renderOrder),
          children.forEach((mesh) => _this.add(mesh)),
          group.add(_this.group),
          MeshMerge.cache[_input.prefix] ||
            (MeshMerge.cache[_input.prefix] = Promise.create());
      }
      !(function () {
        if ("object" == typeof _input) {
          if (!1 === _input.get("visible")) return;
          _this.parent.ready().then(initFromSceneLayout);
        } else "boolean" == typeof _input && (_dynamic = _input);
      })(),
        (this.onDestroy = function () {
          _mesh.destroy(), delete MeshBatch.shaders[_shaderKey];
        }),
        (this.ready = function () {
          return _this.wait("mesh");
        }),
        (this.add = function (mesh) {
          if (((mesh.uploadIgnore = !0), !mesh.visible)) return;
          if (
            ((mesh.merge = _this),
            mesh.updateMatrixWorld(!0),
            _mesh ||
              (async function initMesh(mesh) {
                if (
                  (((_mesh = new Mesh(World.QUAD, mesh.shader)).asyncPromise =
                    Promise.create()),
                  _this.group.add(_mesh),
                  _input?.get &&
                    ((_mesh.castShadow = _input.get("castShadow")),
                    (_mesh.shader.receiveShadow = _input.get("receiveShadow"))),
                  _dynamic && initDynamic(),
                  _input?.prefix)
                ) {
                  let cached = MeshMerge.cache[_input.prefix];
                  if (cached)
                    return (_geom = await cached), void completeMerge();
                }
                await defer();
                let data = await Promise.all(_pending),
                  buffers = [];
                data.forEach((obj) => {
                  for (let key in obj)
                    obj[key].buffer && buffers.push(obj[key].buffer);
                });
                let merged = await Thread.shared().meshMergeComplete(
                  { data: data },
                  buffers
                );
                _geom = new Geometry();
                for (let key in merged)
                  "components" !== key &&
                    _geom.addAttribute(
                      key,
                      new GeometryAttribute(merged[key], merged.components[key])
                    );
                merged.indexBuffer && (_geom.index = merged.indexBuffer),
                  _input?.prefix &&
                    MeshMerge.cache[_input.prefix].resolve(_geom),
                  completeMerge();
              })(mesh),
            _input?.prefix)
          ) {
            if (MeshMerge.cache[_input.prefix])
              return (
                (mesh.visible = !1),
                _meshes.push(mesh),
                void (mesh.mergeIndex = _index++)
              );
          }
          let geom = mesh.geometry;
          if (mesh.attributes)
            for (let key in mesh.attributes) {
              let attr = mesh.attributes[key];
              attr instanceof Vector4 && (attr.isVector4 = !0),
                attr instanceof Vector3 && (attr.isVector3 = !0),
                attr instanceof Vector2 && (attr.isVector2 = !0),
                attr instanceof Color && (attr.isColor = !0);
            }
          let data = {},
            components = {},
            buffers = [];
          for (let key in geom.attributes)
            (data[key] = new Float32Array(geom.attributes[key].array)),
              buffers.push(data[key].buffer),
              (components[key] = geom.attributes[key].itemSize);
          geom.index &&
            ((data.indexBuffer = new Uint32Array(geom.index)),
            buffers.push(data.indexBuffer.buffer)),
            (data.attributes = mesh.attributes),
            (data.components = components),
            (data.matrix =
              "world" == _input
                ? mesh.matrixWorld.elements
                : mesh.matrix.elements),
            _dynamic && (data.matrix = null),
            (data.dynamic = _dynamic),
            (data.index = mesh.mergeIndex = _index++),
            (mesh.visible = !1),
            _meshes.push(mesh),
            _pending.push(Thread.shared().meshMergeTransform(data, buffers));
        }),
        (this.onDestroy = function () {
          _input?.prefix && delete MeshMerge.cache[_input.prefix];
        });
    },
    (_) => {
      Thread.upload(function meshMergeTransform(e, id) {
        let geom = new Geometry();
        for (let key in e)
          !key.includes(["components", "matrix"]) &&
            e[key] instanceof Float32Array &&
            geom.addAttribute(
              key,
              new GeometryAttribute(e[key], e.components[key])
            );
        if ((e.indexBuffer && (geom.index = e.indexBuffer), e.attributes))
          for (let key in e.attributes) {
            let components = 1,
              attr = e.attributes[key];
            attr.isVector4
              ? (components = 4)
              : attr.isVector3 || attr.isColor
              ? (components = 3)
              : attr.isVector2 && (components = 2);
            let buffer = new Float32Array(
                geom.attributes.position.count * components
              ),
              step = buffer.length / components;
            for (let i = 0; i < step; i++)
              4 == components
                ? ((buffer[4 * i + 0] = attr.x),
                  (buffer[4 * i + 1] = attr.y),
                  (buffer[4 * i + 2] = attr.z),
                  (buffer[4 * i + 3] = attr.w))
                : 3 == components
                ? ((buffer[3 * i + 0] = attr.x || attr.r || 0),
                  (buffer[3 * i + 1] = attr.y || attr.g || 0),
                  (buffer[3 * i + 2] = attr.z || attr.b || 0))
                : 2 == components
                ? ((buffer[2 * i + 0] = attr.x), (buffer[2 * i + 1] = attr.y))
                : (buffer[i] = attr);
            geom.addAttribute(key, new GeometryAttribute(buffer, components));
          }
        e.matrix && geom.applyMatrix(new Matrix4().fromArray(e.matrix));
        let indexBuffer = new Float32Array(geom.attributes.position.count);
        for (let i = 0; i < indexBuffer.length; i++) indexBuffer[i] = e.index;
        geom.addAttribute("mIndex", new GeometryAttribute(indexBuffer, 1));
        let data = {},
          buffers = [],
          components = {};
        for (let key in geom.attributes)
          (data[key] = geom.attributes[key].array),
            (components[key] = geom.attributes[key].itemSize),
            buffers.push(data[key].buffer);
        geom.index &&
          ((data.indexBuffer = geom.index),
          buffers.push(data.indexBuffer.buffer)),
          (data.components = components),
          resolve(data, id, buffers);
      }),
        Thread.upload(function meshMergeComplete({ data: data }, id) {
          let _geom;
          data.forEach((data) => {
            let geom = new Geometry();
            for (let key in data)
              "components" != key &&
                ("indexBuffer" == key
                  ? (geom.index = data[key])
                  : geom.addAttribute(
                      key,
                      new GeometryAttribute(data[key], data.components[key])
                    ));
            _geom ? _geom.merge(geom) : (_geom = geom);
          });
          let result = {},
            components = {},
            buffers = [];
          for (let key in _geom.attributes)
            (result[key] = _geom.attributes[key].array),
              (components[key] = _geom.attributes[key].itemSize),
              buffers.push(result[key].buffer);
          _geom.index &&
            ((result.indexBuffer = _geom.index),
            buffers.push(result.indexBuffer.buffer)),
            (result.components = components),
            resolve(result, id, buffers);
        }),
        (MeshMerge.shaders = {}),
        (MeshMerge.cache = {});
    }
  ),
  Class(function OptimizationProfiler() {
    Inherit(this, Component);
    const _this = this;
    var _shaders, _count, _gradientStops, _color;
    function getGradientColor(alpha, ease = "Sine") {
      !(function initGradientColors() {
        _gradientStops ||
          (_gradientStops = [
            new Color("#28c913"),
            new Color("#ffde0a"),
            new Color("#ff0000"),
          ]),
          _color || (_color = new Color());
      })();
      let lastIndex = _gradientStops.length - 1,
        index = Math.clamp(alpha) * lastIndex;
      if (index >= lastIndex) return _color.copy(_gradientStops[lastIndex]);
      let stop0 = Math.floor(index);
      return (
        (alpha = TweenManager.Interpolation[ease].InOut(Math.fract(index))),
        _color
          .copy(_gradientStops[stop0])
          .lerp(_gradientStops[stop0 + 1], alpha, !1)
      );
    }
    function getGradientHexString(alpha, ease) {
      return getGradientColor(alpha, ease).getHexString();
    }
    (this.active =
      Utils.query("optimizationProfiler") ||
      location.hash?.includes("optimizationProfiler")),
      _this.active &&
        ((_shaders = []),
        (_count = Number(
          String(Utils.query("optimizationProfiler")) ||
            location.hash.split("optimizationProfiler=")[1]?.split("&")[0]
        )),
        isNaN(_count) && (_count = null)),
      (this.setupShader = function (shader) {
        shader.addUniforms({
          texDimensions: { value: 0 },
          texelsPerMeter: { value: _count },
        });
        const parse = (_) => {
          for (let key in shader.uniforms) {
            let value = shader.uniforms?.[key]?.value;
            value instanceof Texture &&
              (value.data ||
                (value.dimensions
                  ? (shader.uniforms.texDimensions.value = Math.max(
                      shader.uniforms.texDimensions.value,
                      Math.max(value.dimensions.width, value.dimensions.height)
                    ))
                  : value.promise?.then(parse)));
          }
        };
        _shaders.push(shader), parse();
      }),
      (this.override = function (shader, vsCode, fsCode) {
        let vs = vsCode,
          fs = fsCode,
          enabled = !!_count,
          mesh = shader?.mesh;
        if (
          ((enabled = enabled && mesh instanceof Mesh),
          (enabled = enabled && mesh.geometry !== World.QUAD),
          (enabled = enabled && fsCode.includes("vUv")),
          enabled)
        )
          try {
            !(function () {
              (vs = vs.slice(0, -(vs.length - vs.lastIndexOf("}")))),
                (vs += `vDensityPos = ${
                  vs.includes("vec3 pos ") ? "pos" : "position"
                };\n`),
                (vs += "}");
              let split = vs.split("void main");
              (split[0] += "\n        out vec3 vDensityPos;\n        "),
                (vs = split.join("void main"));
            })(),
              (function () {
                (fs = fs.slice(0, -(fs.length - fs.lastIndexOf("}")))),
                  (fs += "FragColor = vec4(getDensityColor(), 1.0);\n"),
                  (fs += "}");
                let split = fs.split("void main");
                (split[0] +=
                  "\n        #define TEXEL_DENSITY_EPSILON 10e-10\n        uniform float texDimensions;\n        uniform float texelsPerMeter;\n        in vec3 vDensityPos;\n \nfloat MipLevel(vec2 uv)\n{\n  vec2 dx = dFdx(uv);\n  vec2 dy = dFdy(uv);\n  float d = max( dot(dx, dx), dot(dy, dy) );\n \n  float maxRange = pow(2., (10.0 - 1.) * 2.);\n  d = clamp(d, 1., maxRange);\n \n  float mipLevel = 0.5 * log2(d);\n  return floor(mipLevel);\n}\n\nvec3 getDensityColor() {\n    vec2 uv = vUv.xy;\n    \n    float texWidth = texDimensions;\n    float texHeight = texDimensions;\n\n    vec2 ddxUV  = dFdx(uv * texWidth  / texelsPerMeter);\n    vec2 ddyUV  = dFdy(uv * texHeight / texelsPerMeter);\n    vec3 ddxPos = dFdx(vDensityPos);\n    vec3 ddyPos = dFdy(vDensityPos);\n\t\n\t// NOTE(jserrano): check LOD ?\n\t//float mipLevel = MipLevel(uv * texDimensions);\n    //float mipSize  = pow(2., mipLevel);\n    \n    //ddxUV /= mipSize;\n    //ddyUV /= mipSize;\n\n    float uvArea   = length( cross(vec3(ddxUV,0), vec3(ddyUV,0)) );\n    float faceArea = length( cross(ddxPos, ddyPos) );\n\tfloat density  = uvArea / max(10e-10, faceArea);\n    \n    const float lowRatioLimit  = 0.8;\n    const float midRatio       = 1.0;\n    const float highRatioLimit = 1.2;\n    \n    vec3 finalColor = vec3(0);\n    \n\tif (density > lowRatioLimit && density < highRatioLimit)\n\t{\n        vec3 lowDensityColor  = vec3( 1., 1., 1. );\n        vec3 midDensityColor  = vec3( 0., 1., 0. );\n        vec3 highDensityColor = vec3( 0., 0., 0. );\n        \n        vec3 lowColorStep = mix( lowDensityColor, midDensityColor, smoothstep(lowRatioLimit, midRatio, density) );\n        finalColor = mix( lowColorStep, highDensityColor, smoothstep(midRatio, highRatioLimit, density) );\n\t}\n    else if (density > highRatioLimit)\n    {\n        vec3 lowDensityColor  = vec3( 1., 1., 0. );\n        vec3 highDensityColor = vec3( 1., 0., 0. );\n        \n        float ratio = smoothstep(highRatioLimit, 2., density);\n        finalColor = mix( lowDensityColor, highDensityColor, ratio );\n    }\n    else\n    {\n        vec3 lowDensityColor  = vec3( 0., 0., 1. );\n        vec3 highDensityColor = vec3( 0., 1., 1. );\n        \n        float ratio = smoothstep(0., lowRatioLimit, density);\n        finalColor = mix( lowDensityColor, highDensityColor, ratio );\n    }\n\n    return finalColor;\n}\n        "),
                  (fs = split.join("void main"));
              })();
          } catch (e) {
            (vs = vsCode), (fs = fsCode);
          }
        return [vs, fs];
      }),
      (this.logTextures = function () {
        if (!this.active)
          return void console.log("Add optimizationProfiler in the URL!");
        let map = new Map();
        _shaders?.forEach((shader) => {
          if (!shader._gl) return;
          let sceneLayout,
            uilName = shader.mesh?.uilName;
          if (uilName) {
            let parent = shader.mesh._parent;
            for (; parent; ) {
              if (parent.classRef?.name) {
                sceneLayout = parent.classRef;
                break;
              }
              parent = parent._parent;
            }
          }
          for (let key in shader.uniforms) {
            let value = shader.uniforms?.[key]?.value;
            if (value instanceof Texture && !value.data && value.dimensions) {
              if (!map.has(value)) {
                let size = Math.max(
                  value.dimensions.width,
                  value.dimensions.height
                );
                map.set(value, { sceneLayouts: {}, shaders: {}, size: size });
              }
              let info = map.get(value);
              sceneLayout &&
                (info.sceneLayouts[sceneLayout.name] ||
                  (info.sceneLayouts[sceneLayout.name] = {}),
                (info.sceneLayouts[sceneLayout.name][uilName] = !0)),
                info.shaders[shader.fsName] ||
                  (info.shaders[shader.fsName] = {}),
                (info.shaders[shader.fsName][key] = !0);
            }
          }
        });
        let textures = Array.from(map.keys());
        textures.sort((a, b) => map.get(b).size - map.get(a).size),
          textures.forEach((texture) => {
            let info = map.get(texture),
              sceneLayouts = Object.keys(info.sceneLayouts),
              shaders = Object.keys(info.shaders),
              name = texture.src;
            if (
              (!name &&
                sceneLayouts.length &&
                (name = Object.keys(info.sceneLayouts[sceneLayouts[0]])[0]),
              !name)
            ) {
              let uniforms = Object.keys(info.shaders[shaders[0]]);
              name = `${shaders[0]}/${uniforms[0]}`;
            }
            console.group(name);
            let compressed,
              bgColor = getGradientHexString(
                Math.range(info.size, 512, 1024, 0, 0.5),
                "Cubic"
              );
            (compressed =
              "ktx2" === texture.compressed
                ? "✅ (ktx2)"
                : texture.compressed
                ? "⚠️ (ktx1)"
                : "❌"),
              console.log(
                `%c ${info.size}`,
                `background-color: ${bgColor}; color: #000000;`,
                `Compressed: ${compressed}`
              );
            for (let sceneLayout in info.sceneLayouts)
              console.log(
                `${sceneLayout}: ${Object.keys(
                  info.sceneLayouts[sceneLayout]
                ).join(", ")}`
              );
            for (let shader in info.shaders)
              console.log(
                `${shader}: ${Object.keys(info.shaders[shader]).join(", ")}`
              );
            console.groupEnd(name);
          });
      }),
      (this.logVertices = function (sort = !1) {
        if (!_shaders || !_shaders.length) return;
        let total = 0,
          shaders = _shaders
            .filter(
              (shader) =>
                shader._gl &&
                Boolean(shader?.mesh?.geometry) &&
                !(shader?.mesh instanceof Points)
            )
            .map((shader) => ({
              shader: shader,
              count: shader.mesh.geometry.isInstanced
                ? shader.mesh.geometry.attributes.position.count *
                  shader.mesh.geometry.maxInstancedCount
                : shader.mesh.geometry.attributes.position.count,
            }));
        sort && (shaders = shaders.sort((a, b) => b.count - a.count)),
          shaders.forEach(({ shader: shader, count: count }) => {
            (total += count),
              console.group(shader.mesh.uilName || shader.fsName),
              shader.mesh.uilName || console.log(shader.mesh),
              console.log(
                `%c ${
                  shader.mesh.geometry.isInstanced ? "Instanced" : ""
                } Vertices ${count}`,
                `background-color: ${(function bgColor(count) {
                  return getGradientHexString(
                    Math.range(count, 15e3, 3e4, 0, 0.5)
                  );
                })(count)}; color: #000000;`
              ),
              console.groupEnd();
          }),
          console.log(
            "%c TOTAL VERTICES " + total,
            "background-color: #ff00ff; color: #000000;"
          );
      });
  }, "static"),
  Class(function RTPool(
    _type,
    _size = 3,
    _format,
    _multisample = !1,
    _samplesAmount = 4
  ) {
    Inherit(this, Component);
    const _this = this;
    var _pool,
      _indexed = {};
    (this.nullRT = Utils3D.createRT(2, 2)), (this.nullRT.setSize = () => {});
    var _array = [],
      _resizeDisabled = !1;
    function createRT() {
      let rt = Utils3D.createRT(
        Stage.width * World.DPR,
        Stage.height * World.DPR,
        _type,
        _format,
        _multisample,
        _samplesAmount
      );
      return (rt.index = _pool.length()), rt;
    }
    function addListeners() {
      _resizeDisabled || _this.events.sub(Events.RESIZE, resizeHandler);
    }
    function resizeHandler() {
      _array.forEach((rt) => {
        rt.setSize(Stage.width * World.DPR, Stage.height * World.DPR);
      });
    }
    !(function initPool() {
      _pool = new ObjectPool();
      for (let i = 0; i < _size; i++) {
        let rt = createRT();
        _pool.put(rt), _array.push(rt);
      }
    })(),
      defer(addListeners),
      this.get("array", (_) => _array),
      (this.getRT = function (index) {
        return index
          ? (_indexed[index] || (_indexed[index] = createRT()), _indexed[index])
          : _pool.get() || createRT();
      }),
      (this.putRT = function (rt) {
        rt.scissor && delete rt.scissor, rt !== _this.nullRT && _pool.put(rt);
      }),
      (this.setSize = function (width, height) {
        _this.disableResize(),
          _array.forEach((rt) => {
            rt.setSize(width, height);
          });
      }),
      (this.onDestroy = function () {
        let p = _pool.get();
        for (; p; ) p.dispose(), (p = _pool.get());
      }),
      (this.clone = function (
        type = _type,
        size = _size,
        format = _format,
        multisample = _multisample,
        samplesAmount = _samplesAmount
      ) {
        return new RTPool(type, size, format, multisample, samplesAmount);
      }),
      (this.disableResize = function () {
        (_resizeDisabled = !0),
          _this.events.unsub(Events.RESIZE, resizeHandler);
      });
  },
  "singleton"),
  Class(function PerformanceAnalyzer() {
    Inherit(this, Component);
    const _this = this;
    var _lowFrame = 0;
    function startRender() {
      _this.startRender(loop);
    }
    function loop() {
      let targetDelta = 1e3 / Render.REFRESH_RATE,
        realDelta = Render.DELTA;
      Math.abs(targetDelta - realDelta) > 2 &&
        ++_lowFrame > 2 * Render.REFRESH_RATE &&
        (_this.stopRender(loop),
        (function reportLowFPS() {
          Dev.postPerfLog({ message: "Unable to meet target framerate" });
        })());
    }
    Hydra.LOCAL &&
      (function init() {
        _this.delayedCall(startRender, 1e4);
      })();
  }, "static"),
  Class(function RenderCount() {
    const _this = this;
    var $container,
      LOG,
      _map = {},
      _display = {};
    (this.map = _map),
      (async function () {
        await Hydra.ready(),
          (_this.active = Utils.query("uil") || Utils.query("renderCount")),
          (LOG = _this.active && Utils.query("log")),
          Utils.query("renderCount") &&
            (async function initUIL() {
              await Hydra.ready(),
                ($container = Stage.create("RenderCount"))
                  .css({
                    width: 175,
                    height: "auto",
                    paddingBottom: 5,
                    bottom: 0,
                    maxHeight: 400,
                    overflowY: "scroll",
                  })
                  .bg("#111")
                  .setZ(9999999);
            })();
      })(),
      (this.add = function (name, detail, amt = 1) {
        if (_this.active) {
          if (void 0 === _map[name] && ((_map[name] = 0), $container)) {
            let $wrapper = $container.create("wrapper");
            $wrapper.css({ position: "relative", width: "100%", height: 20 }),
              ($wrapper.label = $wrapper.create("label")),
              $wrapper.label
                .fontStyle("Arial", 12, "#fff")
                .text(name)
                .css({ left: 10 }),
              ($wrapper.value = $wrapper.create("value")),
              $wrapper.value
                .fontStyle("Arial", 12, "#fff")
                .text(0)
                .css({ right: 10 }),
              (_display[name] = $wrapper);
          }
          LOG &&
            (console.groupCollapsed(name),
            detail && console.log(detail),
            console.trace(),
            console.groupEnd()),
            (_map[name] += amt),
            _display[name]?.value?.text?.(_map[name] || "0");
        }
      }),
      (this.remove = function (name, amt = 1) {
        _this.active &&
          _map[name] &&
          ((_map[name] -= amt),
          _display[name]?.value?.text?.(_map[name] || "0"));
      });
  }, "static"),
  Class(function RenderMonitor() {
    Inherit(this, Component);
    const _this = this;
    let $container,
      $frameDuration,
      $buttonContainer,
      $queryStats,
      $activeToggle,
      $logButton,
      _paused = !1,
      $queries = [],
      _frameDuration = 0,
      _queries = [],
      _results = {},
      _ticker = 0,
      _prevResults = {},
      _capturingResult = !1;
    const FRAME_INTERVAL = Render.REFRESH_RATE || 60;
    function getToggleLabel() {
      return _paused ? "resume" : "pause";
    }
    function getQueryName(q) {
      return q?.obj?.mesh?.uilName
        ? `${q?.obj?.fsName} - ${q?.obj?.mesh?.uilName}` || "fs name missing"
        : q?.obj?.fsName || "fs name missing";
    }
    function createQueryResult(q) {
      const queryEl = $queryStats.create("query-result");
      queryEl.css({
        position: "relative",
        width: "100%",
        display: "flex",
        justifyContent: "space-between",
        alignItems: "ceter",
      });
      let name = getQueryName(q);
      "BlitPass" === name && (name = "BlitPass (MSAA?)"),
        (q.obj.__renderstatsname = name),
        (queryEl.name = queryEl.create("shader-name").text(name)),
        queryEl.name.css({
          position: "relative",
          color: "#ffffff",
          fontSize: "14px",
          opacity: 0.85,
        }),
        (queryEl.duration = queryEl.create("render-duration")),
        queryEl.duration.text(
          `${Math.round(q?.duration / q?.resultCount, 2).toFixed(2)} ms`
        ),
        queryEl.duration.css({
          position: "relative",
          color: "#ffffff",
          fontSize: "14px",
          fontVariant: "tabular-nums",
        }),
        queryEl.interact(
          (e) => {
            queryEl.name.css({ opacity: "over" === e.action ? 1 : 0.85 });
          },
          (_) => logResult(name, q)
        ),
        $queries.push(queryEl);
    }
    function captureResults() {
      if (_paused)
        for (let key in _prevResults) {
          const q = _prevResults[key];
          logResult(getQueryName(q), q);
        }
      _capturingResult = !0;
    }
    function logResult(name, q) {
      console.group(name),
        console.log(q.obj.mesh || q.obj),
        console.log(
          `render duration: ${Math.round(q?.duration / q?.resultCount, 2)}`
        ),
        console.groupEnd();
    }
    function updateResults(query) {
      const key = `${query.id} ${query.queryObject.fsName}`;
      _results.hasOwnProperty(key)
        ? ((_results[key].duration += query.timeElapsed),
          _results[key].resultCount++)
        : (_results[key] = {
            obj: query.queryObject,
            duration: query.timeElapsed,
            resultCount: 1,
          }),
        (query.queryObject.renderTimeQuery = null),
        query.destroy();
    }
    function updateStats() {
      _this.active &&
        (_paused ||
          (_ticker % FRAME_INTERVAL == 0 &&
            (function displayResults() {
              $queries.forEach(($q) => $q.destroy()), ($queries.length = 0);
              for (let key in _results) _results[key].duration;
              const resultsAsArray = Object.entries(_results);
              resultsAsArray.sort((a, b) => b[1].duration - a[1].duration),
                (_results = Object.fromEntries(resultsAsArray));
              for (let key in _results)
                (_frameDuration +=
                  _results[key].duration / _results[key].resultCount),
                  createQueryResult(_results[key]);
              $frameDuration?.duration.text(
                `${Math.round(_frameDuration, 2).toFixed(2)} ms`
              ),
                (_frameDuration = 0),
                (_capturingResult = !1),
                (_prevResults = { ..._results }),
                (_results = {}),
                (_queries = []);
            })(),
          _ticker++));
    }
    !(async function () {
      await Hydra.ready(),
        (_this.active =
          Utils.query("renderMonitor") || Utils.query("rendermonitor")),
        _this.active &&
          (function initUIL() {
            $container = Stage.create("RenderMonitor");
            const w = Device.mobile ? 375 : 500;
            $container
              .css({
                position: "fixed",
                width: `${w}px`,
                height: "auto",
                maxHeight: "300px",
                minHeight: "min-content",
                padding: 15,
                bottom: 0,
                left: 0,
                whiteSpace: "no-wrap",
              })
              .bg("#111")
              .setZ(99999),
              ($buttonContainer = $container.create(
                "render-monitor-button-container"
              )),
              $buttonContainer.css({
                position: "relative",
                width: "min-content",
                display: "flex",
                justifyContent: "space-between",
                alignItems: "center",
              }),
              ($activeToggle = $buttonContainer.create(
                "render-monitor-active-toggle",
                "button"
              )),
              $activeToggle.text(getToggleLabel()),
              $activeToggle.css({
                position: "relative",
                marginBottom: "15px",
                marginRight: "5px",
                cursor: "pointer",
              }),
              ($activeToggle.div.onclick = () => {
                (_paused = !_paused), $activeToggle.text(getToggleLabel());
              }),
              ($logButton = $buttonContainer.create(
                "render-monitor-log",
                "button"
              )),
              $logButton.text("capture results"),
              $logButton.css({
                position: "relative",
                width: "max-content",
                marginBottom: "15px",
                whiteSpace: "no-wrap",
                cursor: "pointer",
              }),
              ($logButton.div.onclick = () => {
                captureResults();
              }),
              ($frameDuration = $container.create("frame-duration")),
              $frameDuration.css({
                position: "relative",
                width: "100%",
                display: "flex",
                justifyContent: "space-between",
                alignItems: "center",
                marginBottom: "20px",
              }),
              ($frameDuration.label = $frameDuration
                .create("frame-duration-label")
                .text("Total frame")),
              $frameDuration.label.css({
                position: "relative",
                color: "#ffffff",
                fontSize: "14px",
                paddingRight: "14px",
              }),
              ($frameDuration.duration = $frameDuration
                .create("frame-duration-label")
                .text(_frameDuration)),
              $frameDuration.duration.css({
                position: "relative",
                color: "#ffffff",
                fontSize: "14px",
              }),
              ($queryStats = $container.create("query-stats")),
              $queryStats.css({
                position: "relative",
                maxHeight: "200px",
                overflowY: "scroll",
                paddingBottom: "20px",
              });
          })(),
        _this.active && (Render.endFrame = updateStats);
    })(),
      this.get("results", (_) => _results),
      this.get("queries", (_) => _queries),
      this.get("frameDuration", (_) => _frameDuration),
      (this.captureResults = captureResults),
      (this.createQuery = function createQuery(gl, obj) {
        return new RenderTimeQuery(gl, obj, updateResults);
      }),
      (this.updateResults = updateResults);
  }, "static"),
  Class(function RenderStats() {
    const _this = this;
    var _trace,
      _filter,
      $container,
      _map = {},
      _display = {};
    function flush() {
      for (let key in _map)
        (_this.stats[key] = _map[key]),
          _display[key] && _display[key].value.text(_map[key] || "0"),
          (_map[key] = 0);
      _trace = null;
    }
    (_this.stats = {}),
      (async function () {
        await Hydra.ready(),
          (_this.active = Utils.query("renderStats")),
          Utils.query("renderStats") &&
            (async function initUIL() {
              if (
                (await Hydra.ready(),
                ($container = Stage.create("RenderStats"))
                  .css({
                    position: "fixed",
                    width: 150,
                    height: "auto",
                    paddingTop: 5,
                  })
                  .bg("#111")
                  .setZ(99999),
                Utils.query("uil"))
              ) {
                const left = RenderCount.active ? 150 : 0;
                $container.css({ bottom: 0, left: left });
              }
            })(),
          (Render.drawFrame = flush);
        let frames = 0,
          prevTime = 0,
          fps = Render.REFRESH_RATE;
        Render.start((_) => {
          (frames += 1),
            Render.TIME >= prevTime + 1e3 &&
              ((fps = (1e3 * frames) / (Render.TIME - prevTime)),
              (fps = Math.round(fps, fps >= 1 ? 0 : 2)),
              (prevTime = Render.TIME),
              (frames = 0)),
            _this.update("FPS", fps);
        });
      })(),
      (this.update = function (name, amt = 1, detail, detail2) {
        if (Hydra.LOCAL) {
          if (_trace == name) {
            if (_filter && detail) {
              if (
                !(
                  "string" == typeof detail
                    ? detail
                    : Utils.getConstructorName(detail)
                )
                  .toLowerCase()
                  .includes(_filter.toLowerCase())
              )
                return;
            }
            console.groupCollapsed(name),
              detail &&
                console.log(
                  "string" == typeof detail
                    ? detail
                    : Utils.getConstructorName(detail)
                ),
              detail2 && console.log(detail2),
              console.trace(),
              console.groupEnd();
          }
          if (void 0 === _map[name] && ((_map[name] = 0), $container)) {
            let $wrapper = $container.create("wrapper");
            $wrapper.css({ position: "relative", width: "100%", height: 20 }),
              ($wrapper.label = $wrapper.create("label")),
              $wrapper.label
                .fontStyle("Arial", 12, "#fff")
                .text(name)
                .css({ left: 10 }),
              ($wrapper.value = $wrapper.create("value")),
              $wrapper.value
                .fontStyle("Arial", 12, "#fff")
                .text(0)
                .css({ right: 10 }),
              (_display[name] = $wrapper);
          }
          _map[name] += amt;
        }
      }),
      (this.trace = function (name, filter = null) {
        (_trace = name), (_filter = filter);
      }),
      (this.log = function () {
        for (let key in _this.stats) console.log(key, _this.stats[key]);
        console.log("----");
      });
  }, "static"),
  Class(function RenderTimeQuery(_gl, shader, resultavailableCB = () => {}) {
    Inherit(this, Component);
    const _this = this;
    (_this.durationQuery = null),
      (_this.testInProgress = !1),
      (_this.resultsAvailable = !1),
      (_this.queryEnded = !0),
      (_this.timeElapsed = 0),
      (_this.prevTimeElapsed = 0),
      (_this.inactive = !1),
      (_this.inactivityAttempts = 100);
    const ext = Renderer.extensions.disjointTimerQuery;
    function endDurationQuery() {
      _this.queryEnded ||
        ((_this.queryEnded = !0), _gl.endQuery(ext.TIME_ELAPSED_EXT));
    }
    function checkQueryResults() {
      let available = _gl.getQueryParameter(
          _this.durationQuery,
          _gl.QUERY_RESULT_AVAILABLE
        ),
        disjoint = _gl.getParameter(ext.GPU_DISJOINT_EXT);
      if (
        ((_this.prevTimeElapsed = _this.timeElapsed), available && !disjoint)
      ) {
        let elapsedTime = _gl.getQueryParameter(
          _this.durationQuery,
          _gl.QUERY_RESULT
        );
        (shader.renderDuration = _this.timeElapsed =
          (function timeInMS(res) {
            return Math.round(res / 1e6, 2);
          })(elapsedTime)),
          (_this.resultsAvailable = !0);
      }
      (available || disjoint) && (deleteQueries(), resultavailableCB(_this));
    }
    function deleteQueries() {
      _gl.deleteQuery(_this.durationQuery), (_this.durationQuery = null);
    }
    !(async function () {
      await Hydra.ready(),
        ext
          ? ((_this.queryObject = shader),
            (_this.id = shader.mesh?.id || shader.parent?.__id),
            (shader.renderTimeQuery = _this))
          : console.error("extension not available");
    })(),
      (this.beginTest = function beginTest() {
        if (spector) {
          const v = Object.values(RenderMonitor.results).find(
              (i) => i.obj === shader
            ),
            name = v?.obj?.__renderstatsname;
          spector.log(`RenderMonitor:START = ${name}`);
        }
        _this.queryObject &&
          (_this.testInProgress ||
            ((_this.testInProgress = !0),
            (_this.queryEnded = !1),
            (_this.resultsAvailable = !1),
            (_this.resultsReady = Promise.create()),
            _gl.getParameter(ext.GPU_DISJOINT_EXT),
            (function initDrawDurationQuery() {
              _this.durationQuery ||
                ((_this.durationQuery = _gl.createQuery()),
                _gl.beginQuery(ext.TIME_ELAPSED_EXT, _this.durationQuery));
            })()));
      }),
      (this.endTest = function endTest(force = !1) {
        if (spector) {
          const v = Object.values(RenderMonitor.results).find(
              (i) => i.obj === shader
            ),
            name = v?.obj?.__renderstatsname,
            duration = v?.duration / v?.resultCount;
          spector.log(`RenderMonitor:END = ${name}; duration = ${duration}ms`);
        }
        if (force)
          return (
            (_this.testInProgress = !1),
            endDurationQuery(),
            deleteQueries(),
            void _gl.getParameter(ext.GPU_DISJOINT_EXT)
          );
        _this.durationQuery &&
          _this.testInProgress &&
          (endDurationQuery(), checkQueryResults());
      }),
      (this.deleteQueries = deleteQueries);
  }),
  Class(function RenderTimer() {
    const _this = this;
    var $container,
      _display = {},
      _times = {};
    !(async function () {
      await Hydra.ready(),
        (_this.active = Utils.query("renderTimer")),
        _this.active &&
          (async function initUIL() {
            ($container = Stage.create("RenderTimer"))
              .css({
                width: 150,
                height: "auto",
                paddingBottom: 5,
                bottom: 0,
                right: 0,
              })
              .bg("#111")
              .setZ(9999999);
          })();
    })(),
      (this.start = function (name) {
        _times[name] = performance.now();
      }),
      (this.stop = function (name) {
        if (!_display[name] && $container) {
          let $wrapper = $container.create("wrapper");
          $wrapper.css({ position: "relative", width: "100%", height: 20 }),
            ($wrapper.label = $wrapper.create("label")),
            $wrapper.label
              .fontStyle("Arial", 12, "#fff")
              .text(name)
              .css({ left: 10 }),
            ($wrapper.value = $wrapper.create("value")),
            $wrapper.value
              .fontStyle("Arial", 12, "#fff")
              .text(0)
              .css({ right: 10 }),
            (_display[name] = $wrapper);
        }
        _display[name] &&
          _display[name].value.text(
            (performance.now() - _times[name]).toFixed(3) || "0"
          );
      });
  }, "static"),
  Class(function FBOHelper() {
    Inherit(this, Element);
    const _this = this,
      $this = _this.element,
      { getType: getType } = require("GLTypes"),
      LABEL_OFFSET = 20;
    let _renderer,
      $list,
      $label,
      $tableTop,
      $tableBottom,
      _counter = 0,
      _activeFBO = null,
      _mouseOnStart = new Vector2(),
      _lastOffset = new Vector2();
    function resize() {
      _this.fbos.forEach(resizeSingle);
    }
    function resizeSingle($fbo, index = 0) {
      const prevFboHeight = index > 0 ? _this.fbos[index - 1].height : 0;
      ($fbo.x = 50),
        ($fbo.y = Stage.height / 2 - $fbo.height / 2 - prevFboHeight);
    }
    function handleQuadOver() {
      if (null == _activeFBO) return void $label.css({ display: "none" });
      $label.css({
        top: Mouse.y - LABEL_OFFSET,
        left: Mouse.x + LABEL_OFFSET,
        pointerEvents: "none",
      });
      const quad = _this.quads[_activeFBO],
        quadHit = quad.interaction.checkObjectHit(quad, Mouse);
      if (quadHit) {
        const uv = quadHit.uv;
        !(function readPixel(fbo, u, v) {
          const x = ~~(fbo.width * u),
            y = ~~(fbo.height * v);
          fbo instanceof Texture ||
            _renderer.readPixels(
              fbo,
              x,
              y,
              1,
              1,
              fbo.__pixelBuffer,
              getType(fbo.texture) || _renderer.context.FLOAT
            );
          const posText = `\n            X: ${x} </br>\n            Y: ${y} </br>\n            u: ${u} </br>\n            v: ${v} </br>\n            </br>\n        `,
            dataText = `\n            R: ${fbo.__pixelBuffer[0]} </br>\n            G: ${fbo.__pixelBuffer[1]} </br>\n            B: ${fbo.__pixelBuffer[2]} </br>\n            A: ${fbo.__pixelBuffer[3]} </br>\n        `;
          $tableTop.html(posText), $tableBottom.html(dataText);
        })(_this.fbos[_activeFBO], uv.x, uv.y);
      }
    }
    function loop() {
      handleQuadOver();
    }
    (_this.fbos = []),
      (_this.quads = []),
      (_this.items = []),
      (async function () {
        (_renderer = World.RENDERER),
          _this.onResize(resize),
          (function initUI() {
            const styles = {
              position: "absolute",
              top: "0",
              left: "0",
              color: "#FFF",
              background: "#161616",
              fontFamily: "sans-serif",
            };
            ($list = $this
              .create("div")
              .css({ ...styles, padding: 20, minWidth: 150 })),
              $list
                .create("strong")
                .css({
                  position: "relative",
                  paddingBottom: 15,
                  fontWeight: 900,
                })
                .text("FBO helper"),
              ($label = $this
                .create("label")
                .css({
                  ...styles,
                  display: "flex",
                  flexFlow: "column nowrap",
                  fontSize: "14px",
                  padding: "10px",
                })),
              ($tableTop = $label.create("span").css({ position: "relative" })),
              ($tableBottom = $label
                .create("span")
                .css({ position: "relative" })),
              Stage.add($label);
          })(),
          Stage.add($this),
          _this.startRender(loop);
      })(),
      (_this.attach = function (fbo, params = {}) {
        !(function setFBOBufferType(fbo) {
          const possibleTypes = {};
          (possibleTypes[Texture.UNSIGNED_BYTE] = Uint8Array),
            (possibleTypes[Texture.FLOAT] = possibleTypes[Texture.HALF_FLOAT] =
              Float32Array);
          const type = possibleTypes[fbo.texture ? fbo.texture.type : fbo.type];
          type || console.warn(`Can't find texture type ${fbo.texture.type}`),
            (fbo.__pixelBuffer = new type(4)),
            _this.fbos.push(fbo);
        })(fbo),
          (function initScreenQuad(fbo, params) {
            const width = params.width || 600,
              height = (fbo.height * width) / fbo.width,
              name =
                params.name ||
                `FBO #${String(_this.fbos.length + 1).padStart(2, "0")}`,
              $quad = $gl(width, height, fbo.texture || fbo);
            ($quad.group.visible = !1),
              ($quad.__i = _counter),
              $quad.interact(
                (e) => {
                  _this.flag("isDragging") ||
                    ("over" === e.action &&
                      ($label.css({ display: "flex" }),
                      (_activeFBO = $quad.__i)),
                    "out" === e.action && $label.css({ display: "none" }));
                },
                (e) => {}
              );
            const input = new Interaction(Stage);
            _this.events.sub(input, Interaction.END, function onMouseUp() {
              _this.flag("isDragging", !1);
            }),
              _this.events.sub(
                input,
                Interaction.START,
                function onMouseDown() {
                  (_mouseOnStart.x = Mouse.x), (_mouseOnStart.y = Mouse.y);
                  const activeQuad = _this.quads[_activeFBO];
                  if (!activeQuad?.group) return;
                  const activeQuadGroup = activeQuad.group,
                    diffX =
                      _mouseOnStart.x -
                      activeQuadGroup.position.x -
                      activeQuad.dimensions.x / 2,
                    diffY =
                      _mouseOnStart.y +
                      activeQuadGroup.position.y -
                      activeQuad.dimensions.y / 2;
                  (_lastOffset.x = diffX), (_lastOffset.y = diffY);
                }
              ),
              _this.events.sub(input, Interaction.DRAG, function onMouseDrag() {
                if (null != _activeFBO) {
                  if (_this.quads[_activeFBO].group) {
                    const $obj = _this.quads[_activeFBO],
                      group = $obj.group;
                    (group.position.x =
                      Mouse.x - $obj.dimensions.x / 2 - _lastOffset.x),
                      (group.position.y =
                        -1 * (Mouse.y - $obj.dimensions.y / 2) + _lastOffset.y);
                  }
                  _this.flag("isDragging", !0);
                }
              });
            let $item = $list
              .create("")
              .text(name)
              .css({
                position: "relative",
                wordBreak: "keep-all",
                padding: 5,
                fontSize: "14px",
                marginBottom: 5,
              });
            $item.interact(
              () => {},
              (e) => {
                const isVisible = $quad.group.visible;
                $item.css({ background: isVisible ? "#161616" : "#333" }),
                  ($quad.group.visible = !isVisible);
              }
            ),
              resizeSingle($quad),
              GLUI.Stage.add($quad),
              _this.quads.push($quad);
          })(fbo, params),
          _counter++;
      });
  }, "singleton"),
  Class(
    function FloatingMesh(
      _mesh,
      _options = ({
        camera: camera,
        wobble: wobble,
        rotateMin: rotateMin,
        rotateMax: rotateMax,
        speed: speed,
        lookAtRange: lookAtRange,
        lookAtForce: lookAtForce,
        wobbleLerp: wobbleLerp,
        rotationLerp: rotationLerp,
        influenceLerp: influenceLerp,
        id: id,
      } = {
        camera: World.CAMERA,
        wobble: [0.2, 0.2, 0.2],
        rotateMin: [0, 0, 0],
        rotateMax: [0.2, 0.2, 0],
        speed: [1, 1, 1],
        lookAtRange: [100, 200],
        lookAtForce: [10, 10],
        wobbleLerp: 0.05,
        rotationLerp: 0.05,
        influenceLerp: 0.1,
        id: "",
      })
    ) {
      Inherit(this, Component);
      const _this = this;
      let _screenProj,
        _wrapper = new Group(),
        _time = 0,
        _force = !1,
        _influence = 0,
        _influenceTarget = 0,
        _originalRot = new Vector3(),
        _wobbleTarget = new Vector3(),
        _rotateTarget = new Vector3(),
        _lookAt = new Vector3(),
        _mouse = new Vector3();
      function findScreenProj() {
        const camera = _this.options.camera || World.CAMERA;
        camera && (_screenProj = ScreenProjection.find(camera)),
          (_time = 0),
          (_force = !0),
          _originalRot.copy(_mesh.rotation);
      }
      function loop(_, dt) {
        const mm = Mouse;
        _mouse.set(mm.x, mm.y, 0),
          _rotateTarget.copy(_originalRot),
          (_rotateTarget.x += Math.map(
            Math.sin(_time * _this.options.speed[0]),
            -1,
            1,
            Math.radians(_this.options.rotateMin[0]),
            Math.radians(_this.options.rotateMax[0]),
            !0
          )),
          (_rotateTarget.y += Math.map(
            Math.sin(_time * _this.options.speed[1]),
            -1,
            1,
            Math.radians(_this.options.rotateMin[1]),
            Math.radians(_this.options.rotateMax[1]),
            !0
          )),
          (_rotateTarget.z += Math.map(
            Math.sin(_time * _this.options.speed[2]),
            -1,
            1,
            Math.radians(_this.options.rotateMin[2]),
            Math.radians(_this.options.rotateMax[2]),
            !0
          )),
          (_wobbleTarget.x =
            Math.sin(_time * _this.options.speed[0]) * _this.options.wobble[0]),
          (_wobbleTarget.y =
            Math.sin(_time * _this.options.speed[1]) * _this.options.wobble[1]),
          (_wobbleTarget.z =
            Math.sin(_time * _this.options.speed[2]) * _this.options.wobble[2]);
        const t = _screenProj.project(_mesh);
        t.z = 0;
        const mouseRange = t.distanceTo(_mouse);
        (_influence = Math.map(
          mouseRange,
          _this.options.lookAtRange[0],
          _this.options.lookAtRange[1],
          0,
          1,
          !0
        )),
          isNaN(_influence) ||
            ((_influenceTarget = Math.lerp(
              _influence,
              _influenceTarget,
              _force ? 1 : _this.options.influenceLerp
            )),
            _influence < 0.05 &&
              _this.options.id &&
              _this.events.fire(FloatingMesh.MOUSE_OVER, {
                name: _this.options.id,
              }),
            t &&
              t.x &&
              t.y &&
              ((_lookAt.x =
                _originalRot.y +
                0.001 * (mm.x - t.x) * _this.options.lookAtForce[0]),
              (_lookAt.y =
                _originalRot.x +
                0.001 * (mm.y - t.y) * _this.options.lookAtForce[1]),
              (_lookAt.z = _originalRot.z)),
            (_lookAt.x = Math.lerp(
              _rotateTarget.y,
              _lookAt.x,
              _force ? 1 : _influenceTarget,
              !1
            )),
            (_lookAt.y = Math.lerp(
              _rotateTarget.x,
              _lookAt.y,
              _force ? 1 : _influenceTarget,
              !1
            )),
            (_lookAt.z = Math.lerp(
              _rotateTarget.z,
              _lookAt.z,
              _force ? 1 : _influenceTarget,
              !1
            )),
            (_wobbleTarget.x = Math.lerp(
              _wobbleTarget.x,
              _wrapper.position.x,
              _force ? 1 : _influenceTarget,
              !1
            )),
            (_wobbleTarget.y = Math.lerp(
              _wobbleTarget.y,
              _wrapper.position.y,
              _force ? 1 : _influenceTarget,
              !1
            )),
            (_wobbleTarget.z = Math.lerp(
              _wobbleTarget.z,
              _wrapper.position.z,
              _force ? 1 : _influenceTarget,
              !1
            )),
            (_mesh.rotation.x = Math.lerp(
              _lookAt.y,
              _mesh.rotation.x,
              _force ? 1 : _this.options.rotationLerp
            )),
            (_mesh.rotation.y = Math.lerp(
              _lookAt.x,
              _mesh.rotation.y,
              _force ? 1 : _this.options.rotationLerp
            )),
            (_mesh.rotation.z = Math.lerp(
              _lookAt.z,
              _mesh.rotation.z,
              _force ? 1 : _this.options.rotationLerp
            )),
            (_wrapper.position.x = Math.lerp(
              _wobbleTarget.x,
              _wrapper.position.x,
              _force ? 1 : _this.options.wobbleLerp
            )),
            (_wrapper.position.y = Math.lerp(
              _wobbleTarget.y,
              _wrapper.position.y,
              _force ? 1 : _this.options.wobbleLerp
            )),
            (_wrapper.position.z = Math.lerp(
              _wobbleTarget.z,
              _wrapper.position.z,
              _force ? 1 : _this.options.wobbleLerp
            )),
            (_time += 0.001 * dt),
            (_force = !1));
      }
      !(function () {
        _this.options = _options;
        const parent = _mesh._parent;
        _wrapper.add(_mesh),
          parent.add(_wrapper),
          (_mesh._floatingWrapper = _wrapper),
          findScreenProj(),
          _this.startRender(loop);
      })(),
        _this.get("input", (_) => _input),
        _this.set("camera", (cam) => {
          (_options.camera = cam), findScreenProj();
        });
    },
    (_) => {
      FloatingMesh.MOUSE_OVER = "mouseOver";
    }
  ),
  Class(function FloatingMeshLayer(_mesh, _shader, _group, _input) {
    Inherit(this, Component);
    const _this = this;
    let _config;
    !(function () {
      const floatingMeshInstance = _this.initClass(FloatingMesh, _mesh);
      (_config = InputUIL.create(`FloatingMesh_${_input.prefix}`, _group)),
        _config.addToggle("visible", !1),
        _config.addVector("rotateMin", [0, 0, 0]),
        _config.addVector("rotateMax", [0.2, 0.2, 0.2]),
        _config.addVector("wobble", [0.2, 0.2, 0.2]),
        _config.addVector("speed", [1, 1, 1]),
        _config.addVector("lookAtRange", [100, 200]),
        _config.addVector("lookAtForce", [10, 10]),
        _config.addNumber("wobbleLerp", 0.05),
        _config.addNumber("rotationLerp", 0.05),
        _config.addNumber("influenceLerp", 0.1),
        _config.setLabel("FloatingMesh");
      const baseConfig = () => ({
        visible: _config.get("visible"),
        rotateMin: _config.get("rotateMin"),
        rotateMax: _config.get("rotateMax"),
        wobble: _config.get("wobble"),
        speed: _config.get("speed"),
        lookAtRange: _config.get("lookAtRange"),
        lookAtForce: _config.get("lookAtForce"),
        wobbleLerp: _config.getNumber("wobbleLerp"),
        rotationLerp: _config.getNumber("rotationLerp"),
        influenceLerp: _config.getNumber("influenceLerp"),
      });
      (floatingMeshInstance.options = baseConfig()),
        (floatingMeshInstance.visible = baseConfig().visible),
        (_config.onUpdate = (key) => {
          if ("visible" === key)
            return (floatingMeshInstance.visible = _config.get("visible"));
          const newConfig = floatingMeshInstance.options;
          let getProp = [
            "wobbleLerp",
            "rotationLerp",
            "influenceLerp",
          ].includes(key)
            ? "getNumber"
            : "get";
          newConfig[key] = _config[getProp](key);
        });
    })();
  }),
  Class(function Fluid(_simSize = 128, _dyeSize = 512, _rect = Stage) {
    Inherit(this, Component);
    const _this = this;
    var _fbos = {},
      _scenes = {},
      _tmpVec = new Vector2(),
      _lastSplat = Render.TIME;
    const DYE_WIDTH = _dyeSize,
      DYE_HEIGHT = _dyeSize,
      SIM_WIDTH = _simSize,
      SIM_HEIGHT = _simSize,
      config = {
        DENSITY_DISSIPATION: 0.97,
        VELOCITY_DISSIPATION: 0.98,
        PRESSURE_DISSIPATION: 0.8,
        PRESSURE_ITERATIONS: 20,
        CURL: 30,
        DEBUG_MOUSE: !0,
        SPLAT_RADIUS: 0.25,
      };
    function updateParamsHz(param) {
      return 0 == (param = Math.clamp(param))
        ? 0
        : Math.exp(Math.log(param) * Render.HZ_MULTIPLIER);
    }
    function loop() {
      (_scenes.curl.uniforms.uVelocity.value = _fbos.velocity.read),
        _scenes.curl.render(_fbos.curl.fbo),
        (_scenes.vorticity.uniforms.uVelocity.value = _fbos.velocity.read),
        (_scenes.vorticity.uniforms.uCurl.value = _fbos.curl.fbo),
        (_scenes.vorticity.uniforms.curl.value = config.CURL),
        _scenes.vorticity.render(_fbos.velocity.write),
        _fbos.velocity.swap(),
        (_scenes.divergence.uniforms.uVelocity.value = _fbos.velocity.read),
        _scenes.divergence.render(_fbos.divergence.fbo),
        (_scenes.clear.uniforms.uTexture.value = _fbos.pressure.read),
        (_scenes.clear.uniforms.value.value = updateParamsHz(
          config.PRESSURE_DISSIPATION
        )),
        _scenes.clear.render(_fbos.pressure.write),
        _fbos.pressure.swap(),
        (_scenes.pressure.uniforms.uDivergence.value = _fbos.divergence.fbo);
      for (let i = 0; i < config.PRESSURE_ITERATIONS; i++)
        (_scenes.pressure.uniforms.uPressure.value = _fbos.pressure.read),
          _scenes.pressure.render(_fbos.pressure.write),
          _fbos.pressure.swap();
      (_scenes.gradientSubtract.uniforms.uPressure.value = _fbos.pressure.read),
        (_scenes.gradientSubtract.uniforms.uVelocity.value =
          _fbos.velocity.read),
        _scenes.gradientSubtract.render(_fbos.velocity.write),
        _fbos.velocity.swap(),
        _scenes.advection.uniforms.texelSize.value.set(
          1 / SIM_WIDTH,
          1 / SIM_HEIGHT
        ),
        (_scenes.advection.uniforms.uVelocity.value = _fbos.velocity.read),
        (_scenes.advection.uniforms.uSource.value = _fbos.velocity.read),
        (_scenes.advection.uniforms.dissipation.value = updateParamsHz(
          config.VELOCITY_DISSIPATION
        )),
        _scenes.advection.render(_fbos.velocity.write),
        _fbos.velocity.swap(),
        _scenes.advection.uniforms.texelSize.value.set(
          1 / DYE_WIDTH,
          1 / DYE_HEIGHT
        ),
        (_scenes.advection.uniforms.uVelocity.value = _fbos.velocity.read),
        (_scenes.advection.uniforms.uSource.value = _fbos.density.read),
        (_scenes.advection.uniforms.dissipation.value = updateParamsHz(
          config.DENSITY_DISSIPATION
        )),
        _scenes.advection.render(_fbos.density.write),
        _fbos.density.swap(),
        (_scenes.display.uniforms.uTexture.value = _fbos.density.read),
        _scenes.display.uniforms.texelSize.value.set(
          1 / _rect.width,
          1 / _rect.height
        ),
        _scenes.display.render(_this.rt);
    }
    (this.rt = Utils3D.createRT(_rect.width, _rect.height)),
      (this.fbos = _fbos),
      (this.additiveBlending = !0),
      (_this.rt.disableDepth = !0),
      (function initFBOs() {
        (_fbos.density = _this.initClass(
          FluidFBO,
          DYE_WIDTH,
          DYE_HEIGHT,
          Texture.LINEAR
        )),
          (_fbos.velocity = _this.initClass(
            FluidFBO,
            SIM_WIDTH,
            SIM_HEIGHT,
            Texture.LINEAR
          )),
          (_fbos.divergence = _this.initClass(
            FluidFBO,
            SIM_WIDTH,
            SIM_HEIGHT,
            Texture.NEAREST
          )),
          (_fbos.curl = _this.initClass(
            FluidFBO,
            SIM_WIDTH,
            SIM_HEIGHT,
            Texture.NEAREST
          )),
          (_fbos.pressure = _this.initClass(
            FluidFBO,
            SIM_WIDTH,
            SIM_HEIGHT,
            Texture.NEAREST
          ));
      })(),
      (function initScenes() {
        (_scenes.curl = _this.initClass(FluidScene, "fluidBase", "curlShader", {
          texelSize: { value: new Vector2(1 / SIM_WIDTH, 1 / SIM_HEIGHT) },
          uVelocity: { value: null },
          depthWrite: !1,
        })),
          (_scenes.vorticity = _this.initClass(
            FluidScene,
            "fluidBase",
            "vorticityShader",
            {
              texelSize: { value: new Vector2(1 / SIM_WIDTH, 1 / SIM_HEIGHT) },
              uVelocity: { value: null },
              uCurl: { value: null },
              curl: { value: config.CURL },
              dt: { value: 1 / Render.REFRESH_RATE },
            }
          )),
          (_scenes.divergence = _this.initClass(
            FluidScene,
            "fluidBase",
            "divergenceShader",
            {
              texelSize: { value: new Vector2(1 / SIM_WIDTH, 1 / SIM_HEIGHT) },
              uVelocity: { value: null },
            }
          )),
          (_scenes.clear = _this.initClass(
            FluidScene,
            "fluidBase",
            "clearShader",
            {
              uTexture: { value: null },
              value: { value: config.PRESSURE_DISSIPATION },
            }
          )),
          (_scenes.pressure = _this.initClass(
            FluidScene,
            "fluidBase",
            "pressureShader",
            {
              texelSize: { value: new Vector2(1 / SIM_WIDTH, 1 / SIM_HEIGHT) },
              uPressure: { value: null },
              uDivergence: { value: null },
            }
          )),
          (_scenes.gradientSubtract = _this.initClass(
            FluidScene,
            "fluidBase",
            "gradientSubtractShader",
            {
              texelSize: { value: new Vector2(1 / SIM_WIDTH, 1 / SIM_HEIGHT) },
              uPressure: { value: null },
              uVelocity: { value: null },
            }
          )),
          (_scenes.advection = _this.initClass(
            FluidScene,
            "fluidBase",
            "advectionShader",
            {
              texelSize: { value: new Vector2(1 / SIM_WIDTH, 1 / SIM_HEIGHT) },
              uVelocity: { value: null },
              uSource: { value: null },
              dt: { value: 1 / Render.REFRESH_RATE },
              dissipation: { value: config.VELOCITY_DISSIPATION },
            }
          )),
          (_scenes.display = _this.initClass(
            FluidScene,
            "fluidBase",
            "displayShader",
            {
              texelSize: {
                value: new Vector2(1 / _rect.width, 1 / _rect.height),
              },
              uTexture: { value: null },
            }
          )),
          (_scenes.splat = _this.initClass(
            FluidScene,
            "fluidBase",
            "splatShader",
            {
              uTarget: { value: null },
              aspectRatio: { value: _rect.width / _rect.height },
              point: { value: new Vector2() },
              prevPoint: { value: new Vector2() },
              color: { value: new Vector3() },
              bgColor: { value: new Color("#000000") },
              radius: { value: config.SPLAT_RADIUS / 100 },
              canRender: { value: 0 },
              uAdd: { value: 1 },
            }
          ));
      })(),
      _this.startRender(loop),
      (this.updateConfig = function (key, value) {
        config[key] = value;
      }),
      (this.drawInput = function (
        x,
        y,
        dx,
        dy,
        color,
        radius = config.SPLAT_RADIUS,
        independent
      ) {
        (_scenes.splat.uniforms.uTarget.value = _fbos.velocity.read),
          (_scenes.splat.uniforms.radius.value =
            Math.min(radius, config.SPLAT_RADIUS) / 200),
          (_scenes.splat.uniforms.aspectRatio.value =
            _rect.width / _rect.height),
          _tmpVec.set(x / _rect.width, 1 - y / _rect.height);
        let now = Render.TIME,
          delta = now - _lastSplat;
        (_lastSplat = now),
          delta > 50 || independent
            ? _scenes.splat.uniforms.prevPoint.value.copy(_tmpVec)
            : _scenes.splat.uniforms.prevPoint.value.copy(
                _scenes.splat.uniforms.point.value
              ),
          _scenes.splat.uniforms.point.value.copy(_tmpVec),
          _scenes.splat.uniforms.color.value.set(dx, -dy, 1),
          (_scenes.splat.uniforms.uAdd.value = 1),
          _scenes.splat.render(_fbos.velocity.write),
          _fbos.velocity.swap(),
          (_scenes.splat.uniforms.uTarget.value = _fbos.density.read),
          _scenes.splat.uniforms.color.value.set(color.r, color.g, color.b),
          (_scenes.splat.uniforms.uAdd.value = _this.additiveBlending ? 1 : 0),
          _scenes.splat.render(_fbos.density.write, !0),
          _fbos.density.swap(),
          (_scenes.splat.uniforms.canRender.value = 1);
      });
  }),
  Class(function FluidFBO(_width, _height, _filter) {
    Inherit(this, Component);
    const _this = this,
      type =
        Device.mobile || Renderer.type != Renderer.WEBGL1
          ? Texture.HALF_FLOAT
          : Texture.FLOAT;
    var _fbo1 = new RenderTarget(_width, _height, {
        minFilter: _filter,
        magFilter: _filter,
        format: Texture.RGBAFormat,
        type: type,
      }),
      _fbo2 = new RenderTarget(_width, _height, {
        minFilter: _filter,
        magFilter: _filter,
        format: Texture.RGBAFormat,
        type: type,
      });
    (this.fbo = _fbo1),
      (this.uniform = { value: _fbo1 }),
      (_fbo1.disableDepth = !0),
      (_fbo2.disableDepth = !0),
      (_fbo1.generateMipmaps = !1),
      (_fbo2.generateMipmaps = !1),
      (this.swap = function () {
        let temp = _fbo1;
        (_fbo1 = _fbo2), (_fbo2 = temp), (_this.uniform.value = _fbo1);
      }),
      this.get("read", (_) => _fbo1),
      this.get("write", (_) => _fbo2);
  }),
  Class(function FluidLayer(_input, _group) {
    Inherit(this, Object3D);
    var _fluid,
      _config,
      _this = this;
    !(function initConfig() {
      (_config = InputUIL.create(`${_input.prefix}fluid`, _group)).setLabel(
        "Fluid Config"
      ),
        _config.add("dyeSize", 512),
        _config.add("simSize", 128),
        _config.add("velocity", 0.98),
        _config.add("density", 0.97),
        _config.add("pressure", 0.8),
        _config.add("iterations", 5),
        _config.add("curl", 30),
        _config.add("defaultRadius", 25),
        _config.addToggle("debugMouse", !1);
    })(),
      (function initFluid() {
        let rect = Stage,
          wildcard = _input.get("wildcard");
        if (wildcard && wildcard.includes("x")) {
          let split = wildcard.split("x");
          rect = { width: Number(split[0]), height: Number(split[1]) };
        }
        (_fluid = _this.initClass(
          Fluid,
          _config.getNumber("simSize"),
          _config.getNumber("dyeSize"),
          rect
        )),
          (_this.rt = _fluid.rt),
          (_this.fbos = _fluid.fbos),
          (_config.onUpdate = (key) => {
            switch (key) {
              case "velocity":
                _fluid.updateConfig(
                  "VELOCITY_DISSIPATION",
                  _config.getNumber(key)
                );
                break;
              case "density":
                _fluid.updateConfig(
                  "DENSITY_DISSIPATION",
                  _config.getNumber(key)
                );
                break;
              case "pressure":
                _fluid.updateConfig(
                  "PRESSURE_DISSIPATION",
                  _config.getNumber(key)
                );
                break;
              case "iterations":
                _fluid.updateConfig(
                  "PRESSURE_ITERATIONS",
                  _config.getNumber(key)
                );
                break;
              case "curl":
                _fluid.updateConfig("CURL", _config.getNumber(key));
                break;
              case "defaultRadius":
                _fluid.updateConfig("SPLAT_RADIUS", _config.getNumber(key));
                break;
              case "debugMouse":
                _fluid.updateConfig("DEBUG_MOUSE", _config.get(key));
            }
          }),
          [
            "velocity",
            "density",
            "pressure",
            "iterations",
            "curl",
            "defaultRadius",
            "debugMouse",
          ].forEach(_config.onUpdate);
      })(),
      (this.initMesh = function initMesh() {
        let shader = _this.initClass(Shader, "ScreenQuad", {
            tMap: { value: _fluid.rt },
          }),
          mesh = new Mesh(World.QUAD, shader);
        _this.add(mesh), (_this.mesh = mesh);
      }),
      (this.drawInput = _fluid.drawInput),
      (this.updateConfig = _fluid.updateConfig),
      this.set("additiveBlending", (v) => (_fluid.additiveBlending = v)),
      this.get("config", () => _config),
      (this.applyTo = function (shader) {
        (shader.uniforms.tFluid = _this.fbos.velocity.uniform),
          (shader.uniforms.tFluidMask = { value: _this });
      });
  }),
  Class(function FluidScene(_vs, _fs, _uniforms) {
    Inherit(this, Component);
    const _this = this;
    var _scene = new Scene();
    !(function () {
      _uniforms.depthWrite = !1;
      let shader = _this.initClass(Shader, _vs, _fs, _uniforms),
        mesh = new Mesh(World.QUAD, shader);
      (shader.depthWrite = !1),
        (mesh.noMatrices = !0),
        _scene.add(mesh),
        (_this.uniforms = shader.uniforms);
    })(),
      (this.render = function (rt) {
        (World.RENDERER.autoClear = !1),
          World.RENDERER.renderSingle(_scene.children[0], World.CAMERA, rt),
          (World.RENDERER.autoClear = !0);
      });
  }),
  Class(function FXAA() {
    Inherit(this, NukePass);
    (this.uniforms = { tMask: { value: null } }),
      this.init("FXAA", "FXAA"),
      (this.setMask = function (texture) {
        this.uniforms.tMask.value = texture;
      });
  }),
  Class(function GLA11y() {
    Inherit(this, Element);
    const _this = this;
    var $this,
      _groups = [],
      _links = [];
    function isVisible(group) {
      if (group.__glseoParent) {
        const seoHidden = !!group.__glseoParent.seoHidden,
          hidden = !!group.__glseoParent.hidden;
        return !seoHidden && !hidden;
      }
      return group.seo.enabled && group.determineVisible();
    }
    function isDeleted(group) {
      return group.__glseoParent ? group.__glseoParent.deleted : group.deleted;
    }
    function loop() {
      for (let i = _groups.length - 1; i > -1; i--) {
        let group = _groups[i];
        if (isDeleted(group))
          return $this.removeChild(group.seo), _groups.splice(i, 1);
        isVisible(group)
          ? (group.seo &&
              group.seo.hidden &&
              ((group.seo.hidden = !1), $this.add(group.seo)),
            (seo = group.seo),
            Array.prototype.slice.call(seo.div.children).forEach((div) => {
              let seo = div.hydraObject,
                group = seo && seo.group;
              if (!seo || !group) return;
              let hidden = !group.determineVisible();
              hidden !== seo.hidden &&
                (hidden ? seo.hide() : seo.show(), (seo.hidden = hidden));
            }))
          : group.seo &&
            !group.seo.hidden &&
            ((group.seo.hidden = !0), $this.removeChild(group.seo, !0));
      }
      var seo;
      for (let i = _links.length - 1; i > -1; i--) {
        let group = _links[i];
        if (isDeleted(group))
          return $this.removeChild(group.seo), _groups.splice(i, 1);
        isVisible(group)
          ? group.seoHidden &&
            ((group.seoHidden = !1), group.seoDOM.forEach((obj) => obj.show()))
          : group.seoHidden ||
            ((group.seoHidden = !0), group.seoDOM.forEach((obj) => obj.hide()));
      }
    }
    function aLink($object, url, label, options = {}) {
      let seo = $("link", "a");
      return (
        (seo.group = $object.group),
        seo.attr("href", "#" === url ? url : Hydra.absolutePath(url)),
        seo.text(label),
        seo.accessible(),
        (seo.div.onfocus = (_) => $object._divFocus()),
        (seo.div.onblur = (_) => $object._divBlur()),
        (seo.div.onclick = (e) => {
          e.preventDefault(), $object._divSelect();
        }),
        options.role &&
          (seo.attr("role", options.role),
          (seo.div.onkeydown = (e) => {
            switch (e.key) {
              case " ":
              case "Spacebar":
                e.preventDefault(), e.stopPropagation(), $object._divSelect();
            }
          })),
        seo
      );
    }
    !(async function () {
      (window.GLSEO = _this),
        await Hydra.ready(),
        (function initHTML() {
          ($this = _this.element).setZ(-1), Stage.add($this);
        })(),
        HydraCSS.style(".GLA11y *", { position: "relative" });
    })(),
      (this.registerPage = function (group, name) {
        let topLevel = group;
        !(group =
          group instanceof GLUIObject
            ? group
            : group.group || group.scene || group).determineVisible &&
          group.group &&
          (group.determineVisible = group.group.determineVisible.bind(
            group.group
          )),
          Global.PLAYGROUND || World.ELEMENT.mouseEnabled(!1),
          (topLevel.seo = group.seo = $(name)),
          (group.seo.hidden = !0),
          (group.seo.enabled = !0);
        let remove = group.seo.remove.bind(group.seo);
        (group.seo.remove = (_) => {
          _groups.remove(group), remove();
        }),
          _groups.push(group),
          _this.startRender(loop, 10);
      }),
      (this.setPageH1 = function (group, title) {
        let $h1 = group.seo.h1;
        $h1 ||
          (($h1 = group.seo.create("title", "h1")),
          defer(() => {
            let el = $h1.div;
            el.parentNode.insertBefore(el, el.parentNode.firstChild);
          })),
          $h1.text(title);
      }),
      (this.registerPersist = function (group, name) {
        let topLevel = group;
        (group =
          group instanceof GLUIObject
            ? group
            : group.group || group.scene || group),
          Global.PLAYGROUND || World.ELEMENT.mouseEnabled(!1),
          (topLevel.seo = group.seo = $this.create(name));
      }),
      (this.link = function ($dom, group) {
        $dom instanceof HydraObject &&
          ((group = group.group || group.scene || group).seoDOM ||
            (group.seoDOM = []),
          group.seoDOM.push($dom),
          _links.push(group)),
          $dom instanceof GLUIObject && ($dom.seo = group.seo);
      }),
      (this.textNode = function ($text, text) {
        let parent = ($text._3d ? $text.anchor || $text.group : $text)._parent;
        if ($text.parentSeo) {
          let parentSeo = $text.parentSeo;
          parent =
            parentSeo.group && parentSeo.group.seo
              ? parentSeo.group
              : parentSeo;
        } else if (parent)
          for (; parent && !parent.seo; ) parent = parent._parent;
        parent &&
          parent.seo &&
          ($text.seo
            ? ($text.seo.text(text), $text.seo.accessible())
            : (($text.seo = $("text")),
              ($text.seo.group = $text.group),
              $text.seo.text(text),
              $text.seo.accessible(),
              parent.seo.add($text.seo),
              ($text.seo.aLink = function (url, options) {
                let index = Array.prototype.slice
                  .call(parent.seo.div.children)
                  .indexOf($text.seo.div);
                $text.seo.remove(),
                  ($text.seo = aLink($text, url, text, options)),
                  parent.seo.div.insertBefore(
                    $text.seo.div,
                    parent.seo.div.children[index]
                  );
              }),
              ($text.seo.unlink = function () {
                parent.seo.div.removeChild($text.seo.div),
                  ($text.seo.group = null),
                  ($text.seo = null);
              })));
      }),
      (this.bindToPage = function (parent, child, name) {
        (child.__glseoParent = parent), _this.registerPage(child, name);
      }),
      (this.objectNode = function ($object, $parent) {
        let parent = $parent || ($object._3d ? $object.group : $object)._parent;
        if ($object.parentSeo)
          parent = $object.parentSeo.group || $object.parentSeo;
        else {
          if (!parent) return;
          for (; parent && !parent.seo; ) parent = parent._parent;
        }
        parent &&
          parent.seo &&
          ($object.seo ||
            (($object.seo = {}),
            ($object.seo.group = $object.group),
            ($object.seo.aLink = function (url, label, options) {
              let index = Array.prototype.slice
                .call(parent.seo.div.children)
                .indexOf($object.seo.div);
              ($object.seo = aLink($object, url, label, options)),
                parent.seo.div.insertBefore(
                  $object.seo.div,
                  parent.seo.div.children[index]
                ),
                ($object.seo.unlink = function () {
                  parent.seo.div.removeChild($object.seo.div),
                    ($object.seo.group = null),
                    ($object.seo = null);
                });
            })));
      });
  }, "static"),
  Class(
    function GLText({
      font: font,
      italic: italic = !1,
      bold: bold = !1,
      text: text,
      width: width = 1 / 0,
      align: align = "left",
      size: size = 1,
      direction: direction = "ltr",
      letterSpacing: letterSpacing = 0,
      lineHeight: lineHeight = 1.4,
      wordSpacing: wordSpacing = 0,
      wordBreak: wordBreak = !1,
      langBreak: langBreak = !1,
      paragraphSpacing: paragraphSpacing = 1,
      color: color = new Color("#000000"),
      alpha: alpha = 1,
      shader: shader = "DefaultText",
      customCompile: customCompile = !1,
    }) {
      const _this = this;
      var _override,
        _promise = Promise.create();
      const config = GLText.FONT_CONFIG[font];
      function overrideParams() {
        if (GLText.overrideParams) {
          _override = {
            letterSpacing: letterSpacing,
            size: size,
            wordSpacing: wordSpacing,
            lineHeight: lineHeight,
          };
          let obj = GLText.overrideParams({
            letterSpacing: letterSpacing,
            size: size,
            wordSpacing: wordSpacing,
            lineHeight: lineHeight,
          });
          (letterSpacing = obj.letterSpacing),
            (size = obj.size),
            (wordSpacing = obj.wordSpacing),
            (lineHeight = obj.lineHeight);
        }
      }
      function resetOverride() {
        _override &&
          ((letterSpacing = _override.letterSpacing),
          (size = _override.size),
          (wordSpacing = _override.wordSpacing),
          (lineHeight = _override.lineHeight));
      }
      !(function init() {
        overrideParams(),
          (_this.charLength = text.length),
          (_this.text = new GLTextGeometry({
            font: font,
            italic: italic,
            bold: bold,
            text: text,
            width: width,
            align: align,
            direction: direction,
            wordSpacing: wordSpacing,
            letterSpacing: letterSpacing,
            paragraphSpacing: paragraphSpacing,
            size: size,
            lineHeight: lineHeight,
            wordBreak: wordBreak,
            langBreak: langBreak,
            config: config,
          })),
          (_this.string = text),
          resetOverride(),
          _this.text.loaded.then(
            ({
              buffers: buffers,
              texture: texture,
              textureBold: textureBold,
              textureItalic: textureItalic,
              height: height,
              numLines: numLines,
            }) => {
              (_this.texture = texture),
                bold && (_this.textureBold = textureBold),
                italic && (_this.textureItalic = textureItalic),
                (_this.shader = new Shader(shader, {
                  tMap: { value: _this.texture, ignoreUIL: !0 },
                  tMapBold: {
                    value: _this.textureBold || Utils3D.getEmptyTexture(),
                    ignoreUIL: !0,
                  },
                  tMapItalic: {
                    value: _this.textureItalic || Utils3D.getEmptyTexture(),
                    ignoreUIL: !0,
                  },
                  uColor: { value: color, ignoreUIL: !0 },
                  uAlpha: { value: alpha, ignoreUIL: !0 },
                  transparent: !0,
                  customCompile: customCompile,
                })),
                _this.onCreateShader && _this.onCreateShader(_this.shader),
                (function createGeometry(buffers) {
                  (_this.geometry = new Geometry()),
                    _this.geometry.addAttribute(
                      "position",
                      new GeometryAttribute(buffers.position, 3)
                    ),
                    _this.geometry.addAttribute(
                      "uv",
                      new GeometryAttribute(buffers.uv, 2)
                    ),
                    _this.geometry.addAttribute(
                      "local",
                      new GeometryAttribute(buffers.local, 2)
                    ),
                    _this.geometry.addAttribute(
                      "animation",
                      new GeometryAttribute(buffers.animation, 3)
                    ),
                    _this.geometry.addAttribute(
                      "weight",
                      new GeometryAttribute(buffers.weight, 1)
                    ),
                    _this.geometry.setIndex(
                      new GeometryAttribute(buffers.index, 1)
                    ),
                    (_this.geometry.boundingBox = buffers.boundingBox),
                    (_this.geometry.boundingSphere = buffers.boundingSphere),
                    (_this.geometry.letterCount = buffers.letterCount + 1),
                    (_this.geometry.wordCount = buffers.wordCount + 1),
                    (_this.geometry.lineCount = buffers.lineCount + 1);
                })(buffers),
                (_this.mesh = new Mesh(_this.geometry, _this.shader)),
                (_this.height = height),
                _promise.resolve();
            }
          );
      })(),
        void 0 === font && console.log(font, text),
        (this.destroy = function () {
          _this.mesh && _this.mesh.destroy && _this.mesh.destroy();
        }),
        (this.ready = this.loaded =
          function () {
            return _promise;
          }),
        (this.centerY = function () {
          (_this.mesh.position.y = 0.5 * _this.height),
            (_this.needsCenterY = !0);
        }),
        (this.resize = function (options) {
          return this.setText(text, options);
        }),
        (this.tweenColor = function (c, time = 300, ease = "easeOutCubic") {
          c && color.tween(c, time, ease);
        }),
        (this.setColor = function (c) {
          c && color.set(c);
        }),
        (this.setText = function (txt, options) {
          if (
            (text != txt ||
              !(function match(options) {
                return (
                  !options ||
                  (options.font == font &&
                    options.italic == italic &&
                    options.bold == bold &&
                    (options.width || 1 / 0) == width &&
                    options.align == align &&
                    options.direction == direction &&
                    !(
                      options.wordSpacing > 0 &&
                      options.wordSpacing != wordSpacing
                    ) &&
                    options.letterSpacing == letterSpacing &&
                    options.paragraphSpacing == paragraphSpacing &&
                    options.size == size &&
                    options.lineHeight == lineHeight &&
                    !(
                      (!0 === options.wordBreak && !options.wordBreak) ||
                      (0 == options.wordBreak && options.wordBreak)
                    ))
                );
              })(options)) &&
            (text = txt)
          )
            return (
              (function setVars(options) {
                (font = options.font || font),
                  (bold = options.bold || bold),
                  (italic = options.italic || italic),
                  (width = options.width || width),
                  (align = options.align || align),
                  (wordSpacing = options.wordSpacing || wordSpacing),
                  (letterSpacing = options.letterSpacing || letterSpacing),
                  (paragraphSpacing =
                    options.paragraphSpacing || paragraphSpacing),
                  (size = options.size || size),
                  (lineHeight = options.lineHeight || lineHeight),
                  (wordBreak = options.wordBreak || wordBreak),
                  (langBreak = options.langBreak || langBreak),
                  (direction = options.direction || direction);
              })(options || {}),
              overrideParams(),
              (_this.string = text),
              (_this.charLength = text.length),
              console.log(_this.text),
              (_this.text = new GLTextGeometry({
                font: font,
                italic: italic,
                bold: bold,
                text: text,
                width: width,
                align: align,
                direction: direction,
                wordSpacing: wordSpacing,
                letterSpacing: letterSpacing,
                paragraphSpacing: paragraphSpacing,
                size: size,
                lineHeight: lineHeight,
                wordBreak: wordBreak,
                langBreak: langBreak,
                config: config,
              })),
              resetOverride(),
              (_promise = Promise.create()),
              _this.text.loaded.then(({ buffers: buffers, height: height }) => {
                !(function updateGeometry(buffers) {
                  _this.geometry.attributes.position.setArray(buffers.position),
                    _this.geometry.attributes.uv.setArray(buffers.uv),
                    _this.geometry.attributes.animation.setArray(
                      buffers.animation
                    ),
                    _this.geometry.attributes.weight.setArray(buffers.weight),
                    (_this.geometry.index = buffers.index),
                    (_this.geometry.indexNeedsUpdate = !0),
                    (_this.geometry.boundingBox = buffers.boundingBox),
                    (_this.geometry.boundingSphere = buffers.boundingSphere),
                    (_this.geometry.letterCount = buffers.letterCount + 1),
                    (_this.geometry.wordCount = buffers.wordCount + 1),
                    (_this.geometry.lineCount = buffers.lineCount + 1);
                })(buffers),
                  (_this.height = height),
                  _this.needsCenterY && _this.centerY(),
                  _promise.resolve();
              }),
              _promise
            );
        }),
        (this.getData = function () {
          return {
            font: font,
            italic: italic,
            bold: bold,
            text: text,
            width: width,
            align: align,
            direction: direction,
            wordSpacing: wordSpacing,
            letterSpacing: letterSpacing,
            paragraphSpacing: paragraphSpacing,
            size: size,
            lineHeight: lineHeight,
            wordBreak: wordBreak,
            langBreak: langBreak,
            color: color,
          };
        });
    },
    (_) => {
      GLText.FONT_CONFIG = {};
    }
  ),
  Class(
    function GLTextGeometry({
      font: font,
      italic: italic,
      bold: bold,
      text: text,
      width: width = 1 / 0,
      align: align = "left",
      size: size = 1,
      direction: direction = "ltr",
      letterSpacing: letterSpacing = 0,
      paragraphSpacing: paragraphSpacing = 1,
      lineHeight: lineHeight = 1.4,
      wordSpacing: wordSpacing = 0,
      wordBreak: wordBreak = !1,
      langBreak: langBreak = !1,
      config: config = {},
    }) {
      let json,
        texture,
        glyphs,
        bJson,
        bTexture,
        bGlyphs,
        iJson,
        iTexture,
        iGlyphs,
        _this = this;
      (_this.loaded = Promise.create()),
        (_this.fontLoaded = Promise.create()),
        (async function init() {
          await (async function loadFont() {
            ([json, texture, glyphs] = await GLTextGeometry.loadFont(font)),
              bold &&
                ([bJson, bTexture, bGlyphs] = await GLTextGeometry.loadFont(
                  bold
                ));
            italic &&
              ([iJson, iTexture, iGlyphs] = await GLTextGeometry.loadFont(
                italic
              ));
            _this.fontLoaded.resolve();
          })(),
            (async function createGeometry() {
              let buffers = await GLTextThread.generate({
                font: font,
                bold: bold,
                italic: italic,
                text: text,
                width: width,
                align: align,
                size: size,
                direction: direction,
                letterSpacing: letterSpacing,
                paragraphSpacing: paragraphSpacing,
                lineHeight: lineHeight,
                wordSpacing: wordSpacing,
                wordBreak: wordBreak,
                langBreak: langBreak,
                json: json,
                glyphs: glyphs,
                bJson: bJson,
                bGlyphs: bGlyphs,
                iJson: iJson,
                iGlyphs: iGlyphs,
                config: config,
              });
              (_this.buffers = buffers),
                (_this.texture = texture),
                (_this.textureBold = bTexture),
                (_this.textureItalic = iTexture),
                (_this.numLines = buffers.lineLength),
                (_this.height = _this.numLines * size * lineHeight),
                _this.onLayout &&
                  _this.onLayout(
                    buffers,
                    texture,
                    _this.height,
                    _this.numLines
                  ),
                _this.loaded.resolve({
                  buffers: buffers,
                  texture: texture,
                  textureBold: bTexture,
                  textureItalic: iTexture,
                  height: _this.height,
                  numLines: _this.numLines,
                });
            })();
        })();
    },
    (_) => {
      async function loadJSON(font) {
        return await get(
          (function getPathTo(font, ext) {
            let fontName = GLTextGeometry.fontMapping[font] || font,
              suffix = ext ? `.${ext}` : "";
            return Assets.getPath(`${getFontPath(font)}${fontName}${suffix}`);
          })(font, "json")
        );
      }
      async function loadTexture(font) {
        let base = `${getFontPath(font)}${font}`,
          path =
            [`${base}.ktx2`, Assets.supportsWebP() && `${base}.webp`]
              .filter(Boolean)
              .find((candidate) =>
                (window.ASSETS?.SW || []).includes(candidate)
              ) || `${base}.png`,
          texture = await Utils3D.getTexture(path);
        return (
          (texture.generateMipmaps = !1),
          (texture.minFilter = Texture.LINEAR),
          texture
        );
      }
      function getFontPath(font) {
        return GLTextGeometry.fontMapping[font] && GLTextGeometry.fontPath
          ? GLTextGeometry.fontPath
          : "fonts/";
      }
      let _promises = {};
      (GLTextGeometry.fontMapping = {}),
        (GLTextGeometry.chars = {}),
        (GLTextGeometry.loadFont = function (font) {
          if (!_promises[font]) {
            let promise = Promise.create();
            (_promises[font] = promise),
              (async function () {
                let [json, texture] = await Promise.all([
                    loadJSON(font),
                    loadTexture(font),
                  ]),
                  glyphs = {};
                json.chars.forEach((d) => (glyphs[d.char] = d)),
                  promise.resolve([json, texture, glyphs]),
                  (GLTextGeometry.chars[font] = json.chars);
              })();
          }
          return _promises[font];
        });
    }
  ),
  Class(function GLTextThread() {
    function loadTextGeometry(
      {
        font: font,
        bold: bold,
        italic: italic,
        text: text,
        width: width,
        align: align,
        size: size,
        direction: direction,
        letterSpacing: letterSpacing,
        paragraphSpacing: paragraphSpacing,
        lineHeight: lineHeight,
        wordSpacing: wordSpacing,
        wordBreak: wordBreak,
        langBreak: langBreak,
        json: json,
        glyphs: glyphs,
        bJson: bJson,
        bGlyphs: bGlyphs,
        iJson: iJson,
        iGlyphs: iGlyphs,
        config: config,
      },
      pid
    ) {
      const newline = /\n/,
        whitespace = /[^\S ]/,
        langbreak = !!langBreak && new RegExp(langBreak),
        dir = "rtl" === direction ? -1 : 1;
      config || (config = {}),
        (config.boldBaseOffset = config.boldBaseOffset
          ? config.boldBaseOffset
          : 0),
        (config.italicBaseOffset = config.italicBaseOffset
          ? config.italicBaseOffset
          : 0);
      let buffers,
        scale = size / json.common.base,
        weights = [],
        weight = { 0: glyphs, 1: bGlyphs, 2: iGlyphs };
      function getKernPairOffset(id1, id2) {
        for (let i = 0; i < json.kernings.length; i++) {
          let k = json.kernings[i];
          if (!(k.first < id1) && !(k.second < id2))
            return k.first > id1 || (k.first === id1 && k.second > id2)
              ? 0
              : k.amount;
        }
        return 0;
      }
      !(function setWeights() {
        let i = 0,
          w = 0;
        for (; i < text.length; ) {
          let code = text.substring(i, i + 3).toLowerCase(),
            endcode = text.substring(i, i + 4).toLowerCase();
          ("<b>" !== code && "<i>" !== code) ||
            ((w = "<b>" === code ? 1 : 2),
            (text = text.substring(0, i) + text.substring(i + 3))),
            ("</b>" !== endcode && "</i>" !== endcode) ||
              ((w = 0), (text = text.substring(0, i) + text.substring(i + 4))),
            weights.push(w),
            i++;
        }
      })(),
        (function createGeometry() {
          let numChars = text.replace(/[ \n]/g, "").length;
          buffers = {
            position: new Float32Array(4 * numChars * 3),
            uv: new Float32Array(4 * numChars * 2),
            local: new Float32Array(4 * numChars * 2),
            animation: new Float32Array(3 * numChars * 4),
            index: new Uint16Array(6 * numChars),
            weight: new Float32Array(4 * numChars),
          };
          for (let i = 0; i < numChars; i++)
            buffers.index.set(
              [4 * i, 4 * i + 2, 4 * i + 1, 4 * i + 1, 4 * i + 2, 4 * i + 3],
              6 * i
            );
          !(function layout() {
            const lines = [];
            let cursor = 0,
              wordCursor = 0,
              wordWidth = 0,
              line = newLine();
            function newLine(br = !1) {
              const line = { width: 0, glyphs: [] };
              return (
                lines.last() && (lines.last().br = br),
                lines.push(line),
                (wordCursor = cursor),
                (wordWidth = 0),
                line
              );
            }
            for (; cursor < text.length; ) {
              let prev = text[cursor - 1],
                char = text[cursor];
              if (
                !line.width &&
                whitespace.test(char) &&
                !(prev && newline.test(char) && newline.test(prev))
              ) {
                cursor++, (wordCursor = cursor), (wordWidth = 0);
                continue;
              }
              if (newline.test(char)) {
                cursor++, (line = newLine(!0));
                continue;
              }
              let style = weight[weights[cursor]] || weight[0],
                glyph = style[char];
              if (
                (glyph ||
                  (console.warn(`font ${font} missing character '${char}'`),
                  (char = Object.keys(style)[0]),
                  (glyph = style[char])),
                (glyph.weight = weights[cursor]),
                line.glyphs.length)
              ) {
                const prevGlyph = line.glyphs[line.glyphs.length - 1][0];
                let kern = getKernPairOffset(glyph.id, prevGlyph.id) * scale;
                (line.width += kern), (wordWidth += kern * dir);
              }
              let gl = Object.assign({}, glyph);
              (gl.weight = weights[cursor]), line.glyphs.push([gl, line.width]);
              let advance = 0;
              if (
                (whitespace.test(char)
                  ? ((gl.whitespace = !0),
                    (wordCursor = cursor),
                    (wordWidth = 0),
                    (advance += wordSpacing * size))
                  : (advance += letterSpacing * size),
                (advance += glyph.xadvance * scale),
                (line.width += advance),
                (wordWidth += advance),
                line.width > width)
              ) {
                if (
                  (wordBreak || (char && langBreak && !langbreak.test(char))) &&
                  line.glyphs.length > 1
                ) {
                  (line.width -= advance),
                    line.glyphs.pop(),
                    (line = newLine());
                  continue;
                }
                if (!wordBreak && wordWidth !== line.width) {
                  let numGlyphs = cursor - wordCursor + 1;
                  line.glyphs.splice(-numGlyphs, numGlyphs),
                    (cursor = wordCursor),
                    (line.width -= wordWidth),
                    (line = newLine());
                  continue;
                }
              }
              cursor++;
            }
            line.width || lines.pop();
            if ("justify" === align) {
              let max = -1 / 0;
              lines.forEach((l) => {
                (l.whitespaces = 0),
                  max < l.width && (max = l.width),
                  l.glyphs.forEach((g) => {
                    g[0].whitespace && l.whitespaces++;
                  });
              }),
                lines.forEach((l) => {
                  let totalToAdd = max - l.width,
                    addToWhitespace =
                      0 === l.whitespaces ? 0 : totalToAdd / l.whitespaces;
                  l.width = max;
                  let additionalOffset = 0;
                  l.glyphs.forEach((g) => {
                    (g[1] += additionalOffset),
                      g[0].whitespace && (additionalOffset += addToWhitespace);
                  });
                });
            }
            !(function populateBuffers(lines) {
              const texW = json.common.scaleW,
                texH = json.common.scaleH;
              let geom,
                y = (config.baseOffset ? config.baseOffset : 0.07) * size,
                j = 0,
                glyphIndex = 0,
                wordIndex = -1,
                lineId = -1;
              for (let lineIndex = 0; lineIndex < lines.length; lineIndex++) {
                let line = lines[lineIndex];
                wordIndex++, lineId++;
                for (let i = 0; i < line.glyphs.length; i++) {
                  const glyph = line.glyphs[i][0];
                  let x = line.glyphs[i][1];
                  if (
                    (-1 === dir && (x = line.width - x),
                    "center" === align || "justify" === align
                      ? (x -= 0.5 * line.width)
                      : "right" === align && (x -= line.width * dir),
                    whitespace.test(glyph.char))
                  ) {
                    wordIndex++;
                    continue;
                  }
                  1 === glyph.weight && (y += config.boldBaseOffset * scale),
                    2 === glyph.weight &&
                      (y += config.italicBaseOffset * scale),
                    (x += glyph.xoffset * scale * dir),
                    (y -= glyph.yoffset * scale),
                    buffers.weight.set(
                      [glyph.weight, glyph.weight, glyph.weight, glyph.weight],
                      4 * glyphIndex
                    );
                  let w = glyph.width * scale,
                    h = glyph.height * scale;
                  -1 === dir
                    ? buffers.position.set(
                        [x - w, y - h, 0, x - w, y, 0, x, y - h, 0, x, y, 0],
                        4 * j * 3
                      )
                    : buffers.position.set(
                        [x, y - h, 0, x, y, 0, x + w, y - h, 0, x + w, y, 0],
                        4 * j * 3
                      ),
                    buffers.animation.set(
                      [
                        glyphIndex,
                        wordIndex,
                        lineId,
                        glyphIndex,
                        wordIndex,
                        lineId,
                        glyphIndex,
                        wordIndex,
                        lineId,
                        glyphIndex,
                        wordIndex,
                        lineId,
                      ],
                      3 * glyphIndex * 4
                    ),
                    glyphIndex++;
                  let u = glyph.x / texW,
                    uw = glyph.width / texW,
                    v = 1 - glyph.y / texH,
                    vh = glyph.height / texH;
                  buffers.uv.set(
                    [u, v - vh, u, v, u + uw, v - vh, u + uw, v],
                    4 * j * 2
                  ),
                    buffers.local.set([0, 1, 0, 0, 1, 1, 1, 0], 4 * j * 2),
                    1 === glyph.weight && (y -= config.boldBaseOffset * scale),
                    2 === glyph.weight &&
                      (y -= config.italicBaseOffset * scale),
                    (y += glyph.yoffset * scale),
                    j++;
                }
                y -= size * lineHeight * (line.br ? paragraphSpacing : 1);
              }
              window.zUtils3D &&
                ((geom = new Geometry()),
                geom.addAttribute(
                  "position",
                  new GeometryAttribute(buffers.position, 3)
                ),
                geom.computeBoundingBox(),
                geom.computeBoundingSphere());
              let backing = [];
              for (let key in buffers) backing.push(buffers[key].buffer);
              (buffers.lineLength = lines.length),
                geom &&
                  ((buffers.boundingBox = geom.boundingBox),
                  (buffers.boundingSphere = geom.boundingSphere));
              (buffers.letterCount = glyphIndex),
                (buffers.lineCount = lineId),
                (buffers.wordCount = wordIndex),
                resolve(buffers, pid, backing);
            })(lines);
          })();
        })();
    }
    Thread.upload(loadTextGeometry),
      (this.generate = async function (obj) {
        return Thread.shared().loadTextGeometry(obj);
      });
  }, "static"),
  Class(function GLUI() {
    Inherit(this, Component);
    const _this = this,
      hasMetal = !!window.Metal,
      hasAuraAR = !!window.AURA_AR;
    function loop() {
      hasMetal ||
        (hasAuraAR &&
          AURA_AR.active &&
          ((World.NUKE.postRender = null), (AURA_AR.postRender = loop)),
        _this.Scene && _this.Scene.render(),
        _this.Stage && _this.Stage.render());
    }
    (window.$gl = function (width, height, map, customCompile) {
      return new GLUIObject(width, height, map, customCompile);
    }),
      (window.$glText = function (
        text,
        fontName,
        fontSize,
        options,
        customCompile
      ) {
        return new GLUIText(text, fontName, fontSize, options, customCompile);
      }),
      (this.init = async function (is2D, is3D) {
        _this.initialized ||
          (void 0 === is2D && ((is2D = !0), (is3D = !0)),
          await AssetLoader.waitForLib("zUtils3D"),
          is2D && (_this.Stage = new GLUIStage()),
          is3D &&
            ((_this.Scene = new GLUIStage3D()),
            (_this.Scene.interaction.input = Mouse)),
          _this.wait(World, "NUKE", (_) => {
            (_this.initialized = !0),
              _this.Scene && (World.NUKE.onBeforeRender = _this.Scene.mark),
              (World.NUKE.postRender = loop);
          }));
      }),
      (this.clear = function () {
        _this.Stage.clear(), _this.Scene.clear();
      }),
      (this.ready = function () {
        return _this.wait(_this, "initialized");
      }),
      (this.renderDirect = function (render) {
        _this.Scene && _this.Scene.renderDirect(render),
          _this.Stage && _this.Stage.renderDirect(render);
      });
  }, "static"),
  Class(function GLUIElement() {
    Inherit(this, Component);
    (this.element = $gl()),
      (this.create = function (w, h, t) {
        return this.element.create(w, h, t);
      });
  }),
  Class(function GLUIUtils() {
    const _this = this;
    (_this.setRetinaMode = function ($obj, retinaMode, parent) {
      if (
        (RenderManager.type === RenderManager.WEBVR && (retinaMode = !1),
        parent ||
          (parent = ($obj.anchor && $obj.anchor._parent) || $obj.group._parent))
      )
        if (retinaMode) {
          let gluiToRTScene,
            p = parent;
          for (; p; ) p.glSceneEnabled && (gluiToRTScene = p), (p = p.parent);
          gluiToRTScene
            ? gluiToRTScene.glScene.add($obj)
            : GLUI.Scene.add($obj),
            parent.add($obj.anchor),
            ($obj.anchor.retinaAnchorFor = $obj),
            $obj.group.asyncPromise &&
              !$obj.anchor.asyncPromise &&
              ($obj.anchor.asyncPromise = $obj.group.asyncPromise),
            ($obj.anchor.position.equals($obj.group.position) &&
              $obj.anchor.scale.equals($obj.group.scale) &&
              $obj.anchor.quaternion.equals($obj.group.quaternion)) ||
              (($obj.isDirty = !0),
              $obj.mesh &&
                $obj.mesh.onBeforeRender &&
                $obj.mesh.onBeforeRender());
        } else
          _this.isRetinaMode($obj) &&
            (parent.remove($obj.anchor),
            GLUI.Scene.remove($obj),
            ($obj.anchor._parent = null),
            ($obj.group.visible = parent.determineVisible()),
            "boolean" == typeof $obj.isDirty &&
            $obj.mesh &&
            $obj.mesh.onBeforeRender
              ? (($obj.isDirty = !0), $obj.mesh.onBeforeRender())
              : ($obj.group.position.setScalar(0),
                $obj.group.quaternion.set(0, 0, 0, 1),
                $obj.group.scale.setScalar(1)),
            ($obj.deferred = !1),
            ($obj.parent = null)),
            parent.add($obj.group);
    }),
      (_this.isRetinaMode = function ($obj) {
        return (
          RenderManager.type !== RenderManager.WEBVR &&
          $obj.anchor &&
          $obj.anchor._parent &&
          $obj.parent === GLUI.Scene
        );
      });
  }, "static"),
  Class(function GLUIBatch(
    globalUniforms = {},
    _useWorldCoords,
    cacheSuffix = ""
  ) {
    Inherit(this, Component);
    const _this = this;
    var _timer,
      _geometry,
      _shader,
      _objects = [];
    function loop() {
      if (_geometry)
        for (let i = 0; i < _objects.length; i++) {
          let obj = _objects[i];
          obj._buffers &&
            (obj.mesh.onBeforeRender(),
            _useWorldCoords &&
              (obj.group.updateMatrixWorld(),
              obj.mesh.getWorldPosition(obj.worldPosition),
              obj.worldRotation.setFromQuaternion(
                obj.mesh.getWorldQuaternion()
              ),
              obj.mesh.getWorldScale(obj.worldScale)),
            obj._buffers.forEach((buffer) => {
              let dirty = !1;
              if (
                ((dirty = !buffer.value.equals(buffer.lookup)),
                buffer.value.copy(buffer.lookup),
                dirty)
              ) {
                let attribute = _geometry.attributes[buffer.key],
                  array = attribute.array;
                switch (buffer.key) {
                  case "scale":
                    _useWorldCoords
                      ? ((array[2 * i + 0] = obj.worldScale.x),
                        (array[2 * i + 1] = obj.worldScale.y))
                      : ((array[2 * i + 0] =
                          obj.group.scale.x * obj.mesh.scale.x),
                        (array[2 * i + 1] =
                          obj.group.scale.y * obj.mesh.scale.y));
                    break;
                  case "rotation":
                    array[i] = buffer.lookup.z;
                    break;
                  default:
                    _useWorldCoords
                      ? ((array[3 * i + 0] = obj.worldPosition.x),
                        (array[3 * i + 1] = obj.worldPosition.y))
                      : ((array[3 * i + 0] = obj.group.position.x),
                        (array[3 * i + 1] = obj.group.position.y)),
                      (array[3 * i + 2] = obj.mesh.renderOrder);
                }
                attribute.needsUpdate = !0;
              }
            }),
            obj._uniforms.forEach((uniform) => {
              let dirty = !1;
              if (
                ("f" == uniform.type
                  ? ((dirty =
                      obj.mesh.shader.uniforms[uniform.key].value !=
                      uniform.value),
                    (uniform.value =
                      obj.mesh.shader.uniforms[uniform.key].value))
                  : ((dirty = !obj.mesh.shader.uniforms[
                      uniform.key
                    ].value.equals(uniform.value)),
                    uniform.value.copy(
                      obj.mesh.shader.uniforms[uniform.key].value
                    )),
                dirty)
              ) {
                let attribute = _geometry.attributes["a_" + uniform.key],
                  array = attribute.array;
                "f" == uniform.type
                  ? (array[i] = uniform.value)
                  : uniform.value.toArray(array, i * uniform.components),
                  (attribute.needsUpdate = !0);
              }
            }));
        }
    }
    function getTypeFromSize(size) {
      switch (size) {
        case 1:
          return "float";
        case 2:
          return "vec2";
        case 3:
          return "vec3";
        case 4:
          return "vec4";
      }
    }
    function createMesh() {
      let shader = _objects[0].mesh.shader;
      _geometry = new Geometry().instanceFrom(
        _objects[0].mesh.geometry.clone()
      );
      let map = {},
        arrays = {};
      _objects.forEach((obj, i) => {
        obj.mesh.onBeforeRender();
        let buffers = [],
          uniforms = [];
        for (let key in shader.uniforms) {
          let uniform = shader.uniforms[key];
          uniform &&
            (uniform.value instanceof Color &&
              uniforms.push({ key: key, type: "c", components: 3 }),
            uniform.value instanceof Vector4 &&
              uniforms.push({ key: key, type: "v4", components: 4 }),
            uniform.value instanceof Vector3 &&
              uniforms.push({ key: key, type: "v3", components: 3 }),
            uniform.value instanceof Vector2 &&
              uniforms.push({ key: key, type: "v", components: 2 }),
            "number" == typeof uniform.value &&
              uniforms.push({ key: key, type: "f", components: 1 }));
        }
        _useWorldCoords &&
          ((obj.worldScale = new Vector3()),
          (obj.worldRotation = new Euler()),
          (obj.worldPosition = new Vector3())),
          buffers.push({
            key: "scale",
            lookup: _useWorldCoords ? obj.worldScale : obj.group.scale,
            components: 2,
          }),
          buffers.push({
            key: "rotation",
            lookup: _useWorldCoords ? obj.worldRotation : obj.group.rotation,
            components: 1,
          }),
          buffers.push({
            key: "offset",
            lookup: _useWorldCoords ? obj.worldPosition : obj.group.position,
            components: 3,
          }),
          uniforms.forEach((uniform) => {
            arrays["a_" + uniform.key] || (arrays["a_" + uniform.key] = []),
              map["a_" + uniform.key] || (map["a_" + uniform.key] = uniform);
            let value = shader.uniforms[uniform.key].value;
            "object" == typeof value
              ? ((uniform.value = value.clone()),
                uniform.value.toArray(
                  arrays["a_" + uniform.key],
                  i * uniform.components
                ))
              : ((uniform.value = shader.uniforms[uniform.key].value),
                arrays["a_" + uniform.key].push(uniform.value));
          }),
          buffers.forEach((buffer) => {
            switch (
              (arrays[buffer.key] || (arrays[buffer.key] = []),
              map[buffer.key] || (map[buffer.key] = buffer),
              (buffer.value = buffer.lookup.clone()),
              buffer.key)
            ) {
              case "scale":
                arrays[buffer.key].push(
                  obj.group.scale.x * obj.mesh.scale.x,
                  obj.group.scale.y * obj.mesh.scale.y
                );
                break;
              case "rotation":
                arrays[buffer.key].push(buffer.lookup.z);
                break;
              default:
                arrays[buffer.key].push(
                  buffer.lookup.x,
                  buffer.lookup.y,
                  obj.mesh.renderOrder
                );
            }
          }),
          (obj._buffers = buffers),
          (obj._uniforms = uniforms),
          (obj.shader.neverRender = !0);
      });
      let attributes = [],
        defines = [];
      for (let key in map)
        key.includes("a_") &&
          (attributes.push(`% ${getTypeFromSize(map[key].components)} ${key};`),
          defines.push(`${key.replace("a_", "v_")} = ${key};`));
      (attributes = attributes.join("\n")), (defines = defines.join("\n"));
      for (let key in arrays)
        _geometry.addAttribute(
          key,
          new GeometryAttribute(
            new Float32Array(arrays[key]),
            map[key].components,
            1
          )
        );
      let cacheKey = shader.fsName + cacheSuffix;
      if (GLUIBatch.cache[cacheKey]) _shader = GLUIBatch.cache[cacheKey];
      else {
        (_shader = _this.initClass(
          Shader,
          "GLUIBatch",
          shader.fsName,
          Object.assign(
            {},
            {
              transparent: !0,
              depthWrite: !1,
              depthTest: !1,
              customCompile: Utils.uuid(),
            },
            globalUniforms
          )
        )).vertexShader || _shader.resetProgram();
        let vsSplit = _shader.vertexShader.split("__ACTIVE_THEORY_LIGHTS__"),
          fsSplit = _shader.fragmentShader.split("__ACTIVE_THEORY_LIGHTS__"),
          definitions = [];
        fsSplit[1].split("\n").forEach((line) => {
          if (line.includes("uniform")) {
            if (line.includes("sampler2D")) return;
            let data = line.split(" ");
            definitions.push(`${data[2].replace(";", "")} = a_${data[2]}`),
              (vsSplit[1] =
                `\nattribute ${data[1]} a_${data[2]}\nvarying ${data[1]} ${data[2]}` +
                vsSplit[1]),
              (vsSplit[1] = vsSplit[1].replace(line, "")),
              (fsSplit[1] = fsSplit[1].replace(
                line,
                `varying ${data[1]} ${data[2]}`
              ));
          }
        }),
          (vsSplit[1] = vsSplit[1].replace(
            "//vdefines",
            "\n" + definitions.join("\n")
          )),
          (_shader.vertexShader = vsSplit.join("__ACTIVE_THEORY_LIGHTS__")),
          (_shader.fragmentShader = fsSplit.join("__ACTIVE_THEORY_LIGHTS__")),
          (GLUIBatch.cache[cacheKey] = _shader);
      }
      shader.replicateUniformsTo(_shader),
        (_this.mesh = new Mesh(_geometry, _shader)),
        (_this.mesh.frustumCulled = !1),
        _this.group.add(_this.mesh);
    }
    (this.group = new Group()),
      "boolean" == typeof globalUniforms &&
        ((_useWorldCoords = globalUniforms), (globalUniforms = {})),
      GLUIBatch.cache || (GLUIBatch.cache = {}),
      _this.startRender(loop),
      (this.add = function (obj) {
        if (
          (clearTimeout(_timer),
          (_timer = _this.delayedCall(createMesh, 50)),
          _useWorldCoords)
        ) {
          let getAlpha = obj.getAlpha;
          getAlpha &&
            (obj.getAlpha = () =>
              (_this.parent ? _this.parent.getAlpha() : 1) *
              getAlpha.call(obj));
        } else _this.parent.add(obj);
        _objects.push(obj);
      }),
      (this.setZ = async function (z) {
        await _this.wait("mesh"), (_this.mesh.renderOrder = z);
      }),
      (this.onDestroy = function () {
        _this.mesh && _this.mesh.destroy();
      });
  }),
  Class(function GLUIBatchText(
    globalUniforms = {},
    _useWorldCoords,
    _shaderName
  ) {
    Inherit(this, Component);
    const _this = this;
    var _geometry,
      _shader,
      _timer,
      _forceUpdate,
      _promises = [],
      _toSplice = [],
      _objects = [],
      _offset = 0;
    function loop() {
      if (!_geometry) return;
      let updated = !1;
      for (let key in _geometry.attributes) {
        let attrib = _geometry.attributes[key];
        attrib.updateRange.length && (attrib.updateRange.length = 0);
      }
      let len = _objects.length;
      for (let i = 0; i < len; i++) {
        let obj = _objects[i];
        obj.mesh.onBeforeRender(),
          _useWorldCoords &&
            (obj.group.updateMatrixWorld(),
            obj.mesh.getWorldPosition(obj.worldPosition),
            obj.worldRotation.setFromQuaternion(obj.mesh.getWorldQuaternion()),
            obj.mesh.getWorldScale(obj.worldScale));
        let offset = obj._offset,
          count = obj._count,
          end = offset + count;
        obj._buffers.forEach((buffer) => {
          let dirty = !1;
          if (
            ((dirty = !buffer.value.equals(buffer.lookup)),
            buffer.value.copy(buffer.lookup),
            dirty)
          ) {
            let array = _geometry.attributes[buffer.key].array;
            for (let j = offset; j < end; j++)
              switch (buffer.components) {
                case 4:
                  (array[4 * j + 0] = buffer.lookup.x),
                    (array[4 * j + 1] = buffer.lookup.y),
                    (array[4 * j + 2] = buffer.lookup.z),
                    (array[4 * j + 3] = buffer.lookup.w);
                  break;
                case 3:
                  (array[3 * j + 0] = buffer.lookup.x),
                    (array[3 * j + 1] = buffer.lookup.y),
                    (array[3 * j + 2] = buffer.lookup.z);
                  break;
                case 2:
                  (array[2 * j + 0] = buffer.lookup.x),
                    (array[2 * j + 1] = buffer.lookup.y);
                  break;
                case 1:
                  array[j] = buffer.lookup.z;
              }
            (updated = !0),
              (buffer.updateRange.offset = offset * buffer.components),
              (buffer.updateRange.count = count * buffer.components),
              _geometry.attributes[buffer.key].updateRange.push(
                buffer.updateRange
              ),
              (_geometry.attributes[buffer.key].needsUpdate = !0);
          }
        }),
          obj._uniforms.forEach((uniform) => {
            let dirty = !1;
            if (
              ("f" == uniform.type
                ? ((dirty =
                    obj.mesh.shader.uniforms[uniform.key].value !=
                    uniform.value),
                  (uniform.value = obj.mesh.shader.uniforms[uniform.key].value))
                : ((dirty = !obj.mesh.shader.uniforms[uniform.key].value.equals(
                    uniform.value
                  )),
                  uniform.value.copy(
                    obj.mesh.shader.uniforms[uniform.key].value
                  )),
              dirty || _forceUpdate)
            ) {
              let array = _geometry.attributes[`a_${uniform.key}`].array;
              for (let j = offset; j < end; j++)
                "f" == uniform.type
                  ? (array[j] = obj.mesh.shader.uniforms[uniform.key].value)
                  : obj.mesh.shader.uniforms[uniform.key].value.toArray(
                      array,
                      j * uniform.components
                    );
              (updated = !0),
                (uniform.updateRange.offset = offset * uniform.components),
                (uniform.updateRange.count = count * uniform.components),
                _geometry.attributes[`a_${uniform.key}`].updateRange.push(
                  uniform.updateRange
                ),
                (_geometry.attributes[`a_${uniform.key}`].needsUpdate = !0);
            }
          });
      }
      if (updated)
        for (let key in _geometry.attributes) {
          let bottom,
            attrib = _geometry.attributes[key];
          if (!attrib.updateRange.length) continue;
          let toSplice = _toSplice;
          toSplice.length = 0;
          for (let i = 0; i < attrib.updateRange.length; i++) {
            let current = attrib.updateRange[i],
              prev = attrib.updateRange[i - 1];
            prev
              ? prev.offset + prev.count == current.offset
                ? ((bottom.count += current.count), toSplice.push(i))
                : (bottom = current)
              : (bottom = current);
          }
          for (let i = toSplice.length - 1; i > -1; i--)
            attrib.updateRange.splice(toSplice[i], 1);
        }
      _forceUpdate = !1;
    }
    async function createMesh() {
      if (_this.flag("mesh")) return;
      await Promise.all(_promises), await _this.wait(100);
      let mesh = new Mesh(_geometry, _shader);
      (_this.mesh = mesh),
        (mesh.frustumCulled = !1),
        _this.group.add(mesh),
        _this.flag("mesh", !0);
    }
    (this.group = new Group()),
      (this.enable3D = () => {}),
      "boolean" == typeof globalUniforms &&
        ((_useWorldCoords = globalUniforms), (globalUniforms = {})),
      _this.flag("canLoad", !0),
      _this.startRender(loop),
      (_this.add = async function (obj) {
        if ((await _this.flag("canLoad"), _this.destroy)) {
          if (
            (_this.flag("canLoad", !1),
            await obj.loaded(),
            void 0 !== obj.mesh.shader.neverRender &&
              (obj.mesh.shader.neverRender = !0),
            _promises.push(obj.loaded()),
            (function addAttributes(obj, mesh) {
              let { geometry: geometry, shader: shader } = mesh,
                count = geometry.attributes.uv.count;
              mesh.onBeforeRender();
              let buffers = [],
                uniforms = [];
              for (let key in shader.uniforms) {
                let uniform = shader.uniforms[key];
                uniform.value instanceof Color &&
                  uniforms.push({ key: key, type: "c", components: 3 }),
                  uniform.value instanceof Vector3 &&
                    uniforms.push({ key: key, type: "v3", components: 3 }),
                  uniform.value instanceof Vector4 &&
                    uniforms.push({ key: key, type: "v4", components: 4 }),
                  uniform.value instanceof Vector2 &&
                    uniforms.push({ key: key, type: "v", components: 2 }),
                  "number" == typeof uniform.value &&
                    uniforms.push({ key: key, type: "f", components: 1 });
              }
              _useWorldCoords &&
                ((obj.worldScale = new Vector3()),
                (obj.worldRotation = new Euler()),
                (obj.worldPosition = new Vector3())),
                buffers.push({
                  key: "offset",
                  lookup: _useWorldCoords
                    ? obj.worldPosition
                    : obj.group.position,
                  components: 3,
                }),
                buffers.push({
                  key: "scale",
                  lookup: _useWorldCoords ? obj.worldScale : obj.group.scale,
                  components: 2,
                }),
                buffers.push({
                  key: "rotation",
                  lookup: _useWorldCoords
                    ? obj.worldRotation
                    : obj.group.rotation,
                  components: 1,
                }),
                uniforms.forEach((uniform) => {
                  (uniform.updateRange = {}),
                    (uniform.value = shader.uniforms[uniform.key].value),
                    "object" == typeof uniform.value &&
                      (uniform.value = uniform.value.clone()),
                    (uniform.buffer = new Float32Array(
                      count * uniform.components
                    ));
                }),
                buffers.forEach((buffer) => {
                  (buffer.updateRange = {}),
                    (buffer.value = buffer.lookup.clone()),
                    (buffer.buffer = new Float32Array(
                      count * buffer.components
                    ));
                });
              for (let i = 0; i < count; i++)
                buffers.forEach((buffer) => {
                  switch (buffer.components) {
                    case 4:
                      (buffer.buffer[4 * i + 0] = buffer.lookup.x),
                        (buffer.buffer[4 * i + 1] = buffer.lookup.y),
                        (buffer.buffer[4 * i + 2] = buffer.lookup.z),
                        (buffer.buffer[4 * i + 3] = buffer.lookup.w);
                      break;
                    case 3:
                      (buffer.buffer[3 * i + 0] = buffer.lookup.x),
                        (buffer.buffer[3 * i + 1] = buffer.lookup.y),
                        (buffer.buffer[3 * i + 2] = buffer.lookup.z);
                      break;
                    case 2:
                      (buffer.buffer[2 * i + 0] = buffer.lookup.x),
                        (buffer.buffer[2 * i + 1] = buffer.lookup.y);
                      break;
                    case 1:
                      buffer.buffer[i] = buffer.lookup.z;
                  }
                }),
                  uniforms.forEach((uniform) => {
                    "f" == uniform.type
                      ? (uniform.buffer[i] = shader.uniforms[uniform.key].value)
                      : shader.uniforms[uniform.key].value.toArray(
                          uniform.buffer,
                          i * uniform.components
                        );
                  });
              buffers.forEach((buffer) => {
                geometry.addAttribute(
                  buffer.key,
                  new GeometryAttribute(buffer.buffer, buffer.components)
                );
              }),
                uniforms.forEach((uniform) => {
                  geometry.addAttribute(
                    `a_${uniform.key}`,
                    new GeometryAttribute(uniform.buffer, uniform.components)
                  );
                }),
                (obj._offset = _offset),
                (obj._count = count),
                (obj._uniforms = uniforms),
                (obj._buffers = buffers),
                _objects.push(obj),
                (_offset += count);
            })(obj, obj.mesh),
            _useWorldCoords)
          ) {
            let getAlpha = obj.getAlpha;
            getAlpha &&
              (obj.getAlpha = () =>
                (_this.parent ? _this.parent.getAlpha() : 1) *
                getAlpha.call(obj));
          }
          _geometry
            ? _geometry.merge(obj.mesh.geometry)
            : (function initGeometry(mesh) {
                (_shader = _this.initClass(
                  Shader,
                  _shaderName || "GLUIBatchText",
                  _shaderName || mesh.shader.fsName,
                  {
                    transparent: !0,
                    depthWrite: !1,
                    customCompile: `${mesh.shader.vsName}|${mesh.shader.fsName}|instance`,
                    ...globalUniforms,
                  }
                )).vertexShader || _shader.resetProgram();
                let vsSplit = _shader.vertexShader.split(
                    "__ACTIVE_THEORY_LIGHTS__"
                  ),
                  fsSplit = _shader.fragmentShader.split(
                    "__ACTIVE_THEORY_LIGHTS__"
                  ),
                  definitions = [],
                  definitionSplit = [];
                fsSplit[1].split("\n").forEach((line) => {
                  if (line.includes("uniform")) {
                    if (line.includes("sampler2D")) return;
                    let data = line.split(" ");
                    definitions.push(
                      `${data[2].replace(";", "")} = a_${data[2]}`
                    ),
                      (vsSplit[1] = `\nattribute ${data[1]} a_${data[2]}\nvarying ${data[1]} ${data[2]}${vsSplit[1]}`),
                      (vsSplit[1] = vsSplit[1].replace(line, "")),
                      (fsSplit[1] = fsSplit[1].replace(
                        line,
                        `varying ${data[1]} ${data[2]}`
                      ));
                  }
                }),
                  definitions.forEach((def) =>
                    definitionSplit.push(def.split(" =")[0].trim())
                  );
                let baseVS = Shaders.getShader(`${mesh.shader.vsName}.vs`);
                if (baseVS.includes("//start batch main")) {
                  let main = baseVS
                    .split("//start batch main")[1]
                    .split("//end batch main")[0];
                  vsSplit[1] = vsSplit[1].replace("//custommain", main);
                  let beforeMain = baseVS.split("void main() {")[0];
                  (beforeMain = beforeMain.replace(
                    "uniform sampler2D tMap;",
                    ""
                  )),
                    (beforeMain = beforeMain.replace("varying vec2 vUv;", "")),
                    beforeMain.split("\n").forEach((line) => {
                      definitionSplit.forEach((def) => {
                        line.includes(def) &&
                          line.includes(["uniform", "varying"]) &&
                          (beforeMain = beforeMain.replace(line, ""));
                      });
                    }),
                    (vsSplit[0] += beforeMain);
                }
                (vsSplit[1] = vsSplit[1].replace(
                  "//vdefines",
                  `\n${definitions.join("\n")}`
                )),
                  (_shader.vertexShader = vsSplit.join(
                    "__ACTIVE_THEORY_LIGHTS__"
                  )),
                  (_shader.fragmentShader = fsSplit.join(
                    "__ACTIVE_THEORY_LIGHTS__"
                  )),
                  mesh.shader.copyUniformsTo(_shader),
                  (_geometry = mesh.geometry.clone());
                for (let key in _geometry.attributes)
                  _geometry.attributes[key].updateRange = [];
              })(obj.mesh),
            _this.flag("canLoad", !0),
            clearTimeout(_timer),
            (_timer = _this.delayedCall(createMesh, 50)),
            (obj.isDirty = !0);
        }
      }),
      (_this.forceUpdate = function () {
        _forceUpdate = !0;
      }),
      (_this.onDestroy = function () {
        _this.mesh && _this.mesh.destroy();
      }),
      (_this.setZ = async function (z) {
        await _this.wait("mesh"), _this.mesh && (_this.mesh.renderOrder = z);
      });
  }),
  Class(function GLUIStageInteraction2D(_camera, _scene, _stage, _custom) {
    Inherit(this, Component);
    const _this = this;
    var _ray,
      _over,
      _click,
      _customTest,
      _disabled,
      _blocked,
      _test = [],
      _objects = (this.objects = []),
      _hold = new Vector2(),
      _lastTestedPoint = (new Vector2(), new Vector2()),
      _plane = new Plane();
    function cacheTopScene(obj) {
      let p = obj;
      for (; p; )
        p instanceof Scene && (obj.interactionScene = p), (p = p._parent);
    }
    function testObjects() {
      let objects = GLUI.Stage.interaction.objects;
      _test.length = 0;
      for (let i = objects.length - 1; i > -1; i--) {
        let obj = objects[i];
        obj.interactionScene || cacheTopScene(obj),
          (obj.forceGLUIInteraction ||
            (obj.determineVisible() && _scene == obj.interactionScene)) &&
            _test.push(obj);
      }
      return _test;
    }
    function externalStart() {
      _this._invisible || start(_lastTestedPoint);
    }
    function externalRelease() {
      _this._invisible || end(_lastTestedPoint);
    }
    function move(e) {
      if (GLUI.PREVENT_INTERACTION || _this._invisible || _disabled || _blocked)
        return;
      _ray || ((_ray = new Raycaster(_camera)).testVisibility = !1);
      let objects = testObjects();
      if (!objects.length)
        return void (
          _over &&
          (_over._onOver({ action: "out", object: _over }),
          (_over = null),
          Stage.cursor("auto"))
        );
      let hit = _ray.checkHit(objects, e, _stage);
      try {
        if (hit[0]) {
          _customTest || (GLUI.HIT = !0);
          let obj = hit[0].object.glui;
          _over ||
            ((_over = obj)._onOver({ action: "over", object: obj }),
            Stage.cursor("pointer")),
            _over != obj &&
              (_over._onOver({ action: "out", object: _over }),
              (_over = obj)._onOver({ action: "over", object: obj }),
              Stage.cursor("pointer"));
        } else _customTest || (GLUI.HIT = !1), _over && (_over._onOver({ action: "out", object: _over }), (_over = null), Stage.cursor("auto"));
      } catch (e) {
        console.warn(e);
      }
    }
    function start(e) {
      let handlingEvent = !(e instanceof Vector2),
        checkDefault = GLUI.PREVENT_DEFAULT_INTERACTION && handlingEvent,
        checkPrevention =
          GLUI.PREVENT_INTERACTION || _this._invisible || _disabled || _blocked;
      checkDefault ||
        checkPrevention ||
        ((_custom && handlingEvent) ||
          (!Device.mobile && RenderManager.type != RenderManager.WEBVR) ||
          move(e),
        _over &&
          !_click &&
          ((_click = _over), _hold.copy(e), (_hold.time = Date.now())));
    }
    function end(e) {
      if (
        !(GLUI.PREVENT_INTERACTION || _this._invisible || _disabled || _blocked)
      ) {
        if (
          (_customTest &&
            Device.mobile &&
            _click &&
            null == _over &&
            (_over = _click),
          (GLUI.HIT = !1),
          _click)
        ) {
          if (Date.now() - _hold.time > 750) return (_click = null);
          if (_click == _over)
            try {
              (_blocked = !0),
                _this.delayedCall((_) => {
                  _blocked = !1;
                }, _this.preventDoubleClickTime),
                _click._onClick({ action: "click", object: _click }),
                (Device.mobile || _custom) &&
                  _over &&
                  (_over._onOver({ action: "out", object: _over }),
                  (_over = null),
                  Stage.cursor("auto"));
            } catch (e) {
              console.warn(e);
            }
        }
        _click = null;
      }
    }
    function findCapture(object) {
      let capture = object.__slc;
      return void 0 === capture && window.UI3D
        ? (object.__slc = UI3D.findStageLayoutCapture(object) || null)
        : capture;
    }
    (this.preventDoubleClickTime = 300),
      (function addListeners() {
        _custom || _this.events.sub(Mouse.input, Interaction.MOVE, move),
          _this.events.sub(Mouse.input, Interaction.START, start),
          _this.events.sub(Mouse.input, Interaction.END, end),
          _this.events.sub(Interaction3D.EXTERNAL_PRESS, externalStart),
          _this.events.sub(Interaction3D.EXTERNAL_RELEASE, externalRelease);
      })(),
      _this.startRender((_) => {}),
      (this.add = function (obj) {
        obj && _objects.push(obj.mesh || obj);
      }),
      (this.remove = function (obj) {
        obj && _objects.remove(obj.mesh || obj);
      }),
      (this.testWith = function (point, id) {
        (point.customTest = !0),
          _lastTestedPoint.copy(point),
          (_lastTestedPoint.customTest = !0),
          (_customTest = !0),
          move(point),
          Device.mobile &&
            RenderManager.type != RenderManager.WEBVR &&
            _over &&
            start(point);
      }),
      (this.testWithFinger = function (point, distance, minDistance) {
        _ray || ((_ray = new Raycaster(_camera)).testVisibility = !1),
          (_customTest = !0);
        let objects = testObjects();
        if (objects.length)
          if (distance < 0.02) {
            let hit = _ray.checkHit(objects, point, _stage);
            try {
              if (hit[0]) {
                let obj = hit[0].object.glui;
                (!obj._preventClickTime ||
                  Render.TIME - obj._preventClickTime >
                    _this.preventDoubleClickTime) &&
                  (obj._requiresClear ||
                    ((_over = obj),
                    obj._onOver({ action: "over", object: obj }),
                    obj._onClick({ action: "click", object: obj }),
                    (obj._preventClickTime = Render.TIME),
                    (obj._requiresClear = !0)));
              } else
                _over &&
                  ((_over._requiresClear = !1),
                  _over._onOver({ action: "out", object: _over }),
                  (_over = null));
            } catch (e) {
              console.warn(e);
            }
          } else
            _over &&
              ((_over._requiresClear = !1),
              _over._onOver({ action: "out", object: _over }),
              (_over = null));
      }),
      (this.checkObjectHit = function (object, mouse) {
        let capture = findCapture(object);
        return capture
          ? capture.checkObjectHit(object.mesh || object, mouse)
          : (_ray || ((_ray = new Raycaster(_camera)).testVisibility = !1),
            _ray.checkHit(object.mesh || object, mouse, _stage)[0]);
      }),
      (this.checkObjectFromValues = function (object, origin, direction) {
        let capture = findCapture(object);
        return capture
          ? capture.checkObjectFromValues(
              object.mesh || object,
              origin,
              direction
            )
          : (_ray || ((_ray = new Raycaster(_camera)).testVisibility = !1),
            _ray.checkFromValues(object.mesh || object, origin, direction)[0]);
      }),
      (this.getObjectHitLocalCoords = function (v, object, mouse) {
        let capture = findCapture(object);
        if (capture) return capture.getObjectHitLocalCoords(v, object, mouse);
        let hit = _this.checkObjectHit(object, mouse);
        if (hit) return v.copy(hit.point), hit.object.worldToLocal(v);
        {
          let mesh = object.mesh || object;
          return (
            _plane.normal
              .set(0, 0, 1)
              .applyQuaternion(mesh.getWorldQuaternion()),
            (_plane.constant = -mesh.getWorldPosition().dot(_plane.normal)),
            _ray.ray.intersectPlane(_plane, v),
            mesh.worldToLocal(v)
          );
        }
      }),
      this.set("_disabled", (v) => {
        (_disabled = v) &&
          ((_click = null),
          _over &&
            (_over._onOver({ action: "out", object: _over }),
            (_over = null),
            Stage.cursor("auto")));
      }),
      (this.onInvisible = () => {
        (_click = null),
          _over &&
            (_over._onOver({ action: "out", object: _over }),
            (_over = null),
            Stage.cursor("auto"));
      });
  }),
  Class(function GLUIStageInteraction3D() {
    Inherit(this, Component);
    function onHover(e) {
      e.mesh.glui._onOver({ action: e.action, object: e.mesh.glui });
    }
    function onClick(e) {
      e.mesh.glui._onClick({ action: e.action, object: e.mesh.glui });
    }
    (this.add = function (obj, camera = World.CAMERA) {
      Interaction3D.find(camera).add(obj.mesh || obj, onHover, onClick);
    }),
      (this.remove = function (obj, camera = World.CAMERA) {
        Interaction3D.find(camera).remove(obj.mesh || obj);
      }),
      (this.checkObjectHit = function (object, mouse, camera = World.CAMERA) {
        return Interaction3D.find(camera).checkObjectHit(object.mesh, mouse);
      }),
      (this.checkObjectFromValues = function (
        object,
        origin,
        direction,
        camera = World.CAMERA
      ) {
        return Interaction3D.find(camera).checkObjectFromValues(
          object.mesh,
          origin,
          direction
        );
      }),
      (this.getObjectHitLocalCoords = function (
        v,
        object,
        mouse,
        camera = World.CAMERA
      ) {
        return Interaction3D.find(camera).getObjectHitLocalCoords(
          v,
          object.mesh,
          mouse
        );
      });
  }),
  Class(function GLUICornerPin($obj) {
    Inherit(this, Component);
    const _this = this;
    var _geom, _vertices, _last;
    function loop() {
      (_vertices[0] = _this.tl.x),
        (_vertices[1] = -_this.tl.y),
        (_vertices[3] = _vertices[9] = _this.bl.x),
        (_vertices[4] = _vertices[10] = -_this.bl.y),
        (_vertices[6] = _vertices[15] = _this.tr.x),
        (_vertices[7] = _vertices[16] = -_this.tr.y),
        (_vertices[12] = _this.br.x),
        (_vertices[13] = -_this.br.y),
        (function dirty() {
          let a = _vertices,
            b = _last;
          for (let i = a.length - 1; i > -1; i--) if (a[i] != b[i]) return !0;
          return !1;
        })() && (_geom.attributes.position.needsUpdate = !0),
        _last.set(_vertices);
    }
    (this.tl = new Vector2(0, 0)),
      (this.tr = new Vector2($obj.width, 0)),
      (this.bl = new Vector2(0, $obj.height)),
      (this.br = new Vector2($obj.width, $obj.height)),
      (function initGeometry() {
        (_geom = $obj.mesh.geometry.toNonIndexed()),
          $obj.useGeometry(_geom),
          $obj.mesh.scale.set(1, 1, 1),
          (_vertices = _geom.attributes.position.array),
          (_last = new Float32Array(_vertices));
      })(),
      _this.startRender(loop),
      (this.update = function () {
        this.tl.set(0, 0),
          this.tr.set($obj.width, 0),
          this.bl.set(0, $obj.height),
          this.br.set($obj.width, $obj.height);
      }),
      (this.tween = function (type, val, time, ease, delay) {
        return (
          (val = val instanceof Vector2 ? val : new Vector2(val.x, val.y)),
          tween(_this[type], val, time, ease, delay)
        );
      });
  });
class GLUIObject {
  constructor(width, height, map, customCompile) {
    let shader = (this.textureShader = new Shader("GLUIObject", {
      tMap: { value: null },
      uAlpha: { type: "f", value: 1 },
      transparent: !0,
      depthTest: !1,
      customCompile: customCompile,
    }));
    (shader.persists = !0),
      map || (shader.visible = !1),
      (this.usingMap = null != map && "empty" != map && "" != map),
      (this.tMap = shader.uniforms.tMap),
      (this.group = new Group()),
      (this.alpha = 1),
      (this._x = 0),
      (this._y = 0),
      (this._z = 0),
      (this._scaleX = 1),
      (this._scaleY = 1),
      (this._scale = 1),
      (this._rotation = 0),
      (this.multiTween = !0),
      (this.children = []),
      (this.dimensions = new Vector3(width, height, 1)),
      (this._shader = shader),
      (this.mesh = new Mesh(GLUIObject.getGeometry("2d"), shader)),
      (this.mesh.glui = this),
      this.group.add(this.mesh),
      (shader.mesh = this.mesh),
      window.GLSEO && GLSEO.objectNode(this),
      this.bg(
        "string" == typeof map
          ? map.includes(["#", "0x"])
            ? map
            : "empty" === map || "" === map
            ? null
            : Utils3D.getTexture(map, { premultiplyAlpha: !1 })
          : map
      );
    const _this = this;
    (this.mesh.onBeforeRender = (_) => {
      if (!_this.mesh.determineVisible() && _this.firstRender) return;
      let alpha = _this.getAlpha();
      if (
        (_this.mesh.shader.uniforms.uAlpha &&
          (_this.mesh.shader.uniforms.uAlpha.value = alpha),
        _this.usingMap)
      )
        if (alpha < 0.001) {
          if (
            ((_this.mesh.neverRender = !0),
            (_this.mesh.shader.visible = !1),
            !_this.isDirty && _this.firstRender)
          )
            return;
        } else (_this.mesh.neverRender = !1), (_this.mesh.shader.visible = !0);
      if (!_this.isDirty && _this.firstRender) return;
      RenderStats.active &&
        RenderStats.update(
          "GLUIObject",
          1,
          `${_this.mesh.shader.vsName}|${_this.mesh.shader.fsName}`,
          _this.mesh
        ),
        (_this.group.position.x = _this._x),
        (_this.group.position.y = _this._3d ? _this._y : -_this._y),
        (_this.group.position.z = _this._z),
        1 != _this.scale &&
          ((_this.group.position.x +=
            (_this.dimensions.x - _this.dimensions.x * _this.scale) / 2),
          (_this.group.position.y -=
            (_this.dimensions.y - _this.dimensions.y * _this.scale) / 2));
      _this.mesh.shader;
      if (_this.calcMask) {
        let v = _this.isMasked;
        v.copy(v.origin),
          _this.group.localToWorld(v),
          (v.z = v.width),
          (v.w = v.height);
      }
      map
        ? _this.corners ||
          (_this.mesh.scale.set(1, 1, 1).multiply(_this.dimensions),
          (_this.group.scale.x = _this._scaleX * _this._scale),
          (_this.group.scale.y = _this._scaleY * _this._scale))
        : _this.group.scale.set(
            _this._scaleX * _this._scale,
            _this._scaleY * _this._scale,
            1
          ),
        _this._3d
          ? _this.anchor && _this.anchor._parent
            ? (_this.anchor.position.copy(_this.group.position),
              _this.anchor.scale.copy(_this.group.scale),
              _this.anchor.quaternion.setFromEuler(_this._rotation),
              (_this.anchor.isDirty = !0))
            : (_this.group.quaternion.setFromEuler(_this._rotation),
              (_this.group.matrixDirty = !0))
          : (_this.group.rotation.z = Math.radians(_this._rotation)),
        _this.firstRender ||
          (_this.group.updateMatrixWorld(!0),
          (_this.firstRender = !0),
          _this.onMountedHook && _this.onMountedHook()),
        (_this.isDirty = !1);
    }),
      (_this.isDirty = !0);
  }
  get width() {
    return this.dimensions.x;
  }
  set width(w) {
    let dirty = Math.abs(this.dimensions.x - w) > Base3D.DIRTY_EPSILON;
    (this.dimensions.x = w),
      dirty &&
        ((this.isDirty = !0), this.__internalDirty && this.__internalDirty());
  }
  get height() {
    return this.dimensions.y;
  }
  set height(h) {
    let dirty = Math.abs(this.dimensions.y - h) > Base3D.DIRTY_EPSILON;
    (this.dimensions.y = h),
      dirty &&
        ((this.isDirty = !0), this.__internalDirty && this.__internalDirty());
  }
  get x() {
    return this._x;
  }
  set x(v) {
    let dirty = Math.abs(this._x - v) > Base3D.DIRTY_EPSILON;
    (this._x = v),
      dirty &&
        ((this.isDirty = !0), this.__internalDirty && this.__internalDirty());
  }
  get y() {
    return this._y;
  }
  set y(v) {
    let dirty = Math.abs(this._y - v) > Base3D.DIRTY_EPSILON;
    (this._y = v),
      dirty &&
        ((this.isDirty = !0), this.__internalDirty && this.__internalDirty());
  }
  get z() {
    return this._z;
  }
  set z(v) {
    let dirty = Math.abs(this._z - v) > Base3D.DIRTY_EPSILON;
    (this._z = v),
      dirty &&
        ((this.isDirty = !0), this.__internalDirty && this.__internalDirty());
  }
  get scale() {
    return this._scale;
  }
  set scale(v) {
    let dirty = Math.abs(this._scale - v) > Base3D.DIRTY_EPSILON;
    (this._scale = v),
      dirty &&
        ((this.isDirty = !0), this.__internalDirty && this.__internalDirty());
  }
  get scaleX() {
    return this._scaleX;
  }
  set scaleX(v) {
    let dirty = Math.abs(this._scaleX - v) > Base3D.DIRTY_EPSILON;
    (this._scaleX = v),
      dirty &&
        ((this.isDirty = !0), this.__internalDirty && this.__internalDirty());
  }
  get scaleY() {
    return this._scaleY;
  }
  set scaleY(v) {
    let dirty = Math.abs(this._scaleY - v) > Base3D.DIRTY_EPSILON;
    (this._scaleY = v),
      dirty &&
        ((this.isDirty = !0), this.__internalDirty && this.__internalDirty());
  }
  get rotation() {
    return this._rotation;
  }
  set rotation(v) {
    let dirty = Math.abs(this._rotation - v) > Base3D.DIRTY_EPSILON;
    (this._rotation = v),
      dirty &&
        ((this.isDirty = !0), this.__internalDirty && this.__internalDirty());
  }
  style(props) {
    for (let prop in props) void 0 !== this[prop] && (this[prop] = props[prop]);
    return this;
  }
  size(w, h) {
    return (
      (this.width = w),
      (this.height = h),
      this.corners && this.corners.update(),
      this
    );
  }
  add($obj) {
    return (
      $obj?.parent?.children?.remove($obj),
      ($obj.parent = this),
      this.group.add($obj.group),
      this.children.push($obj),
      this.isMasked && $obj.mask(this.isMasked, this.maskShader),
      this._3d && !$obj._3d && $obj.enable3D(),
      this.deferred &&
        ($obj.deferRender(!0),
        $obj.anchor && this.anchor && this.anchor.add($obj.anchor)),
      this
    );
  }
  interact(over, click, camera = World.CAMERA, url, label, options) {
    "string" == typeof camera &&
      ((options = label),
      (label = url),
      (url = camera),
      (camera = World.CAMERA));
    const bubble = (e, fn) => {
      e.stopPropagation = function () {
        e._stopProp = !0;
      };
      let parent = this._parent;
      for (; parent; ) {
        if (e._stopProp) return;
        parent[fn]?.(e), (parent = parent.parent);
      }
    };
    if (
      ((this._onOver = (e) => {
        bubble(e, "_onChildHover"), over(e);
      }),
      (this._onClick = (e) => {
        bubble(e, "_onChildClick"), click(e);
      }),
      (this._interactCamera = camera),
      over
        ? this.interaction.add(this, camera)
        : this.interaction.remove(this, camera),
      "string" == typeof url && "string" == typeof label)
    ) {
      const _this = this;
      defer((_) => {
        !_this.seo && window.GLSEO && GLSEO.objectNode(_this),
          _this.seo && _this.seo.aLink && _this.seo.aLink(url, label, options);
      });
    }
    return this;
  }
  clearInteract() {
    return (
      this._onOver &&
        (this.interaction.remove(this, this._interactCamera),
        (this._onClick = GLUIObject.noop),
        (this._onOver = GLUIObject.noop)),
      this.seo && this.seo.unlink(),
      this
    );
  }
  remove(param) {
    param &&
      console.warn(
        "GLUIObject.remove removes ITSELF from its parent. use removeChild instead"
      ),
      this.children.slice().forEach((child) => {
        child.remove ? child.remove() : child.destroy && child.destroy();
      }),
      this.clearInteract(),
      this.parent &&
        (this.parent.children
          ? this.parent.children?.remove(this)
          : GLUI.Stage.remove(this)),
      this.mesh._parent
        ? this.group._parent?.remove(this.group)
        : this._3d
        ? GLUI.Scene.remove(this)
        : GLUI.Stage.remove(this);
    let textureShader = this.textureShader;
    for (let key in textureShader.uniforms) {
      let uniform = textureShader.uniforms[key];
      uniform &&
        uniform.value &&
        uniform.value.destroy &&
        uniform.value.destroy();
    }
  }
  create(width, height, map, customCompile) {
    let $obj = $gl(width, height, map, customCompile);
    return this.add($obj), this._3d && $obj.enable3D(), $obj;
  }
  removeChild(obj) {
    return this.group.remove(obj.group), this;
  }
  tween(obj, time, ease, delay) {
    return tween(this, obj, time, ease, delay);
  }
  enable3D(style2d) {
    (this._3d = !0),
      (this.mesh.geometry = GLUIObject.getGeometry(style2d ? "2d" : "3d")),
      (this.mesh.shader.depthTest = !0),
      (this._rotation = new Euler()),
      this.anchor || (this.anchor = new Group()),
      (this.anchor.onMatrixDirty = (_) => {
        _this.isDirty = !0;
      });
    const _this = this;
    return (
      _this._rotation.onChange((_) => {
        _this.isDirty = !0;
      }),
      this
    );
  }
  loaded() {
    return !0;
  }
  setZ(z) {
    return (this.mesh.renderOrder = z), this;
  }
  bg(path) {
    if (void 0 !== path)
      return (
        "string" == typeof path
          ? path.length <= 10 && (path.startsWith("0x") || path.startsWith("#"))
            ? (this.colorShader ||
                (this.colorShader = new Shader("GLUIColor", {
                  transparent: !0,
                  uAlpha: { type: "f", value: 1 },
                  uColor: { value: new Color(path) },
                })),
              this.colorShader.set("uColor", new Color(path)),
              this._shader != this.colorShader &&
                this.useShader(this.colorShader))
            : ((this.textureShader.uniforms.tMap.value = Utils3D.getTexture(
                path,
                { premultiplyAlpha: !1 }
              )),
              this._shader != this.textureShader &&
                this.useShader(this.textureShader))
          : (this._shader.uniforms.tMap || this.useShader(this.textureShader),
            (this._shader.uniforms.tMap.value = path)),
        this
      );
  }
  show() {
    return (
      (this.group.matrixDirty = !0),
      (this.mesh.matrixDirty = !0),
      (this.group.visible = !0),
      this.anchor && (this.anchor.visible = !0),
      this
    );
  }
  hide() {
    return (
      (this.group.visible = !1), this.anchor && (this.anchor.visible = !1), this
    );
  }
  useShader(shader) {
    return (
      shader &&
        (shader != this.textureShader &&
          shader != this.colorShader &&
          ((shader.uniforms.tMap = this.mesh.shader.uniforms.tMap),
          (shader.uniforms.uAlpha = this.mesh.shader.uniforms.uAlpha)),
        this._3d || (shader.depthTest = !1),
        (shader.transparent = !0)),
      (this._shader = shader),
      (this.mesh.shader = shader || this._shader),
      (shader.mesh = this.mesh),
      this
    );
  }
  depthTest(bool) {
    this.mesh.shader.depthTest = bool;
  }
  childInteract(hover, click) {
    (this._onChildHover = hover), (this._onChildClick = click);
  }
  useGeometry(geom) {
    return (this.mesh.geometry = geom), this;
  }
  updateMap(src) {
    this._shader.uniforms.tMap.value =
      "string" == typeof src ? Utils3D.getTexture(src) : src;
  }
  async mask(obj, shader) {
    await defer();
    let dimensions = {},
      p = this._parent;
    for (; p; )
      p.stageLayoutCapture &&
        ((dimensions.width = p.stageLayoutCapture.width),
        (dimensions.height = p.stageLayoutCapture.height)),
        (p = p._parent);
    dimensions.width ||
      ((dimensions.width = Stage.width), (dimensions.height = Stage.height)),
      obj.group.updateMatrixWorld(!0),
      obj.mesh.onBeforeRender();
    let box = new Box3().setFromObject(obj.mesh),
      minX = box.min.x / dimensions.width,
      minY = box.max.y / dimensions.height,
      maxX = box.max.x / dimensions.width,
      maxY = -box.min.y / dimensions.height;
    this.shader &&
      (this.useShader(shader),
      this.shader.addUniforms({
        uMaskValues: { value: new Vector4(minX, minY, maxX, maxY) },
      })),
      obj.hide(),
      this.group.traverse((o) => {
        o.glui && o.glui != this && o.glui.mask(obj, shader);
      });
  }
  deferRender(parent) {
    (this.deferred = !0),
      parent || ((this.anchor = new Group()), GLUI.Scene.addDeferred(this));
  }
  clearTween() {
    return (
      this._mathTweens &&
        this._mathTweens.forEach((t) => {
          t.tween.stop();
        }),
      this
    );
  }
  createCorners() {
    this.corners = new GLUICornerPin(this);
  }
  getAlpha() {
    if (this._gluiParent) {
      let alpha = this._gluiParent.getAlpha();
      return (this.alpha = alpha), alpha;
    }
    let alpha = this.alpha,
      $parent = this.parent;
    for (; $parent; ) (alpha *= $parent.alpha), ($parent = $parent.parent);
    return alpha;
  }
  get shader() {
    return this._shader;
  }
  _divFocus() {
    this._onOver && this._onOver({ action: "over", object: this }),
      this.onDivFocus && this.onDivFocus();
  }
  _divBlur() {
    this._onOver && this._onOver({ action: "out", object: this }),
      this.onDivBlur && this.onDivBlur();
  }
  _divSelect() {
    this._onClick && this._onClick({ action: "click", object: this }),
      this.onDivSelect && this.onDivSelect();
  }
  get _parent() {
    return this.parent;
  }
  get interaction() {
    return (this._3d ? GLUI.Scene : GLUI.Stage).interaction;
  }
  forceUpdate() {
    (this.firstRender = !1), this.mesh.onBeforeRender();
  }
}
!(function () {
  var _geom2d, _geom3d;
  (GLUIObject.getGeometry = function (type) {
    return "2d" == type
      ? (_geom2d ||
          (_geom2d = new PlaneGeometry(1, 1)).applyMatrix(
            new Matrix4().makeTranslation(0.5, -0.5, 0)
          ),
        _geom2d)
      : (_geom3d || (_geom3d = World.PLANE), _geom3d);
  }),
    (GLUIObject.clear = function () {
      _geom2d = _geom3d = null;
    }),
    (GLUIObject.noop = (_) => {});
})();
class GLUIText {
  constructor(text, fontName, fontSize, options = {}, customCompile) {
    (options.font = fontName || options.font),
      (options.text = text),
      (options.seoText = options.seoText || text),
      (options.width = options.width),
      (options.align = options.align || "left"),
      (options.size = fontSize || options.size),
      (options.lineHeight = options.lineHeight),
      (options.letterSpacing = options.letterSpacing),
      (options.wordSpacing = options.wordSpacing),
      (options.wordBreak = options.wordBreak),
      (options.langBreak = options.langBreak),
      (options.color = new Color(options.color)),
      (options.customCompile = customCompile),
      (this.text = new GLText(options)),
      (this.group = new Group()),
      (this.group.asyncPromise = this.text.text.fontLoaded),
      (this.alpha = 1),
      (this._x = 0),
      (this._y = 0),
      (this._z = 0),
      (this._scaleX = 1),
      (this._scaleY = 1),
      (this._scale = 1),
      (this._rotation = 0),
      (this.multiTween = !0);
    const _this = this;
    text &&
      defer((_) => {
        _this.seo || _this.seoText(options.seoText);
      }),
      this.text.ready().then((_) => {
        let mesh = _this.text.mesh;
        (mesh.glui = _this),
          (mesh.shader.visible = !1),
          (_this.mesh = mesh),
          _this.group.add(mesh),
          _this._3d && !_this._style2d && _this.text.centerY(),
          _this._3d || (_this.text.mesh.shader.depthTest = !1),
          (mesh.shader.mesh = mesh),
          (mesh.onBeforeRender = (_) => {
            if (!mesh.determineVisible() && _this.firstRender) return;
            let alpha = _this.getAlpha();
            if (
              (mesh.shader.uniforms.uAlpha &&
                (mesh.shader.uniforms.uAlpha.value = alpha),
              alpha < 0.001)
            ) {
              if (
                ((mesh.shader.visible = !1),
                (mesh.neverRender = !0),
                !_this.isDirty && _this.firstRender)
              )
                return;
            } else (mesh.neverRender = !1), (mesh.shader.visible = !0);
            (!_this.isDirty && _this.firstRender) ||
              (RenderStats.active &&
                RenderStats.update(
                  "GLUIText",
                  1,
                  `${mesh.shader.vsName}|${mesh.shader.fsName}`,
                  mesh
                ),
              (_this.group.position.x = _this._x),
              (_this.group.position.y = _this._3d ? _this._y : -_this._y),
              (_this.group.position.z = _this._z),
              _this.group.scale.set(
                _this._scaleX * _this._scale,
                _this._scaleY * _this._scale,
                1
              ),
              _this._3d
                ? _this.anchor && _this.anchor._parent
                  ? (_this.anchor.position.copy(_this.group.position),
                    _this.anchor.scale.copy(_this.group.scale),
                    _this.anchor.quaternion.setFromEuler(_this._rotation))
                  : _this.group.quaternion.setFromEuler(_this._rotation)
                : (_this.group.rotation.z = Math.radians(_this._rotation)),
              _this.firstRender ||
                (_this.group.updateMatrixWorld(!0),
                (_this.firstRender = !0),
                (mesh.shader.visible = !0)),
              _this.onInternalUpdate && _this.onInternalUpdate(),
              (_this.isDirty = !1));
          });
      });
  }
  get x() {
    return this._x;
  }
  set x(v) {
    Math.abs(this._x - v) > Base3D.DIRTY_EPSILON && (this.isDirty = !0),
      (this._x = v);
  }
  get y() {
    return this._y;
  }
  set y(v) {
    Math.abs(this._y - v) > Base3D.DIRTY_EPSILON && (this.isDirty = !0),
      (this._y = v);
  }
  get z() {
    return this._z;
  }
  set z(v) {
    Math.abs(this._z - v) > Base3D.DIRTY_EPSILON && (this.isDirty = !0),
      (this._z = v);
  }
  get scale() {
    return this._scale;
  }
  set scale(v) {
    Math.abs(this._scale - v) > Base3D.DIRTY_EPSILON && (this.isDirty = !0),
      (this._scale = v);
  }
  get scaleX() {
    return this._scaleX;
  }
  set scaleX(v) {
    Math.abs(this._scaleX - v) > Base3D.DIRTY_EPSILON && (this.isDirty = !0),
      (this._scaleX = v);
  }
  get scaleY() {
    return this._scaleY;
  }
  set scaleY(v) {
    Math.abs(this._scaleY - v) > Base3D.DIRTY_EPSILON && (this.isDirty = !0),
      (this._scaleY = v);
  }
  get rotation() {
    return this._rotation;
  }
  set rotation(v) {
    Math.abs(this._rotation - v) > Base3D.DIRTY_EPSILON && (this.isDirty = !0),
      (this._rotation = v);
  }
  get dimensions() {
    return (
      this._dimensions || (this._dimensions = {}),
      this.text &&
        this.text.geometry &&
        !this._dimensions.max &&
        ((this._dimensions = this.text.geometry.boundingBox),
        (this._dimensions.width = Math.abs(
          this._dimensions.min.x - this._dimensions.max.x
        )),
        (this._dimensions.height = Math.abs(
          this._dimensions.min.y - this._dimensions.max.y
        ))),
      this._dimensions
    );
  }
  interact(over, click, camera = World.CAMERA, seoLink, options) {
    "string" == typeof camera &&
      ((options = seoLink), (seoLink = camera), (camera = World.CAMERA)),
      (this._onOver = over),
      (this._onClick = click),
      (this._interactCamera = camera);
    let stage = this._3d ? GLUI.Scene : GLUI.Stage;
    const _this = this;
    return (
      _this.text.ready().then((_) => {
        if (over) {
          if (
            (_this.text.geometry.boundingBox ||
              _this.text.geometry.computeBoundingBox(),
            !_this.hitArea)
          ) {
            let bb = _this.text.geometry.boundingBox,
              shader = Utils3D.getTestShader();
            if (
              ((shader.visible = !1),
              (_this.hitArea = new Mesh(World.PLANE, shader)),
              (_this.hitArea.glui = _this),
              _this.hitArea.scale.set(
                Math.abs(bb.min.x) + Math.abs(bb.max.x),
                Math.abs(bb.min.y) + Math.abs(bb.max.y),
                1
              ),
              (_this._3d && !_this._style2d) ||
                (_this.hitArea.position.x = (bb.max.x - bb.min.x) / 2),
              (_this.hitArea.position.y = (bb.min.y - bb.max.y) / 2),
              _this._3d)
            )
              switch (_this.text.getData().align) {
                case "center":
                  _this.hitArea.position.x = 0;
                  break;
                case "right":
                  _this.hitArea.position.x = (bb.min.x - bb.max.x) / 2;
              }
            else
              switch (_this.text.getData().align) {
                case "center":
                  _this.hitArea.position.x = 0;
                  break;
                case "right":
                  _this.hitArea.position.x = -(bb.max.x - bb.min.x) / 2;
              }
            _this.text.mesh.add(_this.hitArea);
          }
          stage.interaction.add(_this.hitArea, camera);
        } else stage.interaction.remove(_this.hitArea, camera);
      }),
      defer((_) => {
        seoLink &&
          _this.seo &&
          _this.seo.aLink &&
          _this.seo.aLink(seoLink, options);
      }),
      this
    );
  }
  clearInteract() {
    if (this._onOver) {
      (this._3d ? GLUI.Scene : GLUI.Stage).interaction.remove(
        this.hitArea,
        this._interactCamera
      ),
        (this._onClick = GLUIObject.noop),
        (this._onOver = GLUIObject.noop);
    }
    return this;
  }
  remove(param) {
    param &&
      console.warn(
        "GLUIObject.remove removes ITSELF from its parent. use removeChild instead"
      );
    let stage = this._3d ? GLUI.Scene : GLUI.Stage;
    this.mesh && this.mesh.parent
      ? this.group.parent.remove(this.group)
      : stage.remove(this),
      this.hitArea &&
        stage.interaction.remove(this.hitArea, this._interactCamera),
      this.text && this.text.destroy && this.text.destroy(),
      Utils.nullObject(this.mesh),
      Utils.nullObject(this);
  }
  tween(obj, time, ease, delay) {
    return tween(this, obj, time, ease, delay);
  }
  enable3D(style2d) {
    (this._3d = !0), (this._style2d = style2d), (this._rotation = new Euler());
    const _this = this;
    return (
      _this._rotation.onChange((_) => {
        _this.isDirty = !0;
      }),
      _this.text.ready().then((_) => {
        _this.text.mesh.shader.depthTest = !0;
      }),
      this.anchor || (this.anchor = new Group()),
      (this.anchor.onMatrixDirty = (_) => {
        _this.isDirty = !0;
      }),
      (_this.isDirty = !0),
      this
    );
  }
  depthTest(bool) {
    const _this = this;
    return (
      _this.text.ready().then((_) => {
        _this.text.mesh.shader.depthTest = bool;
      }),
      this
    );
  }
  setZ(z) {
    const _this = this;
    return (
      _this.text.ready().then((_) => {
        _this.text.mesh.renderOrder = z;
      }),
      this
    );
  }
  height() {
    return this.mesh ? this.text.height : 0;
  }
  async setText(text, options) {
    return (
      text && ((text = text.toString()), this.seoText(text)),
      await this.text.ready(),
      await this.text.setText(text, options),
      (this._dimensions = null),
      this
    );
  }
  seoText(text) {
    window.GLSEO && GLSEO.textNode(this, text);
  }
  getTextString() {
    return this.text.string;
  }
  setColor(color) {
    const _this = this;
    return _this.text.ready().then((_) => _this.text.setColor(color)), this;
  }
  tweenColor(color, time, ease, delay) {
    const _this = this;
    return (
      _this.text
        .ready()
        .then((_) => _this.text.tweenColor(color, time, ease, delay)),
      this
    );
  }
  async resize(options) {
    await this.text.ready(),
      await this.text.resize(options),
      (this._dimensions = null);
  }
  show() {
    return (
      this.text.ready().then((_) => {
        (this.text.mesh.visible = !0), this.text.mesh.updateMatrixWorld(!0);
      }),
      this
    );
  }
  async mask(obj, shader) {
    await defer();
    let dimensions = {},
      p = this._parent;
    for (; p; )
      p.stageLayoutCapture &&
        ((dimensions.width = p.stageLayoutCapture.width),
        (dimensions.height = p.stageLayoutCapture.height)),
        (p = p._parent);
    dimensions.width ||
      ((dimensions.width = Stage.width), (dimensions.height = Stage.height)),
      obj.group.updateMatrixWorld(!0),
      obj.mesh.onBeforeRender();
    let box = new Box3().setFromObject(obj.mesh),
      minX = box.min.x / dimensions.width,
      minY = box.max.y / dimensions.height,
      maxX = box.max.x / dimensions.width,
      maxY = -box.min.y / dimensions.height;
    this.shader &&
      (this.useShader(shader),
      this.shader.addUniforms({
        uMaskValues: { value: new Vector4(minX, minY, maxX, maxY) },
      })),
      obj.hide(),
      this.group.traverse((o) => {
        o.glui && o.glui != this && o.glui.mask(obj, shader);
      });
  }
  hide() {
    const _this = this;
    return _this.text.ready().then((_) => (_this.text.mesh.visible = !1)), this;
  }
  loaded() {
    return this.text.ready();
  }
  length() {
    return this.text.charLength;
  }
  deferRender(parent) {
    (this.deferred = !0),
      parent ||
        (this.anchor || (this.anchor = new Group()),
        GLUI.Scene.addDeferred(this));
  }
  getAlpha() {
    if (this._gluiParent) {
      let alpha = this._gluiParent.getAlpha();
      return (this.alpha = alpha), alpha;
    }
    let alpha = this.alpha,
      $parent = this.parent;
    for (; $parent; ) (alpha *= $parent.alpha), ($parent = $parent.parent);
    return alpha;
  }
  size() {}
  upload() {
    const _this = this;
    return _this.text.ready().then((_) => _this.text.mesh.upload()), this;
  }
  _divFocus() {
    this._onOver && this._onOver({ action: "over", object: this }),
      this.onDivFocus && this.onDivFocus();
  }
  _divBlur() {
    this._onOver && this._onOver({ action: "out", object: this }),
      this.onDivBlur && this.onDivBlur();
  }
  _divSelect() {
    this._onClick && this._onClick({ action: "click", object: this }),
      this.onDivBlurSelect && this.onDivSelect();
  }
  get _parent() {
    return this.parent;
  }
  async useShader(shader) {
    await this.text.ready(),
      (shader.uniforms.tMap = this.text.shader.uniforms.tMap),
      (shader.uniforms.uAlpha = this.text.shader.uniforms.uAlpha),
      (shader.uniforms.uColor = this.text.shader.uniforms.uColor),
      (shader.transparent = !0),
      (!this._3d || this._3d || this.parent) && (shader.depthTest = !1),
      (this.text.mesh.shader = shader || this.text.shader),
      (this.text.shader = shader),
      (this.text.mesh.shader.mesh = this.text.mesh);
  }
}
Class(function GLUIStage() {
  Inherit(this, Component);
  const _this = this;
  var _scene = new Scene(),
    _camera = new OrthographicCamera(1, 1, 1, 1, 0.1, 1);
  function resizeHandler() {
    (_camera.left = Stage.width / -2),
      (_camera.right = Stage.width / 2),
      (_camera.top = Stage.height / 2),
      (_camera.bottom = Stage.height / -2),
      (_camera.near = 0.01),
      (_camera.far = 1e3),
      _camera.updateProjectionMatrix(),
      (_camera.position.x = Stage.width / 2),
      (_camera.position.y = -Stage.height / 2);
  }
  (this.interaction = new GLUIStageInteraction2D(_camera, _scene, Stage)),
    (this.alpha = 1),
    (this.scene = _scene),
    (_scene.disableAutoSort = !0),
    (_camera.position.z = 1),
    (function addListeners() {
      _this.events.sub(Events.RESIZE, resizeHandler);
    })(),
    resizeHandler(),
    (this.add = function ($obj) {
      ($obj.parent = _this), _scene.add($obj.group || $obj.mesh);
    }),
    (this.remove = function ($obj) {
      ($obj.parent = null), _scene.remove($obj.group);
    }),
    (this.clear = function () {
      _scene.traverse((obj) => {
        obj.geometry && obj.shader && obj.destroy();
      }),
        (_scene.children.length = _scene.childrenLength = 0);
    }),
    (this.renderToRT = function (scene, rt) {
      let clearAlpha;
      rt.fxscene &&
        rt.fxscene.clearAlpha > -1 &&
        ((clearAlpha = World.RENDERER.getClearAlpha()),
        World.RENDERER.setClearAlpha(0));
      let autoClear = World.RENDERER.autoClear;
      (World.RENDERER.autoClear = !1),
        World.RENDERER.render(scene, _camera, rt),
        (World.RENDERER.autoClear = autoClear),
        clearAlpha && World.RENDERER.setClearAlpha(clearAlpha);
    }),
    (this.resize = resizeHandler),
    (this.render = function loop() {
      if (!_scene.children.length) return;
      let clear = World.RENDERER.autoClear;
      (World.RENDERER.autoClear = !1),
        World.RENDERER.render(_scene, _camera, null, !0),
        (World.RENDERER.autoClear = clear);
    }),
    (this.renderDirect = (callback) => {
      _scene.children.length &&
        (_scene.traverse((obj) => {
          obj.shader && (obj.shader.depthTest = !1);
        }),
        callback(_scene, _camera));
    });
}),
  Class(function GLUIStage3D() {
    Inherit(this, Object3D);
    const _this = this;
    var _camera,
      _externalRenders = [],
      _scene = new Scene(),
      _list = new LinkedList();
    (this.alpha = 1),
      (this.scene = _scene),
      (this.interaction = new GLUIStageInteraction3D()),
      (this.add = function (obj, parent) {
        (obj.parent = _this),
          (obj._gluiParent = parent),
          obj.anchor && (obj.anchor._gluiParent = parent),
          obj._3d || obj.enable3D(),
          obj.deferRender();
      }),
      (this.clear = function () {
        _scene.traverse((obj) => {
          obj.geometry && obj.shader && obj.destroy();
        }),
          (_scene.children.length = _scene.childrenLength = 0);
      }),
      (this.addDeferred = function (obj) {
        _list.push(obj), _scene.add(obj.group || obj.mesh);
      }),
      (this.remove = function (obj) {
        _scene.remove(obj.group || obj.mesh), _list.remove(obj);
      }),
      (this.disableAutoSort = function () {
        _scene.disableAutoSort = !0;
      }),
      (this.renderToRT = function (scene, camera) {
        (camera = camera.camera || camera),
          scene.traverse((mesh) => {
            let obj = mesh.glui || mesh;
            obj &&
              obj.anchor &&
              obj.anchor.determineVisible() &&
              Utils3D.decompose(obj.anchor, obj.group || obj);
          }),
          (scene._textRenderCamera = camera),
          _externalRenders.push(scene);
      }),
      (this.renderToRT2 = function (scene, rt, camera) {
        let clearAlpha;
        rt.fxscene &&
          rt.fxscene.clearAlpha > -1 &&
          ((clearAlpha = World.RENDERER.getClearAlpha()),
          World.RENDERER.setClearAlpha(0));
        let autoClear = World.RENDERER.autoClear;
        (World.RENDERER.autoClear = !1),
          World.RENDERER.render(scene, camera, rt),
          (World.RENDERER.autoClear = autoClear),
          clearAlpha && World.RENDERER.setClearAlpha(clearAlpha);
      }),
      (this.render = function loop() {
        if (!window.Metal) {
          if (_list.length) {
            let obj = _list.start();
            for (; obj; )
              obj._marked &&
                ((obj._marked = !1), Utils3D.decompose(obj.anchor, obj.group)),
                (obj = _list.next());
            let clear = World.RENDERER.autoClear;
            Renderer.context.clear(Renderer.context.DEPTH_BUFFER_BIT),
              (World.RENDERER.autoClear = !1),
              World.RENDERER.render(_scene, _camera || World.CAMERA),
              (World.RENDERER.autoClear = clear);
          }
          if (_externalRenders.length)
            for (; _externalRenders.length; ) {
              let scene = _externalRenders.shift(),
                camera = scene._textRenderCamera,
                clear = World.RENDERER.autoClear;
              Renderer.context.clear(Renderer.context.DEPTH_BUFFER_BIT),
                (World.RENDERER.autoClear = !1),
                World.RENDERER.render(scene, camera),
                (World.RENDERER.autoClear = clear);
            }
        }
      }),
      (this.mark = function mark() {
        let obj = _list.start();
        for (; obj; )
          obj.anchor._parent &&
            (obj.group.visible = obj.anchor.determineVisible()),
            obj.mesh &&
              obj.mesh.determineVisible() &&
              obj.anchor._parent &&
              (obj._marked = !0),
            (obj = _list.next());
      }),
      (this.renderDirect = function (callback) {
        if (_list.length) {
          let obj = _list.start();
          for (; obj; )
            obj._marked &&
              ((obj._marked = !1), Utils3D.decompose(obj.anchor, obj.group)),
              (obj = _list.next());
          _scene.traverse((obj) => {
            obj.shader && (obj.shader.depthTest = !1);
          }),
            callback(_scene, _camera || World.CAMERA);
        }
      }),
      this.set("camera", (c) => {
        _camera = c.camera || c;
      });
  }),
  Module(function FirefoxGPUFixer() {
    this.exports = function () {
      GPU.detect("radeon r9 200") &&
        ("mac" == Device.system.os || Device.pixelRatio > 1) &&
        (Device.graphics.webgl.gpu = "radeon pro 455");
    };
  }),
  Class(function GPU() {
    Inherit(this, Component);
    var _this = this,
      _split = {};
    Hydra.ready(async () => {
      for (var key in ((_this.detect = function (match) {
        if (Device.graphics.gpu) return Device.graphics.gpu.detect(match);
      }),
      (_this.detectAll = function () {
        if (Device.graphics.gpu) {
          for (var match = !0, i = 0; i < arguments.length; i++)
            Device.graphics.gpu.detect(arguments[i]) || (match = !1);
          return match;
        }
      }),
      (_this.matchGPU = function (str, min, max = 99999) {
        let num = (function splitGPU(string) {
          if (_split[string]) return _split[string];
          if (!_this.detect(string)) return -1;
          try {
            var num = Number(_this.gpu.split(string)[1].split(" ")[0]);
            return (_split[string] = num), num;
          } catch (e) {
            return -1;
          }
        })(str);
        return num >= min && num < max;
      }),
      (_this.gpu = Device.graphics.gpu ? Device.graphics.gpu.identifier : ""),
      "apple gpu" == _this.gpu &&
        (Device.mobile
          ? await require("iOSGPUTest")()
          : require("MacOSPerformanceTest")()),
      "firefox" === Device.system.browser && require("FirefoxGPUFixer")(),
      (_this.BLOCKLIST = require("GPUBlocklist").match()),
      (_this.T0 = !(
        Device.mobile ||
        (!_this.BLOCKLIST &&
          !_this.detect("radeon(tm) r5") &&
          !_this.detect("radeon r9 200") &&
          !_this.detect("hd graphics family") &&
          !_this.detect("intel(r) uhd graphics direct") &&
          !_this.matchGPU("hd graphics ", 1e3, 5001) &&
          !(_this.matchGPU("hd graphics ", 0, 618) && Device.pixelRatio > 1) &&
          !(
            _this.detect(["hd graphics", "iris"]) &&
            Math.max(Stage.width, Stage.height) > 1800
          ) &&
          !_this.detect(["intel iris opengl engine"]) &&
          !_this.matchGPU("iris(tm) graphics ", 1e3))
      )),
      (_this.T1 = !(
        _this.BLOCKLIST ||
        Device.mobile ||
        _this.T0 ||
        (!_this.matchGPU("iris(tm) graphics ", 540, 1e3) &&
          !_this.matchGPU("hd graphics ", 514, 1e3) &&
          !_this.matchGPU("intel(r) uhd graphics ", 600, 1e3) &&
          _this.detect(["nvidia", "amd", "radeon", "geforce"]) &&
          !_this.detect(["vega 8"]))
      )),
      (_this.T2 =
        !_this.BLOCKLIST &&
        !Device.mobile &&
        !(
          !_this.detect(["nvidia", "amd", "radeon", "geforce"]) ||
          _this.T1 ||
          _this.T0
        )),
      (_this.T3 = !(
        _this.BLOCKLIST ||
        Device.mobile ||
        (!_this.detect(["titan", "amd radeon pro", "quadro"]) &&
          !_this.matchGPU("gtx ", 940) &&
          !_this.matchGPU("radeon (tm) rx ", 400) &&
          !_this.detect("amd radeon(tm) graphics direct3d11 vs_5_0") &&
          !_this.matchGPU("radeon rx ", 400) &&
          !_this.matchGPU("radeon pro ", 420))
      )),
      (_this.T4 = !(
        _this.BLOCKLIST ||
        Device.mobile ||
        (!_this.detect(["titan", "quadro", "radeon vii", "apple m"]) &&
          !_this.matchGPU("gtx ", 1060) &&
          !_this.matchGPU("rtx") &&
          !_this.matchGPU("radeon rx ", 500) &&
          !_this.matchGPU("vega ", 50) &&
          !_this.detect([
            "radeon pro 5300m",
            "radeon pro 5500m",
            "radeon pro 5600m",
            "amd radeon unknown prototype",
          ]))
      )),
      (_this.T5 = !(
        _this.BLOCKLIST ||
        Device.mobile ||
        (!_this.detect(["titan", "radeon vii"]) &&
          !_this.matchGPU("gtx ", 1080) &&
          !_this.matchGPU("rtx ", 2060) &&
          !_this.matchGPU("radeon rx ", 5500) &&
          (!_this.detect("apple m") || !_this.detect("max")))
      )),
      (_this.MT0 =
        !!Device.mobile &&
        (!!_this.BLOCKLIST ||
          !("ios" != Device.system.os || !_this.detect("a7")) ||
          !("android" != Device.system.os || !_this.detect("sgx")) ||
          (_this.detect("adreno")
            ? _this.matchGPU("adreno (tm) ", 0, 415)
            : _this.detect("mali")
            ? _this.matchGPU("mali-t", 0, 628)
            : !("ios" != Device.system.os || !_this.detect(["a8", "a9"])) ||
              !!_this.detect("mali-g") ||
              !!_this.matchGPU("adreno (tm) ", 420)))),
      (_this.MT1 = (function () {
        if (!Device.mobile) return !1;
        if (_this.BLOCKLIST) return !1;
        if ("ios" == Device.system.os && _this.detect("a10")) return !0;
        if ("android" == Device.system.os && !_this.MT0) return !0;
        if (_this.detect("nvidia tegra") && Device.detect("pixel c")) return !0;
        if (_this.detect("mali-g")) return _this.matchGPU("mali-g", 73);
        if (_this.detect("adreno")) {
          if (_this.matchGPU("adreno (tm) ", 600, 616)) return !0;
          if (_this.matchGPU("adreno (tm) ", 530, 600)) return !0;
        }
        return !1;
      })()),
      (_this.MT2 =
        !!Device.mobile &&
        !_this.BLOCKLIST &&
        (!("ios" != Device.system.os || !_this.detect(["a11", "a12"])) ||
          (_this.detect("adreno")
            ? _this.matchGPU("adreno (tm) ", 630)
            : _this.detect("mali-g")
            ? _this.matchGPU("mali-g", 74)
            : !(
                !navigator.platform
                  .toLowerCase()
                  .includes(["mac", "windows"]) ||
                "chrome" != Device.system.browser
              )))),
      (_this.MT3 =
        !!Device.mobile &&
        !_this.BLOCKLIST &&
        (!(
          "ios" != Device.system.os ||
          !_this.detect(["a12", "a13", "a14", "a15", "a16", "a17", "a18"])
        ) ||
          (_this.detect("adreno")
            ? _this.matchGPU("adreno (tm) ", 640)
            : _this.detect("mali-g")
            ? _this.matchGPU("mali-g", 76)
            : !(
                !navigator.platform
                  .toLowerCase()
                  .includes(["mac", "windows"]) ||
                "chrome" != Device.system.browser
              )))),
      (_this.MT4 =
        !!Device.mobile &&
        !_this.BLOCKLIST &&
        (!(
          "ios" != Device.system.os ||
          !_this.detect([
            "a14",
            "a15",
            "a16",
            "a17",
            "a18",
            "a19",
            "a20",
            "apple m",
          ])
        ) ||
          (_this.detect("adreno")
            ? _this.matchGPU("adreno (tm) ", 650)
            : _this.detect("mali-g")
            ? _this.matchGPU("mali-g", 78)
            : !(
                !navigator.platform
                  .toLowerCase()
                  .includes(["mac", "windows"]) ||
                "chrome" != Device.system.browser
              )))),
      (_this.lt = function (num) {
        return _this.TIER > -1 && _this.TIER <= num;
      }),
      (_this.gt = function (num) {
        return _this.TIER > -1 && _this.TIER >= num;
      }),
      (_this.eq = function (num) {
        return _this.TIER > -1 && _this.TIER == num;
      }),
      (_this.mobileEq = function (num) {
        return _this.M_TIER > -1 && _this.M_TIER == num;
      }),
      (_this.mobileLT = function (num) {
        return _this.M_TIER > -1 && _this.M_TIER <= num;
      }),
      (_this.mobileGT = function (num) {
        return _this.M_TIER > -1 && _this.M_TIER >= num;
      }),
      _this))
        "T" == key.charAt(0) &&
          !0 === _this[key] &&
          (_this.TIER = Number(key.charAt(1))),
          "MT" == key.slice(0, 2) &&
            !0 === _this[key] &&
            (_this.M_TIER = Number(key.charAt(2)));
      !1 !== Utils.query("gpu") &&
        (Device.mobile || Utils.query("gpu").toString().includes("m")
          ? ((_this.TIER = -1),
            (_this.M_TIER = Number(Utils.query("gpu").slice(1))))
          : (_this.TIER = Number(Utils.query("gpu")))),
        "ios" == Device.system.os &&
          Render.REFRESH_RATE < 40 &&
          (_this.M_TIER -= 1),
        (_this.OVERSIZED =
          (!Device.mobile &&
            _this.TIER <= 0 &&
            Math.max(window.innerWidth, window.innerHeight) > 1400) ||
          (!Device.mobile &&
            _this.TIER <= 1 &&
            Device.pixelRatio < 2 &&
            Math.max(window.innerWidth, window.innerHeight) > 1600)),
        "ie" == Device.system.browser && (_this.OVERSIZED = !0),
        (_this.initialized = !0);
    }),
      (this.ready = function () {
        return this.wait("initialized");
      });
  }, "static"),
  Module(function MacOSPerformanceTest() {
    function test() {
      let results = [];
      function getPrime() {
        return (function largest_prime_factor(n) {
          return factors(n).filter(primep).pop();
        })(1e12);
      }
      function factors(n) {
        var i,
          out = [],
          sqrt_n = Math.sqrt(n);
        for (i = 2; i <= sqrt_n; i++) n % i == 0 && out.push(i);
        return out;
      }
      function primep(n) {
        return 0 === factors(n).length;
      }
      for (let i = 0; i < 3; i++) {
        let time = performance.now();
        getPrime(), results.push(10 * (performance.now() - time));
      }
      return results.sort((a, b) => a - b), results[0];
    }
    this.exports = function () {
      let result = test();
      screen.width <= 1440 && screen.height <= 900
        ? (Device.graphics.webgl.gpu =
            result > 540 ? "intel iris opengl engine" : "safari tier 1")
        : (Device.graphics.webgl.gpu =
            result > 475
              ? result > 540
                ? "intel iris opengl engine"
                : "safari tier 1"
              : result < 375
              ? "amd radeon pro 455 opengl engine"
              : "nvidia geforce 750m opengl engine");
    };
  }),
  Module(function iOSGPUTest() {
    function getRenderer(complete, takUrl) {
      var nodes = [
        {
          x: "Unknown",
          m: function (n) {
            return (function family() {
              var segments = /iPhone|iPad|Macintosh/.exec(navigator.userAgent);
              if (segments && segments.length > 0) return segments[0];
              return "";
            })();
          },
          n: [4, 2, 1, 3],
        },
        {
          x: "Apple A7 GPU|Apple A8 GPU|Apple A9 GPU|Apple A10 GPU|Apple A11 GPU|Apple A12 GPU|Apple A13 GPU|Apple A14 GPU|Apple A15 GPU",
          m: function (n) {
            return height();
          },
          n: [15, 10, 11, 12, 14, 6, 7, 8, 13, 5, 9],
          v: ["iPhone"],
        },
        {
          x: "Apple A7 GPU|Apple A8 GPU|Apple A9X GPU|Apple A10X GPU|Apple A9 GPU|Apple A12X GPU|Apple A10 GPU|Apple A12 GPU|Apple A8X GPU|Apple M1 GPU|Apple A14 GPU|Apple A12Z GPU",
          m: function (n) {
            return height();
          },
          n: [21, 20, 18, 19, 17, 16],
          v: ["iPad"],
        },
        {
          x: "Apple A9X GPU|Apple A10X GPU|Apple A9 GPU|Apple A10 GPU|Apple A11 GPU|Apple A12X GPU|Apple A12 GPU|Apple A8 GPU|Apple A8X GPU|Apple A13 GPU|Apple A14 GPU|Apple M1 GPU|Apple A12Z GPU|Apple A15 GPU",
          m: function (n) {
            return height();
          },
          n: [20, 18, 27, 10, 11, 12, 14, 19, 23, 26, 24, 17, 25, 13, 9, 22],
          v: ["Macintosh"],
        },
        { x: "Apple A10 GPU", v: ["iPod Touch"] },
        {
          x: "Apple A7 GPU|Apple A9 GPU|Apple A10 GPU|Apple A11 GPU|Apple A8 GPU|Apple A13 GPU",
          m: function (n) {
            return mediacolorgamut();
          },
          n: [29, 28],
          v: [1136],
        },
        {
          x: "Apple A8 GPU|Apple A10 GPU|Apple A11 GPU|Apple A9 GPU",
          m: function (n) {
            return mediacolorgamut();
          },
          n: [30, 31],
          v: [2001],
        },
        {
          x: "Apple A8 GPU|Apple A9 GPU|Apple A10 GPU|Apple A11 GPU",
          m: function (n) {
            return mediacolorgamut();
          },
          n: [32, 33],
          v: [2208],
        },
        {
          x: "Apple A8 GPU|Apple A9 GPU|Apple A10 GPU|Apple A11 GPU|Apple A13 GPU",
          m: function (n) {
            return mediacolorgamut();
          },
          n: [34, 35],
          v: [1334],
        },
        {
          x: "Apple A11 GPU|Apple A12 GPU|Apple A13 GPU|Apple A14 GPU|Apple A15 GPU",
          m: function (n) {
            return hash3d();
          },
          n: [37, 38, 39, 40, 36, 41],
          v: [2436],
        },
        {
          x: "Apple A12 GPU|Apple A13 GPU",
          m: function (n) {
            return hash3d();
          },
          n: [42, 36],
          v: [2688],
        },
        {
          x: "Apple A12 GPU|Apple A13 GPU",
          m: function (n) {
            return hash3d();
          },
          n: [44, 43],
          v: [1624],
        },
        {
          x: "Apple A12 GPU|Apple A13 GPU",
          m: function (n) {
            return hash3d();
          },
          n: [44, 36],
          v: [1792],
        },
        {
          x: "Apple A11 GPU|Apple A12 GPU|Apple A14 GPU|Apple A13 GPU|Apple A15 GPU",
          m: function (n) {
            return hash3d();
          },
          n: [47, 45, 36, 46, 41],
          v: [2079],
        },
        { x: "Apple A14 GPU", v: [2532] },
        { x: "Apple A14 GPU", v: [2778] },
        {
          x: "Apple A7 GPU|Apple A8 GPU|Apple A9X GPU|Apple A10X GPU|Apple A9 GPU|Apple A12X GPU|Apple A10 GPU|Apple A12 GPU|Apple A8X GPU|Apple M1 GPU",
          m: function (n) {
            return mediacolorgamut();
          },
          n: [49, 48],
          v: [2048],
        },
        {
          x: "Apple A9X GPU|Apple A10X GPU|Apple A12X GPU|Apple M1 GPU|Apple A12Z GPU",
          m: function (n) {
            return mediacolorgamut();
          },
          n: [50, 51],
          v: [2732],
        },
        {
          x: "Apple A10X GPU|Apple A12 GPU",
          m: function (n) {
            return hash();
          },
          n: [53, 52],
          v: [2224],
        },
        {
          x: "Apple A12X GPU|Apple M1 GPU|Apple A12Z GPU",
          m: function (n) {
            return hash3d();
          },
          n: [55, 54],
          v: [2388],
        },
        {
          x: "Apple A10 GPU|Apple A12 GPU",
          m: function (n) {
            return hash();
          },
          n: [56, 57],
          v: [2160],
        },
        { x: "Apple A14 GPU", v: [2360] },
        {
          x: "Apple A9X GPU|Apple A10X GPU|Apple A9 GPU|Apple A12X GPU|Apple A10 GPU|Apple A12 GPU|Apple A8 GPU|Apple A8X GPU|Apple M1 GPU",
          m: function (n) {
            return mediacolorgamut();
          },
          n: [58, 49],
          v: [2048],
        },
        {
          x: "Apple A9 GPU|Apple A10 GPU|Apple A11 GPU",
          m: function (n) {
            return mediacolorgamut();
          },
          n: [59, 33],
          v: [2208],
        },
        {
          x: "Apple A9 GPU|Apple A10 GPU|Apple A11 GPU|Apple A13 GPU",
          m: function (n) {
            return mediacolorgamut();
          },
          n: [59, 35],
          v: [1334],
        },
        {
          x: "Apple A9 GPU|Apple A10 GPU|Apple A11 GPU|Apple A13 GPU",
          m: function (n) {
            return mediacolorgamut();
          },
          n: [60, 29],
          v: [1136],
        },
        {
          x: "Apple A10 GPU|Apple A11 GPU|Apple A9 GPU",
          m: function (n) {
            return mediacolorgamut();
          },
          n: [59, 31],
          v: [2001],
        },
        { x: "Apple A14 GPU", v: [2360, 2778] },
        {
          x: "Apple A7 GPU|Apple A9 GPU|Apple A8 GPU",
          m: function (n) {
            return hash();
          },
          n: [61, 63, 62, 64, 65],
          v: ["srgb"],
        },
        {
          x: "Apple A10 GPU|Apple A11 GPU|Apple A13 GPU",
          m: function (n) {
            return hash3d();
          },
          n: [66, 37, 67],
          v: ["p3"],
        },
        {
          x: "Apple A8 GPU|Apple A9 GPU",
          m: function (n) {
            return hash();
          },
          n: [68, 69],
          v: ["srgb"],
        },
        {
          x: "Apple A10 GPU|Apple A11 GPU",
          m: function (n) {
            return hash();
          },
          n: [70, 71],
          v: ["p3"],
        },
        {
          x: "Apple A8 GPU|Apple A9 GPU",
          m: function (n) {
            return hash();
          },
          n: [72, 73],
          v: ["srgb"],
        },
        {
          x: "Apple A10 GPU|Apple A11 GPU",
          m: function (n) {
            return hash();
          },
          n: [70, 74],
          v: ["p3"],
        },
        {
          x: "Apple A8 GPU|Apple A9 GPU",
          m: function (n) {
            return hash();
          },
          n: [75, 76],
          v: ["srgb"],
        },
        {
          x: "Apple A10 GPU|Apple A11 GPU|Apple A13 GPU",
          m: function (n) {
            return hash3d();
          },
          n: [66, 37, 67],
          v: ["p3"],
        },
        { x: "Apple A12 GPU", v: [958581112, 2301174800, 4085158452] },
        { x: "Apple A11 GPU", v: [367695777, 411650080, 1220644697] },
        { x: "Apple A13 GPU", v: [4193218782] },
        { x: "Apple A14 GPU", v: [105985484] },
        { x: "Apple A14 GPU", v: [3403189785] },
        { x: "Apple A14 GPU|Apple A15 GPU", v: [2364051618] },
        { x: "Apple A13 GPU", v: [352823931, 4193218782] },
        {
          x: "Apple A12 GPU",
          v: [958581112, 2301174800, 3403189785, 4085158452],
        },
        { x: "Apple A13 GPU", v: [352823931, 3335845976, 4193218782] },
        { x: "Apple A11 GPU", v: [367695777, 411650080] },
        { x: "Apple A14 GPU", v: [105985484, 679860869, 3403189785] },
        { x: "Apple A13 GPU", v: [352823931] },
        {
          x: "Apple A7 GPU|Apple A8 GPU|Apple A9X GPU|Apple A9 GPU|Apple A10 GPU|Apple A8X GPU",
          m: function (n) {
            return hash();
          },
          n: [80, 77, 81, 82, 83, 85, 78, 79, 84, 61],
          v: ["srgb"],
        },
        {
          x: "Apple A10X GPU|Apple A9X GPU|Apple A12X GPU|Apple A12 GPU|Apple M1 GPU",
          m: function (n) {
            return hash3d();
          },
          n: [55, 87, 86, 88, 89],
          v: ["p3"],
        },
        { x: "Apple A9X GPU", v: ["srgb"] },
        {
          x: "Apple A10X GPU|Apple A12X GPU|Apple M1 GPU|Apple A12Z GPU",
          m: function (n) {
            return hash3d();
          },
          n: [91, 90, 94, 92, 93],
          v: ["p3"],
        },
        { x: "Apple A10X GPU", v: [63583436, 2114570256, 3129316290] },
        { x: "Apple A12 GPU", v: [1349146759, 2917249763] },
        { x: "Apple A12X GPU|Apple A12Z GPU", v: [4085158452] },
        { x: "Apple M1 GPU", v: [105985484, 3403189785] },
        { x: "Apple A10 GPU", v: [2114570256] },
        { x: "Apple A12 GPU", v: [1349146759, 2206992415] },
        {
          x: "Apple A9X GPU|Apple A9 GPU|Apple A10 GPU|Apple A8 GPU|Apple A8X GPU",
          m: function (n) {
            return hash3d();
          },
          n: [101, 96, 98, 97, 95, 99, 100],
          v: ["srgb"],
        },
        { x: "Apple A9 GPU", v: ["srgb"] },
        {
          x: "Apple A9 GPU|Apple A10 GPU",
          m: function (n) {
            return hash();
          },
          n: [102, 64, 65],
          v: ["srgb"],
        },
        { x: "Apple A7 GPU", v: [857422828, 1915583345] },
        { x: "Apple A9 GPU", v: [46663968, 3129316290] },
        { x: "Apple A8 GPU", v: [839732043, 3816812018, 4125234388] },
        { x: "Apple A9 GPU", v: [2114570256] },
        { x: "Apple A9 GPU", v: [63583436] },
        { x: "Apple A10 GPU", v: [583354101, 3458129248, 3928876783] },
        {
          x: "Apple A13 GPU",
          v: [352823931, 3335845976, 3403189785, 4193218782],
        },
        { x: "Apple A8 GPU", v: [1411440593, 1924197914, 4125234388] },
        { x: "Apple A9 GPU", v: [2114570256, 3129316290] },
        { x: "Apple A10 GPU", v: [63583436, 2114570256, 3129316290] },
        { x: "Apple A11 GPU", v: [1349146759, 2917249763] },
        {
          x: "Apple A8 GPU",
          v: [1411440593, 1913250432, 3074367344, 4125234388],
        },
        { x: "Apple A9 GPU", v: [46663968, 2114570256, 3129316290] },
        { x: "Apple A11 GPU", v: [2917249763, 3237505312] },
        { x: "Apple A8 GPU", v: [3128296539, 3816812018, 4125234388] },
        { x: "Apple A9 GPU", v: [46663968, 63583436, 2114570256, 3129316290] },
        { x: "Apple A8 GPU", v: [2656686317, 3710391565] },
        { x: "Apple A9X GPU|Apple A9 GPU|Apple A10 GPU", v: [3129316290] },
        {
          x: "Apple A9 GPU|Apple A9X GPU|Apple A10 GPU",
          m: function (n) {
            return hash3d();
          },
          n: [103, 95, 99],
          v: [2114570256],
        },
        { x: "Apple A10 GPU", v: [46663968] },
        {
          x: "Apple A8 GPU|Apple A8X GPU",
          m: function (n) {
            return benchmarkcpuavg(n);
          },
          n: [105, 104],
          v: [4125234388],
        },
        {
          x: "Apple A8 GPU|Apple A8X GPU",
          m: function (n) {
            return hash3d();
          },
          n: [106, 107, 108],
          v: [4005673483],
        },
        {
          x: "Apple A8 GPU|Apple A8X GPU",
          v: [1350183384, 1361285941, 3816812018],
        },
        {
          x: "Apple A9X GPU|Apple A9 GPU|Apple A10 GPU",
          m: function (n) {
            return hash3d();
          },
          n: [101, 100],
          v: [63583436],
        },
        {
          x: "Apple A8 GPU|Apple A8X GPU",
          m: function (n) {
            return hash3d();
          },
          n: [110, 109],
          v: [2870741841],
        },
        { x: "Apple A10X GPU|Apple A9X GPU", v: [3458129248] },
        { x: "Apple A12X GPU|Apple A12 GPU", v: [4085158452] },
        {
          x: "Apple A10X GPU|Apple A9X GPU",
          m: function (n) {
            return benchmarkcpuavg(n);
          },
          n: [111, 112],
          v: [583354101],
        },
        {
          x: "Apple A10X GPU|Apple A9X GPU",
          m: function (n) {
            return benchmarkcpuavg(n);
          },
          n: [113, 114],
          v: [3928876783],
        },
        { x: "Apple A12X GPU", v: [4085158452] },
        { x: "Apple A10X GPU", v: [583354101, 3458129248, 3928876783] },
        { x: "Apple M1 GPU", v: [105985484] },
        {
          x: "Apple M1 GPU|Apple A10X GPU",
          m: function (n) {
            return hash();
          },
          n: [116, 115],
          v: [3403189785],
        },
        { x: "Apple A12Z GPU", v: [958581112] },
        { x: "Apple A9X GPU|Apple A10 GPU", v: [3458129248] },
        { x: "Apple A8X GPU", v: [1480368425, 1783160115] },
        {
          x: "Apple A8X GPU|Apple A10 GPU",
          m: function (n) {
            return hash();
          },
          n: [56, 117],
          v: [3403189785],
        },
        { x: "Apple A8 GPU", v: [3312905059, 3928382683] },
        {
          x: "Apple A9 GPU|Apple A9X GPU|Apple A10 GPU",
          m: function (n) {
            return benchmarkcpuavg(n);
          },
          n: [118, 119],
          v: [583354101],
        },
        {
          x: "Apple A9X GPU|Apple A9 GPU|Apple A10 GPU",
          m: function (n) {
            return benchmarkcpuavg(n);
          },
          n: [120, 122, 121],
          v: [3928876783],
        },
        { x: "Apple A10 GPU", v: [1058363647, 2015944978] },
        { x: "Apple A9 GPU", v: [46663968] },
        { x: "Apple A10 GPU", v: [3403189785] },
        {
          x: "Apple A8 GPU|Apple A8X GPU",
          m: function (n) {
            return benchmarkcpustd(n);
          },
          n: [123, 124],
          r: [{ a: 29.78, b: 30.87 }],
        },
        { x: "Apple A8 GPU", r: [{ a: 31.19, b: 31.59 }] },
        { x: "Apple A8X GPU", v: [1783160115] },
        { x: "Apple A8 GPU", v: [3928382683] },
        {
          x: "Apple A8 GPU|Apple A8X GPU",
          m: function (n) {
            return benchmarkcpustd(n);
          },
          n: [125, 126],
          v: [3403189785],
        },
        { x: "Apple A8 GPU", v: [3312905059] },
        { x: "Apple A8X GPU", v: [1480368425] },
        { x: "Apple A10X GPU", r: [{ a: 14.16, b: 17.21 }] },
        { x: "Apple A9X GPU", r: [{ a: 18.44, b: 35.94 }] },
        { x: "Apple A10X GPU", r: [{ a: 12.34, b: 15.6 }] },
        { x: "Apple A9X GPU", r: [{ a: 16.8, b: 121.37 }] },
        { x: "Apple M1 GPU", v: [1349146759] },
        { x: "Apple A10X GPU", v: [2114570256] },
        { x: "Apple A8X GPU", v: [4005673483] },
        { x: "Apple A9X GPU|Apple A9 GPU", r: [{ a: 24.38, b: 31.67 }] },
        { x: "Apple A10 GPU|Apple A9X GPU", r: [{ a: 16.82, b: 22.52 }] },
        { x: "Apple A9 GPU|Apple A9X GPU", r: [{ a: 19.79, b: 21.64 }] },
        {
          x: "Apple A10 GPU|Apple A9X GPU",
          m: function (n) {
            return benchmarkcpustd(n);
          },
          n: [127],
          r: [{ a: 14.44, b: 19.65 }],
        },
        { x: "Apple A9 GPU|Apple A9X GPU", r: [{ a: 22.74, b: 24.91 }] },
        { x: "Apple A8X GPU", r: [{ a: 0.26, b: 5.62 }] },
        { x: "Apple A8 GPU", r: [{ a: 6.32, b: 161.36 }] },
        { x: "Apple A8X GPU", r: [{ a: 0.53, b: 13.31 }] },
        { x: "Apple A8 GPU", r: [{ a: 83.08, b: 2952.42 }] },
        { x: "Apple A9X GPU|Apple A10 GPU", r: [{ a: 29.8, b: 228.33 }] },
      ];
      function hash3d() {
        var gl,
          program,
          canvas,
          mat4 = {
            create: function () {
              for (var result = new Array(16), i = 0; i < 16; i++)
                result[i] = i % 5 == 0 ? 1 : 0;
              return result;
            },
            perspective: function (out, fovy, aspect, near, far) {
              var nf,
                f = 1 / Math.tan(fovy / 2);
              return (
                (out[0] = f / aspect),
                (out[1] = 0),
                (out[2] = 0),
                (out[3] = 0),
                (out[4] = 0),
                (out[5] = f),
                (out[6] = 0),
                (out[7] = 0),
                (out[8] = 0),
                (out[9] = 0),
                (out[11] = -1),
                (out[12] = 0),
                (out[13] = 0),
                (out[15] = 0),
                null != far && far !== 1 / 0
                  ? ((nf = 1 / (near - far)),
                    (out[10] = (far + near) * nf),
                    (out[14] = 2 * far * near * nf))
                  : ((out[10] = -1), (out[14] = -2 * near)),
                out
              );
            },
            lookAt: function (out, eye, center, up) {
              var x0,
                x1,
                x2,
                y0,
                y1,
                y2,
                z0,
                z1,
                z2,
                len,
                eyex = eye[0],
                eyey = eye[1],
                eyez = eye[2],
                upx = up[0],
                upy = up[1],
                upz = up[2],
                centerx = center[0],
                centery = center[1],
                centerz = center[2];
              return Math.abs(eyex - centerx) < 1e-6 &&
                Math.abs(eyey - centery) < 1e-6 &&
                Math.abs(eyez - centerz) < 1e-6
                ? mat4.identity(out)
                : ((z0 = eyex - centerx),
                  (z1 = eyey - centery),
                  (z2 = eyez - centerz),
                  (x0 =
                    upy * (z2 *= len = 1 / Math.hypot(z0, z1, z2)) -
                    upz * (z1 *= len)),
                  (x1 = upz * (z0 *= len) - upx * z2),
                  (x2 = upx * z1 - upy * z0),
                  (len = Math.hypot(x0, x1, x2))
                    ? ((x0 *= len = 1 / len), (x1 *= len), (x2 *= len))
                    : ((x0 = 0), (x1 = 0), (x2 = 0)),
                  (y0 = z1 * x2 - z2 * x1),
                  (y1 = z2 * x0 - z0 * x2),
                  (y2 = z0 * x1 - z1 * x0),
                  (len = Math.hypot(y0, y1, y2))
                    ? ((y0 *= len = 1 / len), (y1 *= len), (y2 *= len))
                    : ((y0 = 0), (y1 = 0), (y2 = 0)),
                  (out[0] = x0),
                  (out[1] = y0),
                  (out[2] = z0),
                  (out[3] = 0),
                  (out[4] = x1),
                  (out[5] = y1),
                  (out[6] = z1),
                  (out[7] = 0),
                  (out[8] = x2),
                  (out[9] = y2),
                  (out[10] = z2),
                  (out[11] = 0),
                  (out[12] = -(x0 * eyex + x1 * eyey + x2 * eyez)),
                  (out[13] = -(y0 * eyex + y1 * eyey + y2 * eyez)),
                  (out[14] = -(z0 * eyex + z1 * eyey + z2 * eyez)),
                  (out[15] = 1),
                  out);
            },
            multiply: function (out, a, b) {
              var a00 = a[0],
                a01 = a[1],
                a02 = a[2],
                a03 = a[3],
                a10 = a[4],
                a11 = a[5],
                a12 = a[6],
                a13 = a[7],
                a20 = a[8],
                a21 = a[9],
                a22 = a[10],
                a23 = a[11],
                a30 = a[12],
                a31 = a[13],
                a32 = a[14],
                a33 = a[15],
                b0 = b[0],
                b1 = b[1],
                b2 = b[2],
                b3 = b[3];
              return (
                (out[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30),
                (out[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31),
                (out[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32),
                (out[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33),
                (b0 = b[4]),
                (b1 = b[5]),
                (b2 = b[6]),
                (b3 = b[7]),
                (out[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30),
                (out[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31),
                (out[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32),
                (out[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33),
                (b0 = b[8]),
                (b1 = b[9]),
                (b2 = b[10]),
                (b3 = b[11]),
                (out[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30),
                (out[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31),
                (out[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32),
                (out[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33),
                (b0 = b[12]),
                (b1 = b[13]),
                (b2 = b[14]),
                (b3 = b[15]),
                (out[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30),
                (out[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31),
                (out[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32),
                (out[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33),
                out
              );
            },
            identity: function (out) {
              return (
                (out[0] = 1),
                (out[1] = 0),
                (out[2] = 0),
                (out[3] = 0),
                (out[4] = 0),
                (out[5] = 1),
                (out[6] = 0),
                (out[7] = 0),
                (out[8] = 0),
                (out[9] = 0),
                (out[10] = 1),
                (out[11] = 0),
                (out[12] = 0),
                (out[13] = 0),
                (out[14] = 0),
                (out[15] = 1),
                out
              );
            },
          };
        var imageHash = 0;
        if (null != (canvas = document.createElement("canvas"))) {
          var imageData = (function generate() {
            if (
              (gl = (function getRenderingContext() {
                (canvas.width = 67), (canvas.height = 67);
                var gl =
                  canvas.getContext("webgl") ||
                  canvas.getContext("experimental-webgl");
                return (
                  gl &&
                    (gl.viewport(0, 0, 67, 67),
                    gl.clearColor(0, 0, 0, 1),
                    gl.clear(gl.COLOR_BUFFER_BIT)),
                  gl
                );
              })())
            ) {
              var vertexShader = gl.createShader(gl.VERTEX_SHADER);
              gl.shaderSource(
                vertexShader,
                "attribute vec3 c,d; uniform vec4 e; uniform vec3 f,g;uniform mat4 h,i;varying vec3 j;void main(){vec3 a=normalize(d);vec4 b=h*vec4(c,1.);vec3 k=normalize(vec3(e-b));j=g*f*max(dot(k,a),0.),gl_Position=i*vec4(c,1.);}"
              ),
                gl.compileShader(vertexShader);
              var fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
              gl.shaderSource(
                fragmentShader,
                "#ifdef GL_ES\nprecision mediump float;\n#endif\nvarying vec3 j;void main(){gl_FragColor = vec4(j, 1.0);}"
              ),
                gl.compileShader(fragmentShader),
                (program = gl.createProgram()),
                gl.attachShader(program, vertexShader),
                gl.attachShader(program, fragmentShader),
                gl.linkProgram(program),
                gl.detachShader(program, vertexShader),
                gl.detachShader(program, fragmentShader),
                gl.deleteShader(vertexShader),
                gl.deleteShader(fragmentShader),
                gl.useProgram(program);
              var n = (function initVertexBuffers(gl) {
                var latNumber,
                  longNumber,
                  vertexPositionData = [],
                  normalData = [],
                  textureCoordData = [],
                  indexData = [];
                for (latNumber = 0; latNumber <= 50; ++latNumber) {
                  var theta = (latNumber * Math.PI) / 50,
                    sinTheta = Math.sin(theta),
                    cosTheta = Math.cos(theta);
                  for (longNumber = 0; longNumber <= 50; ++longNumber) {
                    var phi = (2 * longNumber * Math.PI) / 50,
                      sinPhi = Math.sin(phi),
                      x = Math.cos(phi) * sinTheta,
                      y = cosTheta,
                      z = sinPhi * sinTheta,
                      u = 1 - longNumber / 50,
                      v = 1 - latNumber / 50;
                    vertexPositionData.push(2 * x),
                      vertexPositionData.push(2 * y),
                      vertexPositionData.push(2 * z),
                      normalData.push(x),
                      normalData.push(y),
                      normalData.push(z),
                      textureCoordData.push(u),
                      textureCoordData.push(v);
                  }
                }
                for (latNumber = 0; latNumber < 50; ++latNumber)
                  for (longNumber = 0; longNumber < 50; ++longNumber) {
                    var first = 51 * latNumber + longNumber,
                      second = first + 50 + 1;
                    indexData.push(first),
                      indexData.push(second),
                      indexData.push(first + 1),
                      indexData.push(second),
                      indexData.push(second + 1),
                      indexData.push(first + 1);
                  }
                (vertexPositionData = new Float32Array(vertexPositionData)),
                  (normalData = new Float32Array(normalData)),
                  (textureCoordData = new Float32Array(textureCoordData)),
                  (indexData = new Uint16Array(indexData));
                var vertexPositionBuffer = gl.createBuffer(),
                  vertexNormalBuffer = gl.createBuffer(),
                  indexBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, vertexPositionBuffer),
                  gl.bufferData(
                    gl.ARRAY_BUFFER,
                    vertexPositionData,
                    gl.STATIC_DRAW
                  );
                var VertexPosition = gl.getAttribLocation(program, "c");
                gl.vertexAttribPointer(VertexPosition, 3, gl.FLOAT, !1, 0, 0),
                  gl.enableVertexAttribArray(VertexPosition),
                  gl.bindBuffer(gl.ARRAY_BUFFER, vertexNormalBuffer),
                  gl.bufferData(gl.ARRAY_BUFFER, normalData, gl.STATIC_DRAW);
                var VertexNormal = gl.getAttribLocation(program, "d");
                return (
                  gl.vertexAttribPointer(VertexNormal, 3, gl.FLOAT, !1, 0, 0),
                  gl.enableVertexAttribArray(VertexNormal),
                  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer),
                  gl.bufferData(
                    gl.ELEMENT_ARRAY_BUFFER,
                    indexData,
                    gl.STATIC_DRAW
                  ),
                  indexData.length
                );
              })(gl);
              gl.clearColor(0, 0, 0, 1), gl.enable(gl.DEPTH_TEST);
              var projection = mat4.create();
              mat4.perspective(projection, Math.PI / 6, 1, 0.1, 100);
              var modelView = mat4.create();
              mat4.lookAt(modelView, [0, 0, 10], [0, 0, 0], [0, 1, 0]);
              var mvpMatrix = mat4.create();
              mat4.multiply(mvpMatrix, projection, modelView);
              var ModelViewMatrix = gl.getUniformLocation(program, "h");
              gl.uniformMatrix4fv(ModelViewMatrix, !1, modelView);
              var MVP = gl.getUniformLocation(program, "i");
              gl.uniformMatrix4fv(MVP, !1, mvpMatrix);
              var LightPosition = gl.getUniformLocation(program, "e");
              gl.uniform4fv(LightPosition, [10, 10, 10, 1]);
              var Kd = gl.getUniformLocation(program, "f");
              gl.uniform3fv(Kd, [0.9, 0.5, 0.3]);
              var Ld = gl.getUniformLocation(program, "g");
              return (
                gl.uniform3fv(Ld, [1, 1, 1]),
                gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT),
                gl.drawElements(gl.TRIANGLES, n, gl.UNSIGNED_SHORT, 0),
                (function cleanup() {
                  gl.useProgram(null), program && gl.deleteProgram(program);
                })(),
                canvas.toDataURL()
              );
            }
          })();
          imageData && (imageHash = fnvHash(imageData));
        }
        return imageHash;
      }
      var benchmarkValues = null;
      function benchmarkcpu() {
        function workerState() {
          (this.samples = []), (this.active = 0);
        }
        function timerComplete(worker) {
          worker.terminate(), finished(worker.state);
        }
        function workerComplete(source) {
          clearTimeout(source.currentTarget.timeout);
          var state = source.currentTarget.state;
          source.currentTarget.terminate(),
            (state.samples = state.samples.concat(source.data)),
            finished(state);
        }
        function finished(state) {
          state.active--,
            0 === state.active &&
              ((benchmarkValues = state.samples),
              state.resolve(benchmarkValues));
        }
        function workerFetchUrl(resolve, reject, url) {
          fetch(url, { mode: "same-origin" })
            .then(function (response) {
              if (response.ok)
                !(function workersStart(resolve, reject, url) {
                  var workers = [],
                    state = new workerState();
                  (state.resolve = resolve), (state.reject = reject);
                  try {
                    for (var i = 0; i < 2; i++) {
                      var worker = new Worker(url);
                      (worker.state = state),
                        (worker.onmessage = workerComplete),
                        (worker.onerror = function (error) {
                          reject(error);
                        }),
                        workers.push(worker);
                    }
                    for (i = 0; i < workers.length; i++)
                      state.active++,
                        workers[i].postMessage(80),
                        (workers[i].timeout = setTimeout(
                          timerComplete,
                          4e3,
                          workers[i]
                        ));
                  } catch (ex) {
                    reject(new Error(ex));
                  }
                })(resolve, reject, response.url);
              else {
                var error = new Error("Url could not be reached");
                (error.response = response), reject(error);
              }
            })
            .catch(function (error) {
              reject(error);
            });
        }
        return new Promise(function (resolve, reject) {
          null != benchmarkValues
            ? resolve(benchmarkValues)
            : setTimeout(function () {
                workerFetchUrl(resolve, reject, takUrl);
              }, 1e3);
        });
      }
      function benchmarkcpuavg(node) {
        return benchmarkcpu()
          .then(function (values) {
            var average = 0;
            values.length > 0 &&
              (average =
                values.reduce(function (previous, current) {
                  return current + previous;
                }) / values.length);
            resolveNode(node, average, 0);
          })
          .catch(function (error) {
            complete(node.x);
          });
      }
      function benchmarkcpustd(node) {
        return benchmarkcpu()
          .then(function (values) {
            var std = 0;
            if (values.length > 0) {
              var sum = values.reduce(function (previous, current) {
                  return current + previous;
                }),
                average = values.length > 0 ? sum / values.length : 0;
              std =
                values.reduce(function (sq, n) {
                  return sq + Math.pow(n - average, 2);
                }, 0) /
                (values.length - 1);
            }
            resolveNode(node, std, 0);
          })
          .catch(function (error) {
            complete(node.x);
          });
      }
      function fnvHash(str) {
        for (var h = 2166136261, i = 0; i < str.length; ++i)
          (h ^= str.charCodeAt(i)),
            (h += (h << 1) + (h << 4) + (h << 7) + (h << 8) + (h << 24));
        return h >>> 0;
      }
      function hash() {
        var imageHash = 0,
          canvas = document.createElement("canvas");
        if (null != canvas) {
          var imageData = (function drawImage(canvas) {
            (canvas.width = 67), (canvas.height = 67);
            var ctx = canvas.getContext("2d", { alpha: !0 });
            if (null != ctx)
              return (
                (ctx.imageSmoothingQuality = "low"),
                (ctx.imageSmoothingEnabled = !0),
                (ctx.globalCompositeOperation = "source-over"),
                (ctx.globalAlpha = 1),
                (ctx.miterLimit = 1 / 0),
                (ctx.filter = "none"),
                (ctx.lineCap = "butt"),
                (ctx.lineDashOffset = 0),
                (ctx.lineJoin = "miter"),
                (ctx.font = "10pt Arial"),
                (ctx.lineWidth = 2),
                void 0 !== ctx.setLineDash && ctx.setLineDash([10, 20]),
                (ctx.shadowColor = "black"),
                (ctx.shadowOffsetX = -3),
                (ctx.shadowOffsetY = -5),
                ctx.translate(canvas.width / 2, canvas.height / 2),
                ctx.rotate(0.8901179),
                (ctx.fillStyle = "green"),
                (ctx.textAlign = "center"),
                (ctx.textBaseline = "middle"),
                ctx.fillText("*51Degrees*", 0, 0),
                ctx.beginPath(),
                (ctx.shadowColor = "yellow"),
                (ctx.shadowBlur = 1),
                (ctx.shadowOffsetX = 1),
                (ctx.shadowOffsetY = 1),
                (ctx.strokeStyle = "red"),
                (ctx.fillStyle = "rgba(0, 0, 255, 0.6)"),
                void 0 === ctx.ellipse
                  ? ctx.arc(0, 0, 25, 0, 2 * Math.PI)
                  : ctx.ellipse(0, 0, 25, 15, Math.PI / 4, 0, 2 * Math.PI),
                ctx.fill(),
                ctx.stroke(),
                canvas.toDataURL()
              );
          })(canvas);
          imageData && (imageHash = fnvHash(imageData));
        }
        return imageHash;
      }
      function height() {
        return window.screen.height * window.devicePixelRatio;
      }
      function mediacolorgamut() {
        return (function getMediaSingleValue(name, possibleValues) {
          for (var i = 0; i < possibleValues.length; i++)
            if (
              ((query = "(" + name + ": " + possibleValues[i] + ")"),
              window.matchMedia(query).matches)
            )
              return possibleValues[i];
          var query;
          return "n/a";
        })("color-gamut", ["p3", "srgb"]);
      }
      function resolveNode(node, value, iterations) {
        for (var i = 0; i < node.n.length; i++) {
          var child = nodes[node.n[i]];
          if (child.r)
            for (var c = 0; c < child.r.length; c++) {
              var range = child.r[c];
              if (
                (null === range.a || value >= range.a) &&
                (null === range.b || value <= range.b)
              )
                return void evaluateNode(child, 0);
            }
          else if (child.v && -1 != child.v.indexOf(value))
            return void evaluateNode(child, 0);
        }
        node.n.length > 0 &&
          iterations < 10 &&
          setTimeout(function () {
            evaluateNode(node, iterations + 1);
          }, 10),
          complete(node.x);
      }
      function evaluateNode(node, iterations) {
        if (node.m) {
          var result = node.m(node);
          result || "" === result
            ? result.then || resolveNode(node, result, iterations)
            : node.x && complete(node.x);
        } else complete(node.x);
      }
      evaluateNode(nodes[0], 0), complete("done");
    }
    function test() {
      let results = [];
      function getPrime() {
        return (function largest_prime_factor(n) {
          return factors(n).filter(primep).pop();
        })(1e11);
      }
      function factors(n) {
        var i,
          out = [],
          sqrt_n = Math.sqrt(n);
        for (i = 2; i <= sqrt_n; i++) n % i == 0 && out.push(i);
        return out;
      }
      function primep(n) {
        return 0 === factors(n).length;
      }
      for (let i = 0; i < 3; i++) {
        let time = performance.now();
        getPrime(), results.push(10 * (performance.now() - time));
      }
      return results.sort((a, b) => a - b), results[0];
    }
    function fallbackTest() {
      let res =
          Math.min(screen.width, screen.height) +
          "x" +
          Math.max(screen.width, screen.height),
        time = test();
      switch (res) {
        case "320x480":
          Device.graphics.webgl.gpu = "legacy";
          break;
        case "320x568":
          Device.graphics.webgl.gpu =
            time <= 400 ? "apple a8" : time <= 500 ? "apple a7" : "legacy";
          break;
        case "375x812":
        case "414x896":
          Device.graphics.webgl.gpu =
            time <= 150 ? "apple a13" : time <= 180 ? "apple a12" : "apple a11";
          break;
        case "414x736":
        case "375x667":
          Device.graphics.webgl.gpu =
            time <= 220
              ? "apple a11"
              : time <= 250
              ? "apple a10"
              : time <= 360
              ? "apple a9"
              : time <= 400
              ? "apple a8"
              : time <= 600
              ? "apple a7"
              : "legacy";
          break;
        default:
        case "768x1024":
          Device.graphics.webgl.gpu =
            time <= 140
              ? "apple a14"
              : time <= 160
              ? "apple a13"
              : time <= 180
              ? "apple a12"
              : time <= 220
              ? "apple a11"
              : time <= 250
              ? "apple a10"
              : time <= 360
              ? "apple a9"
              : time <= 400
              ? "apple a8"
              : time <= 600
              ? "apple a7"
              : "legacy";
          break;
        case "834x1112":
          Device.graphics.webgl.gpu =
            time <= 160
              ? "apple a13"
              : time <= 180
              ? "apple a12"
              : time <= 220
              ? "apple a11"
              : "apple a10";
          break;
        case "834x1194":
          time <= 140
            ? (Device.graphics.webgl.gpu = "apple m1 gpu")
            : time <= 160
            ? (Device.graphics.webgl.gpu = "apple a13")
            : time <= 180 && (Device.graphics.webgl.gpu = "apple a12");
          break;
        case "810x1080":
          time <= 160
            ? (Device.graphics.webgl.gpu = "apple a13")
            : time <= 220
            ? (Device.graphics.webgl.gpu = "apple a11")
            : time <= 250 && (Device.graphics.webgl.gpu = "apple a10");
          break;
        case "820x1180":
          Device.graphics.webgl.gpu = "apple a14";
          break;
        case "428x926":
        case "390x844":
          Device.graphics.webgl.gpu = "apple a15";
          break;
        case "1024x1366":
          Device.graphics.webgl.gpu =
            time <= 140
              ? "apple m1 gpu"
              : time <= 160
              ? "apple a13"
              : time <= 180
              ? "apple a12"
              : time <= 220
              ? "apple a11"
              : time <= 250
              ? "apple a10"
              : "apple a9";
      }
    }
    this.exports = function () {
      let _value,
        promise = Promise.create();
      return (
        getRenderer((value) => {
          if ("done" == value) {
            if (!_value) return fallbackTest(), promise.resolve();
            if (_value.includes("|"))
              try {
                let split = _value.split("|");
                if (1 == split.length && split[0].includes("Apple M"))
                  Device.graphics.webgl.gpu = "apple m1 gpu";
                else {
                  let output = split
                    .filter((v) => !v.includes("Apple M"))
                    .map((v) =>
                      Number(
                        v
                          .replace("Apple", "")
                          .replace("X", "")
                          .replace("Z", "")
                          .split("A")[1]
                          .split(" ")[0]
                      )
                    );
                  if (
                    (output.sort((a, b) => a - b),
                    output[output.length - 1] - output[0] > 2
                      ? fallbackTest()
                      : (Device.graphics.webgl.gpu = split[0].toLowerCase()),
                    "apple a14 gpu" == Device.graphics.webgl.gpu)
                  ) {
                    let res =
                      Math.min(screen.width, screen.height) +
                      "x" +
                      Math.max(screen.width, screen.height);
                    ("428x926" != res && "390x844" != res) ||
                      (Device.graphics.webgl.gpu = "apple a15 gpu");
                  }
                }
              } catch (e) {
                fallbackTest();
              }
            else Device.graphics.webgl.gpu = _value.toLowerCase();
            promise.resolve();
          } else _value = value;
        }),
        promise
      );
    };
  }),
  Module(function GPUBlocklist() {
    this.exports = {
      match: function () {
        return (
          !Device.graphics.gpu ||
          Device.graphics.gpu.detect([
            "radeon hd 6970m",
            "radeon hd 6770m",
            "radeon hd 6490m",
            "radeon hd 6630m",
            "radeon hd 6750m",
            "radeon hd 5750",
            "radeon hd 5670",
            "radeon hd 4850",
            "radeon hd 4870",
            "radeon hd 4670",
            "geforce 9400m",
            "geforce 320m",
            "geforce 330m",
            "geforce gt 130",
            "geforce gt 120",
            "geforce gtx 285",
            "geforce 8600",
            "geforce 9600m",
            "geforce 9400m",
            "geforce 8800 gs",
            "geforce 8800 gt",
            "quadro fx 5",
            "quadro fx 4",
            "radeon hd 2600",
            "radeon hd 2400",
            "radeon hd 2600",
            "mali-4",
            "mali-3",
            "mali-2",
            "swiftshader",
            "basic render driver",
            "generic renderer",
            "sgx543",
            "legacy",
            "sgx 543",
          ])
        );
      },
    };
  }),
  Class(function HydraBloom(
    _nuke,
    {
      nMips: nMips = 6,
      enabled: enabled = !0,
      useMask: useMask = !1,
      useHdr: useHdr = !1,
      useRTPool: useRTPool = !1,
    } = {},
    _unique
  ) {
    Inherit(this, Component);
    const _this = this;
    "string" == typeof options
      ? ((_unique = _params), (_nuke = World.NUKE))
      : "string" == typeof _nuke
      ? ((_unique = _nuke), (_nuke = World.NUKE))
      : !_nuke || _nuke instanceof Nuke
      ? ((_nuke = _nuke || World.NUKE), (_unique = _unique || ""))
      : (_nuke = World.NUKE);
    let _DPR = 0.5 * _nuke.dpr;
    const PASS_COUNT = nMips,
      FORMAT = !1 !== useHdr ? Texture.HALF_FLOAT : Texture.RGBAFormat;
    let _blitProgram,
      _lumaProgram,
      _downSampleProgram,
      _upSampleProgram,
      _inputTexture,
      _brightnessTexture,
      textureParams = {
        minFilter: Texture.LINEAR,
        magFilter: Texture.LINEAR,
        format: FORMAT,
        generateMipmaps: !1,
      };
    _this.blitResolution = new Vector2(
      Math.round(_nuke.stage.width * _DPR),
      Math.round(_nuke.stage.height * _DPR)
    );
    let _downSamplePasses = [],
      _upSamplePasses = [];
    _this.enabled = enabled || !0;
    let _inputUIL = null;
    function createRT(width, height, opts) {
      return new RenderTarget(width, height, opts);
    }
    function loop() {
      if (!_this.enabled || !1 === _this.visible) return;
      let inputTarget = _inputTexture || _nuke.rttBuffer.texture;
      _lumaProgram.shader.uniforms.luminosityThreshold.value > 0.001 &&
        !useMask &&
        (_lumaProgram.shader.set("tDiffuse", inputTarget),
        World.RENDERER.renderSingle(
          _lumaProgram,
          World.CAMERA,
          _brightnessTexture
        ),
        (inputTarget = _brightnessTexture.texture)),
        _blitProgram.shader.set("tMap", inputTarget),
        World.RENDERER.renderSingle(
          _blitProgram,
          World.CAMERA,
          _downSamplePasses[0].buffer
        );
      for (let i = 0; i < PASS_COUNT - 1; i++)
        _downSampleProgram.shader.set(
          "uResolution",
          _downSamplePasses[i].resolution
        ),
          _downSampleProgram.shader.set(
            "tMap",
            _downSamplePasses[i].buffer.texture
          ),
          World.RENDERER.renderSingle(
            _downSampleProgram,
            World.CAMERA,
            _downSamplePasses[i + 1].buffer
          );
      const count = PASS_COUNT - 1;
      for (let i = 0; i < count; i++)
        _upSampleProgram.shader.set(
          "uResolution",
          0 === i
            ? _downSamplePasses[count].resolution
            : _upSamplePasses[i].resolution
        ),
          _upSampleProgram.shader.set(
            "tMap",
            0 === i
              ? _downSamplePasses[count].buffer.texture
              : _upSamplePasses[i].buffer.texture
          ),
          _upSampleProgram.shader.set(
            "tNext",
            _downSamplePasses[count - i - 1].buffer.texture
          ),
          World.RENDERER.renderSingle(
            _upSampleProgram,
            World.CAMERA,
            _upSamplePasses[i + 1].buffer
          );
    }
    function handleResize() {
      _brightnessTexture.setSize(
        _nuke.stage.width * _nuke.dpr,
        _nuke.stage.height * _nuke.dpr
      ),
        (_this.blitResolution = new Vector2(
          Math.round(_nuke.stage.width * _DPR),
          Math.round(_nuke.stage.height * _DPR)
        ));
      let resX = _this.blitResolution.x,
        resY = _this.blitResolution.y;
      for (let i = 0; i < PASS_COUNT; i++)
        _downSamplePasses[i].buffer.setSize(resX, resY),
          (resX = Math.round(0.5 * resX)),
          (resY = Math.round(0.5 * resY));
      for (let i = 0; i < PASS_COUNT; i++)
        (resX = Math.round(2 * resX)),
          (resY = Math.round(2 * resY)),
          _upSamplePasses[i].buffer.setSize(resX, resY);
    }
    !(function initPasses() {
      _brightnessTexture = createRT(
        _nuke.stage.width * _nuke.dpr,
        _nuke.stage.height * _nuke.dpr,
        textureParams
      );
      let resX = _this.blitResolution.x,
        resY = _this.blitResolution.y;
      for (let i = 0; i < PASS_COUNT; i++)
        _downSamplePasses.push({
          buffer: createRT(resX, resY, textureParams),
          resolution: new Vector2(resX, resY),
        }),
          (resX = Math.round(0.5 * resX)),
          (resY = Math.round(0.5 * resY));
      for (let i = 0; i < PASS_COUNT; i++)
        (resX = Math.round(2 * resX)),
          (resY = Math.round(2 * resY)),
          _upSamplePasses.push({
            buffer: createRT(resX, resY, textureParams),
            resolution: new Vector2(resX, resY),
          });
    })(),
      (function initPrograms() {
        const geo = World.QUAD,
          blitShader = _this.initClass(Shader, "Blit", {
            tMap: { value: null },
            depthTest: !1,
            depthWrite: !1,
          });
        if (((_blitProgram = new Mesh(geo, blitShader)), !useMask)) {
          const luminosityShader = _this.initClass(
            Shader,
            "BloomLuminosityPass",
            {
              tDiffuse: { value: null, ignoreUIL: !0 },
              luminosityThreshold: { value: 0 },
              smoothWidth: { value: 0.01, ignoreUIL: !0 },
              defaultColor: { value: new Color(0), ignoreUIL: !0 },
              defaultOpacity: { value: 0, ignoreUIL: !0 },
              unique: _unique,
            }
          );
          ShaderUIL.add(luminosityShader).setLabel(
            "Hydra Bloom Luminosity Params"
          ),
            (_lumaProgram = new Mesh(geo, luminosityShader));
        }
        const downSampleShader = _this.initClass(Shader, "DownSample", {
          tMap: { value: null },
          uResolution: { value: new Vector2(2, 2) },
          uSeed: { value: 0 },
          uRadius: { value: 1 },
          depthTest: !1,
          depthWrite: !1,
          unique: _unique,
        });
        _downSampleProgram = new Mesh(geo, downSampleShader);
        const upSampleShader = _this.initClass(Shader, "UpSample", {
          tMap: { value: null },
          tNext: { value: null },
          uResolution: { value: new Vector2(2, 2) },
          uSeed: { value: 0 },
          uRadius: { value: 1 },
          uIntensity: { value: 1 },
          uTint: { value: new Color() },
          depthTest: !1,
          depthWrite: !1,
          unique: _unique,
        });
        _upSampleProgram = new Mesh(geo, upSampleShader);
      })(),
      (function initPass() {
        _this.pass = _this.initClass(NukePass, "HydraBloomPass", {
          tHydraBloom: {
            value: _upSamplePasses[PASS_COUNT - 1].buffer.texture,
          },
        });
      })(),
      (function initInputUIL() {
        (_inputUIL = InputUIL.create(`HydraBloom${_unique || ""}`)),
          _inputUIL.setLabel(`Hydra Bloom ${_unique || ""}`),
          _inputUIL.addNumber("Bloom_Radius", 1, 0.1),
          _inputUIL.addNumber("Bloom_Intensity", 1, 0.1),
          _inputUIL.addColor("Bloom_Tint", new Color()),
          (_inputUIL.onUpdate = (key, value) => {
            _upSampleProgram.shader.set(
              "uRadius",
              _inputUIL.getNumber("Bloom_Radius")
            ),
              _upSampleProgram.shader.set(
                "uIntensity",
                _inputUIL.getNumber("Bloom_Intensity")
              ),
              _upSampleProgram.shader.set(
                "uTint",
                new Color(_inputUIL.get("Bloom_Tint"))
              );
          });
      })(),
      (function addHandlers() {
        _this.onResize(handleResize);
      })(),
      _this.startRender(loop),
      this.set("texture", (texture) => {
        _inputTexture = texture;
      }),
      this.get("output", (_) => _upSamplePasses[PASS_COUNT - 1].buffer.texture),
      (this.onInvisible = function () {}),
      (this.onVisible = function () {}),
      (_this.onDestroy = function () {
        _downSamplePasses.forEach((pass) => pass.buffer.destroy()),
          _upSamplePasses.forEach((pass) => pass.buffer.destroy()),
          (_downSamplePasses = []),
          (_upSamplePasses = []);
      });
  }),
  Class(function Initializer3D() {
    Inherit(this, Component);
    const _this = this;
    let _loader,
      _working,
      _promises = [],
      _queue = [];
    async function resolve() {
      await Promise.all(_promises),
        clearTimeout(_this.fire),
        (_this.fire = _this.delayedCall((_) => {
          _this.events.fire(_this.READY),
            (_this.resolved = !0),
            (Utils3D.onTextureCreated = null),
            _loader && _loader.trigger(50);
        }, 100));
    }
    async function workQueue() {
      clearTimeout(_this.warningTimer), (_working = !0);
      let promise = _queue.shift();
      if (!promise) return (_working = !1);
      promise.resolve(workQueue),
        Hydra.LOCAL &&
          (_this.warningTimer = _this.delayedCall((_) => {
            console.warn("Long running queue has taken more than 5 seconds.");
          }, 5e3));
    }
    function incCompleted() {
      _loader && _loader.trigger(1);
    }
    (this.READY = "initializer_ready"),
      (this.bundle = function () {
        return new (function PromiseBundler() {
          const promises = [],
            ready = Promise.create();
          let timer;
          function run() {
            clearTimeout(timer),
              (timer = _this.delayedCall((_) => {
                Promise.all(promises).then((_) => ready.resolve());
              }, 100));
          }
          (this.capture = function (promise) {
            promises.push(promise), run();
          }),
            (this.ready = function () {
              return run(), ready;
            });
        })();
      }),
      (this.promise = this.capture =
        function (promise) {
          return (
            _loader && _loader.add(1),
            promise.then(incCompleted),
            _promises.push(promise),
            clearTimeout(_this.timer),
            (_this.timer = _this.delayedCall(resolve, 100)),
            promise
          );
        }),
      (this.ready = this.loaded =
        function () {
          return _this.wait(_this, "resolved");
        }),
      (this.createWorld = async function () {
        await Promise.all([
          AssetLoader.waitForLib("zUtils3D"),
          Shaders.ready(),
          GPU.ready(),
          UILStorage.ready(),
        ]),
          World.instance();
      }),
      (this.linkSceneLayout = function (loader) {
        _this.captureTextures(),
          (SceneLayout.initializer = _this.capture),
          (_loader = loader);
      }),
      (this.queue = function (immediate) {
        if (immediate) return Promise.resolve((_) => {});
        let promise = Promise.create();
        return _queue.push(promise), _working || workQueue(), promise;
      }),
      (this.captureTextures = function () {
        Utils3D.onTextureCreated = (texture) => {
          _this.promise(texture.promise);
        };
      }),
      (this.uploadAll = async function (group) {
        if (!group) throw "Undefined passed to uploadAll";
        let sceneLayout;
        if (
          group instanceof SceneLayout ||
          (window.StageLayout && group instanceof StageLayout)
        ) {
          if (((sceneLayout = group), sceneLayout.uploaded)) return;
          (sceneLayout.uploaded = !0),
            await sceneLayout.loadedAllLayers(),
            (group = group.group);
        }
        let promises = [],
          layouts = [],
          textures = [];
        if (sceneLayout) {
          sceneLayout.textures = textures;
          for (let key in sceneLayout.layers) {
            let layer = sceneLayout.layers[key];
            layer.uploadSync && layer.uploadSync();
          }
        }
        group.traverse((obj) => {
          if (
            (obj.sceneLayout && obj != group && layouts.push(obj.sceneLayout),
            obj.stageLayout && obj != group && layouts.push(obj.stageLayout),
            !obj.uploadIgnore && 0 != obj.visible)
          ) {
            if (obj.shader)
              for (let key in obj.shader.uniforms) {
                let uniform = obj.shader.uniforms[key];
                uniform &&
                  uniform.value &&
                  uniform.value.promise &&
                  (textures.push(uniform.value),
                  promises.push(
                    uniform.value.promise
                      .then(uniform.value.upload.bind(uniform.value))
                      .catch((e) => {})
                  ));
              }
            obj.asyncPromise
              ? promises.push(obj.asyncPromise.then(obj.upload.bind(obj)))
              : obj.upload && obj.upload();
          }
        }),
          await Promise.catchAll(promises),
          textures.forEach((t) => t.upload());
        for (let i = 0; i < layouts.length; i++)
          await _this.uploadAll(layouts[i]);
        sceneLayout &&
          sceneLayout._completeInitialization &&
          sceneLayout._completeInitialization(!0),
          sceneLayout && delete sceneLayout.textures;
      }),
      (this.uploadAllDistributed = this.uploadAllAsync =
        async function (group, releaseQueue) {
          if (!group) throw "Undefined passed to uploadAllDistributed";
          let sceneLayout;
          if (
            (releaseQueue ||
              "boolean" == typeof releaseQueue ||
              (releaseQueue = await _this.queue()),
            group instanceof SceneLayout ||
              (window.StageLayout && group instanceof StageLayout))
          ) {
            if (((sceneLayout = group), sceneLayout.uploaded))
              return "function" == typeof releaseQueue
                ? releaseQueue()
                : void 0;
            (sceneLayout.uploaded = !0),
              await sceneLayout.loadedAllLayers(),
              (group = group.group);
          }
          let uploads = [],
            _async = [],
            promises = [],
            layouts = [],
            textures = [];
          if (sceneLayout) {
            sceneLayout.textures = textures;
            for (let key in sceneLayout.layers) {
              let layer = sceneLayout.layers[key];
              layer.upload && !layer.uploadIgnore && layer.upload();
            }
          }
          group.traverse((obj) => {
            if (
              (obj.sceneLayout && obj != group && layouts.push(obj.sceneLayout),
              obj.stageLayout && obj != group && layouts.push(obj.stageLayout),
              !obj.uploadIgnore && 0 != obj.visible)
            ) {
              if (obj.shader)
                for (let key in obj.shader.uniforms) {
                  let uniform = obj.shader.uniforms[key];
                  uniform &&
                    uniform.value &&
                    uniform.value.promise &&
                    (textures.push(uniform.value),
                    promises.push(
                      uniform.value.promise
                        .then((_) =>
                          uploads.push(uniform.value.upload.bind(uniform.value))
                        )
                        .catch((e) => {})
                    ));
                }
              if (obj.asyncPromise)
                promises.push(
                  obj.asyncPromise.then((_) => {
                    obj.geometry && (obj.geometry.distributeBufferData = !0),
                      uploads.push(obj.upload.bind(obj)),
                      obj.geometry &&
                        _async.push(
                          obj.geometry.uploadBuffersAsync.bind(obj.geometry)
                        );
                  })
                );
              else if (obj.upload) {
                if (obj.geometry) {
                  if (obj.geometry.uploaded) return;
                  obj.geometry.distributeBufferData = !0;
                }
                uploads.push(obj.upload.bind(obj)),
                  obj.geometry &&
                    _async.push(
                      obj.geometry.uploadBuffersAsync.bind(obj.geometry)
                    );
              }
            }
          });
          let canFinish = !1,
            promise = Promise.create(),
            worker = new Render.Worker((_) => {
              let upload = uploads.shift();
              upload
                ? upload()
                : canFinish
                ? ((async (_) => {
                    for (let i = 0; i < _async.length; i++) await _async[i]();
                    for (let i = 0; i < layouts.length; i++)
                      await _this.uploadAllAsync(layouts[i], !!releaseQueue);
                    "function" == typeof releaseQueue && releaseQueue(),
                      promise.resolve();
                  })(),
                  worker.stop())
                : worker.pause();
            }, 1);
          return (
            Promise.catchAll(promises).then((_) => {
              worker.resume(), (canFinish = !0);
            }),
            sceneLayout &&
              sceneLayout._completeInitialization &&
              sceneLayout._completeInitialization(!1),
            sceneLayout &&
              promise.then((_) => {
                delete sceneLayout.textures;
              }),
            promise
          );
        }),
      (this.detectUploadAll = function (group, sync, releaseQueue) {
        return sync
          ? _this.uploadAll(group)
          : _this.uploadAllDistributed(group, releaseQueue);
      }),
      (this.detectUploadNuke = function (nuke, sync) {
        return sync ? _this.uploadNukeAsync(nuke) : _this.uploadNuke(nuke);
      }),
      (this.uploadNuke = async function (nuke) {
        for (let i = 0; i < nuke.passes.length; i++) {
          let pass = nuke.passes[i],
            uniforms = pass.uniforms;
          for (let key in uniforms)
            uniforms[key].value &&
              uniforms[key].value.promise &&
              (await uniforms[key].value.promise),
              uniforms[key].value &&
                uniforms[key].value.upload &&
                uniforms[key].value.upload();
          pass.upload();
        }
        Nuke.defaultPass.uploaded || Nuke.defaultPass.upload();
      }),
      (this.uploadNukeAsync = function (nuke) {
        return this.uploadNuke(nuke);
      }),
      (this.destroyAll = function (scene) {
        scene.traverse((obj) => {
          if (obj.geometry && obj.shader) {
            for (let key in obj.shader.uniforms) {
              let uniform = obj.shader.uniforms[key];
              uniform &&
                uniform.value instanceof Texture &&
                uniform.value.destroy();
            }
            obj.destroy();
          }
        });
      }),
      this.set("loader", (loader) => {
        _loader = loader;
      });
  }, "static"),
  Class(function AreaLightUtil() {
    Inherit(this, Component);
    var _init,
      _loaded = Promise.create(),
      _textures = [];
    this.append = async function (shader) {
      Lighting.fallbackAreaToPoint ||
        (_init ||
          (async function load() {
            _init = !0;
            let data = await fetch(
                Assets.getPath("assets/images/_lighting/arealights.json")
              ),
              json = await data.json();
            (_textures[0] = new DataTexture(
              new Float32Array(json.LTC1),
              64,
              64,
              Texture.RGBAFormat,
              Texture.FLOAT
            )),
              (_textures[1] = new DataTexture(
                new Float32Array(json.LTC2),
                64,
                64,
                Texture.RGBAFormat,
                Texture.FLOAT
              )),
              _loaded.resolve();
          })(),
        (shader.uniforms.tLTC1 = { type: "t", value: null }),
        (shader.uniforms.tLTC2 = { type: "t", value: null }),
        await _loaded,
        shader.set("tLTC1", _textures[0]),
        shader.set("tLTC2", _textures[1]));
    };
  }, "static"),
  Class(
    function Light(_input, _group) {
      Inherit(this, Object3D);
      const _this = this;
      var _config,
        _folder,
        _debug,
        prefix = `L_${_input.prefix}`,
        _light = (this.light = new BaseLight());
      function loop() {
        _light.position.copy(_this.group.position),
          _light.rotation.copy(_this.group.rotation);
      }
      function initNumber(key) {
        let initValue = UILStorage.get(`${prefix}${key}`) || _light[key];
        if (_folder) {
          let number = new UILControlNumber(`${prefix}${key}`, {
            label: key,
            value: initValue,
            step: 0.05,
          });
          number.onChange((e) => {
            (_light[key] = e),
              _this.events.fire(Light.UPDATE, {
                prefix: prefix,
                key: key,
                val: e,
                group: _this,
              });
          }),
            number.onFinishChange((e) => UILStorage.set(`${prefix}${key}`, e)),
            _folder.add(number);
        }
        _light[key] = initValue;
      }
      function update(e) {
        e.prefix == prefix &&
          e.group != _this &&
          (e.color ? _light[e.key].set(e.val) : (_light[e.key] = e.val));
      }
      !(function () {
        !(async function initConfig() {
          (_config = InputUIL.create(prefix + "_config", _group)).setLabel(
            "Config"
          ),
            _config.addSelect("type", [
              { label: "Null", value: "-1" },
              { label: "Directional", value: "0" },
              { label: "Point", value: "1" },
              { label: "Spot", value: "2" },
              { label: "Area", value: "3" },
            ]),
            await defer();
          let setup = (_) => {
            (_light.properties.w = _config.getNumber("type") + 1),
              _group &&
                Utils.query("debugLight") &&
                (_debug && _debug.destroy(),
                (_debug = _this.initClass(
                  LightDebug,
                  _config.getNumber("type"),
                  _light,
                  _folder
                )));
          };
          setup(),
            (function initSpecificUIL(type) {
              switch (type) {
                case 0:
                  break;
                case 2:
                  (_light.radius = 1),
                    (_light.feather = 0),
                    _light.rotation.set(0, Math.radians(90), 0),
                    initNumber("radius"),
                    initNumber("feather"),
                    _light.data.set(
                      _light.rotation.z,
                      _light.rotation.y,
                      _light.rotation.x,
                      _light.radius
                    ),
                    (_light.data2.x = _light.feather),
                    _group &&
                      _this.startRender((_) => {
                        (_light.data2.x = _light.feather),
                          _light.data.set(
                            _light.rotation.z,
                            _light.rotation.y,
                            _light.rotation.x,
                            _light.radius
                          );
                      });
                  break;
                case 3:
                  (_light._overridePos = new Vector3()),
                    (_light.width = 1),
                    (_light.height = 1),
                    (_light.roughness = 0.5),
                    (_light.isAreaLight = !0),
                    initNumber("width"),
                    initNumber("height"),
                    initNumber("roughness");
                  let pos = new Vector3(),
                    matrix4 = new Matrix4(),
                    matrix42 = new Matrix4(),
                    halfWidth = new Vector3(),
                    halfHeight = new Vector3(),
                    camera = World.CAMERA,
                    p = _this.group._parent;
                  for (; p; )
                    p instanceof Scene && p.nuke && (camera = p.nuke.camera),
                      (p = p._parent);
                  let updateProperties = (_) => {
                    _light.updateMatrixWorld(!0),
                      pos.setFromMatrixPosition(_light.matrixWorld),
                      pos.applyMatrix4(camera.matrixWorldInverse),
                      (_light.data.x = pos.x),
                      (_light.data.y = pos.y),
                      (_light.data.z = pos.z),
                      (_light.data.w = _light.roughness),
                      matrix42.identity(),
                      matrix4.copy(_light.matrixWorld),
                      matrix4.premultiply(camera.matrixWorldInverse),
                      matrix42.extractRotation(matrix4),
                      halfWidth.set(0.5 * _light.width, 0, 0),
                      halfHeight.set(0, 0.5 * _light.height, 0),
                      halfWidth.applyMatrix4(matrix42),
                      halfHeight.applyMatrix4(matrix42),
                      (_light.data2.x = halfWidth.x),
                      (_light.data2.y = halfWidth.y),
                      (_light.data2.z = halfWidth.z),
                      (_light.data3.x = halfHeight.x),
                      (_light.data3.y = halfHeight.y),
                      (_light.data3.z = halfHeight.z);
                  };
                  RenderManager.type == RenderManager.WEBVR
                    ? _this.startRender((e) => {
                        (camera = e.camera), updateProperties();
                      }, RenderManage.EYE_RENDER)
                    : _this.startRender(updateProperties);
              }
            })(_config.getNumber("type")),
            (_config.onUpdate = setup);
        })(),
          _group &&
            ((_folder = (function createFolder() {
              if (!UIL.sidebar) return null;
              let folder = new UILFolder(prefix, {
                label: "Params",
                closed: !0,
              });
              return _group.add(folder), folder;
            })()),
            (function addListeners() {
              _this.events.sub(Light.UPDATE, update);
            })()),
          initNumber("intensity"),
          initNumber("distance"),
          initNumber("bounce"),
          (function initColor(key) {
            let initValue = UILStorage.get(`${prefix}${key}`);
            if (_folder) {
              let color = new UILControlColor(`${prefix}${key}`, {
                label: key,
                value: initValue,
              });
              color.onChange((e) => {
                _light[key].set(e),
                  _this.events.fire(Light.UPDATE, {
                    prefix: prefix,
                    key: key,
                    val: e,
                    color: !0,
                    group: _this,
                  });
              }),
                color.onFinishChange((e) =>
                  UILStorage.set(`${prefix}${key}`, e)
                ),
                _folder.add(color);
            }
            initValue && _light[key].set(initValue);
          })("color");
        let p = _this.parent.group._parent;
        for (; p; )
          p instanceof Scene &&
            p._lightingData &&
            (_light._lightingData = p._lightingData),
            (p = p._parent);
        Lighting.add(_light), _this.startRender(loop);
      })(),
        (this.onDestroy = function () {
          _light.destroy();
        });
    },
    (_) => {
      Light.UPDATE = "light_update";
    }
  ),
  Class(function LightDebug(_type, _light, _folder) {
    Inherit(this, Object3D);
    const _this = this;
    function createLight() {
      let geom = World.SPHERE,
        shader = Utils3D.getTestShader(_light.color);
      shader.set("color", _light.color),
        (shader.depthTest = !1),
        (shader.transparent = !0);
      let mesh = new Mesh(geom, shader);
      mesh.scale.setScalar(0.5), _this.add(mesh);
    }
    !(function () {
      switch (_type) {
        case -1:
        case 1:
        case 0:
          !(function initPoint() {
            createLight();
            let geom = new IcosahedronGeometry(1, 1),
              shader = Utils3D.getTestShader(_light.color);
            shader.set("color", _light.color),
              (shader.wireframe = !0),
              (shader.transparent = !0),
              shader.set("alpha", 0.2);
            let mesh = new Mesh(geom, shader);
            mesh.scale.setScalar(_light.distance),
              _this.add(mesh),
              _this.startRender((_) => mesh.scale.setScalar(_light.distance));
          })();
          break;
        case 2:
          !(function initSpot() {
            createLight();
          })();
          break;
        case 3:
          !(function initArea() {
            let geom = World.PLANE,
              shader = Utils3D.getTestShader(_light.color);
            shader.set("color", _light.color),
              (shader.transparent = !0),
              (shader.side = Shader.DOUBLE_SIDE);
            let mesh = new Mesh(geom, shader);
            _this.add(mesh),
              _this.startRender((_) =>
                mesh.scale.set(_light.width, _light.height, 1)
              );
          })();
      }
    })(),
      (this.onDestroy = function () {
        _this.parent.group.remove(_this.group);
      });
  }),
  Class(function LitMaterial(_mesh, _shader, _group, _input) {
    (_shader.receiveLight = !0),
      (_shader.receiveShadow = !0),
      _shader.addUniforms({
        tMap: {
          value: Utils3D.getTexture("assets/images/_scenelayout/black.jpg"),
        },
      });
  }),
  Class(function ShadowLight(_input, _group) {
    Inherit(this, Object3D);
    const _this = this;
    var _light, _timer;
    !(async function () {
      ((_light = new BaseLight()).prefix = _input.prefix),
        _this.add(_light),
        (_light.silentShadow = ShadowLight.LOCKED),
        (_this.light = _light);
      let scene,
        p = _this.parent.group._parent;
      for (; p; )
        p instanceof Scene &&
          p._lightingData &&
          (_light._lightingData = p._lightingData),
          (p = p._parent);
      (_light.castShadow = !0),
        ShadowUIL.add(_light, _group).setLabel("Shadows"),
        ShadowLight.LOCKED ||
          (_this.startRender((_) => {}),
          _this.flag("waitStarted", Render.TIME),
          await _this.wait(
            () => (
              (scene = (function findScene() {
                let p = _this.group._parent;
                for (; p; ) {
                  if (p instanceof Scene) return p;
                  p = p._parent;
                }
              })()),
              !scene &&
                !_this.flag("warned") &&
                Render.TIME - _this.flag("waitStarted") > 2e3 &&
                (console.warn("ShadowLight has no parent scene after 2000ms"),
                _this.flag("warned", !0)),
              scene &&
                _this.flag("warned") &&
                console.log(
                  `False alarm, ShadowLight got parent scene after ${
                    Render.TIME - _this.flag("waitStarted")
                  }ms`
                ),
              scene
            )
          ),
          (scene.hasShadowLight = !0),
          scene.bindSceneChange((_) => {
            _light.static &&
              ((_light.shadow.frozen = !1),
              clearTimeout(_timer),
              (_timer = _this.delayedCall(
                (_) => (_light.shadow.frozen = !0),
                250
              )));
          }));
    })(),
      (this.onVisible = async function () {
        await defer(),
          _light.static &&
            ((_light.shadow.frozen = !1),
            clearTimeout(_timer),
            (_timer = _this.delayedCall(
              (_) => (_light.shadow.frozen = !0),
              250
            )));
      }),
      (this.onDestroy = function () {
        _light.destroy();
      });
  }),
  Class(function LottieMesh(_mesh, _shader, _group, _input) {
    Inherit(this, Component);
    const _this = this;
    let _lottie, _active, _frame, _config;
    function loop() {
      if (!_active || !_lottie.animation) return;
      let targetFrame = _shader.get("uFrame");
      targetFrame !== _frame &&
        ((_lottie.animation.loop = !1),
        _lottie.animation.setCurrentRawFrameValue(targetFrame),
        (_frame = targetFrame));
    }
    _mesh._lottiemesh ||
      ((_mesh._lottiemesh = _this),
      (function initConfig() {
        (_config = InputUIL.create(`${_input.prefix}lottiemesh`, _group)),
          _config.setLabel("Lottie"),
          _config.addFile("file", { relative: "assets/geometry" }),
          _config.addNumber("resolution", 1, 0.1);
      })(),
      (function initShader() {
        (_mesh.shader = _this.initClass(Shader, "LottieShader")),
          _this.initClass(LottieShader, _mesh, _mesh.shader, _group, _input),
          (_shader = _mesh.shader).addUniforms({ uFrame: { value: 0 } }),
          ShaderUIL.add(_shader, _group).setLabel("Lottie Shader");
      })(),
      _this.startRender(loop)),
      (this.onVisible = async function () {
        (_active = !0),
          (_lottie = _this.initClass(LottieTexture, {
            path: _config.getFilePath("file"),
            dpr: _config.getNumber("resolution") || 1,
          })),
          await _lottie.ready,
          _shader.set("tMap", _lottie.texture);
      }),
      (this.onInvisible = function () {
        (_active = !1), _lottie?.destroy();
      }),
      (this.onDestroy = function () {
        (_active = !1), _lottie?.destroy();
      }),
      this.get("active", (_) => _active),
      this.get("lottie", (_) => _lottie),
      this.get("frame", (_) => _frame);
  }),
  Class(function LottieShader(_mesh, _shader, _group, _input) {
    Inherit(this, Component);
    !(function () {
      const unique = `lottie_${_group?.id || _input?.name || _mesh?.uilName}`;
      _shader.addUniforms({
        tMap: { value: null, ignoreUIL: !0 },
        uFrame: { value: 0 },
        uSharp: { value: 1 },
        uSharpEdge: { value: 0.6 },
        uSolidColor: { value: new Color("#101010") },
        uSecondColor: { value: new Color("#FFD600") },
        uUseSolidColor: { value: 0 },
        uScale: { value: 1 },
        unique: unique,
        transparent: !0,
      });
    })();
  }),
  Class(
    function LottieTexture({
      path: path = null,
      json: json = null,
      dpr: dpr = 1,
      maxResolution: maxResolution = 2048,
      settings: settings,
    } = {}) {
      Inherit(this, Component);
      let _json,
        _texture,
        _animation,
        _ready = Promise.create();
      !(async function () {
        await LottieTexture.LOAD(),
          (_json =
            json ||
            (await (async function loadJSON(file) {
              if (!file) return;
              let req = LottieTexture.CACHE[file];
              req ||
                ((LottieTexture.CACHE[file] = get(file)),
                (req = LottieTexture.CACHE[file]));
              return (req = await req), req;
            })(path))),
          _json
            ? (!(function loadLottie() {
                const container = document.createElement("div");
                container.setAttribute("class", "ignore-html2canvas");
                let width = parseInt(_json.w * dpr),
                  height = parseInt(_json.w * dpr),
                  ratio = width / height;
                const maxSize = maxResolution;
                width > maxSize
                  ? ((width = maxSize), (height = width / ratio))
                  : height > maxSize &&
                    ((height = maxSize), (width = height * ratio));
                let lottieContainer =
                  document.querySelector(".lottie-container");
                lottieContainer ||
                  ((lottieContainer = document.createElement("div")),
                  lottieContainer.setAttribute("class", "lottie-container"),
                  (lottieContainer.style.width = "100vw"),
                  (lottieContainer.style.height = "100%"),
                  (lottieContainer.style.pointerEvents = "none"),
                  (lottieContainer.style.overflow = "hidden"),
                  document.body.appendChild(lottieContainer));
                (container.style.width = `${width}px`),
                  (container.style.height = `${height}px`),
                  (container.style.opacity = 0),
                  (container.style.position = "relative"),
                  (container.style.top = 0),
                  (container.style.left = 0),
                  (container.style.pointerEvents = "none"),
                  lottieContainer.appendChild(container),
                  (_animation = window.lottie.loadAnimation({
                    container: container,
                    renderer: "canvas",
                    loop: !1,
                    autoplay: !1,
                    animationData: _json,
                    rendererSettings: { dpr: 1 },
                    ...settings,
                  }));
              })(),
              (function initTexture() {
                (_texture = new Texture(_animation.container)),
                  (_texture.format = Texture.RGBAFormat),
                  (_texture.minFilter = Texture.LINEAR),
                  (_texture.magFilter = Texture.LINEAR),
                  (_texture.generateMipmaps = !1),
                  (_texture.loaded = !1),
                  _animation.addEventListener("enterFrame", () => {
                    (_texture.needsUpdate = !0), (_texture.loaded = !0);
                  });
              })(),
              _ready.resolve())
            : console.error("Missing json lottie.");
      })(),
        (this.onDestroy = async function () {
          await _ready,
            _animation?.container?.parentElement &&
              _animation?.container?.parentElement.parentElement.removeChild(
                _animation?.container?.parentElement
              ),
            _texture?.destroy(),
            _animation?.destroy(),
            (_texture = null),
            (_animation = null),
            (_json = null);
        }),
        this.get("ready", (_) => _ready),
        this.get("texture", (_) => _texture),
        this.get("animation", (_) => _animation),
        this.get("json", (_) => _json);
    },
    (_) => {
      (LottieTexture.LOADING = !1),
        (LottieTexture.LOADED = Promise.create()),
        (LottieTexture.CACHE = {}),
        (LottieTexture.QUALITY = "high"),
        (LottieTexture.LOAD = async function () {
          if (LottieTexture.LOADING) return LottieTexture.LOADED;
          (LottieTexture.LOADING = !0),
            await AssetLoader.loadAssets(["assets/js/lib/lottie.min.js"]),
            await AssetLoader.waitForLib("lottie");
          const quality = LottieTexture.QUALITY;
          return (
            window.lottie.setQuality(quality),
            LottieTexture.LOADED.resolve(),
            !0
          );
        });
    }
  ),
  Class(function Webcam(_width, _height, _audio) {
    Inherit(this, Component);
    var _this = this;
    let _stream,
      _cameras = {},
      _config = {},
      _back = !1,
      _attempts = 0;
    function establishWebcam() {
      if (_attempts >= 2 || !navigator.mediaDevices) return error();
      (function lookupDevices() {
        let promise = Promise.create();
        return (
          navigator.mediaDevices.enumerateDevices().then((devices) => {
            devices.forEach((device) => {
              device.label.includes("front") &&
                (_cameras.front = { deviceId: { exact: device.deviceId } }),
                device.label.includes("back") &&
                  ((_cameras.back = { deviceId: { exact: device.deviceId } }),
                  (_back = !0));
            }),
              _cameras.front || (_cameras.front = { facingMode: "user" }),
              _cameras.back ||
                ((_cameras.back = { facingMode: "environment" }), (_back = !1)),
              promise.resolve();
          }),
          promise
        );
      })().then(() => {
        _stream && _config.back && _stream.getTracks()[0].stop(),
          Device.mobile.phone &&
            (_cameras &&
              _cameras.back &&
              (_cameras.back.frameRate = { ideal: 60 }),
            _cameras &&
              _cameras.front &&
              (_cameras.front.frameRate = { ideal: 60 })),
          navigator.mediaDevices
            .getUserMedia({
              video: _config.back ? _cameras.back : _cameras.front || !0,
              audio: _audio,
            })
            .then(success)
            .catch(error);
      }),
        (_attempts += 1);
    }
    function success(stream) {
      (_this.denied = !1),
        (_stream = stream),
        _config.back && !_back
          ? establishWebcam()
          : ((_this.div.srcObject = stream),
            _this.events.fire(Events.READY, null, !0));
    }
    function error() {
      (_this.denied = !0), _this.events.fire(Events.ERROR, null, !0);
    }
    (_this.facing = "back"),
      (function createVideo() {
        (_this.div = window.AURA
          ? document.createElement()
          : document.createElement("video")),
          (_this.div.width = _width),
          (_this.div.height = _height),
          (_this.div.autoplay = !0),
          (_this.div.playsinline = !0),
          _this.div.setAttribute("playsinline", !0),
          Stage.add(_this.div),
          (_this.element = $(_this.div));
      })(),
      (function initNavigator() {
        navigator.getUserMedia =
          navigator.getUserMedia ||
          navigator.webkitGetUserMedia ||
          navigator.mozGetUserMedia ||
          navigator.msGetUserMedia;
      })(),
      (this.createStream = function (config = {}) {
        (_attempts = 0),
          (_config = config),
          Device.mobile || (delete _config.back, delete _config.front),
          establishWebcam();
      }),
      (this.flip = function () {
        if (!_back) return;
        let direction;
        "front" === _this.facing
          ? ((_this.facing = "back"), (direction = _cameras.back))
          : ((_this.facing = "front"), (direction = _cameras.front)),
          _stream.getTracks()[0].stop(),
          navigator.getUserMedia(
            { video: direction || !0, audio: _audio },
            success,
            error
          );
      }),
      this.get("width", function () {
        return _width;
      }),
      this.get("height", function () {
        return _height;
      }),
      (this.size = function (w, h) {
        (_this.div.width = _width = w),
          (_this.div.height = _height = h),
          _this.element.size(w, h);
      }),
      (this.getPixels = function (width = _width, height = _height) {
        return (
          _this.canvas ||
            ((_this.canvas = document.createElement("canvas")),
            (_this.canvas.width = width),
            (_this.canvas.height = height),
            (_this.canvas.context = _this.canvas.getContext("2d"))),
          _this.canvas.context.drawImage(_this.div, 0, 0, width, height),
          _this.canvas.context.getImageData(0, 0, width, height)
        );
      }),
      (this.getCanvas = function () {
        return (
          _this.canvas ||
            ((_this.canvas = document.createElement("canvas")),
            (_this.canvas.width = _width),
            (_this.canvas.height = _height),
            (_this.canvas.context = _this.canvas.getContext("2d"))),
          _this.canvas.context.drawImage(_this.div, 0, 0, _width, _height),
          _this.canvas
        );
      }),
      (this.ready = function () {
        return _this.wait((_) => _this.div.readyState > 0);
      }),
      (this.end = function () {
        (_this.active = !1),
          _this.div.pause(),
          _stream && (_stream.getTracks()[0].enabled = !1);
      }),
      (this.restart = function () {
        _this.div.play(),
          _stream && (_stream.getTracks()[0].enabled = !0),
          (_this.active = !0);
      }),
      (this.deviceCount = async function (kind) {
        if (!navigator.mediaDevices) return 0;
        let devices = await navigator.mediaDevices.enumerateDevices(),
          count = 0;
        return (
          devices.forEach((d) => {
            d.kind.includes(kind) && count++;
          }),
          count
        );
      }),
      this.get("stream", (_) => _stream);
  }),
  Class(function LayeredMVShader(_mesh, _shader, _group, _input) {
    Inherit(this, Component);
    function getTexture(path) {
      const texture = Utils3D.getRepeatTexture(path);
      return (texture.minFilter = texture.magFilter = Texture.LINEAR), texture;
    }
    _shader.addUniforms({
      tMap: { value: null, getTexture: getTexture },
      tMapSpecular: { value: null, getTexture: getTexture },
      tMotion: { value: null, getTexture: getTexture },
      uProgress: { value: 0 },
      uColumns: { value: 4 },
      uRows: { value: 4 },
      uColumnsSpecular: { value: 16 },
      uRowsSpecular: { value: 16 },
      uDisplacementStrength: { value: 0.7 },
    });
  }),
  Class(function MVShader(_mesh, _shader, _group, _input) {
    Inherit(this, Component);
    function getTexture(path) {
      const texture = Utils3D.getRepeatTexture(path);
      return (texture.minFilter = texture.magFilter = Texture.LINEAR), texture;
    }
    !(function () {
      _shader.addUniforms({
        tMap: { value: null, getTexture: getTexture },
        tMotion: { value: null, getTexture: getTexture },
        uProgress: { value: 0 },
        uColumns: { value: 4 },
        uRows: { value: 4 },
        uDisplacementStrength: { value: 0.7 },
      });
      const customDefine = _input.get("wildcard");
      customDefine &&
        ((_shader.customCompile = `${_shader.vsName}|${_shader.fsName}${customDefine}`),
        (_shader.defines = _shader.defines || []),
        _shader.defines.push(customDefine.toUpperCase()),
        (_shader.restoreFS = _shader.restoreVS = null),
        _shader.resetProgram());
    })();
  }),
  Class(function MouseFluid(__params) {
    Inherit(this, Object3D);
    const _this = this;
    let _fluid, _layout, _custom;
    (this.scale = 1), (this.scaleBasedOnVelocity = !0);
    let _scale = 1,
      _last = new Vector2(),
      _mouse = new Vector2(),
      _white = new Color("#ffffff"),
      _params = {
        active: !0,
        size: Device.mobile ? 10 : 25,
        minSize: 0,
        maxSize: Device.mobile ? 20 : 60,
        multiplier: Device.mobile ? 1 : 5,
        decreaseValue: 1e-4,
        ...__params,
      };
    function loop() {
      (_scale +=
        (_this.scale - _scale) * Math.framerateNormalizeLerpAlpha(0.05)),
        _custom || _mouse.copy(Mouse);
      let len = _mouse.distanceTo(_last),
        size = _this.scaleBasedOnVelocity
          ? Math.range(len, 0, 5, 0, 60, !0)
          : 25,
        delta = Math.range(len, 0, 15, 0, 10, !0);
      len > 0.01 &&
        _fluid.drawInput(
          _mouse.x,
          _mouse.y,
          (_mouse.x - _last.x) * delta,
          (_mouse.y - _last.y) * delta,
          _white,
          size * _scale
        ),
        _last.copy(_mouse);
    }
    !(async function () {
      (_layout = _this.initClass(SceneLayout, "mousefluid")),
        (_fluid = await _layout.getLayer("fluid")),
        _this.isPlayground() && _fluid.initMesh(),
        (_this.fluid = _fluid),
        _params.active
          ? _this.startRender(loop, RenderManager.AFTER_LOOPS)
          : (_fluid.visible = !1);
    })(),
      (this.applyTo = async function (shader) {
        await _this.wait("fluid"),
          (shader.uniforms.tFluid = _fluid.fbos.velocity.uniform),
          (shader.uniforms.tFluidMask = { value: _fluid });
      }),
      (this.useCustomMouse = function () {
        _custom = !0;
      }),
      (this.getFluid = function () {
        return _layout.getLayer("fluid");
      }),
      (this.setParams = function (params) {
        _params = { ..._params, ...params };
      }),
      this.set("custom", (value) => (_custom = value)),
      this.get("mouse", (_) => _mouse),
      this.set("mouse", (value) => {
        value
          ? (value instanceof Vector2
              ? _mouse.copy(value)
              : _mouse.fromArray(value),
            (_custom = !0))
          : (_custom = !1);
      });
  }, "singleton"),
  Class(function ParentLayer(_input, _group) {
    Inherit(this, Object3D);
    const _this = this;
    !(function () {
      const wildcard = _input.get("wildcard");
      wildcard &&
        wildcard.split(",").forEach((layerName) => {
          !(async function addLayer(name) {
            const layer = await _this.parent.getLayer(name);
            layer || console.error("layer not found.");
            const obj = layer.isMesh ? layer : layer.group;
            (obj._parentlayer = _this.group), _this.group.add(obj);
          })(layerName.trim());
        });
    })();
  }),
  Class(
    function PBRShader(_vertexShader, _fragmentShader, _params) {
      const _this = this;
      function defineSetter(prop) {
        Object.defineProperty(_this, prop, {
          set: function (v) {
            _this.shader[prop] = v;
          },
          get: function () {
            return _this.shader[prop];
          },
        });
      }
      "object" == typeof _vertexShader &&
        ((_params = _vertexShader), (_vertexShader = _fragmentShader = "PBR")),
        "object" == typeof _fragmentShader &&
          ((_params = _fragmentShader), (_fragmentShader = _vertexShader)),
        _vertexShader || (_vertexShader = _fragmentShader = "PBR"),
        (function initShader() {
          let lookup = Utils3D.getLookupTexture("~assets/images/pbr/lut.png");
          (lookup.forcePersist = !0),
            (_this.shader = new Shader(
              _vertexShader,
              _fragmentShader,
              Utils.mergeObject(_params || {}, {
                tBaseColor: {
                  value: null,
                  getTexture: Utils3D.getRepeatTexture,
                },
                tMRO: { value: null, getTexture: Utils3D.getRepeatTexture },
                tNormal: { value: null, getTexture: Utils3D.getRepeatTexture },
                tEnvDiffuse: { value: null, premultiplyAlpha: !1 },
                tEnvSpecular: { value: null, premultiplyAlpha: !1 },
                tLightmap: { value: null, premultiplyAlpha: !1 },
                tLUT: { value: lookup, ignoreUIL: !0 },
                uTint: { value: new Color("#FFFFFF") },
                uTiling: { value: new Vector2(1, 1) },
                uOffset: { value: new Vector2(0, 0) },
                uMRON: { value: new Vector4(1, 1, 1, 1) },
                uEnv: { value: new Vector3(1, 1, 0) },
                uUseLightmap: { value: 0 },
                uHDR: { value: 0, ignoreUIL: !0 },
                uUseTonemapping: { value: 1, ignoreUIL: !0 },
                uUseLinearOutput: { value: 0 },
                uLightmapIntensity: { value: 1 },
                receiveLight: !0,
              })
            )),
            (_this.shader.parent = _this),
            (_this.lights = _this.shader.lights),
            (_this.uniforms = _this.shader.uniforms),
            [
              "side",
              "blending",
              "polygonOffset",
              "polygonOffsetFactor",
              "polygonOffsetUnits",
              "receiveShadow",
              "vertexShader",
              "fragmentShader",
              "depthTest",
              "depthWrite",
              "wireframe",
              "transparent",
              "visible",
              "persists",
              "material",
              "customShadowShader",
            ].forEach(defineSetter);
        })();
    },
    (_) => {
      const prototype = PBRShader.prototype;
      (PBRShader.webgl1 = function () {
        return World.RENDERER.type == Renderer.WEBGL1;
      }),
        (prototype.set = function (key, value) {
          return (
            void 0 !== value && (this.shader.uniforms[key].value = value),
            this.shader.uniforms[key].value
          );
        }),
        (prototype.get = function (key) {
          return this.shader.uniforms[key].value;
        }),
        (prototype.tween = function (
          key,
          value,
          time,
          ease,
          delay,
          callback,
          update
        ) {
          return tween(
            this.shader.uniforms[key],
            { value: value },
            time,
            ease,
            delay,
            callback,
            update
          );
        }),
        (prototype.setPBR = prototype.setOverride =
          function (key, value, ref = this) {
            switch (
              (ref.parent instanceof PBRShader && (ref = ref.parent),
              ref.set(key, value),
              key)
            ) {
              case "tEnvDiffuse":
              case "tEnvSpecular":
              case "tLUT":
                (value.generateMipmaps = !1),
                  (value.minFilter = Texture.LINEAR);
            }
            let src = value.src;
            src &&
              src.toLowerCase().includes("rgbm") &&
              (ref.shader.set("uHDR", 1),
              ref.shader.set("uEnv", new Vector3(1, 1, 0)));
          }),
        (prototype.destroy = function () {
          this.shader.destroy();
        }),
        (prototype.copyUniformsTo = function (shader, linked, ignore) {
          for (let key in this.uniforms)
            void 0 !== this.uniforms[key] &&
              ((ignore && ignore.includes?.(key)) ||
                (shader.uniforms[key] = linked
                  ? this.uniforms[key]
                  : {
                      type: this.uniforms[key].type,
                      value: this.uniforms[key].value,
                    }));
        }),
        (prototype.replicateUniformsTo = function (shader) {
          (shader.uniforms = this.uniforms),
            (shader._uniformKeys = this._uniformKeys),
            (shader._uniformValues = this._uniformValues);
        }),
        (prototype.addUniforms = function (uniforms) {
          uniforms.UILPrefix &&
            ((this.UILPrefix = uniforms.UILPrefix), delete uniforms.UILPrefix);
          for (let key in uniforms)
            (this.hotReloading && this.uniforms[key]) ||
              (this.uniforms[key] = uniforms[key]);
        });
    }
  ),
  Class(function Performance() {
    Inherit(this, Component);
    const _this = this;
    var _overrides = Storage.get("performance_override") || {};
    const PLATFORM_ALLOWED_KEYS = [
      "desktopVRAvailable",
      "enableWorldNukeMSAA",
      "msaaSamples",
      "forceWebGL1",
      "blurFX",
    ];
    function save(obj, key, value) {
      (_overrides[key] = { obj: Utils.getConstructorName(obj), value: value }),
        Storage.set("performance_override", _overrides);
    }
    function convert(tier) {
      if (GPU.BLOCKLIST) return "F";
      switch (tier) {
        case 5:
          return "A++";
        case 4:
          return "A+";
        case 3:
          return "A";
        case 2:
          return "B";
        case 1:
          return "C";
        case 0:
          return "D";
      }
    }
    !(async function () {
      if (
        (Utils.query("performance") && Utils.query("edit")) ||
        Utils.query("custom")
      ) {
        await Hydra.ready();
        for (let key in _overrides) {
          let obj,
            value,
            override = _overrides[key];
          override?.obj
            ? ({ obj: obj, value: value } = override)
            : ((obj = "Tests"), (value = override)),
            window[obj] && (window[obj][key] = (_) => value);
        }
      }
    })(),
      (this.displayResults = async function () {
        let editing = Utils.query("edit");
        await GPU.ready(), __body.bg("#000"), Stage.bg("#000");
        let $results = __body.create("PerformanceResults");
        __body.css({ overflowY: "scroll", background: "#000" }),
          $results
            .fontStyle("Arial", 16, "#fff")
            .css({
              marginLeft: 50,
              marginRight: 50,
              "user-select": "auto",
              zIndex: 999999,
              position: "relative",
            }),
          Mobile.allowNativeScroll(),
          HydraCSS.style(".PerformanceResults *", {
            position: "relative",
            "user-select": "auto",
          });
        Tests.constructor.toString();
        let tests = "",
          keys = [],
          addTest = (obj, key) => {
            let result = obj[key]();
            (tests += `<p><b>${key}:</b> `),
              (tests += editing
                ? "number" == typeof result
                  ? `<input class="${key}" value="${result.toString()}" /></p>`
                  : "boolean" == typeof result
                  ? `<input class="${key}" type="checkbox" ${
                      result ? "checked" : ""
                    }/></p>`
                  : `<input class="${key}" value="${result}" type="text"></p>`
                : `${result}</p>`),
              keys.push({ obj: obj, key: key });
          };
        for (let key in Tests) addTest(Tests, key);
        if (window.Platform)
          for (let key in Platform)
            (key.startsWith("use") ||
              key.startsWith("using") ||
              PLATFORM_ALLOWED_KEYS.includes(key)) &&
              addTest(Platform, key);
        let compressionExtensions = [
            "compressed_texture",
            "texture_compression",
          ],
          enabledExtensions = Device.graphics.webgl?.extensions || [],
          otherExtensions = enabledExtensions
            .filter(
              (ext) => !compressionExtensions.find((n) => ext.includes(n))
            )
            .join(", "),
          dedupe = {};
        compressionExtensions = enabledExtensions
          .map((ext) =>
            compressionExtensions
              .map((name) => {
                let index = ext.indexOf(name);
                if (!(index < 0))
                  return (
                    (index += name.length),
                    "_" === ext.charAt(index) && (index += 1),
                    ext.substring(index)
                  );
              })
              .find(Boolean)
          )
          .filter((ext) => !(!ext || dedupe[ext]) && (dedupe[ext] = !0))
          .join(", ");
        let html = `<h1>Performance Results</h1>\n                    <button id="copy">Copy to clipboard</button>\n                    <p><b>Time:</b> ${new Date()}</p>\n                    <p><b>GPU:</b> ${
          Device.graphics.webgl
            ? Device.graphics.webgl.gpu
            : "WEBGL UNAVAILABLE"
        }</p>\n                    <p><b>WebGL Version:</b> ${
          Device.graphics.webgl
            ? Device.graphics.webgl.version
            : "WEBGL UNAVAILABLE"
        }</p>\n                    <p><b>GPU Tier:</b> ${
          Device.mobile ? convert(GPU.M_TIER) : convert(GPU.TIER)
        } [${
          Device.mobile ? GPU.M_TIER : GPU.TIER
        }]</p>\n                    <p><b>Mobile:</b> ${
          Device.mobile
            ? Object.keys(Device.mobile).filter((key) => Device.mobile[key])
            : "false"
        } </p>\n                    <p><b>User Agent:</b> ${
          Device.agent
        }</p>\n                    <p><b>OS:</b> ${Device.system.os}</p>${
          -1 !== Device.system.version
            ? `\n                    <p><b>OS Version:</b> ${Device.system.version}`
            : ""
        }\n                    <p><b>DPR:</b> ${
          Device.pixelRatio
        }</p>\n                    <p><b>Screen Size:</b> ${screen.width} x ${
          screen.height
        }</p>\n                    <p><b>Stage Size:</b> ${Stage.width} x ${
          Stage.height
        }</p>\n                    <p><b>Browser:</b> ${
          Device.system.browser
        }</p>\n                    <p><b>Browser Version:</b> ${
          Device.system.browserVersion
        }</p>\n                    <p><b>Compressed textures:</b> ${compressionExtensions}</p>\n                    <p><b>WebGL extensions:</b> ${otherExtensions}</p>\n                    <p><b>Media Devices w/ Permissions Granted:</b>${await navigator?.mediaDevices
          ?.enumerateDevices?.()
          .then((devices) =>
            devices
              ?.filter?.((device) => "" !== device.label)
              ?.map((device) => ` ${device.label}`)
          )}</p>\n                    \n                    <h2>Project-Specific Tests</h2>\n                    ${
          editing ? '<button class="resetBtn">Reset All</button>' : ""
        }\n                    ${tests}\n        `;
        $results.html(html);
        let copy = $(document.getElementById("copy"));
        if (
          (copy.bind("click", (_) => {
            let text = `${$results.div.innerText
              .split("\n")
              .slice(2)
              .join("\n")
              .trim()}`;
            Utils.copyToClipboard(text),
              copy.text("Results copied!"),
              clearTimeout(_this.copyTimer),
              (_this.copyTimer = _this.delayedCall((_) => {
                copy.text("Copy to clipboard");
              }, 3e3));
          }),
          editing)
        ) {
          await defer(),
            (document.querySelector(".resetBtn").onclick = (_) => {
              Storage.set("performance_override", null), location.reload();
            });
          for (let { obj: obj, key: key } of keys) {
            let div = document.querySelector(`.${key}`);
            div &&
              (div.onchange = (_) => {
                let value = div.value;
                (value = isNaN(value) ? div.checked : Number(value)),
                  save(obj, key, value);
              });
          }
        }
      });
  }, "static"),
  Class(function RenderManager() {
    Inherit(this, Component);
    const _this = this;
    var _hasGLUI,
      _hasMetal,
      _firingEvt,
      _dpr = null,
      _stringSchedules = new Map(),
      _objectSchedules = new WeakMap();
    function getSchedulesMap(evt) {
      return "string" == typeof evt ? _stringSchedules : _objectSchedules;
    }
    function getSchedule(evt) {
      return getSchedulesMap(evt).get(evt);
    }
    function fire(evt, data) {
      let array = getSchedule(evt);
      if (array) {
        let len = array.length;
        for (let i = 0; i < len; i++) {
          let cb = array[i];
          if (!array.markedForDeletion.has(cb)) {
            _firingEvt = evt;
            try {
              data ? cb(data) : cb(Render.TIME, Render.DELTA);
            } catch (error) {
              let errorEvt = {
                callback: cb,
                error: error,
                preventStopRender: !1,
              };
              Events.emitter._fireEvent(Render.RENDER_CALLBACK_ERROR, errorEvt),
                evt.preventStopRender || _this.unschedule(cb, evt);
            }
          }
        }
        (_firingEvt = void 0),
          array.markedForDeletion.size &&
            (array.markedForDeletion.forEach((_, cb) => {
              array.remove(cb);
            }),
            array.markedForDeletion.clear());
      }
    }
    function startFrame() {
      fire(_this.FRAME_BEGIN);
    }
    function resizeHandler() {
      _this.renderer && _this.renderer.setSize(Stage.width, Stage.height);
    }
    function getDPR() {
      return window.AURA
        ? Device.pixelRatio
        : GPU.OVERSIZED
        ? 1
        : GPU.lt(0)
        ? Math.min(1.3, Device.pixelRatio)
        : GPU.lt(1)
        ? Math.min(1.8, Device.pixelRatio)
        : GPU.mobileLT(2)
        ? Math.min(2, Device.pixelRatio)
        : GPU.gt(4)
        ? Math.max(1.5, Device.pixelRatio)
        : Math.max(1.25, Device.pixelRatio);
    }
    function directRenderCallback(render) {
      _hasGLUI && _hasMetal && GLUI.renderDirect(render);
    }
    (this.NORMAL = "normal"),
      (this.MAGIC_WINDOW = "magic_window"),
      (this.VR = this.WEBVR = "webvr"),
      (this.AR = this.WEBAR = "webar"),
      (this.RENDER = "RenderManager_render"),
      (this.BEFORE_RENDER = "RenderManager_before_render"),
      (this.POST_RENDER = this.FRAME_END = "RenderManager_post_render"),
      (this.EYE_RENDER = "RenderManager_eye_render"),
      (this.FRAME_BEGIN = "RenderManager_frame_begin"),
      (this.AFTER_LOOPS = "RenderManager_after_loops"),
      (this.NATIVE_FRAMERATE = "RenderManager_native_framerate"),
      (this.READY = "render_gl_ready"),
      (this.initialized = Promise.create()),
      _this.events.sub(Events.RESIZE, resizeHandler),
      (Render.startFrame = startFrame),
      Hydra.ready((_) => {
        (_hasGLUI = !!window.GLUI), (_hasMetal = !!window.Metal);
      }),
      this.get("DPR", (v) => getDPR()),
      (this.initialize = function (type, params = {}) {
        if (
          (_this.camera && _this.camera.destroy(),
          _this.renderer && _this.renderer.destroy(),
          (type != _this.WEBVR && type != _this.WEBAR) ||
            ((params.xrCompatible = !0), (params.alpha = !1)),
          !_this.gl)
        ) {
          let camera = new PerspectiveCamera(
            45,
            Stage.width / Stage.height,
            0.01,
            200
          );
          (_this.gl = (function () {
            "safari" == Device.system.browser &&
              Device.system.browserVersion < 13 &&
              delete params.powerPreference,
              Utils.query("compat") && (params.forceWebGL1 = !0);
            let renderer = new (window.Metal ? MetalRenderer : Renderer)(
              params
            );
            return (
              renderer.setSize(Stage.width, Stage.height),
              renderer.setPixelRatio(getDPR()),
              renderer
            );
          })()),
            (_this.scene = new Scene()),
            (_this.nuke = _this.initClass(
              Nuke,
              Stage,
              Object.assign(
                {
                  renderer: _this.gl,
                  scene: _this.scene,
                  camera: camera,
                  dpr: World.DPR,
                },
                params
              )
            ));
        }
        switch (((_dpr = _dpr || World.DPR || 1), type)) {
          case _this.WEBVR:
            (_this.renderer = _this.initClass(
              VRRenderer,
              _this.gl,
              _this.nuke
            )),
              (_this.camera = _this.initClass(VRCamera));
            break;
          case _this.WEBAR:
            (_this.renderer = _this.initClass(
              window.Metal ? MetalARRenderer : ARRenderer,
              _this.gl,
              _this.nuke
            )),
              (_this.camera = _this.initClass(ARCamera));
            break;
          case _this.MAGIC_WINDOW:
            (_this.renderer = _this.initClass(
              MagicWindowRenderer,
              _this.gl,
              _this.nuke
            )),
              (_this.camera = _this.initClass(VRCamera));
            break;
          case _this.NORMAL:
            (_this.renderer = _this.initClass(
              RenderManagerRenderer,
              _this.gl,
              _this.nuke
            )),
              (_this.camera = _this.initClass(RenderManagerCamera));
        }
        (_this.type = type),
          (_this.nuke.camera = _this.camera.worldCamera),
          _this.initialized.resolve();
      }),
      (this.render = function (scene, camera, renderTarget, forceClear) {
        fire(_this.AFTER_LOOPS),
          _this.type == _this.VR && fire(World.NUKE),
          fire(_this.BEFORE_RENDER),
          _this.renderer.render(
            scene || _this.scene,
            _this.nuke.camera,
            renderTarget,
            forceClear,
            directRenderCallback
          ),
          _this.events.fire(_this.POST_RENDER),
          fire(_this.POST_RENDER);
      }),
      (this.schedule = function (callback, slot) {
        let schedules = getSchedulesMap(slot),
          array = schedules.get(slot);
        array ||
          ((array = []),
          (array.markedForDeletion = new Map()),
          schedules.set(slot, array)),
          array.indexOf(callback) >= 0
            ? array.markedForDeletion.delete(callback)
            : array.push(callback);
      }),
      (this.scheduleOne = function (callback, slot) {
        let result;
        "function" != typeof callback &&
          ((slot = callback),
          (result = Promise.create()),
          (callback = result.resolve));
        let array = getSchedule(slot);
        if (array) {
          if (array.find((h) => h.scheduleOneCallback === callback)) return;
        }
        let handler = function () {
          return (
            _this.unschedule(handler, slot), callback.apply(this, arguments)
          );
        };
        return (
          (handler.scheduleOneCallback = callback),
          _this.schedule(handler, slot),
          result
        );
      }),
      (this.unschedule = function (callback, slot) {
        const array = getSchedule(slot);
        if (!array) return;
        const index = array.indexOf(callback);
        index < 0 ||
          (_firingEvt
            ? array.markedForDeletion.set(callback, !0)
            : array.splice(index, 1));
      }),
      (this.setSize = function (width, height) {
        _this.events.unsub(Events.RESIZE, resizeHandler),
          _this.renderer.setSize(width, height);
      }),
      (this.fire = fire);
  }, "static"),
  Class(function RenderManagerCamera() {
    Inherit(this, Component);
    const _this = this;
    (this.worldCamera = window.THREE
      ? new THREE.PerspectiveCamera(30, Stage.width / Stage.height, 0.1, 1e3)
      : new PerspectiveCamera(30, Stage.width / Stage.height, 0.1, 1e3)),
      _this.events.sub(Events.RESIZE, () => {
        (_this.worldCamera.aspect = Stage.width / Stage.height),
          _this.worldCamera.updateProjectionMatrix();
      });
  }),
  Class(function RenderManagerRenderer(_renderer, _nuke) {
    Inherit(this, Component);
    const _this = this;
    var _evt = {};
    (_nuke.onBeforeProcess = (_) => {
      (_evt.stage = Stage),
        (_evt.camera = _nuke.camera),
        _this.events.fire(RenderManager.RENDER, _evt);
    }),
      (this.render = function (scene, camera, _1, _2, directRender) {
        (_nuke.camera = camera),
          _nuke
            ? _nuke.render(directRender)
            : _renderer.render(scene, camera, null, null, directRender);
      }),
      (this.setSize = function (width, height) {
        _renderer.setSize(width, height);
      });
  }),
  Class(function Frag3D(_name) {
    Inherit(this, Object3D),
      (this.layout = this.initClass(SceneLayout, _name)),
      (this.uploadSync = function () {
        return Initializer3D.uploadAll(_this.layout);
      });
  }),
  Class(function FragFXScene(_name) {
    Inherit(this, FXScene);
    const _this = this;
    (this.layout = this.initClass(SceneLayout, _name)),
      (this.group = this.scene),
      this.scene.add(this.layout.group),
      (this._initFXScene = function (nuke, rtPool, options) {
        for (let key in options) options[key] || delete options[key];
        rtPool
          ? _this.create(nuke, rtPool(), options)
          : _this.create(nuke, options);
      }),
      (this.uploadSync = function () {
        return Initializer3D.uploadAll(_this.layout);
      });
  }),
  Class(
    function SceneLayout(_name, _options = {}) {
      Inherit(this, Object3D);
      const _this = this;
      var _dataStore, _data, _timeline, _breakpoint, _stateData, _gizmo;
      const ZERO = new Vector3();
      var _initializers = [],
        _promises = [],
        _breakpoints = [],
        _folders = {},
        _groups = {},
        _custom = {},
        _meshes = {},
        _exists = {},
        _layers = {},
        _uil = UIL.sidebar,
        _graph,
        _config,
        _groupIndex = 0,
        _groupsSynced = Promise.create();
      function initialize(promise) {
        _promises.push(promise);
      }
      function initGizmo() {
        _options.noGizmo ||
          Utils.query("nogizmo") ||
          (_gizmo = _this.initClass(SceneLayoutGizmo));
      }
      function createFolder(name) {
        let folder = new UILFolder(`sl_${_name}_${name}`, {
          label: name,
          closed: !0,
        });
        return (
          folder.hide(), (_folders[`sl_${_name}_${name}`] = folder), folder
        );
      }
      async function initConfig() {
        let input = InputUIL.create(`CONFIG_sl_${_name}`, _uil);
        input.add("Animation"),
          input.add("Layout"),
          input.add("Cinema Config"),
          _graph && _graph.addSpecial("Config", `Config (${_name})`, "Config"),
          input.setLabel("Config");
        let animation = input.get("Animation"),
          layout = input.get("Layout");
        animation &&
          (await ready(),
          _groupsSynced.then(async () => {
            if (
              ((animation = animation.replace(/^\//g, "")),
              (_this.animation = _this.initClass(
                HierarchyAnimation,
                animation,
                linkObjects
              )),
              _timeline)
            )
              _this.startRender((_) => {
                (_this.animation.elapsed = _timeline.elapsed),
                  _this.animation.update();
              });
            else if (_uil) {
              let range = new UILControlRange("Animation", {
                min: 0,
                max: 1,
                step: 0.001,
              });
              range.onChange((val) => {
                (_this.animation.elapsed = val), _this.animation.update();
              }),
                _uil.add(range);
            }
            await _this.animation.ready(), _this.animation.update();
          })),
          layout &&
            (await ready(),
            (_this.layout = _this.initClass(
              HierarchyLayout,
              layout,
              linkObjects
            )),
            await _this.layout.ready()),
          (_config = input),
          await defer(),
          (_this.configured = !0);
      }
      async function linkObjects(data) {
        let array = [];
        for (let i = 0; i < data.length; i++) {
          let name = data[i].name,
            exists = _this.exists(name);
          exists ||
            "null" == name.toLowerCase() ||
            console.warn(`linkAnimation :: ${name} does not exist`);
          let group = new Group(),
            mesh = exists ? await _this.getLayer(name) : null;
          mesh &&
            (_this.layout && mesh instanceof Mesh
              ? (mesh._parent.add(group), group.add(mesh))
              : (group = mesh.group || mesh)),
            (group.name = name),
            array.push(group);
        }
        return array;
      }
      async function initGraph() {
        if (_options.noGraph || !window.UILGraph || SceneLayout.noGraph)
          return (_uil = null), void _groupsSynced.resolve();
        (_graph = UILGraph.instance().getGraph(_name, _this))
          ? (UIL.sidebar.element.show(),
            await _this.ready(),
            _graph.syncVisibility(_layers),
            _graph.syncGroupNames(_groups, _folders),
            _groupsSynced.resolve(),
            Global.PLAYGROUND &&
              Utils.getConstructorName(_this.parent) == Global.PLAYGROUND &&
              _graph.open())
          : _groupsSynced.resolve();
      }
      function ssReflectionsEnabled() {
        if (void 0 !== _this.cachedSSReflections)
          return _this.cachedSSReflections;
        let p = _this,
          has = !1;
        for (; p; ) p.ssgiEnabled && (has = !0), (p = p.parent);
        return (_this.cachedSSReflections = has), has;
      }
      function generateScreenSpaceReflectionsPanel(shader) {
        let texturePath = "assets/images/_scenelayout/mask.jpg";
        shader.addUniforms({
          tReflectivity: { value: Utils3D.getTexture(texturePath) },
          tRoughness: { value: Utils3D.getTexture(texturePath) },
          ssReflectivity: { value: 1 },
          ssIORrefl: { value: 1 },
          ssRougness: { value: 0 },
          ssgiIntensity: { value: 1 },
        });
      }
      function initParams() {
        if (
          (_options.rootPath
            ? "/" != _options.rootPath.charAt(_options.rootPath.length - 1) &&
              (_options.rootPath += "/")
            : (_options.rootPath = ""),
          (_this.timeline = _timeline = _options.timeline),
          _timeline && (_timeline.add({ v: 0 }, { v: 1 }, 100, "linear"), _uil))
        ) {
          let range = new UILControlRange("Timeline", {
            min: 0,
            max: 1,
            step: 0.001,
          });
          range.onChange((val) => {
            (_timeline.elapsed = val), _timeline.update();
          }),
            _uil.add(range),
            range.hide(),
            _graph && _graph.addSpecial("Timeline", "Timeline");
        }
        (_this.baseRenderOrder = _options.baseRenderOrder || 0),
          (_this.data = _options.data),
          (_breakpoint = _options.breakpoint || SceneLayout.breakpoint),
          _options.breakpoint && (_this.localBreakpoint = !0),
          _options.uil && (_uil = _options.uil);
      }
      async function initData() {
        if (
          (await UILStorage.ready(),
          (_dataStore = InputUIL.create(`scenelayout_${_name}`, null)),
          void 0 ===
            (_data = JSON.parse(_dataStore.get("data") || "{}")).layers &&
            (_data.layers = -1),
          (_stateData = UILGroupBridge.createSceneLayout(_name, _this)),
          _options.perFrame)
        )
          _data.layers > 0 ? createLayers() : (_this.loaded = !0);
        else {
          for (let i = 0, c = _data.layers + 1; i < c; i++)
            initialize(createLayer(i));
          _this.loaded = !0;
        }
      }
      function createLayers() {
        let index = 0,
          renderWorker = new Render.Worker(function () {
            initialize(createLayer(index)),
              index++ == _data.layers &&
                (renderWorker.stop(), (_this.loaded = !0));
          }, _options.perFrame);
      }
      function getGroup(name) {
        if (!name) return _this.group;
        if (name == _name) return _this.group;
        if (!_groups[name]) {
          let uilGroup = _uil ? createFolder(name) : null;
          uilGroup &&
            (uilGroup.setLabel(`${name} (Group)`),
            _uil.add(uilGroup),
            _graph && _graph.addGroup(uilGroup.id, name));
          let config = InputUIL.create(`GROUP_${_name}_${name}`, uilGroup);
          config.setLabel("Parameters"),
            config.addToggle("occlusionCulling"),
            _timeline && config.add("tween"),
            config.addToggle("billboard"),
            config.add("breakpoints"),
            config.add("name", "hidden");
          let breakpoints = config.get("breakpoints");
          breakpoints &&
            (breakpoints = breakpoints.replace(/ /g, "").split(","));
          let breakpoint = breakpoints && _breakpoint ? "-" + _breakpoint : "";
          "-" == breakpoint.charAt(breakpoint.length - 1) && (breakpoint = "");
          let group = new Group();
          (_groups[name] = group),
            (_layers[name] = group),
            (_exists[name] = "group"),
            (group.prefix = `${name}_${_name}${breakpoint}`);
          let meshUIL = MeshUIL.add(group, uilGroup);
          meshUIL.setLabel("Mesh"),
            _this.add(group),
            UIL.global && (group._meshUIL = meshUIL),
            uilGroup && (uilGroup.params = config),
            breakpoints && _breakpoints.push(group),
            config.get("billboard") && updateBillboard(!0, mesh);
          let occlusionCulling = config.get("occlusionCulling");
          "boolean" == typeof occlusionCulling &&
            occlusionCulling &&
            _groups[name].generateOcclusionMesh(),
            _stateData.groups[_groupIndex].bind("name", (name) => {
              (_groups[name] = group),
                (_layers[name] = group),
                (_exists[name] = "group");
            }),
            (_stateData.groups[_groupIndex].slGroup = group);
        }
        return _groupIndex++, _groups[name];
      }
      async function createLayer(index, groupName, returnName) {
        let created = !1,
          input,
          id = "number" == typeof index ? index : ++_data.layers,
          graphGroupName = groupName;
        if (graphGroupName) {
          let nameLabel = UILStorage.get(
            `INPUT_GROUP_${_name}_${groupName}_name`
          );
          nameLabel && (groupName = nameLabel);
        }
        if (_stateData.layers[id]?.deleted) return;
        if (
          _this.preventLayerCreation &&
          _this.preventLayerCreation(
            UILStorage.get(`INPUT_Config_${id}_${_name}_name`)
          )
        )
          return;
        let group = _uil ? createFolder(id) : null,
          shader,
          mesh;
        _stateData.layers[id]?.bind("visible", (bool) => {
          mesh && (mesh.visible = bool);
        }),
          _stateData.layers[id]?.bind("parent", async (parent) => {
            if ((await _this.wait((_) => !!mesh), parent > -1)) {
              let obj = _stateData.groups[parent];
              obj.slGroup && obj.slGroup.add(mesh);
            } else _this.group.add(mesh);
          }),
          Hydra.LOCAL &&
            _this.delayedCall((_) => {
              created ||
                console.error(
                  `SceneLayout :: 5 second timer expired creating ${_name} ${input.get(
                    "name"
                  )}`
                );
            }, 5e3),
          (input = InputUIL.create(`Config_${id}_${_name}`, group)),
          input.setLabel("Parameters"),
          input
            .add("name", "hidden")
            .addFile("geometry", { relative: "assets/geometry" })
            .addToggle("visible", !0)
            .addToggle("transparent")
            .addToggle("depthWrite", !0)
            .addToggle("depthTest", !0)
            .addToggle("occlusionCulling", !1)
            .addToggle("castShadow")
            .addToggle("receiveShadow")
            .addToggle("receiveLight")
            .addToggle("billboard")
            .addToggle("animates", !0)
            .add("shader")
            .add("custom")
            .add("script")
            .add("wildcard")
            .add("renderOrder", "hidden")
            .add("group", "hidden")
            .add("breakpoints")
            .addSelect("side", [
              { label: "Front Side", value: "shader_front_side" },
              { label: "Back Side", value: "shader_back_side" },
              { label: "Double Side", value: "shader_double_side" },
              {
                label: "Double Side Transparent",
                value: "shader_double_side_trasparency",
              },
            ])
            .addSelect("blending", [
              { label: "Normal", value: "shader_normal_blending" },
              { label: "Additive", value: "shader_additive_blending" },
              {
                label: "Premultiplied Alpha",
                value: "shader_premultiplied_alpha_blending",
              },
            ]),
          window.FX.ScreenSpaceRaytracer && input.addToggle("ssgi"),
          (input.name = _name),
          (input.prefix = `Element_${id}_${_name}`),
          (input.id = id),
          group && (group.params = input),
          _timeline && input.addToggle("tween"),
          _options.physics &&
            (input.addToggle("physics"),
            input.add("physicsCode"),
            input.addFile("physicsBounds", { relative: "assets/geometry" }));
        let name = input.get("name") || id,
          shaderName = input.get("shader") || "SceneLayout",
          geomPath = input.getFilePath("geometry"),
          visible = input.get("visible"),
          transparent = input.get("transparent"),
          depthWrite = input.get("depthWrite"),
          depthTest = input.get("depthTest"),
          occlusionCulling = input.get("occlusionCulling"),
          billboard = input.get("billboard"),
          animates = input.get("animates"),
          doTween = input.get("tween"),
          renderOrder = input.getNumber("renderOrder"),
          blending = input.get("blending"),
          side = input.get("side"),
          physics = input.get("physics"),
          castShadow = input.get("castShadow"),
          receiveShadow = input.get("receiveShadow"),
          receiveLight = input.get("receiveLight"),
          ssReflections = input.get("ssgi");
        ssReflections && !ssReflectionsEnabled() && (ssReflections = !1);
        let breakpoints = input.get("breakpoints");
        breakpoints && (breakpoints = breakpoints.replace(/ /g, "").split(","));
        let breakpoint = breakpoints && _breakpoint ? "-" + _breakpoint : "";
        "-" == breakpoint.charAt(breakpoint.length - 1) && (breakpoint = ""),
          name && group && group.setLabel(name),
          groupName && input.setValue("group", groupName);
        let groupParent = getGroup(input.get("group"));
        if (group) {
          let groupName = input.get("group"),
            groupId = groupName
              ? `sl_${_name}_${graphGroupName || groupName}`
              : void 0;
          _graph && _graph.addLayer(group.id, name || id + "", groupId);
        }
        if ((_uil && _uil.add(group), "ignore" == name)) return (created = !0);
        let customClass = input.get("custom"),
          scriptClass = input.get("script"),
          customCompile;
        if (
          (shaderName.includes("|") &&
            ([shaderName, customCompile] = shaderName.split("|")),
          (_exists[name] = customClass ? "custom" : "mesh"),
          customClass)
        ) {
          if (customClass === _this.parent.constructor.name)
            return console.warn(
              `Tried to recursively initialize ${customClass}`
            );
          if (!window[customClass])
            return console.warn(
              `Tried to initialize ${customClass} but it doesn't  exist!`
            );
          let obj = _this.initClass(
            window[customClass],
            input,
            group,
            id,
            null
          );
          if (
            ((mesh = obj.group),
            (obj.wildcard = input.get("wildcard")),
            (obj.animates = input.get("animates")),
            "boolean" == typeof visible && mesh && (mesh.visible = visible),
            (_custom[name] = obj),
            (_layers[name] = obj),
            _this.onCreateLayer)
          ) {
            let capture = (cb) => (
              _this.delayedCall((_) => cb(obj, name), 32), !0
            );
            if (!0 === _this.onCreateLayer(name, group, capture)) return;
          }
          if (
            (obj.group && groupParent.add(obj.group),
            (obj.renderOrder = _this.baseRenderOrder + renderOrder),
            mesh)
          ) {
            let meshUIL;
            obj.camera ||
              ((mesh.prefix = `Element_${id}_${_name}${breakpoint}`),
              (meshUIL = MeshUIL.add(mesh, group)),
              meshUIL.setLabel("Mesh"),
              UIL.global && (mesh._meshUIL = meshUIL)),
              breakpoints && _breakpoints.push(mesh),
              scriptClass &&
                !1 !== visible &&
                (scriptClass.includes(",")
                  ? ((scriptClass = scriptClass.replace(/ /g, "").split(",")),
                    scriptClass.forEach((script) => {
                      window[script]
                        ? ((mesh.scriptClass = mesh.scriptClass || []),
                          mesh.scriptClass.push(
                            _this.initClass(
                              window[script],
                              mesh,
                              shader,
                              group,
                              input
                            )
                          ))
                        : console.warn(`scriptClass ${script} not found`);
                    }))
                  : window[scriptClass]
                  ? (mesh.scriptClass = _this.initClass(
                      window[scriptClass],
                      mesh,
                      shader,
                      group,
                      input
                    ))
                  : console.warn(`scriptClass ${scriptClass} not found`)),
              UIL.global &&
                (mesh._sceneLayout = input._sceneLayout =
                  {
                    meshUIL: meshUIL,
                    mesh: mesh,
                    shader: shader,
                    name: name,
                    input: input,
                  });
          }
          return (created = !0), input;
        }
        if (_this.onCreateLayer) {
          let capture = (cb) => {
            let mesh = new Group();
            return (
              (mesh.prefix = `Element_${id}_${_name}${breakpoint}`),
              MeshUIL.add(mesh, group),
              (_meshes[name] = mesh),
              (_layers[name] = mesh),
              _this.delayedCall((_) => cb(mesh, name), 32),
              (created = !0),
              !0
            );
          };
          if (!0 === _this.onCreateLayer(name, group, capture))
            return (created = !0);
        }
        let geom = World.PLANE;
        if (
          (geomPath &&
            geomPath.includes(["World", "SceneLayout"]) &&
            ((geom = eval(geomPath)), (geomPath = null)),
          shaderName.includes(".shader") &&
            ((shader = await resolveShaderRef(shaderName, name)),
            shader || (shaderName = "SceneLayout")),
          !shader)
        )
          if (shaderName.includes("PBR"))
            shader = _this.initClass(PBRShader, shaderName, {
              unique: `Element_${id}_${_name}`,
            });
          else {
            let texturePath = input.getImage("texture");
            texturePath
              ? texturePath.includes("assets/images") ||
                (texturePath = _options.rootPath + texturePath)
              : (texturePath = "assets/images/_scenelayout/uv.jpg"),
              (shader = _this.initClass(Shader, shaderName, {
                unique: `Element_${id}_${_name}`,
                customCompile: customCompile,
                ssReflections: ssReflections,
              })),
              ("SceneLayout" != shaderName && window[shaderName]) ||
                shader.addUniforms({
                  tMap: { value: Utils3D.getTexture(texturePath) },
                  uAlpha: { value: 1 },
                }),
              defer((_) => {
                for (let key in shader.uniforms) {
                  let uniform = shader.uniforms[key];
                  uniform &&
                    uniform.value instanceof Texture &&
                    initialize(uniform.value.promise);
                }
              });
          }
        "boolean" == typeof depthWrite && (shader.depthWrite = depthWrite),
          "boolean" == typeof depthTest && (shader.depthTest = depthTest),
          "boolean" == typeof transparent && (shader.transparent = transparent),
          ssReflections && generateScreenSpaceReflectionsPanel(shader),
          _this.onCreateGeometry &&
            (geomPath = _this.onCreateGeometry(
              geomPath,
              input.get("wildcard")
            ));
        let gltfNodes = null;
        if (geomPath)
          if (
            String(geomPath).indexOf(".glb") > 0 ||
            String(geomPath).indexOf(".gltf") > 0
          ) {
            let loader = new GLTFLoader();
            (gltfNodes = await loader.parse(geomPath, _this, name)),
              (geom = new PlaneGeometry(0, 0));
          } else geom = await GeomThread.loadGeometry(geomPath);
        if (
          ((mesh = new Mesh(geom, shader)),
          "boolean" == typeof occlusionCulling &&
            (mesh.occlusionCulled = occlusionCulling),
          gltfNodes)
        )
          for (let i = 0; i < gltfNodes.length; i++) mesh.add(gltfNodes[i]);
        "boolean" == typeof _options.frustumCulled &&
          (mesh.frustumCulled = _options.frustumCulled),
          "boolean" == typeof visible && (mesh.visible = visible),
          groupParent.add(mesh),
          (mesh.prefix = `Element_${id}_${_name}${breakpoint}`),
          (mesh.uilName = name),
          (mesh.uilGroup = group),
          (mesh.uilGraph = _graph),
          (mesh.wildcard = input.get("wildcard")),
          (mesh.animates = input.get("animates"));
        let meshUIL = MeshUIL.add(mesh, group);
        if (
          (meshUIL.setLabel("Mesh"),
          UIL.global && (mesh._meshUIL = meshUIL),
          physics)
        ) {
          let path = input.getFilePath("physicsBounds"),
            obj;
          if (path) {
            const shapes = await PhysicsBounds.parsePhysicsBoundsShapes(
              Assets.getPath(path)
            );
            shapes &&
              (obj = Physics.instance().createFromShapes(shapes, {}, mesh));
          }
          obj || (obj = Physics.instance().create(mesh)),
            (obj.prefix = `Physics_${id}_${_name}`),
            PhysicsUIL.add(obj, group).setLabel("Physics");
          let physicsCodeClassName = input.get("physicsCode"),
            physicsCodeClass;
          physicsCodeClassName &&
            ((physicsCodeClass = window[physicsCodeClassName]),
            physicsCodeClass ||
              console.warn(
                `physicsCode class ${physicsCodeClassName} not found`
              )),
            physicsCodeClass &&
              _this.initClass(physicsCodeClass, obj, mesh, group, input);
        }
        if (
          ((_meshes[name] = mesh),
          (_layers[name] = mesh),
          breakpoints && _breakpoints.push(mesh),
          (mesh.renderOrder = _this.baseRenderOrder + (renderOrder || 0)),
          billboard && updateBillboard(!0, mesh),
          "SceneLayout" != shaderName &&
            window[shaderName] &&
            (mesh.shaderClass = _this.initClass(
              window[shaderName],
              mesh,
              shader,
              group,
              input
            )),
          shader._copied ||
            (shader !== mesh.shader && !shaderName.includes("PBR")) ||
            ShaderUIL.add(shader, group).setLabel("Shader"),
          shader._copied &&
            shader._copied.shaderClass &&
            shader._copied.shaderClass.applyClone &&
            shader._copied.shaderClass.applyClone(mesh),
          "number" != typeof index &&
            _dataStore.setValue("data", JSON.stringify(_data)),
          blending && (shader.blending = blending),
          side && (shader.side = side),
          castShadow && (mesh.castShadow = castShadow),
          (receiveShadow = receiveShadow || Shader.shouldReceiveShadow(shader)),
          receiveShadow && (shader.receiveShadow = receiveShadow),
          receiveLight && (shader.receiveLight = receiveLight),
          scriptClass &&
            (scriptClass.includes(",")
              ? ((scriptClass = scriptClass.replace(/ /g, "").split(",")),
                scriptClass.forEach((script) => {
                  window[script]
                    ? ((mesh.scriptClass = mesh.scriptClass || []),
                      mesh.scriptClass.push(
                        _this.initClass(
                          window[script],
                          mesh,
                          shader,
                          group,
                          input
                        )
                      ))
                    : console.warn(`scriptClass ${script} not found`);
                }))
              : window[scriptClass]
              ? (mesh.scriptClass = _this.initClass(
                  window[scriptClass],
                  mesh,
                  shader,
                  group,
                  input
                ))
              : console.warn(`scriptClass ${scriptClass} not found`)),
          (input.onUpdate = (key) => {
            switch (key) {
              case "name":
                let nameStr = input.get(key);
                group.setLabel(nameStr),
                  _stateData.layers[id]?.set("name", nameStr);
                break;
              case "visible":
                mesh.visible = input.get(key);
                break;
              case "renderOrder":
                mesh.renderOrder = _this.baseRenderOrder + input.getNumber(key);
                break;
              case "transparent":
                shader.transparent = input.get(key);
                break;
              case "depthWrite":
                shader.depthWrite = input.get(key);
                break;
              case "depthTest":
                shader.depthTest = input.get(key);
                break;
              case "side":
                shader.side = input.get(key);
                break;
              case "blending":
                shader.blending = input.get(key);
                break;
              case "geometry":
                updateGeometry(input.getFilePath(key), mesh);
                break;
              case "shader":
                updateShader(input.get(key), mesh, id, group, input);
                break;
              case "scriptClass":
                updateScriptClass(input.get(key), mesh, group, input);
                break;
              case "receiveShadow":
                updateShadow(input.get(key), mesh);
                break;
              case "receiveLight":
                updateLighting(input.get(key), mesh);
                break;
              case "billboard":
                updateBillboard(input.get(key), mesh);
            }
            UIL.global &&
              ((World.SCENE.displayNeedsUpdate = !0),
              window?.view?.scene && (view.scene.displayNeedsUpdate = !0));
          }),
          Hydra.LOCAL && Global.PLAYGROUND)
        ) {
          _this.events.sub(SceneLayout.HOTLOAD_GEOMETRY, ({ file: file }) => {
            mesh.geometry?._src?.includes(file) && updateGeometry(file, mesh);
          });
          const scriptClassNeedsUpdate = (inst, file) => (
            inst.__cacheName ||
              (inst.__cacheName = Utils.getConstructorName(inst)),
            !!file.includes(inst.__cacheName) && inst.__cacheName
          );
          _this.events.sub(SceneLayout.HOTLOAD_SCRIPT, ({ file: file }) => {
            if (
              (file.includes(mesh.shader?.vsName) &&
                ((shader.hotReloading = !0),
                "SceneLayout" !== shaderName &&
                  window[shaderName] &&
                  (mesh.shaderClass = _this.initClass(
                    window[shaderName],
                    mesh,
                    shader,
                    group,
                    input
                  )),
                group.remove(shader.UILPrefix),
                delete ShaderUIL.exists[shader.UILPrefix],
                ShaderUIL.add(shader, group).setLabel("Shader"),
                (shader.hotReloading = !1)),
              mesh.scriptClass)
            )
              if (Array.isArray(mesh.scriptClass))
                mesh.scriptClass.every((inst, index) => {
                  let name = scriptClassNeedsUpdate(inst, file);
                  return (
                    !name ||
                    (mesh.scriptClass.remove(inst),
                    updateScriptClass(name, mesh, group, input),
                    !1)
                  );
                });
              else {
                let name = scriptClassNeedsUpdate(mesh.scriptClass, file);
                name && updateScriptClass(name, mesh, group, input);
              }
          });
        }
        return (
          UIL.global &&
            (mesh._sceneLayout = input._sceneLayout =
              {
                meshUIL: meshUIL,
                mesh: mesh,
                input: input,
                name: name,
                get shaderUIL() {
                  return this.mesh.shader.shaderUIL;
                },
              }),
          (created = !0),
          returnName ? name : input
        );
      }
      async function updateGeometry(geomPath, mesh) {
        let geom = World.PLANE;
        geomPath && geomPath.includes(["World", "SceneLayout"])
          ? ((geom = eval(geomPath)), (geomPath = null))
          : geomPath &&
            (geom = await GeomThread.loadGeometry(
              geomPath + "?" + Utils.timestamp()
            )),
          (mesh.geometry = geom);
      }
      async function resolveShaderRef(shaderName, layerName) {
        let shaderLayer = shaderName.split(".shader")[0],
          promise = _this.getLayer(shaderLayer);
        Hydra.LOCAL &&
          (promise = Promise.race([
            promise,
            (async () => {
              await _this.loadedAllLayers();
            })(),
          ]));
        let layer = await promise;
        if (layer) {
          let shader = layer.shader;
          return (shader._copied = layer), shader;
        }
        Hydra.LOCAL &&
          console.error(
            `Couldn’t find shader “${shaderName}” for layer “${layerName}” in SceneLayout “${_name}”, because layer “${shaderLayer}” doesn't exist`
          );
      }
      async function updateShader(shaderName = "", mesh, id, group, input) {
        let shader;
        shaderName.includes(".shader") &&
          ((shader = await resolveShaderRef(shaderName, mesh.uilName)),
          shader || (shaderName = "SceneLayout")),
          shader ||
            (shader = shaderName.includes("PBR")
              ? _this.initClass(PBRShader, shaderName, {
                  unique: `Element_${id}_${_name}`,
                })
              : _this.initClass(Shader, shaderName, {
                  unique: `Element_${id}_${_name}`,
                })),
          group.remove(mesh.shader.UILPrefix);
        for (let key in mesh.shader.uniforms) {
          "t" === mesh.shader.uniforms[key].type &&
            mesh.shader.shaderUIL.copyTexture(key, shader);
        }
        (mesh.shader = shader),
          "SceneLayout" !== shaderName &&
            window[shaderName] &&
            (mesh.shaderClass = _this.initClass(
              window[shaderName],
              mesh,
              shader,
              group,
              input
            )),
          ShaderUIL.add(shader, group).setLabel("Shader");
      }
      function updateLighting(bool, mesh) {
        (mesh.shader.customCompile = Utils.uuid()),
          (mesh.shader.receiveLight = bool),
          mesh.shader.resetProgram(),
          mesh.shader.upload();
      }
      function updateShadow(bool, mesh) {
        (mesh.shader.customCompile = Utils.uuid()),
          (mesh.shader.receiveShadow = bool),
          mesh.shader.resetProgram(),
          mesh.shader.upload();
      }
      function updateBillboard(bool, mesh) {
        bool
          ? ((mesh._billboardLoop = (_) => Utils3D.billboard(mesh)),
            _this.startRender(mesh._billboardLoop))
          : (mesh.rotation.set(0, 0, 0), _this.stopRender(mesh._billboardLoop));
      }
      function updateScriptClass(scriptClass, mesh, group, input) {
        scriptClass &&
          (scriptClass.includes(",")
            ? (scriptClass = scriptClass.replace(/ /g, "").split(",")).forEach(
                (script) => {
                  window[script]
                    ? ((mesh.scriptClass = mesh.scriptClass || []),
                      mesh.scriptClass.push(
                        _this.initClass(
                          window[script],
                          mesh,
                          mesh.shader,
                          group,
                          input
                        )
                      ))
                    : console.warn(`scriptClass ${script} not found`);
                }
              )
            : window[scriptClass]
            ? (mesh.scriptClass = _this.initClass(
                window[scriptClass],
                mesh,
                mesh.shader,
                group,
                input
              ))
            : console.warn(`scriptClass ${scriptClass} not found`));
      }
      function addListeners() {
        _this.events.sub(SceneLayout.BREAKPOINT, (e) =>
          _this.localBreakpoint ? null : setBreakpoint(e)
        );
      }
      function setBreakpoint({ value: value }) {
        value != _breakpoint &&
          ((_breakpoint = value),
          _breakpoints.forEach((mesh) => {
            if (!mesh.prefix) return;
            (mesh.prefix = mesh.prefix.split("-")[0] + "-" + _breakpoint),
              "-" == mesh.prefix.charAt(mesh.prefix.length - 1) &&
                (mesh.prefix = mesh.prefix.slice(0, -1));
            let meshUIL = new MeshUILConfig(mesh);
            UIL.global && (mesh._meshUIL = meshUIL);
          }));
      }
      async function ready() {
        await _this.wait(_this, "loaded"),
          UIL.sidebar && UIL.sidebar.toolbar.hideAll();
      }
      function copyFolderProps(from, to) {
        let mesh, params, shader;
        to.forEachFolder((child) => {
          switch (child.label) {
            case "Parameters":
              params = child;
              break;
            case "Mesh":
              mesh = child;
              break;
            case "Shader":
              shader = child;
          }
        });
        let allowed = ["Parameters", "Mesh", "Shader"];
        from.forEachFolder((child) => {
          if (!(allowed.indexOf(child.label) < 0))
            switch ((child.toClipboard(), child.label)) {
              case "Parameters":
                params.fromClipboard();
                break;
              case "Mesh":
                mesh.fromClipboard();
                break;
              case "Shader":
                shader.fromClipboard();
            }
        });
      }
      (this.isSceneLayout = !0),
        (this.name = _name),
        (async function () {
          (_this.group.sceneLayout = _this),
            await initialize(defer()),
            SceneLayout.getTexture ||
              (SceneLayout.getTexture = Utils3D.getTexture),
            initGraph(),
            initParams(),
            initialize(initConfig()),
            initData(),
            addListeners(),
            ready(),
            UIL.global && initGizmo();
        })(),
        (this.ready = async function (early) {
          if (
            (await _this.wait(_this, "loaded"),
            await _this.wait(_this, "configured"),
            early)
          )
            return !0;
          await defer(), await defer();
        }),
        (this.getLayer = async function (name) {
          let timer;
          return (
            Hydra.LOCAL &&
              (timer = _this.delayedCall((_) => {
                _exists[name] ||
                  console.warn(`${name} doesn't exist in SceneLayout ${_name}`);
              }, 1e3)),
            await _this.wait(_layers, name),
            timer && clearTimeout(timer),
            _layers[name]
          );
        }),
        (this.getLayers = async function () {
          let array = [];
          for (let i = 0; i < arguments.length; i++)
            array.push(_this.getLayer(arguments[i]));
          return Promise.all(array);
        }),
        (this.getAllLayers = async function () {
          return await this.ready(), await this.loadedAllLayers(), _layers;
        }),
        (this.getAllMatching = async function (label) {
          let layers = await _this.getAllLayers(),
            array = [];
          for (let key in layers)
            key.includes(label) &&
              ((layers[key].layerName = key), array.push(layers[key]));
          return array;
        }),
        (this.exists = function (name) {
          return _exists[name];
        }),
        (this._createLayer = function (parentId, returnName = !1) {
          return createLayer(null, parentId, returnName);
        }),
        (this._createGroup = function () {
          let index = _groupIndex;
          return getGroup(`group_${_groupIndex}`, parentId), index;
        }),
        (this._rename = function (id, name, value) {
          let folder = _folders[id] || _folders[`sl_${_name}_${id}`];
          folder &&
            (folder.setLabel(value),
            folder.params && folder.params.setValue("name", value),
            [_groups, _custom, _meshes, _exists, _layers].forEach(function (
              store
            ) {
              store[name] &&
                ((store[value] = store[name]),
                (store[name] = null),
                delete store[name]);
            }));
        }),
        (this._deleteLayer = function (id, name, coded) {
          id.includes("_") && (id = (id = id.split("_"))[id.length - 1]);
          let folder = _folders[id] || _folders[`sl_${_name}_${id}`],
            layer = _layers[id] || _layers[name];
          return layer && layer.isGroup && layer.length > 1
            ? (alert("Can't delete a group that has nested layers."), !1)
            : !(
                !coded &&
                !confirm("Are you sure you want to delete this layer?")
              ) &&
                (layer &&
                  layer._parent &&
                  (layer._parent.remove(layer), (layer._parent = null)),
                folder && folder.parent && folder.parent.remove(folder),
                UILStorage.set(`sl_${_name}_${id}_deleted`, !0),
                !0);
        }),
        (this._changeParent = function (
          childId,
          childName,
          parentId,
          parentName
        ) {
          let child = _layers[childId] || _layers[childName],
            parent = _layers[parentId] || _layers[parentName] || _this;
          if (!child) return;
          let folder =
            _folders[childId] || _folders[`sl_${_name}_${childName}`];
          folder &&
            folder.params &&
            folder.params.setValue("group", parentName || null);
          let parentObject = parent.group || parent,
            childObject = child.group || child;
          parentObject.isObject3D &&
            childObject.isObject3D &&
            parentObject.add(childObject),
            child.updateMatrix && child.updateMatrix();
        }),
        (this._visible = function (name, visible) {
          let mesh = _layers[name];
          mesh && (mesh.group && (mesh = mesh.group), (mesh.visible = visible));
        }),
        (this._focus = function (name) {
          UIL.sidebar.toolbar.filterSingle(name);
        }),
        (this._blur = function (name) {
          let folder = _folders[name] || _folders[`sl_${_name}_${name}`];
          folder &&
            folder.forEachFolder &&
            (folder.forEachFolder((f) => f.close()), folder.close());
        }),
        (this._sort = function (order) {
          order.forEach((label, index) => {
            label.children &&
              label.children.forEach(function (child, j, all) {
                let folder = _folders[child];
                if (!folder || !folder.params) return;
                let renderOrder =
                  _this.baseRenderOrder + index + (j + 1) / (all.length + 1);
                folder.params.setValue(
                  "renderOrder",
                  renderOrder - _this.baseRenderOrder
                );
                let mesh = _layers[child] || _layers[folder.label];
                mesh && (mesh.renderOrder = renderOrder);
              });
            let folder = _folders[label];
            if (!folder || !folder.params) return;
            let renderOrder = _this.baseRenderOrder + index;
            folder.params.setValue(
              "renderOrder",
              renderOrder - _this.baseRenderOrder
            );
            let mesh = _layers[label] || _layers[folder.label];
            mesh && (mesh.renderOrder = renderOrder);
          });
        }),
        (this._duplicateLayer = function (id, parentId) {
          let folder = _folders[id] || _folders[`sl_${_name}_${id}`];
          if (!folder) return;
          createLayer(null, parentId);
          let copyShader,
            copy = Object.values(_folders).last();
          folder.forEachControl((input) => {
            "shader" === input.label && (copyShader = input.value);
          }),
            copyShader &&
              (console.log(copyShader),
              copy.forEachControl((input) => {
                "shader" === input.label && input.force(copyShader);
              })),
            copyFolderProps(folder, copy);
        }),
        (this._duplicateGroup = function (id, children) {
          let folder = _folders[id] || _folders[`sl_${_name}_${id}`];
          if (!folder) return;
          let copyId = `group_${_groupIndex + 1}`;
          getGroup(copyId),
            copyFolderProps(folder, Object.values(_folders).last()),
            children.forEach((childId) => {
              _this._duplicateLayer(childId, copyId);
            });
        }),
        (this._getCinemaConfig = async function () {
          let _cinemaConfig = _config.get("Cinema Config").replace(".json", "");
          return await get(
            Assets.getPath(`assets/geometry/${_cinemaConfig}.json`)
          );
        }),
        (this._applyCinemaConfig = function (id, params) {
          let folder = _folders[id] || _folders[`sl_${_name}_${id}`];
          if (!folder) return;
          let mesh = folder.getAll().filter((sub) => "Mesh" == sub.label)[0];
          if (
            (params.geometry &&
              folder.params.setValue(
                "geometry",
                params.geometry.replace("assets/geometry/", "")
              ),
            ["position", "quaternion", "scale"].forEach((transform) => {
              if (params[transform]) {
                let value = JSON.parse(params[transform]);
                if ("quaternion" == transform) {
                  let quat = new Quaternion().fromArray(value);
                  (value = new Euler()
                    .setFromQuaternion(quat)
                    .toArray()
                    .slice(0, 3)
                    .map((angle) => (180 * angle) / Math.PI)),
                    (transform = "rotation");
                }
                mesh
                  .getAll()
                  .filter((control) => control.label == transform)[0]
                  .force(value);
              }
            }),
            params.visible &&
              "false" === params.visible &&
              !params.geometry &&
              (folder.params.setValue("geometry", "World.PLANE"),
              folder.params.setValue("side", "shader_double_side"),
              !Global.PLAYGROUND))
          ) {
            _meshes[folder.params.get("name")].shader.neverRender = !0;
          }
          params.shader && folder.params.setValue("shader", params.shader);
        }),
        (this.loadedAllLayers = async function () {
          return await _this.ready(), Promise.all(_promises);
        }),
        this.set("breakpoint", (value) => {
          (_this.localBreakpoint = !0), setBreakpoint({ value: value });
        }),
        this.get("breakpoint", (_) => _breakpoint),
        this.get("layers", (_) => _layers),
        this.get("layerCount", (_) => _data.layers),
        (this.onDestroy = function () {
          _this.textures &&
            !_options.persistTextures &&
            _this.textures.forEach((t) => {
              t.destroy && t.destroy();
            });
        }),
        (this.addInitializer = function (callback) {
          _initializers.push(callback);
        }),
        (this._completeInitialization = async function (sync) {
          if (!_initializers.length) return !0;
          for (let i = 0; i < _initializers.length; i++)
            await _initializers[i](sync);
          _initializers.length = 0;
        });
    },
    (_) => {
      (SceneLayout.BREAKPOINT = "sl_breakpoint"),
        (SceneLayout.HOTLOAD_GEOMETRY = "sl_hotload_geom"),
        (SceneLayout.HOTLOAD_SCRIPT = "sl_hotload_script"),
        (SceneLayout.setBreakpoint = function (value) {
          SceneLayout.breakpoint !== value &&
            ((SceneLayout.breakpoint = value),
            Events.emitter._fireEvent(SceneLayout.BREAKPOINT, {
              value: value,
            }));
        });
    }
  ),
  Class(function SceneLayoutGizmo() {
    Inherit(this, Object3D);
    const _this = this;
    var _controls, _update, _attached, _lastVal;
    function findCamera() {
      let camera = World.CAMERA,
        p = _this.group._parent;
      for (; p; )
        p instanceof Scene && p.nuke && (camera = p.nuke.camera),
          (p = p._parent);
      return camera;
    }
    function update() {
      let uil = _attached._cameraUIL || _attached._meshUIL,
        key = "translate" == _controls.getMode() ? "position" : "scale",
        value = _attached[key].toArray();
      (function same(a, b) {
        return !(
          !a ||
          !b ||
          Math.abs(a[0] - b[0]) > Base3D.DIRTY_EPSILON ||
          Math.abs(a[1] - b[1]) > Base3D.DIRTY_EPSILON ||
          Math.abs(a[2] - b[2]) > Base3D.DIRTY_EPSILON
        );
      })(value, _lastVal) ||
        ((_lastVal = value),
        _attached._cameraUIL && "position" == key && (key = "groupPos"),
        uil?.[`forceUpdate${key.toUpperCase()}`]?.(value));
    }
    function startMoving() {
      _update = setInterval(update, 250);
    }
    function stopMoving() {
      clearInterval(_update), update();
    }
    function keyDown(e) {
      document.activeElement.tagName
        .toLowerCase()
        .includes(["textarea", "input"]) ||
        ("." == e.key && _controls.setMode("translate"),
        "/" == e.key && _controls.setMode("scale"),
        ("=" != e.key && "+" != e.key) ||
          (_controls.visible = !_controls.visible));
    }
    function playgroundEvent(camera) {
      camera || ((_controls.visible = !1), (camera = findCamera())),
        (_controls.camera = camera);
    }
    async function nodeFocused(e) {
      if (
        ((_controls.visible = !1),
        "Config" != e.name && e.layoutInstance == _this.parent)
      ) {
        let layer = await _this.parent.getLayer(e.name),
          group = layer.group || layer;
        if (!group || !group.updateMatrixWorld) return;
        _controls.attach(group), (_attached = group), (_controls.visible = !0);
      }
    }
    (this.isGizmo = !0),
      ((_controls = new TransformControls(
        findCamera(),
        World.ELEMENT.div
      )).onChange =
        _controls.onMouseDown =
        _controls.onMouseUp =
        _controls.onObjectChange =
          (e) => {}),
      (_controls.onMouseDown = startMoving),
      (_controls.onMouseUp = stopMoving),
      (_controls.draggingChanged = (e) => {
        let activeControls = Playground.instance().activeControls;
        activeControls && (activeControls.enabled = !e.value);
      }),
      SceneLayoutGizmo.initialized
        ? (_controls.visible = !1)
        : (SceneLayoutGizmo.initialized = !0),
      _this.group.add(_controls),
      AppState.bind("playground_camera_active", playgroundEvent),
      (function addListeners() {
        _this.events.sub(Keyboard.DOWN, keyDown),
          _this.events.sub(UILGraphNode.FOCUSED, nodeFocused);
      })(),
      _this.delayedCall((_) => {
        _controls.camera = findCamera();
      }, 500),
      _this.group.traverse((obj) => {
        obj.isGizmo = !0;
      });
  }),
  Class(function SceneLayoutPreloader(_name) {
    Inherit(this, Component);
    function findMatch(src) {
      if (!src) return !1;
      src = src.trim();
      for (let i = ASSETS.length - 1; i > -1; i--)
        if (ASSETS[i].includes(src)) return !0;
      return !1;
    }
    this.load = function (name) {
      let ext,
        promise = Promise.create(),
        array = [],
        settings_dxt = !!Renderer.extensions.s3tc,
        settings_etc = !!Renderer.extensions.etc1,
        settings_pvrtc = !!Renderer.extensions.pvrtc,
        settings_astc = !!Renderer.extensions.astc;
      settings_dxt
        ? (ext = "dxt")
        : settings_etc
        ? (ext = "astc")
        : settings_pvrtc
        ? (ext = "pvrtc")
        : settings_astc && (ext = "astc");
      let keys = UILStorage.getKeys(),
        i = 0,
        worker = new Render.Worker((_) => {
          let key = keys[i];
          if (!key)
            return worker.stop(), void Promise.all(array).then(promise.resolve);
          if (key.includes(name)) {
            let val = UILStorage.get(key);
            if (!val || !val.includes) return i++;
            if (
              (key.includes("geometry") &&
                ("{" == val.charAt(0) && (val = JSON.parse(val).src),
                val.includes(".json") ||
                  val.includes(".bin") ||
                  (val += ".json"),
                val.includes("assets/") || (val = "assets/geometry/" + val),
                array.push(
                  GeomThread.loadGeometry(Assets.getPath(val), null, !0)
                )),
              val.includes(".json") || val.includes(".bin"))
            )
              val.includes("assets/") || (val = "assets/geometry/" + val),
                findMatch(val.split("assets/")[1]) &&
                  array.push(fetch(Assets.getPath(val)).catch((e) => {}));
            else if (val.includes("src")) {
              let obj = JSON.parse(val),
                src = obj.src;
              if (obj.compressed) {
                let src0 = src.split(".")[0],
                  src1 = src0.split("/");
                src = src0 + "/" + src1[src1.length - 1] + "-" + ext + ".ktx";
              }
              findMatch(src.split("assets/")[1]) &&
                array.push(fetch(Assets.getPath(src)).catch((e) => {}));
            }
          }
          i++;
        }, 1);
      return promise;
    };
  }, "static"),
  Class(function UILGroupBridge() {
    Inherit(this, Component);
    var _map = {};
    function Bridge(name) {
      let store = InputUIL.create(`scenelayout_${name}`, null),
        data = JSON.parse(store.get("data") || "{}");
      void 0 === data.layers && (data.layers = -1),
        void 0 === data.groups && (data.groups = -1),
        (this.layers = new StateArray());
      for (let i = 0, c = data.layers + 1; i < c; i++) {
        let obj = AppState.createLocal(),
          key = `sl_${name}_${i}`;
        (obj.deleted = UILStorage.get(`${key}_deleted`)),
          (obj.visible = !0),
          (obj.parent = UILStorage.get(`${key}_parent`)),
          (obj.name = "layer_" + i),
          this.layers.push(obj),
          obj.bind("deleted", (bool) => {
            UILStorage.set(`${key}_deleted`, bool);
          }),
          obj.bind("parent", (parent) => {
            UILStorage.set(`${key}_parent`, parent);
          }),
          UILStorage.state?.bind(
            `${key}_deleted`,
            (bool) => (obj.deleted = bool)
          ),
          UILStorage.state?.bind(
            `${key}_parent`,
            (parent) => (obj.parent = parent)
          );
      }
      this.groups = new StateArray();
      for (let i = 0, c = data.groups + 1; i < c; i++) {
        let obj = AppState.createLocal(),
          key = `sl_${name}_${i}`;
        (obj.deleted = UILStorage.get(`${key}_deleted`)),
          (obj.visible = !0),
          (obj.name = "group_" + i),
          this.groups.push(obj),
          obj.bind("deleted", (bool) => {
            UILStorage.set(`${key}_deleted`, bool);
          }),
          UILStorage.state?.bind(
            `${key}_deleted`,
            (bool) => (obj.deleted = bool)
          );
      }
      (this.createGroup = function () {
        let obj = AppState.createLocal();
        (obj.deleted = !1),
          (obj.visible = !0),
          (obj.parent = parent),
          (obj.name = "group_" + (data.groups + 1)),
          this.groups.push(obj);
        let index = this.sceneLayout._createGroup();
        (data.groups = index), store.set("data", JSON.stringify(data));
      }),
        (this.createLayer = function (parent) {
          let obj = AppState.createLocal();
          (obj.deleted = !1),
            (obj.visible = !0),
            (obj.parent = parent),
            (obj.name = "layer_"),
            this.layers.push(obj),
            (obj.name = this.sceneLayout._createLayer());
        });
    }
    this.createSceneLayout = this.create = function (name, layout) {
      return (
        _map[name] || (_map[name] = new Bridge(name)),
        layout && (_map[name].sceneLayout = layout),
        _map[name]
      );
    };
  }, "static"),
  Class(
    function Scroll(_object, _params) {
      Inherit(this, Component);
      const _this = this,
        PROHIBITED_ELEMENTS = ["prevent_interactionScroll"];
      (this.overscroll = 0),
        (this.x = 0),
        (this.y = 0),
        (this.max = { x: 0, y: 0 }),
        (this.min = { x: 0, y: 0 }),
        (this.delta = { x: 0, y: 0 }),
        (this.enabled = !0),
        (_this.bounds = null);
      const _scrollTarget = { x: 0, y: 0 },
        _scrollInertia = { x: 0, y: 0 };
      let _axes = ["x", "y"];
      var _lastDelta,
        _deltaChange = 0;
      function checkIfProhibited(element) {
        let el = element;
        for (; el; ) {
          if (el.classList)
            for (let i = 0; i < PROHIBITED_ELEMENTS.length; i++)
              if (el.classList.contains(PROHIBITED_ELEMENTS[i])) return !0;
          el = el.parentNode;
        }
        return !1;
      }
      function loop() {
        _this.object &&
          ((Math.round(_this.object.div.scrollLeft) === Math.round(_this.x) &&
            Math.round(_this.object.div.scrollTop) === Math.round(_this.y)) ||
            ((_this.x = _scrollTarget.x = _this.object.div.scrollLeft),
            (_this.y = _scrollTarget.y = _this.object.div.scrollTop),
            stopInertia())),
          _axes.forEach((axis) => {
            _this.isInertia && (_scrollInertia[axis] *= 0.9),
              _scrollTarget[axis] < 0 &&
                ((_scrollTarget[axis] = Math.lerp(0, _scrollTarget[axis], 0.1)),
                (_this.delta[axis] = 0),
                stopInertia());
            let scale = _this.scale;
            Device.mobile && (scale = _this.touchScale),
              _this.limit &&
                (_scrollTarget[axis] = Math.max(
                  _scrollTarget[axis],
                  _this.min[axis]
                )),
              _this.limit &&
                (_scrollTarget[axis] = Math.min(
                  _scrollTarget[axis],
                  _this.max[axis] / scale
                )),
              (_this.delta[axis] = _this.flag("block")
                ? 0
                : 0.5 * (_scrollTarget[axis] * scale - _this[axis])),
              (_this[axis] += _this.delta[axis]),
              Math.abs(_this.delta[axis]) < 0.01 && (_this.delta[axis] = 0),
              Math.abs(_this[axis]) < 0.001 && (_this[axis] = 0),
              _this.flag("block") &&
                ((_scrollTarget[axis] = 0),
                (_this.delta[axis] = 0),
                (_this[axis] = 0)),
              _this.object &&
                ("x" == axis &&
                  (_this.object.div.scrollLeft = Math.round(_this.x)),
                "y" == axis &&
                  (_this.object.div.scrollTop = Math.round(_this.y)));
          });
      }
      function stopInertia() {
        (_this.isInertia = !1), clearTween(_scrollTarget);
      }
      function edgeScroll(e) {
        let element = document.elementFromPoint(
          Math.clamp(Mouse.x, 0, Stage.width),
          Math.clamp(Mouse.y, 0, Stage.height)
        );
        (element && checkIfProhibited(element)) ||
          (_params.lockMouseX && Mouse.x > Stage.width) ||
          ("touch" === e.pointerType &&
            _this.enabled &&
            (e.preventDefault && e.preventDefault(),
            _axes.forEach((axis) => {
              let dir = axis.toUpperCase(),
                delta = `offset${dir}`,
                diff = (_this[`ieDelta${dir}`] || e[delta]) - e[delta];
              (_scrollTarget[axis] += diff),
                (_scrollInertia[axis] = diff),
                (_this.isInertia = !0),
                (_this[`ieDelta${dir}`] = e[delta]);
            }),
            _this.onUpdate && _this.onUpdate(),
            _this.events.fire(Events.UPDATE, _scrollInertia)));
      }
      function edgeScrollEnd() {
        (_this.ieDeltaX = !1), (_this.ieDeltaY = !1);
      }
      function scroll(e) {
        let element = document.elementFromPoint(
          Math.clamp(Mouse.x, 0, Stage.width),
          Math.clamp(Mouse.y, 0, Stage.height)
        );
        if (element && checkIfProhibited(element)) return;
        if (_params.lockMouseX && Mouse.x > Stage.width) return;
        if (!_this.enabled) return;
        if (!checkBounds(e)) return;
        if (
          (_this.object &&
            _this.limit &&
            e.preventDefault &&
            e.preventDefault(),
          !_this.mouseWheel)
        )
          return;
        stopInertia();
        let newDelta = 0;
        _axes.forEach((axis) => {
          let delta = `delta${axis.toUpperCase()}`;
          if ("mac" == Device.system.os) {
            if ("firefox" == Device.system.browser)
              return 1 === e.deltaMode
                ? ((_scrollTarget[axis] += 4 * e[delta]),
                  (_scrollInertia[axis] = 4 * e[delta]),
                  (_this.isInertia = !0),
                  void (newDelta = _scrollInertia[axis]))
                : void (_scrollTarget[axis] += e[delta]);
            if (Device.system.browser.includes(["chrome", "safari"]))
              return (
                (_scrollTarget[axis] += 0.33 * e[delta]),
                (_scrollInertia[axis] = 0.33 * e[delta]),
                (_this.isInertia = !0),
                void (newDelta = _scrollInertia[axis])
              );
          }
          if ("windows" == Device.system.os) {
            if ("firefox" == Device.system.browser && 1 === e.deltaMode)
              return (
                (_scrollTarget[axis] += 10 * e[delta]),
                (_scrollInertia[axis] = 10 * e[delta]),
                (_this.isInertia = !0),
                void (newDelta = _scrollInertia[axis])
              );
            if (Device.system.browser.includes(["chrome"])) {
              let s = 0.25;
              return (
                (_scrollTarget[axis] += e[delta] * s),
                (_scrollInertia[axis] = e[delta] * s),
                (_this.isInertia = !0),
                void (newDelta = _scrollInertia[axis])
              );
            }
            if ("ie" == Device.system.browser)
              return (
                (_scrollTarget[axis] += e[delta]),
                (_scrollInertia[axis] = e[delta]),
                (_this.isInertia = !0),
                void (newDelta = _scrollInertia[axis])
              );
          }
          (_scrollTarget[axis] += e[delta]), (newDelta = _scrollInertia[axis]);
        }),
          (newDelta = Math.abs(newDelta)),
          newDelta != _lastDelta && _deltaChange++,
          _this.flag("hardBlock") ||
            (_deltaChange > 3
              ? newDelta > _lastDelta && _this.flag("block", !1)
              : newDelta >= _lastDelta && _this.flag("block", !1)),
          (_lastDelta = newDelta),
          _this.onUpdate && _this.onUpdate(),
          _this.events.fire(Events.UPDATE, _scrollInertia),
          _this.events.fire(Scroll.EVENT, e);
      }
      function down(e) {
        if (!_this.enabled) return;
        if (!checkBounds(e)) return;
        let element = document.elementFromPoint(
          Math.clamp(e.x || 0, 0, Stage.width),
          Math.clamp(e.y || 0, 0, Stage.height)
        );
        (element && checkIfProhibited(element)) ||
          (stopInertia(), (_this.isDragging = !0));
      }
      function drag(e) {
        if (!_this.enabled) return;
        if (!checkBounds(e)) return;
        let element = document.elementFromPoint(
          Math.clamp(e.x || 0, 0, Stage.width),
          Math.clamp(e.y || 0, 0, Stage.height)
        );
        (element && checkIfProhibited(element)) ||
          (_axes.forEach((axis) => {
            let newDelta = Math.abs(Mouse.delta[axis]);
            _this.flag("hardBlock") ||
              (newDelta > _lastDelta && _this.flag("block", !1)),
              (_lastDelta = newDelta),
              (_scrollTarget[axis] -= Mouse.delta[axis]);
          }),
          _this.events.fire(Events.UPDATE));
      }
      function up(e) {
        if (!_this.enabled || _this.preventInertia) return;
        if (!checkBounds(e)) return;
        let element = document.elementFromPoint(
          Math.clamp(e.x || 0, 0, Stage.width),
          Math.clamp(e.y || 0, 0, Stage.height)
        );
        if (element && checkIfProhibited(element)) return;
        const m = "android" == Device.system.os ? 35 : 25,
          obj = {};
        _axes.forEach((axis) => {
          obj[axis] = _scrollTarget[axis] - Mouse.delta[axis] * m;
        }),
          tween(_scrollTarget, obj, 2500, "easeOutQuint"),
          (_this.isDragging = !1);
      }
      function onKeyDown({ key: key, shiftKey: shiftKey }) {
        let dst = null;
        switch (key) {
          case "Up":
          case "ArrowUp":
            dst = _scrollTarget.y - 150;
            break;
          case "Down":
          case "ArrowDown":
            dst = _scrollTarget.y + 150;
            break;
          case "Home":
            dst = 0;
            break;
          case "End":
            dst = _this.max.y;
            break;
          case "PageUp":
            dst = _scrollTarget.y - Stage.height;
            break;
          case "PageDown":
            dst = _scrollTarget.y + Stage.height;
            break;
          case " ":
          case "Spacebar":
            onKeyDown(shiftKey ? { key: "PageUp" } : { key: "PageDown" });
        }
        null !== dst && _this.scrollTo(dst, "y", 400, "easeOutCubic");
      }
      function resize() {
        if (!_this.enabled) return;
        if ((stopInertia(), !_this.object)) return;
        const p = {};
        Device.mobile &&
          _axes.forEach(
            (axis) =>
              (p[axis] = _this.max[axis]
                ? _scrollTarget[axis] / _this.max[axis]
                : 0)
          ),
          void 0 === _params.height &&
            (_this.max.y =
              _this.object.div.scrollHeight - _this.object.div.clientHeight),
          void 0 === _params.width &&
            (_this.max.x =
              _this.object.div.scrollWidth - _this.object.div.clientWidth),
          Device.mobile &&
            _axes.forEach(
              (axis) =>
                (_this[axis] = _scrollTarget[axis] = p[axis] * _this.max[axis])
            );
      }
      function checkBounds(e) {
        return (
          !_this.bounds ||
          !(
            e.x / Stage.width > _this.bounds.x.y ||
            e.x / Stage.width < _this.bounds.x.x ||
            e.y / Stage.height > _this.bounds.y.y ||
            e.y / Stage.height < _this.bounds.y.x
          )
        );
      }
      !(function initParams() {
        (_object && _object.div) || ((_params = _object), (_object = null)),
          _params || (_params = {}),
          (_this.object = _object),
          (_this.hitObject = _params.hitObject || _this.object),
          (_this.max.y = _params.height || 0),
          (_this.max.x = _params.width || 0),
          (_this.min.y = _params.overscroll || 0),
          (_this.min.x = _params.overscroll || 0),
          (_this.scale = _params.scale || 1),
          (_this.touchScale = _params.touchScale || 1),
          (_this.isDragging = !1),
          (_this.drag =
            void 0 !== _params.drag ? _params.drag : !!Device.mobile),
          (_this.mouseWheel = !1 !== _params.mouseWheel),
          (_this.limit = "boolean" == typeof _params.limit && _params.limit),
          (_this.bounds = _params.bounds || null),
          (_this.keyboard = _params.keyboard || !1),
          Array.isArray(_params.axes) && (_axes = _params.axes);
      })(),
        _this.object &&
          (function style() {
            _this.object.css({ overflow: "auto" });
          })(),
        (function addHandlers() {
          if (
            (Device.mobile ||
              ("ie" === Device.system.browser &&
                Device.system.browserVersion >= 17 &&
                (document.body.addEventListener("pointermove", edgeScroll, !0),
                document.body.addEventListener("pointerup", edgeScrollEnd, !0)),
              "ie" == Device.system.browser
                ? document.body.addEventListener("wheel", scroll, !0)
                : __window.bind("wheel", scroll),
              _this.keyboard && _this.events.sub(Keyboard.DOWN, onKeyDown)),
            _this.drag)
          ) {
            _this.hitObject &&
              _this.hitObject.bind("touchstart", (e) => {
                let element = document.elementFromPoint(
                  Math.clamp(e.x || 0, 0, Stage.width),
                  Math.clamp(e.y || 0, 0, Stage.height)
                );
                (element && checkIfProhibited(element)) || e.preventDefault();
              });
            let input = _this.hitObject
              ? _this.initClass(Interaction, _this.hitObject)
              : Mouse.input;
            _this.events.sub(input, Interaction.START, down),
              _this.events.sub(input, Interaction.DRAG, drag),
              _this.events.sub(input, Interaction.END, up);
          }
          _this.events.sub(Events.RESIZE, resize);
        })(),
        resize(),
        _this.startRender(loop),
        (this.reset = function () {
          return (
            _this.object &&
              _this.object.div &&
              ((_this.object.div.scrollLeft = _this.x = 0),
              (_this.object.div.scrollTop = _this.y = 0)),
            (_scrollTarget.x = _scrollTarget.y = 0),
            (_scrollInertia.x = _scrollInertia.y = 0),
            stopInertia(),
            this
          );
        }),
        (this.onDestroy = function () {
          __window.unbind("wheel", scroll),
            _this.events.unsub(Keyboard.DOWN, onKeyDown);
        }),
        (this.resize = resize),
        (this.scrollTo = function (
          value,
          axis = "y",
          time = 800,
          ease = "easeInOutCubic"
        ) {
          let values = {};
          return (
            (values[axis] = value), tween(_scrollTarget, values, time, ease)
          );
        }),
        (this.setTarget = function (value, axis = "y") {
          _scrollTarget[axis] = value;
        }),
        (this.blockUntilNewScroll = function () {
          return (
            _this.reset(),
            _this.flag("block", !0),
            _this.flag("hardBlock", !0, 200),
            this
          );
        }),
        (this.stopInertia = stopInertia);
    },
    (_) => {
      var _scroll;
      (Scroll.EVENT = "scroll_event"),
        (Scroll.createUnlimited = Scroll.getUnlimited =
          function (options) {
            return (
              _scroll ||
                (_scroll = new Scroll({ limit: !1, drag: Device.mobile })),
              _scroll
            );
          });
    }
  ),
  Class(function ShaderManager(_unique = "") {
    Inherit(this, Component);
    const _this = this;
    var _globals,
      _key,
      _globalShader,
      _globalDesired,
      _lerp = null,
      _shaders = [],
      _labels = {};
    function loop() {
      _shaders.forEach((item) => {
        let { shader: shader, target: target, uniforms: uniforms } = item;
        null !== _lerp &&
          ShaderUIL.lerpShader(target, shader, _lerp, !0, uniforms);
      });
    }
    function updateGlobal() {
      _globalDesired &&
        _globalShader &&
        copyUniformsTo(_globalDesired, _globalShader);
    }
    function copyUniformsTo(from, to) {
      if (from)
        for (let key in to.uniforms) {
          let fromUniform = from.uniforms[key];
          if (fromUniform) {
            let toUniform = to.uniforms[key];
            "number" == typeof toUniform.value
              ? (toUniform.value = fromUniform.value)
              : toUniform.value?.copy?.(fromUniform.value);
          }
        }
    }
    function updateShader(key, item) {
      let {
          states: states,
          shader: shader,
          previous: previous,
          target: target,
        } = item,
        desired = states[key];
      if (desired)
        if (null !== _lerp) {
          copyUniformsTo(desired, target),
            copyUniformsTo(states[_key] || desired, previous);
        } else
          shader == _globalShader
            ? (_globalDesired = desired)
            : desired?.copyUniformsTo?.(shader, !0);
    }
    (this.registerGlobalUniforms = async function (object) {
      let uil = "ShaderManager_Global" + (_unique ? "_" + _unique : "");
      if (object.uniforms) {
        let shader = object;
        (shader.UILPrefix = uil),
          UILStorage.loaded || (await UILStorage.ready()),
          ShaderUIL.add(shader),
          (_globals = shader.uniforms),
          (_globalShader = shader);
      } else {
        (object = object.uniforms || object), (_globals = object);
        let shader = Utils3D.getTestShader();
        (shader.uniforms = object),
          (shader.UILPrefix = uil),
          UILStorage.loaded || (await UILStorage.ready()),
          ShaderUIL.add(shader);
      }
      for (let key in _globals) _globals[key].ignoreUIL = !0;
      _this.startRender(updateGlobal);
    }),
      (this.applyGlobals = async function (shader) {
        _globals || (await _this.wait(() => _globals));
        for (let key in _globals) _globals[key].ignoreUIL = !0;
        shader.addUniforms(_globals);
      }),
      (this.applyStates = function (shader, group, variations, uniforms) {
        let shaders = {},
          isModifyingGlobal = !1;
        if (
          (shader.shader && (shader = shader.shader),
          shader.uniforms == _globals || shader === _globalShader)
        ) {
          for (let key in shader.uniforms) shader.uniforms[key].ignoreUIL = !1;
          isModifyingGlobal = !0;
        }
        const createClone = (name) => {
          let clone = ShaderUIL.createClone(shader.UILPrefix + name, shader);
          if (Array.isArray(uniforms))
            for (let key in clone.uniforms)
              uniforms.includes(key) || delete clone.uniforms[key];
          let input = ShaderUIL.add(clone, group),
            label = _labels[name] || name;
          input.setLabel(`Shader ${label}`);
          let ignored = [];
          for (let key in clone.uniforms)
            clone.uniforms[key].ignoreUIL ||
              ((clone.uniforms[key].ignoreUIL = !0), ignored.push(key));
          return (
            defer(() => {
              ignored.forEach((key) => {
                clone.uniforms[key].ignoreUIL = !1;
              });
            }),
            clone
          );
        };
        if (Array.isArray(variations))
          variations.forEach((name) => {
            shaders[name] = createClone(name);
          });
        else
          for (let key in variations) {
            let name = variations[key];
            shaders[name] || (shaders[name] = createClone(name)),
              key != name && (shaders[key] = shaders[name]);
          }
        let previous = ShaderUIL.createClone(
            shader.UILPrefix + "previous_target",
            shader,
            null,
            null
          ),
          target = ShaderUIL.createClone(
            shader.UILPrefix + "override_target",
            shader,
            null,
            null
          ),
          original = ShaderUIL.createClone(
            shader.UILPrefix + "original_target",
            shader,
            null,
            null
          );
        for (let key in shader.uniforms) {
          let originalUniform = original.uniforms[key],
            shaderUniform = shader.uniforms[key].value;
          "number" == typeof originalUniform.value
            ? (originalUniform.value = shaderUniform)
            : originalUniform.value?.copy?.(shaderUniform);
        }
        shaders.state_original = original;
        let obj = {
          states: shaders,
          shader: shader,
          previous: previous,
          target: target,
          uniforms: uniforms,
        };
        if (
          (_shaders.push(obj),
          _key && updateShader(_key, obj),
          isModifyingGlobal)
        )
          for (let key in shader.uniforms) shader.uniforms[key].ignoreUIL = !0;
        return shaders;
      }),
      (this.applyStatesLabels = function (labels) {
        _labels = labels;
      }),
      (this.setState = function (key, isTransition = !1) {
        if (isTransition) {
          let currentShader = _globals,
            nextShader = _shaders[0].states[key].uniforms;
          for (let key in nextShader)
            currentShader[key] &&
              (currentShader[key].value?.copy
                ? currentShader[key].value.copy(nextShader[key].value)
                : (currentShader[key].value = nextShader[key].value));
          _shaders.forEach((shader) => {
            updateShader(key, shader);
          });
        } else
          _shaders.forEach((item) => {
            let { states: states, target: target } = item;
            copyUniformsTo(states[key], target);
          });
        _key = key;
      }),
      (this.setLerp = function (lerp) {
        "number" == typeof lerp || lerp || (lerp = null),
          null !== (_lerp = lerp)
            ? _this.startRender(loop)
            : _this.stopRender(loop);
      }),
      (this.createLocal = function (unique) {
        return new ShaderManager(unique);
      }),
      (this.createGlobalShader = function (uniforms) {
        let uilUniforms = {};
        for (let key in uniforms) {
          let uniform = uniforms[key],
            value = uniform.value;
          value.clone && (value = value.clone());
          let uilUniform = { value: value };
          Object.prototype.hasOwnProperty.call(uniform, "ignoreUIL") &&
            (uilUniform.ignoreUIL = uniform.ignoreUIL),
            (uilUniforms[key] = uilUniform);
        }
        let shader = _this.initClass(Shader, "ScreenQuad", uilUniforms),
          promise = this.registerGlobalUniforms(shader);
        return (
          (async () => {
            UILStorage.loaded || (await promise), (_globals = uniforms);
          })(),
          shader
        );
      }),
      (this.copyUniformsTo = copyUniformsTo),
      this.get("key", (_) => _key),
      this.get("state", (_) => _key),
      this.get("shaders", (_) => _shaders);
  }, "static"),
  Class(function ShaderManagerTransition(_nuke, _manager = ShaderManager) {
    Inherit(this, Component);
    const _this = this;
    var _from, _to, _ping;
    function loop() {
      _manager.setState(_to, !0),
        _this.pingPong
          ? _ping
            ? (_nuke.renderer.render(_nuke.scene, _nuke.camera, _this.rt),
              (_nuke.preventNewRender = !0),
              (_ping = !1))
            : ((_nuke.preventNewRender = !1), (_ping = !0))
          : _nuke.renderer.render(_nuke.scene, _nuke.camera, _this.rt),
        _manager.setState(_from, !0);
    }
    function resizeHandler() {
      let width = _nuke.stage.width * _nuke.dpr,
        height = _nuke.stage.height * _nuke.dpr;
      _this.rt.setSize(width, height);
    }
    (this.rt = _nuke.rttBuffer.clone()),
      (this.pingPong = !!GPU.lt(1) || !!GPU.mobileLT(2)),
      _this.onResize(resizeHandler),
      (this.start = function (to) {
        (_from = _manager.state),
          (_to = to),
          _this.startRender(loop, RenderManager.BEFORE_RENDER);
      }),
      (this.stop = function () {
        _this.stopRender(loop, RenderManager.BEFORE_RENDER),
          (_nuke.preventNewRender = !1);
      }),
      (this.setNuke = function (nuke) {
        nuke !== _nuke &&
          (_nuke.preventNewRender && (_nuke.preventNewRender = !1),
          (_nuke = nuke));
      });
  }),
  Class(function Shaders() {
    Inherit(this, Component);
    var _this = this;
    function parseSingleShader(code, fileName) {
      let uniforms = code.split("#!UNIFORMS")[1].split("#!")[0],
        varyings = code.split("#!VARYINGS")[1].split("#!")[0],
        attributes = code.split("#!ATTRIBUTES")[1].split("#!")[0];
      for (; code.includes("#!SHADER"); ) {
        let split = (code = code.slice(code.indexOf("#!SHADER"))).split(
            "#!SHADER"
          )[1],
          br = split.indexOf("\n"),
          name = split.slice(0, br).split(": ")[1];
        name.slice(0, 6).includes("Vertex") &&
          (name = fileName.split(".")[0] + ".vs"),
          name.slice(0, 8).includes("Fragment") &&
            (name = fileName.split(".")[0] + ".fs");
        let glsl = split.slice(br);
        glsl = name.includes(".vs")
          ? attributes + uniforms + varyings + glsl
          : uniforms + varyings + glsl;
        let splitName = name.split(".");
        (_this[splitName[0] + (splitName[1].includes("vs") ? ".vs" : ".fs")] =
          glsl),
          (code = code.replace("#!SHADER", "$"));
      }
    }
    function parseCompiled(shaders) {
      var split = shaders.split("{@}");
      split.shift();
      for (var i = 0; i < split.length; i += 2) {
        var name = split[i],
          text = split[i + 1];
        text.includes("#!UNIFORMS")
          ? parseSingleShader(text, name)
          : (_this[name] = text);
      }
    }
    function parseRequirements() {
      for (var key in _this) {
        var obj = _this[key];
        "string" == typeof obj && (_this[key] = require(obj));
      }
    }
    function require(shader) {
      if (!shader.includes("require")) return shader;
      for (
        shader = shader.replace(/# require/g, "#require");
        shader.includes("#require");

      ) {
        var name = shader.split("#require(")[1].split(")")[0];
        if (((name = name.replace(/ /g, "")), !_this[name]))
          throw (
            "Shader required " +
            name +
            ", but not found in compiled shaders.\n" +
            shader
          );
        shader = shader.replace("#require(" + name + ")", _this[name]);
      }
      return shader;
    }
    (this.parse = function (code, file) {
      code.includes("{@}")
        ? (parseCompiled(code), parseRequirements())
        : ((file = (file = file.split("/"))[file.length - 1]),
          (_this[file] = code)),
        (_this.shadersParsed = !0);
    }),
      (this.parseSingle = parseSingleShader),
      (this.onReady = this.ready =
        function (callback) {
          let promise = Promise.create();
          return (
            callback && promise.then(callback),
            _this.wait(() => promise.resolve(), _this, "shadersParsed"),
            promise
          );
        }),
      (this.getShader = function (string) {
        _this.FALLBACKS &&
          _this.FALLBACKS[string] &&
          (string = _this.FALLBACKS[string]);
        var code = _this[string];
        if (!code) throw `No shader ${string} found`;
        for (; code.includes("#test "); )
          try {
            var test = code.split("#test ")[1],
              name = test.split("\n")[0],
              glsl = code.split("#test " + name + "\n")[1].split("#endtest")[0];
            eval(name) || (code = code.replace(glsl, "")),
              (code = code.replace("#test " + name + "\n", "")),
              (code = code.replace("#endtest", ""));
          } catch (e) {
            throw "Error parsing test :: " + string;
          }
        return code;
      });
  }, "static"),
  Class(
    function SplitText(
      _element,
      _options = {
        lineThreshold: 0.2,
        type: "lines",
        asHydraObject: !0,
        noAriaLabel: !1,
        noBalance: !1,
        balanceRatio: 1,
      }
    ) {
      Inherit(this, Component);
      const _this = this;
      if (
        ((_this.isSplit = !1),
        (_this.options = {}),
        (_this.chars = []),
        (_this.words = []),
        (_this.lines = []),
        (_this.originals = []),
        (_this.ariaLabel = []),
        "object" == typeof _element && !_element.div && !_element.children)
      ) {
        let element = _element.element;
        for (const key in _options)
          _options[key] = _element[key] || _options[key];
        (_element = element), (_this.isHydraX = !0);
      }
      function split() {
        _this.isSplit && revert();
        const by = (_this.options.type || "lines")
            .split(",")
            .map((s) => s.trim()),
          byLines = ~by.indexOf("lines"),
          byWords = ~by.indexOf("words"),
          byChars = ~by.indexOf("chars");
        return (
          _this.elements.forEach((element, i) => {
            element instanceof HydraObject && (element = element.div),
              (_this.originals[i] = element.innerHTML),
              (element.innerHTML = element.innerHTML
                .split(/\u200b/)
                .join("<wbr>")),
              byLines &&
                (function balance(el) {
                  _this.lineParents = [];
                  const recursiveBalance = (e) => {
                    e.normalize(),
                      toArray(e.childNodes).forEach((next) => {
                        next.normalize(),
                          (next.__lineParent =
                            next.tagName &&
                            next.hasChildNodes() &&
                            SplitText.BLOCK_TAGS.includes(next.tagName)),
                          next.__lineParent &&
                            ((next.__idx = null),
                            toArray(next.childNodes).find(
                              (node) =>
                                3 === node.nodeType &&
                                node.textContent.replace(/\s+/g, " ").trim()
                                  .length > 0
                            ) &&
                              ((next.__lines = [createLine()]),
                              _this.lineParents.push(next))),
                          recursiveBalance(next);
                      });
                  };
                  recursiveBalance(el),
                    _this.lineParents.length ||
                      (_this.lineParents.push(el),
                      (el.__lines = [createLine()]),
                      (el.__lineParent = !0),
                      (el.__idx = null));
                  _this.options.noBalance ||
                    _this.lineParents.forEach((el) =>
                      BalanceText.relayout(el, _this.options.balanceRatio)
                    );
                })(element),
              (byWords || byLines || byChars) &&
                (_this.words.push(...splitElement(element, "word", /\s+/, !0)),
                byLines &&
                  (!(function detectLinesTop(el, words, lineThreshold) {
                    let lineOffsetY = -999;
                    const computedStyle = window.getComputedStyle(el),
                      threshold =
                        parseFloat(computedStyle.fontSize || 0) * lineThreshold,
                      result = words.map((w) => {
                        const top = Math.round(w.offsetTop);
                        return (
                          Math.abs(top - lineOffsetY) > threshold &&
                            (lineOffsetY = top),
                          (w.__top = lineOffsetY),
                          w.__top
                        );
                      });
                    return [...new Set(result)];
                  })(element, _this.words, _this.options.lineThreshold),
                  (function attachBr(_, words) {
                    let prevLineParent,
                      prevTop = words[0]?.__top || 0;
                    words.forEach((w, i) => {
                      const prevWord = words[i - 1];
                      if (prevTop !== w.__top && prevWord) {
                        const lineParent = findLineParent(w);
                        lineParent.__idx || (lineParent.__idx = `l${w.__top}`),
                          isPrevBr(w.parentElement) ||
                            isPrevBr(w) ||
                            (function isNextBr(el) {
                              return "BR" === el.nextElementSibling?.tagName;
                            })(prevWord) ||
                            (prevLineParent &&
                              prevLineParent?.__idx !== lineParent.__idx) ||
                            w.insertAdjacentHTML("beforebegin", "<br>"),
                          (prevLineParent = lineParent),
                          (prevTop = w.__top);
                      }
                    });
                  })(0, _this.words),
                  splitBr(element),
                  (function replaceWords(element) {
                    Array.from(element.querySelectorAll(".word")).forEach(
                      (el, i) => el.replaceWith(_this.words[i])
                    );
                  })(element),
                  _this.lines.push(
                    ...(function splitLines(el) {
                      const lines = [];
                      findAllBr(el, !1).forEach((br) => {
                        const lineParent = findLineParent(br),
                          line = createLine();
                        (line.__isLine = !0), lineParent?.__lines?.push(line);
                      });
                      let globalLineIndex = 0;
                      return (
                        _this.lineParents.forEach((lp) => {
                          let lineIndex = 0;
                          toArray(lp.childNodes).forEach((next) => {
                            "BR" === next.tagName
                              ? (globalLineIndex++, lineIndex++, next.remove())
                              : (lp.__lines[lineIndex].appendChild(next),
                                toArray(next.childNodes).forEach(
                                  (el) => (el.__line = globalLineIndex)
                                ),
                                (next.__line = globalLineIndex));
                          }),
                            lp.__lines.forEach((line) => lp.appendChild(line)),
                            lines.push(...lp.__lines);
                        }),
                        lines
                      );
                    })(element)
                  )),
                byChars &&
                  _this.words.forEach((w) =>
                    _this.chars.push(...splitElement(w, "char", "", !1))
                  )),
              _this.options.asHydraObject &&
                ((_this.lines = _this.lines.map((l) => $(l))),
                (_this.words = _this.words.map((w) => $(w))),
                (_this.chars = _this.chars.map((c) => $(c)))),
              _this.options.noAriaLabel ||
                element.setAttribute("aria-label", _this.ariaLabel.join(" "));
          }),
          (_this.isSplit = !0),
          _this
        );
      }
      function revert() {
        0 !== _this.originals.length &&
          (_this.elements.forEach(
            (el, i) => (el.innerHTML = _this.originals[i])
          ),
          [
            _this.lines,
            _this.words,
            _this.chars,
            _this.ariaLabel,
            _this.originals,
          ].forEach((arr) => (arr.length = 0)),
          (_this.isSplit = !1));
      }
      function findAllBr(el, onlyNew = !0) {
        const brs = [];
        return (
          (function findBr(e) {
            e.normalize(),
              toArray(e.childNodes).forEach((next) => {
                "BR" !== next.tagName || (onlyNew && next.__newBR)
                  ? findBr(next)
                  : brs.push(next);
              });
          })(el),
          brs
        );
      }
      function splitBr(el) {
        let j = 0;
        const brs = findAllBr(el);
        for (; j < brs.length; ) {
          let i = 0,
            parent = brs[j++].parentElement;
          if (!parent) return splitBr(el);
          for (; !parent.__lineParent; ) {
            if (i++ >= 100) return;
            if (!parent.parentElement) return splitBr(el);
            const cloneInnerHTML = parent.innerHTML,
              parentClone = parent.cloneNode(),
              parentTagName = parentClone.tagName.toLowerCase(),
              cloneOuterHTML = parentClone.outerHTML
                .split(`</${parentTagName}>`)
                .join(""),
              newInnerHTML = cloneInnerHTML
                .split(/<br\b[^>]*>/)
                .join(`</${parentTagName}><br>${cloneOuterHTML}`);
            (parent = parent.parentElement),
              (parent.innerHTML = parent.innerHTML.replace(
                cloneInnerHTML,
                newInnerHTML
              )),
              toArray(parent.childNodes)
                .filter((child) => "BR" === child.tagName)
                .forEach((child) => (child.__newBR = !0));
          }
        }
      }
      function isPrevBr(el) {
        return "BR" === el.previousElementSibling?.tagName;
      }
      function findLineParent(el) {
        let parent = el.parentElement,
          found = !1;
        for (; !found; )
          parent.__lineParent && (found = parent),
            (parent = parent.parentElement);
        return found;
      }
      function splitElement(el, key, splitOn, preserveWhitespace) {
        el.normalize();
        const elements = [],
          F = document.createDocumentFragment(),
          allElements = [];
        return (
          toArray(el.childNodes).forEach((next) => {
            if (next.tagName && !next.hasChildNodes())
              return allElements.push(next);
            next.childNodes.length
              ? (allElements.push(next),
                elements.push(
                  ...splitElement(next, key, splitOn, preserveWhitespace)
                ))
              : (function handleRawElement(
                  parentEl,
                  el,
                  key,
                  splitOn,
                  preserveWhitespace,
                  elements,
                  allElements
                ) {
                  const wholeText = el.wholeText || "",
                    contents = wholeText.trim(),
                    nonBrakingSpaceChar = String.fromCharCode(160);
                  if (contents.length) {
                    " " === wholeText[0] &&
                      allElements.push(document.createTextNode(" "));
                    const words = contents.split(splitOn);
                    for (let i = 0; i < words.length; i++) {
                      let splitText = words[i];
                      i &&
                        preserveWhitespace &&
                        allElements.push(document.createTextNode(" ")),
                        contents.charAt(
                          contents.indexOf(splitText) + splitText.length
                        ) === nonBrakingSpaceChar &&
                          (splitText = splitText
                            .concat(nonBrakingSpaceChar)
                            .concat(words[++i]));
                      const splitEl = createElement(parentEl, key, splitText);
                      elements.push(splitEl), allElements.push(splitEl);
                    }
                    " " === wholeText[wholeText.length - 1] &&
                      allElements.push(document.createTextNode(" "));
                  }
                })(
                  F,
                  next,
                  key,
                  splitOn,
                  preserveWhitespace,
                  elements,
                  allElements
                );
          }),
          allElements.forEach((e) => F.appendChild(e)),
          (el.innerHTML = ""),
          el.appendChild(F),
          elements
        );
      }
      function createLine(parent) {
        const line = document.createElement("span");
        return (
          line.style.setProperty("display", "block"),
          (line.className = "line"),
          line.setAttribute("aria-hidden", !0),
          parent ? parent.appendChild(line) : line
        );
      }
      function createElement(parent, key, text) {
        const el = document.createElement("span");
        return (
          el.style.setProperty("display", "inline-block"),
          (el.className = key),
          (el.textContent = text),
          el.setAttribute("aria-hidden", !0),
          "word" === key && _this.ariaLabel.push(text),
          parent.appendChild(el)
        );
      }
      function toArray(e, parent) {
        return e && 0 !== e.length
          ? e.nodeName
            ? [e]
            : [].slice.call(
                e[0].nodeName ? e : (parent || document).querySelectorAll(e)
              )
          : [];
      }
      !(async function () {
        _this.isHydraX &&
          (await _this.wait(
            () =>
              void 0 !== _element.div.innerText &&
              _element.div.innerText.length &&
              !_element.div.innerText.includes("@[")
          )),
          _element instanceof HydraObject && (_element = _element.div),
          (_this.elements = toArray(_element)),
          (_this.options = _options),
          (_this.options.lineThreshold =
            "number" == typeof _this.options.lineThreshold
              ? _this.options.lineThreshold
              : 0.2),
          (_this.options.asHydraObject =
            "boolean" != typeof _this.options.asHydraObject ||
            _this.options.asHydraObject),
          (_this.options.noAriaLabel =
            "boolean" == typeof _this.options.noAriaLabel &&
            _this.options.noAriaLabel),
          (_this.options.noBalance =
            "boolean" == typeof _this.options.noBalance &&
            _this.options.noBalance),
          split();
      })(),
        (_this.split = split),
        (_this.revert = revert),
        (_this.ready = function () {
          return _this.wait("isSplit");
        });
    },
    (_) => {
      SplitText.BLOCK_TAGS = [
        "DIV",
        "H1",
        "H2",
        "H3",
        "H4",
        "H5",
        "H6",
        "P",
        "UL",
        "OL",
        "LI",
      ];
      const promise = Promise.create();
      SplitText.isFontReady = function () {
        return document.fonts.ready.then(promise.resolve), promise;
      };
    }
  ),
  Class(function StyleUtil() {
    Inherit(this, Component);
    const _this = this;
    function convertSize(size) {
      return "string" == typeof size && _this.breakpoints[size]
        ? _this.breakpoints[size]
        : size;
    }
    function fluid(property, obj, dimension = "width") {
      if (Object.keys(obj).length < 2)
        return console.log("Requires at least 2 values");
      const list = [];
      for (const i in obj)
        list.push({ breakpoint: convertSize(i), value: obj[i] });
      list.sort((a, b) => a.breakpoint - b.breakpoint);
      const first = list[0],
        last = list[list.length - 1];
      let output = `${property}: ${first.value}px;`;
      for (let i = 0; i < list.length - 1; i++) {
        const config1 = list[i],
          config2 = list[i + 1],
          m =
            (config2.value - config1.value) /
            (config2.breakpoint - config1.breakpoint);
        let b = config1.value - m * config1.breakpoint,
          sign = "+";
        b < 0 && ((sign = "-"), (b = Math.abs(b))),
          (output += `\n                @media (min-${dimension}: ${
            config1.breakpoint
          }px) {\n                    ${property}: calc(${100 * m}${
            "width" === dimension ? "vw" : "vh"
          } ${sign} ${b}px);\n                }\n            `);
      }
      return (
        (output += `\n            @media (min-${dimension}: ${last.breakpoint}px) {\n                ${property}: ${last.value}px;\n            }\n        `),
        output
      );
    }
    (this.breakpoints = {
      xxs: 320,
      mob: 375,
      tablet: 768,
      m: 960,
      l: 1024,
      xl: 1280,
      xxl: 1440,
      xxxl: 1920,
      xxxxl: 2048,
    }),
      (this.spacer = { m: { mob: 10, xl: 25 }, xl: { mob: 50, xxl: 150 } }),
      (this.fluid = fluid),
      (this.spacing = function spacing(property, size) {
        if (!_this.spacer[size]) return console.log("size not found");
        if ("padding" === property) {
          let output = "";
          return (
            (output += fluid("padding-top", _this.spacer[size])),
            (output += fluid("padding-right", _this.spacer[size])),
            (output += fluid("padding-bottom", _this.spacer[size])),
            (output += fluid("padding-left", _this.spacer[size])),
            output
          );
        }
        if ("margin" === property) {
          let output = "";
          return (
            (output += fluid("margin-top", _this.spacer[size])),
            (output += fluid("margin-right", _this.spacer[size])),
            (output += fluid("margin-bottom", _this.spacer[size])),
            (output += fluid("margin-left", _this.spacer[size])),
            output
          );
        }
        return fluid(property, _this.spacer[size]);
      }),
      (this.larger = function larger(size, style, dimension = "width") {
        return `\n            @media (min-${dimension}: ${convertSize(
          size
        )}px) {\n                ${style}\n            }\n        `;
      }),
      (this.smaller = function smaller(size, style, dimension = "width") {
        return `\n            @media (max-${dimension}: ${
          convertSize(size) - 1
        }px) {\n                ${style}\n            }\n        `;
      }),
      (this.between = function between(min, max, style, dimension = "width") {
        return `\n            @media (min-${dimension}: ${convertSize(
          min
        )}px) and (max-${dimension}: ${convertSize(
          max
        )}px) {\n                ${style}\n            }\n        `;
      }),
      (this.rtl = function rtl(style) {
        return `\n            html[dir='rtl'] & {\n                ${style}\n            }\n        `;
      });
  }, "static"),
  Class(function UIL() {
    Inherit(this, Component);
    const _this = this;
    let _style,
      $el,
      _ui = {};
    Hydra.ready(async (_) => {
      if (
        !Utils.query("editMode") &&
        !(
          Hydra.LOCAL &&
          window.Platform &&
          window.Platform.isDreamPlatform &&
          Utils.query("uil")
        ) &&
        (!Hydra.LOCAL ||
          Device.mobile ||
          window._BUILT_ ||
          (!Utils.query("uil") && !Device.detect("hydra")))
      )
        return (function doNotLoad() {
          Hydra.LOCAL &&
            Utils.query("remoteUIL") &&
            (_this.sidebar = _this.global = new UILPanel("null"));
        })();
      !(function init() {
        (function initContainer() {
          ($el = $("UIL")),
            $el
              .css({ position: "fixed", contain: "strict", top: 0 })
              .size("100%", "100%")
              .mouseEnabled(!1),
            document.body.insertAdjacentElement("beforeend", $el.div),
            $el.setZ(1e5);
        })(),
          (function initStyle() {
            let initial =
                "\n            .UIL ::-webkit-scrollbar { width:2px; }\n            .UIL ::-webkit-scrollbar-track { background:#161616; }\n            .UIL ::-webkit-scrollbar-thumb { background:#37A1EF; }\n        ",
              style = document.head.appendChild(
                document.createElement("style")
              );
            (style.type = "text/css"),
              (style.id = "uil-style"),
              style.appendChild(document.createTextNode(initial)),
              (_style = style);
          })(),
          (function initSidebar() {
            _this.add(new UILPanel("sidebar")),
              _this.add(new UILPanel("global", { side: "left" }));
          })(),
          (function initGraph() {
            if (!_this.sidebar) return;
            let parent = _ui.sidebar.element.div;
            parent.insertBefore(
              UILGraph.instance().element.div,
              parent.firstChild
            );
          })();
      })(),
        (_this.loaded = !0);
    }),
      (this.ready = function () {
        return _this.wait(_this, "loaded");
      }),
      (this.add = function (panel) {
        return (
          (_ui[panel.id] = panel),
          (_this[panel.id] = panel),
          $el.add(panel),
          _this
        );
      }),
      (this.remove = function (id) {
        let $panel = _ui[id];
        return (
          $panel.eliminate && $panel.eliminate(),
          $panel.destroy(),
          delete _ui[id],
          delete _this[id],
          _this
        );
      }),
      (this.find = function (id) {
        return Object.values(_ui).reduce(
          (acc, el) => acc.concat(el.find(id)),
          []
        );
      }),
      (this.enableSorting = function (id, enable) {
        let el = _this.find(id)[0];
        return el && el.enableSorting && el.enableSorting(enable), _this;
      }),
      (this.addCSS = function (control, style) {
        if (control.styled) return;
        let node = document.createTextNode(style);
        return _style && _style.appendChild(node), (control.styled = !0), _this;
      }),
      (this.REORDER = "uil_reorder");
  }, "static"),
  Class(function CameraUIL() {
    (this.UPDATE = "camera_uil_update"),
      (this.add = function (light, group) {
        return new CameraUILConfig(
          light,
          null === group ? null : group || UIL.global
        );
      });
  }, "static"),
  Class(function CameraUILConfig(_camera, _uil) {
    const _this = this;
    if (!_camera.prefix) throw "camera.prefix required when using MeshUIL";
    var prefix = "CAMERA_" + _camera.prefix,
      _group = _uil ? createFolder() : null,
      _dynamicFOVCallback = null;
    function createFolder() {
      if (!UIL.sidebar) return null;
      let folder = new UILFolder(prefix, { label: _camera.prefix, closed: !0 });
      return _uil.add(folder), folder;
    }
    function initFOV(key) {
      let initValue =
        UILStorage.get(`${prefix}${key}`) || _camera.camera.fov || 9999;
      if (_group) {
        let number = new UILControlNumber(`${prefix}${key}`, {
          label: key,
          value: initValue,
          step: 0.05,
        });
        number.onFinishChange((e) => {
          _group &&
            (Events.emitter._fireEvent(CameraUIL.UPDATE, {
              prefix: prefix,
              key: key,
              val: e,
              fov: !0,
              group: _this,
            }),
            _this["tweenUIL_" + key]?.(e)),
            _camera.setFOV(e),
            UILStorage.set(`${prefix}${key}`, e);
        }),
          _group.add(number);
      }
      defer((_) => {
        _camera.setFOV(initValue);
      });
    }
    function initVec(key) {
      let initValue =
        UILStorage.get(`${prefix}${key}`) || _camera[key]?.toArray();
      if (initValue) {
        if (_group) {
          let vector = new UILControlVector(`${prefix}${key}`, {
            label: key,
            value: initValue,
            step: 0.05,
          });
          vector.onChange((e) => {
            _group &&
              (Events.emitter._fireEvent(CameraUIL.UPDATE, {
                prefix: prefix,
                key: key,
                val: e,
                vec: !0,
                group: _this,
              }),
              _this["tweenUIL_" + key]?.(e)),
              _camera[key].fromArray(e);
          }),
            vector.onFinishChange((e) => UILStorage.set(`${prefix}${key}`, e)),
            _group.add(vector),
            (_this["forceUpdate" + key.toUpperCase()] = (_) => {
              let val = _camera[key].toArray();
              _this["tweenUIL_" + key]
                ? _this["tweenUIL_" + key](val)
                : vector.force(_camera[key].toArray(), !0);
            });
        }
        _camera[key].fromArray(initValue);
      }
    }
    function initNumber(key) {
      let initValue =
        UILStorage.get(`${prefix}${key}`) ||
        (void 0 === _camera[key] ? 9999 : _camera[key]);
      if (_group) {
        let number = new UILControlNumber(`${prefix}${key}`, {
          label: key,
          value: initValue,
          step: 0.05,
        });
        number.onChange((e) => {
          (_camera[key] = e),
            _group &&
              (Events.emitter._fireEvent(CameraUIL.UPDATE, {
                prefix: prefix,
                key: key,
                val: e,
                number: !0,
                group: _this,
              }),
              _this["tweenUIL_" + key]?.(e));
        }),
          number.onFinishChange((e) => UILStorage.set(`${prefix}${key}`, e)),
          _group.add(number);
      }
      _camera[key] = initValue;
    }
    function initRotation(key, applyValue) {
      let toRadians = (array) =>
          array
            ? ((array.length = 3), array.map((x) => Math.radians(x)))
            : [0, 0, 0],
        initValue = toRadians(UILStorage.get(`${prefix}${key}`));
      if (_group) {
        let vector = new UILControlVector(`${prefix}${key}`, {
          label: key,
          value:
            ((array = initValue),
            array
              ? ((array.length = 3), array.map((x) => Math.degrees(x)))
              : [0, 0, 0]),
        });
        vector.onChange((e) => {
          _group &&
            (Events.emitter._fireEvent(CameraUIL.UPDATE, {
              prefix: prefix,
              key: key,
              val: toRadians(e),
              rotation: !0,
              group: _this,
            }),
            _this["tweenUIL_" + key]?.(toRadians(e))),
            applyValue(toRadians(e), key);
        }),
          vector.onFinishChange((e) => UILStorage.set(`${prefix}${key}`, e)),
          _group.add(vector);
      }
      var array;
      applyValue(initValue, key);
    }
    function initDynamicFOV(key) {
      let defaultCode = "",
        code = UILStorage.get(`${prefix}${key}Code`) || defaultCode,
        evalCode = (value) => {
          let method = value.includes("return")
            ? `(function(){ return function getFOV() { ${value}}})()`
            : `(function(){ return function getFOV() { return ${value}}})()`;
          _camera._getDynamicFOV = eval(method);
        },
        editCode = (_) => {
          let editor = new UILExternalEditor(`${prefix}${key}`, 400, 900);
          editor.setCode(code, "c"),
            (editor.onSave = (value) => {
              UILStorage.set(`${prefix}${key}Code`, value),
                evalCode(value),
                (code = value),
                _camera.dynamicFOV();
            });
        },
        btn = new UILControlButton("btn", {
          actions: [{ title: "Dynamic FOV", callback: editCode }],
          hideLabel: !0,
        });
      _group && _group.add(btn),
        defer((_) => {
          evalCode(code),
            (_camera.dynamicFOV = (_) => {
              if (_camera.camera.isOrthographicCamera) return;
              let fov = _camera._getDynamicFOV?.() || _camera.camera.fov;
              if (isNaN(fov))
                return console.warn(
                  `${prefix} Dynamic FOV requires a float value`
                );
              _camera.setFOV(fov);
            }),
            _camera.onResize((_) => _camera.dynamicFOV());
        });
    }
    function initType() {
      let initValue = UILStorage.get(`${prefix}type`) || "perspective";
      if (_group) {
        let control = new UILControlSelect(`${prefix}type`, {
          label: "Type",
          value: initValue,
          options: [
            { label: "Perspective", value: "perspective" },
            { label: "Orthographic", value: "orthographic" },
          ],
        });
        control.onChange((e) => {
          "orthographic" === e
            ? _camera.useOrthographic()
            : _camera.usePerspective(),
            _group &&
              Events.emitter._fireEvent(CameraUIL.UPDATE, {
                prefix: prefix,
                key: "type",
                val: e,
                type: !0,
                group: _this,
              });
        }),
          control.onFinishChange((e) => UILStorage.set(`${prefix}type`, e)),
          _group.add(control);
      }
      "orthographic" === initValue && _camera.useOrthographic();
    }
    function addListeners() {
      Events.emitter._addEvent(CameraUIL.UPDATE, update, _this);
    }
    function update(e) {
      e.prefix == prefix &&
        e.group != _this &&
        (e.fov && _camera.setFOV(e.val),
        e.number && (_camera[e.key] = e.val),
        e.rotation && _camera.group[e.key].fromArray(e.val),
        e.vec && _camera[e.key].fromArray(e.val));
    }
    initType(),
      _camera.position && initVec("position"),
      _camera.group &&
        ((_camera.groupPos = _camera.group.position),
        initVec("groupPos"),
        initRotation("rotation", (value, key) => {
          _camera.group[key].fromArray(value);
        })),
      initFOV("fov"),
      initNumber("zoom"),
      initNumber("near"),
      initNumber("far"),
      _camera.moveXY &&
        (initVec("moveXY"),
        initVec("lookAt"),
        initRotation("cameraRotation", (value, key) => {
          _camera[key].fromArray(value);
        }),
        initVec("viewportFocus"),
        initNumber("lerpSpeed"),
        initNumber("lerpSpeed2"),
        initNumber("deltaRotate"),
        initNumber("deltaLerp"),
        initNumber("wobbleSpeed"),
        initNumber("wobbleStrength"),
        initNumber("wobbleZ")),
      initDynamicFOV("dynamicFOV"),
      _group && addListeners(),
      (this.setLabel = function (name) {
        _group && _group.setLabel(name);
      });
  }),
  Class(function InputUIL() {
    (this.UPDATE = "inputUil_Update"),
      (this.create = function (name, group, decoupled) {
        return new InputUILConfig(
          name,
          null === group ? null : group || UIL.global,
          decoupled
        );
      });
  }, "static"),
  Class(function InputUILConfig(_name, _uil, _decoupled, _slim) {
    var _cache,
      _this = this;
    const prefix = "INPUT_" + _name;
    var _group = _uil
        ? (function createFolder() {
            if (!UIL.sidebar) return null;
            let folder = new UILFolder(_name, { closed: !0 });
            _decoupled ||
              (_uil.add(folder), _uil == UIL.sidebar && folder.hide());
            return folder;
          })()
        : null,
      _fields = _uil ? {} : null;
    function externalUpdate(e) {
      e.prefix == prefix &&
        e.group != _this &&
        (UILStorage.set(`${prefix}_${e.key}`, e.value),
        _this.onUpdate && _this.onUpdate(e.key));
    }
    (_this.group = _group),
      _uil &&
        (function addListeners() {
          Events.emitter._addEvent(InputUIL.UPDATE, externalUpdate, _this);
        })(),
      (this.get = function (key) {
        if (_cache && void 0 !== _cache[key]) return _cache[key];
        let val = UILStorage.get(`${prefix}_${key}`);
        return "boolean" == typeof val
          ? val
          : val && "" != val
          ? "true" === val ||
            ("false" !== val &&
              (val.charAt && "[" == val.charAt(0)
                ? JSON.parse(val)
                : (UIL.global ||
                    (_cache || (_cache = {}),
                    _cache[key] || (_cache[key] = val)),
                  val)))
          : void 0;
      }),
      (this.getFilePath = function (key) {
        let data = this.get(key);
        return "{" === data?.charAt(0)
          ? ((data = JSON.parse(data)),
            data.relative.includes(".") ? data.relative : data.src)
          : data;
      }),
      (this.getNumber = function (key) {
        let number = Number(this.get(key));
        return isNaN(number) && (number = 0), number;
      }),
      _slim ||
        ((this.add = function (
          key,
          initValue,
          uil = window.UILControlText,
          options,
          params = {}
        ) {
          if (!_group || "hidden" == initValue || !UIL.sidebar) return this;
          let value = UILStorage.get(`${prefix}_${key}`);
          if (
            ("true" === value && (value = !0),
            "false" === value && (value = !1),
            uil == UILControlVector &&
              "string" == typeof value &&
              (value = JSON.parse(value)),
            void 0 === value && (value = initValue),
            "string" == typeof value &&
              (uil == UILControlImage || uil == UILControlFile))
          )
            try {
              value = JSON.parse(value);
            } catch (e) {}
          let change = (val, fromInit) => {
            (val = "string" == typeof val ? val : JSON.stringify(val)),
              UILStorage.set(`${prefix}_${key}`, val),
              _this.onUpdate && _this.onUpdate(key, val),
              fromInit ||
                Events.emitter._fireEvent(InputUIL.UPDATE, {
                  prefix: prefix,
                  key: key,
                  value: val,
                  group: _this,
                });
          };
          ("string" != typeof initValue &&
            "number" != typeof initValue &&
            uil != UILControlVector) ||
            UILStorage.get(`${prefix}_${key}`) ||
            change(initValue, !0);
          let opts = Utils.mergeObject(params, {
            label: key,
            value: value,
            options: options,
          });
          uil == window.UILControlButton && (opts = options);
          let config = new uil(`${prefix}_${key}`, opts);
          return (
            config.onFinishChange(change),
            (uil != UILControlVector && uil != UILControlRange) ||
              config.onChange(change),
            _group.add(config),
            (_fields[key] = config),
            this
          );
        }),
        (this.addToggle = function (key, initValue) {
          return UIL.sidebar
            ? this.add(key, initValue, UILControlCheckbox)
            : this;
        }),
        (this.addSelect = function (key, options) {
          return UIL.sidebar
            ? this.add(key, null, UILControlSelect, options)
            : this;
        }),
        (this.addImage = function (key, options) {
          return UIL.sidebar
            ? this.add(key, null, UILControlImage, null, options)
            : this;
        }),
        (this.addFile = function (key, options) {
          if (!UIL.sidebar) return this;
          let existing = this.get(key);
          return existing?.length > 3 && !existing.includes("{")
            ? this.add(key)
            : this.add(key, null, UILControlFile, null, options);
        }),
        (this.addRange = function (key, initValue, options) {
          return UIL.sidebar
            ? this.add(key, initValue, UILControlRange, null, options)
            : this;
        }),
        (this.addNumber = function (key, initValue, step) {
          return UIL.sidebar
            ? this.add(key, initValue, UILControlNumber, null, { step: step })
            : this;
        }),
        (this.addColor = function (key, initValue = new Color()) {
          return UIL.sidebar
            ? this.add(key, initValue.getHexString(), UILControlColor)
            : this;
        }),
        (this.addTextarea = function (key, initValue) {
          return UIL.sidebar
            ? this.add(key, initValue, UILControlTextarea, null, {
                monospace: !0,
                rows: 4,
              })
            : this;
        }),
        (this.addButton = function (key, options) {
          return UIL.sidebar
            ? this.add(key, null, UILControlButton, options)
            : this;
        }),
        (this.addVector = function (key, initValue, options) {
          return UIL.sidebar
            ? (options || (options = { step: 0.05 }),
              this.add(key, initValue, UILControlVector, null, options))
            : this;
        }),
        (this.getImage = function (key) {
          let data = this.get(key);
          if (data) return JSON.parse(data).src;
        }),
        (this.setValue = function (key, value) {
          if (
            (UILStorage.set(`${prefix}_${key}`, value),
            _this.onUpdate && _this.onUpdate(key),
            _fields)
          ) {
            let field = _fields[key];
            field && ((field.value = value), field.update && field.update());
          }
          return this;
        }),
        (this.copyFrom = function (input, fields) {
          fields.forEach((key) => {
            let val = input.get(key);
            void 0 !== val &&
              ("string" != typeof val && (val = JSON.stringify(val)),
              _this.setValue(key, val));
          });
        }),
        (this.setLabel = function (name) {
          _group && _group.setLabel(name);
        }),
        (this.getField = function (key) {
          if (_fields) return _fields[key];
        }),
        (this.setDescription = function (key, desc) {
          _this.getField(key)?.setDescription(desc);
        }));
  }),
  Class(function ListUIL() {
    Inherit(this, Component);
    const _this = this;
    var _panel,
      _created = {};
    function removePanel() {
      _panel &&
        _panel.destroy &&
        (_this.events.unsub(_panel, Events.COMPLETE, removePanel),
        (_panel = _panel.destroy()));
    }
    (this.create = function (id, version = 1, group) {
      "number" != typeof version && ((group = version), (version = 1)),
        (group = null === group ? null : group || UIL.global);
      let config = new ListUILConfig(id, version, UIL.global && !_created[id]);
      return (
        UIL.global &&
          (_created[id] ||
            ((_created[id] = config),
            null != group && config.appendUILGroup(group || UIL.global))),
        config
      );
    }),
      (this.openPanel = function (id, name, template) {
        return (
          removePanel(),
          (_panel = new ListUILEditor(id, name, template)),
          _this.events.sub(_panel, Events.COMPLETE, removePanel),
          _panel
        );
      }),
      (this.set = function () {}),
      (this.get = function () {}),
      (this.getPanel = function () {
        return _panel;
      });
  }, "static"),
  Class(
    function ListUILConfig(_id, _version = 1, _store) {
      Inherit(this, Component);
      const _this = this;
      var _items,
        _folder,
        _config,
        _template = {
          onSort: (_) => {},
          onAdd: (_) => {},
          onRemove: (_) => {},
        },
        _name = "";
      function name() {
        return `LIST_${_id}_config`;
      }
      function updateConfig() {
        (_config.version = _version), UILStorage.setWrite(name(), _config);
      }
      function edit() {
        let panel = ListUIL.openPanel(_id, _name, _this.template);
        _this.events.bubble(panel, Events.UPDATE),
          _this.events.fire(ListUIL.OPEN);
      }
      _store && (_items = []),
        (function initConfig() {
          (_config = UILStorage.get(name()))
            ? _config.version != _version &&
              (updateConfig(),
              UILStorage.clearMatch(name().split("_config")[0]))
            : ((_config = {}), updateConfig());
        })(),
        (this.add = function (item) {
          return _items && _items.push(item), item;
        }),
        (this.template = function (config) {
          return "function" == typeof config && (_template = config), _template;
        }),
        (this.appendUILGroup = function (uil) {
          let folder = new UILFolder("LIST_" + _id, { closed: !0 }),
            button = new UILControlButton("button", {
              actions: [{ title: "Edit List", callback: edit }],
              hideLabel: !0,
            });
          folder.add(button), uil.add(folder), (_folder = folder);
        }),
        (this.setLabel = function (name) {
          _folder && _folder.setLabel(name), (_name = name);
        }),
        (this.onAdd = function (cb) {
          _template.onAdd = cb;
        }),
        (this.onRemove = function (cb) {
          _template.onRemove = cb;
        }),
        (this.onSort = function (cb) {
          _template.onSort = cb;
        }),
        (this.internalAddItems = function (count) {
          if (!count) return;
          let array = [];
          for (let i = 0; i < count; i++) {
            let id = `${_id}_${Utils.timestamp()}`;
            array.push(id);
          }
          UILStorage.set(`${_id}_list_items`, JSON.stringify(array));
        });
    },
    (_) => {
      ListUIL.OPEN = "list_uil_open";
    }
  ),
  Class(function ListUILEditor(_id, _name, _template) {
    Inherit(this, Component);
    const _this = this,
      PANEL_CONFIG = {
        label: _name || "List",
        width: "400px",
        height: "auto",
        drag: !0,
      };
    var _gui,
      _list,
      _add,
      _items,
      _tabs = [],
      _index = 0;
    function initList() {
      !(function read() {
        let data = UILStorage.get(`${_id}_list_items`);
        void 0 === data && (data = "[]");
        _items = JSON.parse(data);
      })(),
        (_list = new UILFolder(`${_id}_list`, { hideTitle: !0 })).enableSorting(
          _id
        ),
        _gui.add(_list);
      for (let id of _items) {
        let view = new ListUILItem(id, _list, _template, _index++);
        _this.events.sub(view, Events.UPDATE, reorder),
          _this.events.sub(view, Events.END, remove),
          _tabs.push(view);
      }
    }
    function initAdd() {
      !(function initButton(title, callback) {
        (_add = new UILControlButton("button", {
          actions: [{ title: title, callback: callback }],
          hideLabel: !0,
        })),
          _gui.add(_add);
      })("Add Item", add);
    }
    function add() {
      let id = `${_id}_${Utils.timestamp()}`,
        view = new ListUILItem(id, _list, _template, _index++);
      _this.events.sub(view, Events.UPDATE, reorder),
        _this.events.sub(view, Events.END, remove),
        _tabs.push(view),
        _items.push(id),
        write();
    }
    function reorder(e) {
      let order = [];
      for (let item of e.order) order.push(item.split("_folder")[0]);
      (_items = order),
        _template().onSort(_items),
        write(),
        _this.events.fire(Events.UPDATE, { order: order });
    }
    function close() {
      _this.events.fire(Events.COMPLETE);
    }
    function remove(e) {
      _items.remove(e.id), write(), refresh();
    }
    function write() {
      let data = JSON.stringify(_items);
      UILStorage.set(`${_id}_list_items`, data);
    }
    function refresh() {
      (_index = 0),
        _list && _list.destroy && (_list = _list.destroy()),
        _add && _add.destroy && (_add = _add.destroy()),
        initList(),
        initAdd();
    }
    !(function initPanel() {
      (_this.gui = _gui = new UILWindow(_id, PANEL_CONFIG)),
        (_this.gui.onClose = close),
        UIL.add(_gui);
    })(),
      refresh(),
      (this.onDestroy = function () {
        _gui.destroy();
      }),
      (this.add = function () {
        add();
      });
  }),
  Class(function ListUILItem(_id, _parent, _template, _index) {
    Inherit(this, Component);
    const _this = this;
    var _folder;
    function onDelete() {
      if (!confirm("You sure you want to delete this?")) return;
      let id = _id;
      _template().onRemove(id), _this.events.fire(Events.END, { id: id });
    }
    function onReorder(e) {
      _this.events.fire(Events.UPDATE, e);
    }
    !(async function initFolder() {
      (_folder = InputUIL.create(`${_id}_folder`, _parent)).setLabel("Item"),
        _folder.group.draggable(!0),
        _this.events.sub(_folder.group, UIL.REORDER, onReorder),
        (_folder.listUILItem = _this);
    })(),
      (function initTemplate() {
        let id = _id;
        (0, _template().onAdd)(id, _folder, _index);
      })(),
      (function initUI() {
        let actions = [{ title: "Delete", callback: onDelete }],
          hideLabel = !0;
        _folder.addButton("delete", { actions: actions, hideLabel: hideLabel });
      })(),
      (this.setLabel = function (label) {
        _folder.setLabel(label);
      }),
      (this.forceSort = function (index) {
        _folder.group.forceSort(index);
      }),
      (this.open = function () {
        _folder.group.open(), _folder.group.openChildren();
      }),
      (this.close = function () {
        _folder.group.close();
      });
  }),
  Class(function MeshUIL() {
    Inherit(this, Component);
    (this.exists = {}),
      (this.UPDATE = "mesh_uil_update"),
      (this.add = function (mesh, group) {
        return new MeshUILConfig(
          mesh,
          null === group ? null : group || UIL.global
        );
      });
  }, "static"),
  Class(function MeshUILConfig(_mesh, _uil) {
    const _this = this;
    if (!_mesh.prefix) throw "mesh.prefix required when using MeshUIL";
    var prefix = "MESH_" + _mesh.prefix,
      _group =
        _uil && !MeshUIL.exists[prefix]
          ? (function createFolder() {
              if (!UIL.sidebar) return null;
              let folder = new UILFolder(prefix, {
                label: _mesh.prefix,
                closed: !0,
              });
              return _uil.add(folder), folder;
            })()
          : null,
      _controls = _group ? {} : null;
    function initVec(key) {
      let initValue = UILStorage.get(`${prefix}${key}`) || _mesh[key].toArray();
      if (_group) {
        let vector = new UILControlVector(`${prefix}${key}`, {
          label: key,
          value: initValue,
          step: 0.05,
        });
        vector.onChange((e) => {
          _mesh[key].fromArray(e),
            _group &&
              (Events.emitter._fireEvent(MeshUIL.UPDATE, {
                prefix: prefix,
                key: key,
                val: e,
                group: _this,
              }),
              _this["tweenUIL_" + key]?.(e));
        }),
          vector.onFinishChange(save),
          _group.add(vector),
          (_this["forceUpdate" + key.toUpperCase()] = (_) => {
            let val = _mesh[key].toArray();
            _this["tweenUIL_" + key]
              ? _this["tweenUIL_" + key](val)
              : vector.force(_mesh[key].toArray(), !0);
          }),
          (_controls[key] = vector);
      }
      _mesh[key].fromArray(initValue);
    }
    function save() {
      for (let key in _controls) {
        let value = _controls[key].value;
        UILStorage.set(`${prefix}${key}`, value);
      }
    }
    function update(e) {
      e.prefix == prefix && e.group != _this && _mesh[e.key].fromArray(e.val);
    }
    (this.group = _group),
      (MeshUIL.exists[prefix] = !0),
      initVec("position"),
      initVec("scale"),
      (function initRotation() {
        let key = "rotation",
          toRadians = (array) =>
            array
              ? ((array.length = 3), array.map((x) => Math.radians(x)))
              : [0, 0, 0],
          toDegrees = (array) =>
            array
              ? ((array.length = 3), array.map((x) => Math.degrees(x)))
              : [0, 0, 0],
          initValue = toRadians(UILStorage.get(`${prefix}${key}`));
        if (_group) {
          let vector = new UILControlVector(`${prefix}${key}`, {
            label: key,
            value: toDegrees(initValue),
          });
          vector.onChange((e) => {
            _mesh[key].fromArray(toRadians(e)),
              _group &&
                (Events.emitter._fireEvent(MeshUIL.UPDATE, {
                  prefix: prefix,
                  key: key,
                  val: toRadians(e),
                  group: _this,
                }),
                _this["tweenUIL_" + key]?.(e));
          }),
            vector.onFinishChange(save),
            _group.add(vector),
            (_controls[key] = vector);
        }
        _mesh[key].fromArray(initValue);
        let rotationEuler = new Euler().fromArray(initValue);
        _mesh.customRotation = new Quaternion().setFromEuler(rotationEuler);
      })(),
      _group &&
        (function addListeners() {
          Events.emitter._addEvent(MeshUIL.UPDATE, update, _this);
        })(),
      (this.setLabel = function (name) {
        _group && _group.setLabel(name);
      }),
      (this.forceUpdate = function (key, val) {
        _mesh[key].fromArray(val), _this["forceUpdate" + key.toUpperCase()]?.();
      });
  }),
  Class(function ShaderUIL() {
    (this.exists = {}),
      (this.UPDATE = "shader_update"),
      (this.TEXTURE_UPDATE = "shader_texture_update"),
      (this.SHADER_UPDATE = "shader_shader_update"),
      (this.add = function (shader, group) {
        return new ShaderUILConfig(
          shader.shader || shader,
          null === group ? null : group || UIL.global
        );
      }),
      (this.createOverride = function (prefix, obj, group, shaderOnly) {
        let uniforms = {};
        Array.isArray(obj)
          ? obj.forEach((o) => {
              o = o.uniforms || o;
              for (let key in o) o[key].ignoreUIL || (uniforms[key] = o[key]);
            })
          : (uniforms = obj.uniforms || obj);
        let shader = Utils3D.getTestShader();
        shader.vertexShader = shader.fragmentShader = "";
        for (let key in uniforms) shader.uniforms[key] = uniforms[key];
        return (
          (shader.UILPrefix = prefix),
          null === shaderOnly ? shader : this.add(shader, group)
        );
      }),
      (this.createDecorator = function (shader, prefix, obj, group) {
        let uniforms = {};
        for (let key in obj) uniforms[key] = shader.uniforms[key];
        let nShader = Utils3D.getTestShader();
        return (
          (nShader.vertexShader = shader.fragmentShader = ""),
          (nShader.uniforms = uniforms),
          (nShader.UILPrefix = prefix),
          this.add(nShader, group)
        );
      }),
      (this.createClone = function (prefix, obj) {
        let uniforms = obj.uniforms || obj,
          shader = Utils3D.getTestShader();
        for (let key in uniforms) {
          let value = uniforms[key].value,
            ignoreUIL = uniforms[key].ignoreUIL || null === value;
          !ignoreUIL && value.clone && (value = value.clone()),
            (shader.uniforms[key] = { value: value, ignoreUIL: ignoreUIL });
        }
        return (shader.UILPrefix = prefix), shader;
      }),
      (this.lerpShader = function (from, to, alpha, hz, uniformsFilter) {
        (from = from.uniforms || from), (to = to.uniforms || to);
        for (let key in from) {
          let f = from[key],
            t = to[key];
          f &&
            t &&
            ((uniformsFilter && -1 === uniformsFilter.indexOf(key)) ||
              ("number" == typeof f.value && "number" == typeof t.value
                ? (t.value = Math.lerp(f.value, t.value, alpha, hz))
                : "c" === f.type && "c" === t.type
                ? ((t.value.r = Math.lerp(f.value.r, t.value.r, alpha, hz)),
                  (t.value.g = Math.lerp(f.value.g, t.value.g, alpha, hz)),
                  (t.value.b = Math.lerp(f.value.b, t.value.b, alpha, hz)))
                : "v3" === f.type && "v3" === t.type
                ? ((t.value.x = Math.lerp(f.value.x, t.value.x, alpha, hz)),
                  (t.value.y = Math.lerp(f.value.y, t.value.y, alpha, hz)),
                  (t.value.z = Math.lerp(f.value.z, t.value.z, alpha, hz)))
                : "v2" === f.type && "v2" === t.type
                ? ((t.value.x = Math.lerp(f.value.x, t.value.x, alpha, hz)),
                  (t.value.y = Math.lerp(f.value.y, t.value.y, alpha, hz)))
                : f.value &&
                  f.value.lerp &&
                  t.value &&
                  t.value.lerp &&
                  t.value.lerp(f.value, alpha, hz)));
        }
      });
  }, "static"),
  Class(function ShaderUILConfig(_shader, _uil) {
    var _textures,
      _this = this;
    const prefix = _shader.UILPrefix;
    var _group =
      _uil && !ShaderUIL.exists[prefix]
        ? (function createFolder() {
            if (!UIL.sidebar) return null;
            let label = (function getName() {
              let split = _shader.UILPrefix.split("/");
              return split.length > 2 ? split[0] + "_" + split[2] : split[0];
            })();
            "_" == label.charAt(label.length - 1) &&
              (label = label.slice(0, -1));
            let folder = new UILFolder(prefix + label, {
              label: label,
              closed: !0,
            });
            return _uil.add(folder), folder;
          })()
        : null;
    function createVector(obj, key) {
      let initValue = UILStorage.get(`${prefix}${key}`) || obj.value.toArray();
      if (_group) {
        let vector = new UILControlVector(`${prefix}${key}`, {
          label: key,
          value: initValue,
          step: 0.05,
          description: obj.description,
        });
        vector.onChange((val) => {
          obj.value.fromArray(val),
            _shader.ubo && (_shader.ubo.needsUpdate = !0),
            Events.emitter._fireEvent(ShaderUIL.UPDATE, {
              prefix: prefix,
              key: key,
              val: val,
              group: _this,
              vector: !0,
            });
        }),
          (_this["forceUpdate" + key.toUpperCase()] = (_) => {
            let val = _shader.get(key).toArray();
            vector.force(val, !0);
          }),
          vector.onFinishChange((e) => UILStorage.set(`${prefix}${key}`, e)),
          _group.add(vector);
      }
      obj.value.fromArray(initValue);
    }
    function createTexture(obj, key) {
      let getTexture;
      _group && !_textures && (_textures = {}),
        (getTexture = obj.cube
          ? obj.getTexture || ShaderUIL.getCubeTexture || Utils3D.getCubeTexture
          : obj.getTexture || ShaderUIL.getTexture || Utils3D.getTexture);
      const set =
          _shader.parent && _shader.parent.setOverride
            ? _shader.parent.setOverride
            : _shader.set || _shader.setUniform,
        get = _shader.get || _shader.getUniform;
      let prefix = _shader.UILPrefix + "_tx",
        data = UILStorage.get(`${prefix}_${key}`);
      data && (data = JSON.parse(data));
      let value = data ? data.src : null,
        change = (data) => {
          let val = data.src,
            cleanPath =
              val.includes("?") && !data.hotreload ? val.split("?")[0] : val;
          data.compressed &&
            ((val += "-compressedKtx"),
            "ktx2" === data.compressed && (val += "2")),
            _textures && (_textures[cleanPath] = change),
            (data.src = cleanPath),
            UILStorage.set(`${prefix}_${key}`, JSON.stringify(data)),
            set(
              key,
              getTexture(val, {
                premultiplyAlpha: obj.premultiplyAlpha,
                scale: obj.scale,
              }),
              _shader
            ),
            _group &&
              Events.emitter._fireEvent(ShaderUIL.UPDATE, {
                prefix: _shader.UILPrefix,
                key: key,
                val: val,
                texture: get(key, _shader),
                group: _this,
              });
        };
      if ((value && value.length && change(data), _group)) {
        let compressOptions = {};
        obj.cube && (compressOptions.cube = !0);
        let img = new UILControlImage(prefix + key, {
          label: key,
          value: data,
          description: obj.description,
          compressOptions: compressOptions,
        });
        img.onFinishChange(change),
          _group.add(img),
          (_this["forceUpdate" + key.toUpperCase()] = (_) => {
            img.force(_shader.get(key), !0);
          });
      }
    }
    function createNumber(obj, key) {
      let initValue = UILStorage.get(`${prefix}${key}`);
      if ((void 0 === initValue && (initValue = obj.value), _group)) {
        let number = new UILControlNumber(`${prefix}${key}`, {
          label: key,
          value: initValue,
          step: 0.05,
          description: obj.description,
        });
        number.onChange((val) => {
          _shader.ubo && (_shader.ubo.needsUpdate = !0),
            Events.emitter._fireEvent(ShaderUIL.UPDATE, {
              prefix: prefix,
              key: key,
              val: val,
              group: _this,
            }),
            (obj.value = val);
        }),
          number.onFinishChange((e) => UILStorage.set(`${prefix}${key}`, e)),
          _group.add(number),
          (_this["forceUpdate" + key.toUpperCase()] = (_) => {
            number.forceUpdate(_shader.get(key), !0);
          });
      }
      obj.value = initValue;
    }
    function createColor(obj, key) {
      let initValue =
        UILStorage.get(`${prefix}${key}`) || obj.value.getHexString();
      if (_group) {
        let color = new UILControlColor(`${prefix}${key}`, {
          label: key,
          value: initValue,
          description: obj.description,
        });
        color.onChange((val) => {
          obj.value.set(val),
            _shader.ubo && (_shader.ubo.needsUpdate = !0),
            _group &&
              Events.emitter._fireEvent(ShaderUIL.UPDATE, {
                prefix: prefix,
                key: key,
                val: val,
                color: !0,
                group: _this,
              });
        }),
          color.onFinishChange((e) => UILStorage.set(`${prefix}${key}`, e)),
          _group.add(color),
          (_this["forceUpdate" + key.toUpperCase()] = (_) => {
            color.force(_shader.get(key).getHexString(), !0);
          });
      }
      initValue && obj.value.set(initValue);
    }
    function createSelect(obj, key) {
      let initValue = UILStorage.get(`${prefix}${key}`);
      if (_group) {
        let { options: options, description: description } = obj,
          select = new UILControlSelect(`${prefix}${key}`, {
            label: key,
            value: initValue,
            options: options,
            description: description,
          });
        select.onChange((val) => {
          _group &&
            Events.emitter._fireEvent(ShaderUIL.UPDATE, {
              prefix: prefix,
              key: key,
              val: val,
              group: _this,
            }),
            (obj.value = val),
            UILStorage.set(`${prefix}${key}`, val);
        }),
          _group.add(select);
      }
      initValue && (obj.value = initValue);
    }
    function textureUpdate(e) {
      if (!_textures) return;
      let cleanPath = e.file.split("?")[0];
      for (let key in _textures) {
        cleanPath == (key.includes("?") ? key.split("?")[0] : key) &&
          _textures[key]({ src: e.file, hotreload: !0 });
      }
    }
    function update(e) {
      if (e.prefix == _shader.UILPrefix && e.group != _this)
        if (e.color) {
          let val = e.val,
            obj = _shader.uniforms[e.key];
          Array.isArray(val)
            ? obj.value.setRGB(val[0], val[1], val[2])
            : obj.value.set(val);
        } else
          e.texture
            ? "remote" != e.texture && _shader.set(e.key, e.texture)
            : e.vector
            ? _shader.uniforms[e.key].value.fromArray(e.val)
            : (_shader.uniforms[e.key].value = e.val);
    }
    (this.group = _group),
      (this.shader = _shader),
      _group && (_shader.shaderUIL = _this),
      (ShaderUIL.exists[_shader.UILPrefix] = !0),
      (function initItems() {
        for (var key in _shader.uniforms) {
          let obj = _shader.uniforms[key];
          obj &&
            !obj.ignoreUIL &&
            (obj.options && Array.isArray(obj.options)
              ? createSelect(obj, key)
              : ("number" == typeof obj.value && createNumber(obj, key),
                obj.value instanceof Color && createColor(obj, key),
                (null === obj.value || obj.value instanceof Texture) &&
                  createTexture(obj, key),
                obj.value instanceof Vector2 && createVector(obj, key),
                obj.value instanceof Vector3 && createVector(obj, key),
                obj.value instanceof Vector4 && createVector(obj, key)));
        }
      })(),
      _group &&
        (function addListeners() {
          Events.emitter._addEvent(ShaderUIL.UPDATE, update, _this),
            Events.emitter._addEvent(
              ShaderUIL.TEXTURE_UPDATE,
              textureUpdate,
              _this
            );
        })(),
      (this.setLabel = function (name) {
        _group && _group.setLabel(name);
      }),
      (this.forceUpdate = function (e) {
        (e.prefix = _shader.UILPrefix),
          update(e),
          _this["forceUpdate" + e.key.toUpperCase()]?.();
      }),
      (this.copyTexture = function (key, shader) {
        let newPrefix = shader.UILPrefix + "_tx",
          prefix = _shader.UILPrefix + "_tx",
          data = UILStorage.get(`${prefix}_${key}`);
        data && UILStorage.set(`${newPrefix}_${key}`, data);
      });
  }),
  Class(function ShadowUIL() {
    this.add = function (light, group) {
      return new ShadowUILConfig(
        light,
        null === group ? null : group || UIL.global
      );
    };
  }, "static"),
  Class(function ShadowUILConfig(_light, _uil) {
    if (!_light.prefix) throw "light.prefix required when using MeshUIL";
    var prefix = "SHADOW_" + _light.prefix,
      _group = _uil
        ? (function createFolder() {
            if (!UIL.sidebar) return null;
            let folder = new UILFolder(prefix, {
              label: _light.prefix,
              closed: !0,
            });
            return _uil.add(folder), folder;
          })()
        : null;
    function initNumber(key) {
      let initValue = UILStorage.get(`${prefix}${key}`) || _light.shadow[key];
      if (_group) {
        let number = new UILControlNumber(`${prefix}${key}`, {
          label: key,
          value: initValue,
          step: 0.05,
        });
        number.onFinishChange((e) => {
          (_light.shadow[key] = e), UILStorage.set(`${prefix}${key}`, e);
        }),
          _group.add(number);
      }
      _light.shadow[key] = initValue;
    }
    function initVec(key) {
      let initValue =
        UILStorage.get(`${prefix}${key}`) || _light[key].toArray();
      if (_group) {
        let vector = new UILControlVector(`${prefix}${key}`, {
          label: key,
          value: initValue,
          step: 0.05,
        });
        vector.onChange((e) => {
          _light[key].fromArray(e),
            "target" == key && _light.shadow.camera.lookAt(_light.target);
        }),
          vector.onFinishChange((e) => UILStorage.set(`${prefix}${key}`, e)),
          _group.add(vector);
      }
      _light[key].fromArray(initValue);
    }
    (_light.target = _light.shadow.target),
      initVec("position"),
      initVec("target"),
      initNumber("fov"),
      initNumber("size"),
      initNumber("area"),
      initNumber("near"),
      initNumber("far"),
      (function initTick(key) {
        let initValue = UILStorage.get(`${prefix}${key}`);
        if (_group) {
          let tick = new UILControlCheckbox(`${prefix}${key}`, {
            label: key,
            value: initValue,
          });
          tick.onFinishChange((e) => {
            (_light[key] = e), UILStorage.set(`${prefix}${key}`, e);
          }),
            _group.add(tick);
        }
        _light[key] = initValue;
      })("static"),
      (this.setLabel = function (name) {
        _group && _group.setLabel(name);
      });
  }),
  Class(function TimelineUIL() {
    Inherit(this, Component);
    const _this = this;
    var _panel,
      _created = {};
    function removePanel() {
      _panel &&
        _panel.destroy &&
        (_this.events.unsub(_panel, Events.COMPLETE, removePanel),
        (_panel = _panel.destroy()));
    }
    (this.create = function (id, version = 1, group) {
      "number" != typeof version && ((group = version), (version = 1)),
        (group = null === group ? null : group || UIL.global);
      let config = new TimelineUILConfig(
        id,
        version,
        UIL.global && !_created[id]
      );
      return (
        UIL.global &&
          (_created[id] ||
            ((_created[id] = config),
            null != group && config.appendUILGroup(group || UIL.global))),
        config
      );
    }),
      (this.openPanel = function (id, name, template) {
        return (
          removePanel(),
          (_panel = new TimelineUILEditor(id, name, template)),
          _this.events.sub(_panel, Events.COMPLETE, removePanel),
          _panel
        );
      }),
      (this.set = function () {}),
      (this.get = function () {});
  }, "static"),
  Class(
    function TimelineUILConfig(_id, _version = 1, _store) {
      Inherit(this, Component);
      const _this = this;
      var _items,
        _folder,
        _config,
        _template = {
          onSort: (_) => {},
          onAdd: (_) => {},
          onRemove: (_) => {},
        },
        _name = "";
      function name() {
        return `TL_${_id}_config`;
      }
      function updateConfig() {
        (_config.version = _version), UILStorage.setWrite(name(), _config);
      }
      function edit() {
        let panel = TimelineUIL.openPanel(name(), _name, _this.template);
        _this.events.bubble(panel, Events.UPDATE),
          _this.events.fire(TimelineUIL.OPEN);
      }
      (this.model = new TimelineUILModel(name())),
        _store && (_items = []),
        (function initConfig() {
          (_config = UILStorage.get(name()))
            ? _config.version != _version &&
              (updateConfig(),
              UILStorage.clearMatch(name().split("_config")[0]))
            : ((_config = {}), updateConfig());
        })(),
        (this.add = function (item) {
          return _items && _items.push(item), item;
        }),
        (this.template = function (config) {
          return "function" == typeof config && (_template = config), _template;
        }),
        (this.appendUILGroup = function (uil) {
          let folder = new UILFolder("TL_" + _id, { closed: !0 }),
            button = new UILControlButton("button", {
              actions: [{ title: "Edit Timeline", callback: edit }],
              hideLabel: !0,
            });
          folder.add(button), uil.add(folder), (_folder = folder);
        }),
        (this.setLabel = function (name) {
          _folder && _folder.setLabel(name), (_name = name);
        }),
        (this.onAdd = function (cb) {
          _template.onAdd = cb;
        }),
        (this.onRemove = function (cb) {
          _template.onRemove = cb;
        }),
        (this.onSort = function (cb) {
          _template.onSort = cb;
        }),
        (this.internalAddItems = function (count) {
          if (!count) return;
          let array = [];
          for (let i = 0; i < count; i++) {
            let id = `${_id}_${Utils.timestamp()}`;
            array.push(id);
          }
          UILStorage.set(`${_id}_list_items`, JSON.stringify(array));
        });
    },
    (_) => {
      TimelineUIL.OPEN = "list_uil_open";
    }
  ),
  Class(function TimelineUILEditor(_id, _name, _template) {
    Inherit(this, Component);
    const _this = this,
      PANEL_CONFIG = {
        label: "Timeline Editor",
        width: "800px",
        height: "auto",
        drag: !0,
      };
    var _gui,
      _list,
      _add,
      _config,
      _items,
      _tabs = [],
      _index = 0;
    function initList() {
      !(function read() {
        let data = UILStorage.get(`${_id}_list_items`);
        void 0 === data && (data = "[]");
        _items = JSON.parse(data);
      })(),
        (_list = new UILFolder(`${_id}_list`, { hideTitle: !0 })),
        _gui.add(_list);
      for (let id of _items) {
        let view = _this.initClass(
          TimelineUILItem,
          id,
          _list,
          _template,
          _index++
        );
        _this.events.sub(view, Events.UPDATE, reorder),
          _this.events.sub(view, Events.END, remove),
          _tabs.push(view);
      }
      _config.rails &&
        (function attachRails() {
          _tabs.forEach((t, i) => {
            t.onUpdate = (v) => {
              _tabs.forEach((t2, j) => {
                t2 != t &&
                  (j < i &&
                    t.getValue() < t2.getValue() &&
                    t2.setValue(t.getValue()),
                  j > i &&
                    t.getValue() > t2.getValue() &&
                    t2.setValue(t.getValue()));
              });
            };
          });
        })();
    }
    function initButton(title, callback) {
      let btn = new UILControlButton("button", {
        actions: [{ title: title, callback: callback }],
        hideLabel: !0,
      });
      return _gui.add(btn), btn;
    }
    function spaceEvenly() {
      _tabs.forEach((t, i) => {
        let perc = Math.range(i, 0, _tabs.length - 1, 0, 1);
        t.setValue(perc);
      });
    }
    function add() {
      let id = `${_id}_${Utils.timestamp()}`,
        view = new TimelineUILItem(id, _list, _template, _index++);
      _this.events.sub(view, Events.UPDATE, reorder),
        _this.events.sub(view, Events.END, remove),
        _tabs.push(view),
        _items.push(id),
        write();
    }
    function reorder(e) {
      let order = [];
      for (let item of e.order) order.push(item.split("_folder")[0]);
      (_items = order),
        _template().onSort(_items),
        write(),
        _this.events.fire(Events.UPDATE, { order: order });
    }
    function remove(e) {
      _items.remove(e.id), write(), refresh();
    }
    function write() {
      let data = JSON.stringify(_items);
      UILStorage.set(`${_id}_list_items`, data);
    }
    function refresh() {
      (_index = 0),
        _list && _list.destroy && (_list = _list.destroy()),
        _add && _add.destroy && (_add = _add.destroy()),
        initList(),
        (function initAdd() {
          _config.lock ||
            (_add = initButton("Add Item", add)).element.css({ width: "20%" }),
            initButton("Space Evenly", spaceEvenly).element.css({
              width: "20%",
            });
        })();
    }
    (_this.config = _config =
      JSON.parse(UILStorage.get(`${_id}_config`) || "{}")),
      (function initPanel() {
        (_this.gui = _gui = new UILWindow(_id, PANEL_CONFIG)), UIL.add(_gui);
      })(),
      refresh(),
      (this.onDestroy = function () {
        _gui.destroy();
      });
  }),
  Class(function TimelineUILItem(_id, _parent, _template, _index) {
    Inherit(this, Component);
    const _this = this;
    var _folder;
    function onDelete() {
      if (!confirm("You sure you want to delete this?")) return;
      let id = _id;
      _template().onRemove(id), _this.events.fire(Events.END, { id: id });
    }
    function onReorder(e) {
      _this.events.fire(Events.UPDATE, e);
    }
    !(async function initFolder() {
      (_folder = InputUIL.create(`${_id}_folder`, _parent)).setLabel("Item"),
        (_this.parent && _this.parent.config.lock) ||
          _folder.group.draggable(!0),
        _this.events.sub(_folder.group, UIL.REORDER, onReorder),
        _folder.group.open();
    })(),
      (function initTemplate() {
        let id = _id;
        (0, _template().onAdd)(id, _folder, _index);
      })(),
      (function initUI() {
        _folder.add(
          "label",
          _this.parent && _this.parent.config.lock ? "hidden" : void 0
        ),
          _folder.addRange("keyframe"),
          _folder.add("percent", "hidden"),
          _folder
            .getField("keyframe")
            .force(Math.round(100 * _folder.getNumber("percent")) || 0),
          (_folder.onUpdate = (key) => {
            if ("keyframe" == key) {
              let val = _folder.getNumber(key) / 100;
              _folder.setValue("percent", val),
                _this.onUpdate && _this.onUpdate(val);
            }
          });
        let label = _folder.get("label");
        if (
          (label && _folder.setLabel(label),
          !_this.parent || !_this.parent.config.lock)
        ) {
          let actions = [{ title: "Delete", callback: onDelete }],
            hideLabel = !0,
            btn =
              (_folder.addButton("delete", {
                actions: actions,
                hideLabel: hideLabel,
              }),
              _folder.getField("delete"));
          btn && btn.$content.css({ width: "20%" });
        }
      })(),
      (this.setLabel = function (label) {
        _folder.setLabel(label);
      }),
      (this.getValue = function (value) {
        return _folder.getNumber("percent");
      }),
      (this.setValue = function (value) {
        _folder.setValue("percent", value),
          _folder.getField("keyframe").force(Math.round(100 * value) || 0);
      });
  }),
  Class(function TimelineUILModel(_id) {
    var _items,
      _config,
      _data = [],
      _map = {};
    !(function initItems() {
      (_config = JSON.parse(UILStorage.get(`${_id}_config`) || "{}")),
        (_items = JSON.parse(UILStorage.get(`${_id}_list_items`) || "[]"));
    })(),
      (function initData() {
        _items.forEach((item, i) => {
          let input = InputUIL.create(
              `${item}_folder`,
              null,
              null,
              !!UIL.global
            ),
            data = {};
          (data.label = input.get("label") || "Item"),
            (data.value = input.getNumber("percent") || 0),
            (data.arbitrary = input.get("arbitrary")),
            _data.push(data),
            (_map[data.label] = data),
            UIL.global &&
              Render.start((_) => {
                (data.label = input.get("label") || "Item"),
                  (data.value = input.getNumber("percent") || 0);
              }, 10);
        });
      })(),
      (this.setState = function (array) {
        for (let i = 0; i < array.length; i++)
          _items[i] || _items.push(`${_id}_${Utils.timestamp()}`);
        _items.length > array.length &&
          (_items = _items.slice(0, array.length)),
          _items.forEach((item, i) => {
            let data = array[i],
              input = InputUIL.create(`${item}_folder`, null);
            input.setValue("label", data.label),
              data.percent && input.setValue("percent", data.percent),
              data.arbitrary && input.setValue("percent", data.arbitrary);
          }),
          UILStorage.set(`${_id}_list_items`, JSON.stringify(_items));
      }),
      (this.lock = function () {
        return (
          _config.lock ||
            ((_config.lock = !0),
            UIL.global &&
              UILStorage.set(`${_id}_config`, JSON.stringify(_config))),
          this
        );
      }),
      (this.rails = function () {
        return (
          _config.rails ||
            ((_config.rails = !0),
            UIL.global &&
              UILStorage.set(`${_id}_config`, JSON.stringify(_config))),
          this
        );
      }),
      (this.getData = function () {
        return _data;
      }),
      (this.get = function (key) {
        return _map[key];
      });
  }),
  Class(function CameraLookAtHelper() {
    Inherit(this, Component);
    const _this = this;
    let _camera,
      _object,
      _defaultLookAt,
      _tweener = { alpha: 0 },
      _lookAt = new Vector3();
    function update() {
      _lookAt.copy(_defaultLookAt),
        _tweener.alpha > 0 &&
          _lookAt.lerp(_object.position, _tweener.alpha, !1);
    }
    _this.get("tweener", () => _tweener),
      (_this.create = async function (camera, object, tween) {
        (_camera = camera),
          (_object = object),
          (_defaultLookAt = _camera.lookAt),
          await tween.loaded(),
          (_camera.lookAt = _lookAt),
          _this.events.sub(tween, TweenUIL.UPDATED, update);
      });
  }),
  Class(function TweenUIL() {
    Inherit(this, Component);
    const _this = this;
    var _getServerTime,
      _folders = {},
      _activeFolder = "Tweens",
      _cache = {},
      _counters = {},
      _synchronizedTweens = [];
    function synchronizedPlaybackLoop() {
      let i = _synchronizedTweens.length - 1;
      if (i < 0) return;
      let serverTime = _getServerTime();
      for (; i >= 0; ) {
        let tween = _synchronizedTweens[i];
        if (tween.seekImmediate) {
          let duration = 1e3 * tween.duration,
            progress = (serverTime % duration) / duration;
          tween.seekImmediate(progress), (i -= 1);
        } else if (
          (_synchronizedTweens.splice(i, 1), 0 === _synchronizedTweens.length)
        ) {
          _this.stopRender(synchronizedPlaybackLoop);
          break;
        }
      }
    }
    (_this.jsons = {}),
      (this.TOGGLE = "tweenuil_toggle"),
      _this.startRender(synchronizedPlaybackLoop),
      (this.create = function (name, config, group) {
        "boolean" == typeof group && (group = void 0);
        let noCache = !1;
        "nocache" == group &&
          ((_counters[name] = (_counters[name] || 0) + 1),
          (noCache = !0),
          (group = void 0));
        let folderName = _activeFolder;
        if (
          ("string" == typeof group && ((folderName = group), (group = null)),
          _folders[folderName] ||
            (function initFolder() {
              if (UIL.global) {
                let folder = new UILFolder(_activeFolder, {
                  label: _activeFolder,
                  closed: !0,
                });
                (_folders[_activeFolder] = folder), UIL.global.add(folder);
              }
            })(),
          !_cache[name] || noCache)
        ) {
          let tween = new TweenUILConfig(
            name,
            config,
            group || _folders[folderName],
            _counters[name]
          );
          tween._bindOnDestroy((_) => {
            delete _cache[name];
          }),
            (_cache[name] = tween);
        }
        return _cache[name];
      }),
      (this.setFolder = function (name) {
        _activeFolder = name;
      }),
      (this.setServerTimeGetter = function (getServerTime) {
        _getServerTime = getServerTime;
      }),
      (this.playSynchronized = async function (tween) {
        _getServerTime
          ? (await tween.preload(),
            tween.progress,
            (tween.manualRender = !0),
            _synchronizedTweens.unshift(tween))
          : console.error(
              "Need to call TweenUIL.setServerTimeGetter(() => time) before using TweenUIL.playSynchronized()"
            );
      }),
      (this.stopSynchronized = function (tween) {
        _synchronizedTweens.remove(tween);
      });
  }, "static"),
  Class(function TweenUILAnchor() {
    Inherit(this, Object3D);
    this.isTweenAnchor = !0;
  }),
  Class(
    function TweenUILConfig(_name, _config, _group, _noCache) {
      Inherit(this, Component);
      const _this = this;
      var _input,
        _promise,
        _meshes,
        _keyframes,
        _objectsWithTracks,
        _savedState,
        _rafDriver,
        _flatMap = {},
        _sheets = {},
        _duration = 0,
        _manualRender = !1,
        _changedKeys = {},
        _cameras = [],
        _audioFile = !1;
      function loop() {
        _this.events.fire(TweenUIL.BEFORE_UPDATE),
          Object.keys(_flatMap).forEach((key) => (_changedKeys[key] = !1)),
          _rafDriver.tick(Render.TIME),
          _this.events.fire(TweenUIL.UPDATED, { changed: _changedKeys }),
          _cameras.forEach((camera) => camera.update());
      }
      function ignoreObject(name, layoutName) {
        return !!_objectsWithTracks && !_objectsWithTracks[name];
      }
      function checkDuration() {
        if (0 === _duration)
          for (let key in _sheets)
            _duration = Math.max(_duration, _sheets[key].length);
      }
      async function play(options = {}) {
        _config.sheets || (await prepareConfig(), linkLocally()),
          checkDuration();
        for (let key in _sheets)
          options.disableAutoPosition ||
            (_sheets[key].sequence.position =
              "reverse" === options?.direction ? _duration : 0),
            _sheets[key].sequence.play({ ...options, rafDriver: _rafDriver });
        return (_promise = _this.wait(1e3 * _duration));
      }
      function linkLocally() {
        makeSendable().sheets.forEach((obj) => {
          const sheet = _sheets[_config.mergedSheetName];
          if (sheet)
            for (let key in obj) {
              for (let key2 in obj[key]) {
                let finalObj = obj[key][key2];
                "number" == typeof finalObj.r &&
                  "number" == typeof finalObj.g &&
                  "number" == typeof finalObj.b &&
                  Object.assign(finalObj, Theatre.core.types.rgba(finalObj));
              }
              sheet
                .object(getTrackNameFromKey(key), obj[key])
                .onValuesChange((newValue) => {
                  (_changedKeys[key] = !0),
                    completeDataLink(newValue, _flatMap[key]);
                }, _rafDriver);
            }
        });
      }
      function getTrackNameFromKey(key, disambiguate = !1) {
        let name = key.split("&"),
          prefix = name[0];
        return (
          name.shift(),
          (name = name.join("_")),
          disambiguate && (name = `${prefix} » ${name}`),
          name
        );
      }
      async function prepareConfig() {
        let array = Array.isArray(_config) ? _config : [_config];
        (_config = {}),
          _audioFile && (_config.audioFile = _audioFile),
          (_config.nudgeMultiplier = 0.05);
        let sheet = {};
        _config.sheets = [sheet];
        for (let i = 0; i < array.length; i++) {
          let layoutName,
            objects = array[i],
            options = {};
          if (objects instanceof SceneLayout)
            (layoutName = objects.name),
              (options.isSceneLayout = !0),
              (objects = await getObjectsFromLayout(objects));
          else {
            if ("object" != typeof objects)
              throw "TweenUIL :: Type not supported";
            if (0 === i) {
              let obj0 = objects[Object.keys(objects)[0]];
              obj0 instanceof Mesh
                ? (layoutName = "Scene")
                : obj0.uniforms
                ? (layoutName = "Shader")
                : isElement(obj0) && (layoutName = "Elements");
            }
          }
          layoutName || (layoutName = `Scene${i + 1}`),
            mergeSheets(
              sheet,
              createSheetFromObjects(objects, layoutName, options)
            ),
            0 === i && (_config.mergedSheetName = layoutName);
        }
        _this.flag("isLoaded", !0);
      }
      function mergeSheets(sheet1, sheet2) {
        let usedNames = {};
        return (
          Object.keys(sheet1).forEach((key) => {
            usedNames[getTrackNameFromKey(key)] = !0;
          }),
          Object.keys(sheet2).forEach((key) => {
            let name = getTrackNameFromKey(key),
              newKey = key;
            usedNames[name] &&
              ((name = getTrackNameFromKey(key, !0)),
              (newKey = `${key.split("&")[0]}&${name}`),
              (_flatMap[newKey] = _flatMap[key]),
              delete _flatMap[key]),
              (usedNames[name] = !0),
              (sheet1[newKey] = sheet2[key]);
          }),
          sheet1
        );
      }
      function makeEulerLink(layer, key) {
        return {
          copy: (obj) => {
            layer[key].set(
              Math.radians(obj.x),
              Math.radians(obj.y),
              Math.radians(obj.z)
            );
          },
          get x() {
            return Math.degrees(layer[key].x);
          },
          get y() {
            return Math.degrees(layer[key].y);
          },
          get z() {
            return Math.degrees(layer[key].z);
          },
        };
      }
      function getMeshObject(layer, parent, layerName) {
        if (parent?.isTweenAnchor) {
          let obj = {};
          return (obj.anchor = { anchor: 0, link: { copy() {} } }), obj;
        }
        layer.rotationLink = makeEulerLink(layer, "rotation");
        let obj = {
          position: {
            x: layer.position.x,
            y: layer.position.y,
            z: layer.position.z,
            link: layer.position,
          },
          scale: {
            x: layer.scale.x,
            y: layer.scale.y,
            z: layer.scale.z,
            link: layer.scale,
          },
          rotation: {
            x: Math.degrees(layer.rotation.x),
            y: Math.degrees(layer.rotation.y),
            z: Math.degrees(layer.rotation.z),
            link: layer.rotationLink,
          },
        };
        if (layer._cameraUIL) {
          (obj.cameraPos = {
            x: parent.position.x,
            y: parent.position.y,
            z: parent.position.z,
            link: {
              copy(from) {
                parent.move(from);
              },
            },
          }),
            (obj.zoom = {
              zoom: parent.zoom,
              link: {
                copy(from) {
                  parent.zoom = from.zoom;
                },
              },
            }),
            (obj.lookAt = {
              x: parent.lookAt.x,
              y: parent.lookAt.y,
              z: parent.lookAt.z,
              link: parent.lookAt,
            }),
            (obj.moveXY = {
              x: parent.moveXY.x,
              y: parent.moveXY.y,
              link: parent.moveXY,
            }),
            (obj.cameraRotation = {
              x: Math.degrees(parent.cameraRotation.x),
              y: Math.degrees(parent.cameraRotation.y),
              z: Math.degrees(parent.cameraRotation.z),
              link: makeEulerLink(parent, "cameraRotation"),
            }),
            (obj.viewportFocus = {
              x: parent.viewportFocus.x,
              y: parent.viewportFocus.y,
              link: parent.viewportFocus,
            });
          let camera = layer.classRef;
          (camera.manualRender = !0), _cameras.push(camera);
        }
        return (
          UIL.global &&
            (_meshes || (_meshes = []),
            (layer._uilLayerName = layerName),
            _meshes.push(layer)),
          parent?.tweenToggle &&
            (obj.toggle = {
              on: 0,
              link: {
                copy: (e) => {
                  0 == e.on && parent.flag("tweenToggle")
                    ? (parent.flag("tweenToggle", !1),
                      parent.events.fire(TweenUIL.TOGGLE, { on: !1 }))
                    : 1 != e.on ||
                      parent.flag("tweenToggle") ||
                      (parent.events.fire(TweenUIL.TOGGLE, { on: !0 }),
                      parent.flag("tweenToggle", !0));
                },
              },
            }),
          obj
        );
      }
      function getShaderObject(shader) {
        let obj = {};
        for (let key in shader.uniforms) {
          let uniform = shader.uniforms[key],
            value = uniform.value;
          void 0 === value ||
            (uniform.ignoreUIL && !uniform.enableTweenUIL) ||
            "HZ" == key ||
            ("number" == typeof value
              ? (obj[key] = { value: value, link: uniform })
              : value instanceof Vector2
              ? (obj[key] = { x: value.x, y: value.y, link: value })
              : value instanceof Vector3
              ? (obj[key] = { x: value.x, y: value.y, z: value.z, link: value })
              : value instanceof Vector4
              ? (obj[key] = {
                  x: value.x,
                  y: value.y,
                  z: value.z,
                  w: value.w,
                  link: value,
                })
              : value instanceof Color &&
                (obj[key] = {
                  r: value.r,
                  g: value.g,
                  b: value.b,
                  a: 1,
                  link: value,
                }));
        }
        return obj;
      }
      function isElement(object) {
        return (
          !!object?.div?.hydraObject ||
          (void 0 !== GLUIObject &&
            (object instanceof GLUIObject || object instanceof GLUIText))
        );
      }
      function getElementObject($element) {
        let obj = { _config: { nudgeMultiplier: 1 } };
        return (
          void 0 !== $element.x &&
            (obj.x = { value: $element.x, link: $element }),
          void 0 !== $element.y &&
            (obj.y = { value: $element.y, link: $element }),
          void 0 !== $element.z &&
            (obj.z = { value: $element.z, link: $element }),
          void 0 !== $element.scale &&
            (obj.scale = { value: $element.scale, link: $element }),
          void 0 !== $element.scaleX &&
            (obj.scaleX = { value: $element.scaleX, link: $element }),
          void 0 !== $element.scaleY &&
            (obj.scaleY = { value: $element.scaleY, link: $element }),
          void 0 !== $element.rotation &&
            (obj.rotation = { value: $element.rotation, link: $element }),
          void 0 !== $element.rotationX &&
            (obj.rotationX = { value: $element.rotationX, link: $element }),
          void 0 !== $element.rotationY &&
            (obj.rotationY = { value: $element.rotationY, link: $element }),
          void 0 !== $element.rotationZ &&
            (obj.rotationZ = { value: $element.rotationZ, link: $element }),
          void 0 !== $element.alpha &&
            (obj.alpha = { value: $element.alpha, link: $element }),
          obj
        );
      }
      function getPlainObject(object) {
        let obj = {};
        for (let key in object) {
          let value = object[key];
          "number" == typeof value
            ? (obj[key] = { value: value, link: object })
            : value instanceof Vector2
            ? (obj[key] = { x: value.x, y: value.y, link: value })
            : value instanceof Vector3
            ? (obj[key] = { x: value.x, y: value.y, z: value.z, link: value })
            : value instanceof Vector4
            ? (obj[key] = {
                x: value.x,
                y: value.y,
                z: value.z,
                w: value.w,
                link: value,
              })
            : value instanceof Color &&
              (obj[key] = {
                r: value.r,
                g: value.g,
                b: value.b,
                a: 1,
                link: value,
              });
        }
        if (Object.keys(obj).length) return obj;
      }
      async function getObjectsFromLayout(layout) {
        let layers = await layout.getAllLayers(),
          objects = {};
        for (let key in layers) {
          let layer = layers[key];
          ignoreObject(key, layout.name) ||
            (!1 !== layer.animates &&
              (layer.ready && !layer.disabled && (await layer.ready()),
              (objects[key] = layer)));
        }
        return objects;
      }
      function createSheetFromObjects(
        objects,
        layoutName,
        { isSceneLayout: isSceneLayout }
      ) {
        let sheet = {};
        for (let name in objects) {
          let object = objects[name],
            key = `${layoutName}&${name}`;
          if (ignoreObject(name)) continue;
          let matched = !1;
          if (object.uniforms)
            _flatMap[key] = sheet[key] = getShaderObject(object);
          else if (isElement(object))
            _flatMap[key] = sheet[key] = getElementObject(object);
          else if (
            ((object instanceof Mesh || object instanceof Group) &&
              ((_flatMap[key] = sheet[key] = getMeshObject(object, null, key)),
              (matched = !0)),
            object.shader &&
              ((_flatMap[`${key}&shader`] = sheet[`${key}&shader`] =
                getShaderObject(object.shader)),
              (matched = !0)),
            object.behavior &&
              ((_flatMap[`${key}&behavior`] = sheet[`${key}&behavior`] =
                getShaderObject(object.behavior)),
              (matched = !0)),
            object.group &&
              ((_flatMap[key] = sheet[key] =
                getMeshObject(object.group, object, key)),
              (matched = !0)),
            !matched && !isSceneLayout)
          ) {
            let obj = getPlainObject(object);
            obj
              ? (_flatMap[key] = sheet[key] = obj)
              : console.warn(`Unclear how to animate object ${key}`, object);
          }
        }
        return sheet;
      }
      function makeSendable() {
        const cleanObject = (obj) => {
          let newObj = {};
          for (let key in obj) "link" != key && (newObj[key] = obj[key]);
          return newObj;
        };
        let obj = { sheets: [], nudgeMultiplier: _config.nudgeMultiplier };
        return (
          _audioFile && (obj.audioFile = _audioFile),
          (obj.filePath = Assets.getPath(`assets/data/timeline-${_name}.json`)),
          obj.filePath.includes("http") ||
            (obj.filePath = Hydra.absolutePath(obj.filePath)),
          _config.sheets.forEach((sheet) => {
            let newSheet = {};
            for (let key in sheet) {
              let top = sheet[key];
              newSheet[key] = {};
              for (let key2 in top)
                newSheet[key][key2] = cleanObject(top[key2]);
            }
            obj.sheets.push(newSheet);
          }),
          obj
        );
      }
      function completeDataLink(dataObj, realObj) {
        let transform;
        for (let key2 in realObj) {
          if ("_config" === key2) continue;
          let valueObj = dataObj[key2],
            link = realObj[key2].link;
          void 0 !== valueObj.value
            ? (!Object.prototype.hasOwnProperty.call(link, key2) &&
              Object.prototype.hasOwnProperty.call(link, "value")
                ? (link.value = valueObj.value)
                : (link[key2] = valueObj.value),
              (transform = link.transform),
              transform &&
                "alpha" == key2 &&
                link.css("opacity", valueObj.value))
            : link.copy(valueObj);
        }
        transform && transform();
      }
      function updateKeyframeData() {
        for (let key in _sheets)
          _this.keyframeTotalProgress =
            _keyframes.positionObject.position / _sheets[key].length;
        (_this.keyframeIndex = _keyframes.current),
          (_this.keyframeLocalProgress = Math.fract(
            _keyframes.positionObject.position
          ));
      }
      function updateKeyframeLoop(hz) {
        _keyframes.positionObject.position = Math.lerp(
          _keyframes.positionObject.target,
          _keyframes.positionObject.position,
          0.07 * hz,
          !1
        );
        for (let key in _sheets)
          _sheets[key].sequence.position = _keyframes.positionObject.position;
        updateKeyframeData();
      }
      !(async function () {})(),
        (this.play = async function (options) {
          return await _this.wait("ready"), play(options);
        }),
        (this.seek = function (value) {
          if (_this.flag("ready")) {
            checkDuration();
            for (let key in _sheets)
              _sheets[key].sequence.position = Math.min(
                _sheets[key].length,
                _duration * value
              );
          }
        }),
        (this.seekImmediate = function (value) {
          _this.seek(value), loop();
        }),
        (this.promise = async function () {
          return await _this.wait("ready"), _promise;
        }),
        (this.setLabel = function (label) {
          _input && _input.setLabel(label);
        }),
        (this.preload = async function () {
          if ((await _this.wait("ready"), _config.sheets)) {
            if (!_this.flag("isLoaded")) return _this.wait("isLoaded");
          } else await prepareConfig(), linkLocally();
          _this.seek(0);
        }),
        (this.loaded = async function () {
          if (!_this.flag("isLoaded") && _config.sheets)
            return _this.wait("isLoaded");
          await _this.preload();
        }),
        (this.seekToKeyframe = async function (index) {
          if ((_this.flag("isLoaded") || (await _this.preload()), !_keyframes))
            return console.warn(
              "TweenUILConfig :: Missing keyframes! Add tween_anchor layer"
            );
          (_keyframes.current = index),
            (_keyframes.positionObject = {
              position: _keyframes[index].position,
              target: _keyframes[index].position,
            }),
            _this.seek(_keyframes[index].position),
            updateKeyframeData(),
            _this.startRender(
              updateKeyframeLoop,
              RenderManager.NATIVE_FRAMERATE
            );
        }),
        (this.playToKeyframe = async function (
          index,
          time,
          ease = "linear",
          delay
        ) {
          await _this.wait("ready"),
            _keyframes.positionObject || (await _this.seekToKeyframe(0));
          let nextKeyframe = _keyframes[index],
            currentKeyframe = _keyframes[_keyframes.current];
          if (!nextKeyframe) return;
          let position = nextKeyframe.position;
          return (
            time ||
              (time =
                1e3 *
                Math.abs(nextKeyframe.position - currentKeyframe.position)),
            _keyframes.tween &&
              (_keyframes.tween = clearTween(_keyframes.tween)),
            (_keyframes.current = index),
            _this.flag("playingToKeyframe", !0, time + 50),
            (_keyframes.tween = tween(
              _keyframes.positionObject,
              { target: position },
              time,
              ease,
              delay
            )),
            _keyframes.tween.promise()
          );
        }),
        (this.peekInKeyframeDirection = function (dir, percent) {
          if (!_keyframes || _this.flag("playingToKeyframe")) return;
          let currentKeyframe = _keyframes[_keyframes.current],
            nextKeyframe = _keyframes[_keyframes.current + dir];
          nextKeyframe &&
            (_keyframes.positionObject.target = Math.mix(
              currentKeyframe.position,
              nextKeyframe.position,
              percent
            ));
        }),
        (this.playToNextKeyframe = async function (time, ease, delay) {
          return this.playToKeyframe(_keyframes.current + 1, time, ease, delay);
        }),
        (this.playToPrevKeyframe = async function (time, ease, delay) {
          return this.playToKeyframe(_keyframes.current - 1, time, ease, delay);
        }),
        (this.playToDirKeyframe = async function (dir, time, ease, delay) {
          return this.playToKeyframe(
            _keyframes.current + dir,
            time,
            ease,
            delay
          );
        }),
        this.get("position", (_) => {
          let position = 0;
          for (let key in _sheets)
            position = Math.max(
              position,
              _sheets[key]?.sequence?.position || 0
            );
          return (
            _this.state.editorOpen && (position = _this.state.editorPosition),
            position
          );
        }),
        this.get(
          "progress",
          (_) => (checkDuration(), _this.position / _duration)
        ),
        _this.get("duration", () => _duration),
        this.get("totalKeyframes", (_) => (_keyframes ? _keyframes.length : 0)),
        this.get("currentKeyframe", (_) =>
          _keyframes ? _keyframes.current : 0
        ),
        this.get("keyframeValue", (_) => {
          if (!_keyframes) return 0;
          let position = _this.position;
          for (let i = 0; i < _keyframes.length; ++i) {
            let keyframe = _keyframes[i];
            if (position >= keyframe.position) {
              let nextKeyframe = _keyframes[i + 1];
              if (!nextKeyframe) return keyframe.value;
              if (position < nextKeyframe.position)
                return Math.range(
                  position,
                  keyframe.position,
                  nextKeyframe.position,
                  keyframe.value,
                  nextKeyframe.value,
                  !0
                );
            }
          }
          return _keyframes[0]?.value || 0;
        }),
        _this.get("keyframeSection", (_) => Math.fract(_this.keyframeValue)),
        (_this.getPositionAtKeyframeValue = (keyframeValue) => {
          let index = Math.floor(keyframeValue),
            position = _keyframes[index]?.position || 0,
            progress = Math.fract(keyframeValue);
          if (progress) {
            let nextPosition = _keyframes[index + 1]?.position;
            nextPosition &&
              (position = Math.mix(position, nextPosition, progress));
          }
          return position;
        }),
        (_this.getProgressAtKeyframeValue = (keyframeValue) => (
          checkDuration(),
          _this.getPositionAtKeyframeValue(keyframeValue) / _duration
        )),
        (_this.getTrackData = function (objectName) {
          for (let key in _savedState.sheetsById) {
            let tracks = _savedState.sheetsById[key].sequence.tracksByObject;
            if (tracks[objectName]) return tracks[objectName];
          }
        }),
        this.get("manualRender", () => _manualRender),
        this.set("manualRender", (value) => {
          (value = !!value) !== _manualRender &&
            ((_manualRender = value)
              ? _this.stopRender(loop)
              : _this.startRender(loop));
        }),
        this.get("sheets", () => _sheets),
        (_this.update = () => {
          _manualRender ||
            !Hydra.LOCAL ||
            _this.flag("manualRenderWarned") ||
            (console.warn(
              "Set manualRender to true if using TweenUIL.update()"
            ),
            _this.flag("manualRenderWarned", !0)),
            loop();
        }),
        (_this.setAudio = async function (path) {
          await _this.loaded();
          let source = Assets.getPath(path);
          for (let sheet in _this.sheets)
            _this.sheets[sheet].sequence.attachAudio({ source: source });
          (_audioFile = source), _config && (_config.audioFile = source);
        });
    },
    () => {
      (TweenUIL.BEFORE_UPDATE = "TweenUIL.BEFORE_UPDATE"),
        (TweenUIL.UPDATED = "TweenUIL.UPDATED");
    }
  ),
  Class(function UILFile(_offline, _path) {
    Inherit(this, Component);
    (this.load = async function () {
      let path = window.UIL_STATIC_PATH || "assets/data/uil.json";
      try {
        let data = await get(path);
        return "string" == typeof data ? (Hydra.LOCAL ? null : {}) : data;
      } catch (e) {
        return {};
      }
    }),
      (this.save = async function (sessionData, data) {
        if (
          (Dev.writeFile(
            window.UIL_STATIC_PATH || "assets/data/uil.json",
            data
          ),
          _offline)
        ) {
          let partial = {};
          try {
            partial = await get("assets/data/uil-partial.json", data);
            for (let key in sessionData) partial[key] = sessionData[key];
          } catch (e) {
            partial = sessionData;
          }
          Dev.writeFile("assets/data/uil-partial.json", partial),
            Storage.set("uil_update_partial", !0);
        }
      });
  }),
  Class(function UILStorage() {
    Inherit(this, Component);
    const _this = this;
    var _storage,
      _platform,
      _fs,
      _keys,
      _storeIds = [],
      _data = {},
      _dataSession = {},
      _id = window.UIL_ID || "default",
      _remote = window.UIL_REMOTE || !1;
    (window.UIL_ID = _id = _id.replaceAll(/[^a-zA-Z0-9 _-]/g, "")),
      (this.SAVE = "uil_save");
    const OFFLINE_FIREBASE = Utils.query("offlineFB");
    function clearOfflineData() {
      Storage.set("uil_update_partial", !1),
        Dev.writeFile("assets/data/uil-partial.json", {});
    }
    async function init() {
      _fs && _fs.destroy(),
        (_fs = _this.initClass(
          uilFile() ? UILFile : UILRemote,
          OFFLINE_FIREBASE
        ));
      let data = await _fs.load();
      if (null === data) {
        let remoteFs = _this.initClass(UILRemote),
          remoteData = await remoteFs.load();
        confirm(
          "Looks like the local uil.json has merge conflicts, do you want to sync from Firebase and resolve it?"
        )
          ? ((_data[_id] = remoteData), await write(), window.location.reload())
          : (data = {});
      }
      if (
        ((_data[_id] = data),
        (_this.loaded = !0),
        !OFFLINE_FIREBASE && Storage.get("uil_update_partial") && !uilFile())
      ) {
        if (
          !confirm(
            "Looks like you have UIL data captured offline, do you want to sync it to Firebase?"
          )
        )
          return clearOfflineData();
        let data = await get("assets/data/uil-partial.json");
        for (let key in data) _this.set(key, data[key]);
        write(!0, !0), clearOfflineData();
      }
    }
    async function write(direct, silent) {
      let prevent = !1,
        e = { prevent: (_) => (prevent = !0) };
      _this.events.fire(_this.SAVE, e),
        (!direct && (e.wait && (await e.wait()), prevent)) ||
          (_fs.save(_dataSession, _data[_id]),
          (_dataSession = {}),
          silent ||
            (__body.css({ display: "none" }),
            _this.delayedCall(() => {
              __body.css({ display: "block" });
            }, 100)));
    }
    function uilFile() {
      return (
        !Utils.query("editMode") &&
        (!Hydra.LOCAL ||
          (!(window.Config && Config.PLATFORM_CONFIG && Utils.query("uil")) &&
            (!!Device.mobile ||
              !!OFFLINE_FIREBASE ||
              !(!window._BUILT_ || Hydra.LOCAL) ||
              !!window.AURA ||
              !!window._UIL_FILE_ ||
              (!window._FIREBASE_UIL_ && !window.UIL_ID) ||
              (!Device.detect("hydra") && !Utils.query("uil")))))
      );
    }
    Hydra.ready(async (_) => {
      window.Platform && Platform.isDreamPlatform && Config.PLATFORM_CONFIG
        ? (async function initLocalCached() {
            (_fs = _this.initClass(UILFile)),
              (_data[_id] = await _fs.load()),
              (_this.loaded = !0);
          })()
        : (Hydra.LOCAL && window.Platform && window.Platform.isPlatform) ||
          init(),
        (Utils.query("editMode") ||
          (Hydra.LOCAL &&
            window.Platform &&
            window.Platform.isDreamPlatform &&
            Utils.query("uil")) ||
          (Hydra.LOCAL &&
            !Device.mobile &&
            !window._BUILT_ &&
            (Utils.query("uil") || Device.detect("hydra")))) &&
          __window.bind("keydown", (e) => {
            (e.ctrlKey || e.metaKey) &&
              83 == e.keyCode &&
              (e.preventDefault(), write());
          });
    }),
      (this.reload = function (id, path, persist) {
        (_this.loaded = !1),
          _platform || (_platform = _id),
          persist && _storeIds.push(id),
          (_id = id),
          (window.UIL_ID = id),
          (window.UIL_STATIC_PATH = path),
          init();
      }),
      (this.set = function (key, value) {
        null === value
          ? (delete _data[_id][key], (_dataSession[key] = value))
          : ((_data[_id][key] = value), (_dataSession[key] = value));
      }),
      (this.setWrite = function (key, value) {
        this.set(key, value), write(!0);
      }),
      (this.clearMatch = function (string) {
        for (let key in _data[_id])
          key.includes(string) && delete _data[_id][key];
        write(!0);
      }),
      (this.write = function (silent) {
        write(!0, silent);
      }),
      (this.get = function (key) {
        let val = _data[_id] && _data[_id][key];
        if (
          (void 0 === val && _platform && (val = _data[_platform][key]),
          void 0 === val && _storeIds)
        )
          for (let i = 0; i < _storeIds.length; i++)
            try {
              val = _data[_storeIds[i]][key];
            } catch (e) {
              val = void 0;
            }
        return val;
      }),
      (this.ready = function () {
        return _this.wait(_this, "loaded");
      }),
      (this.getKeys = function () {
        return _keys || (_keys = Object.keys(_data[_id])), _keys;
      }),
      (this.hasData = function () {
        return !!_data[_id];
      }),
      (_this.uploadFileToRemoteBucket = async function ({
        file: file,
        progress: progress,
      }) {
        if (!_remote) return;
        _storage ||
          (await Services.ready(), (_storage = Services.app().storage()));
        let filename = file.name.replace(/ /g, "_");
        const ref = _storage.ref(`_tmp/${filename}`),
          path =
            `https://storage.googleapis.com/${ref.bucket}/uploads/${_id}/${filename}`.toLowerCase(),
          metadata = {
            customMetadata: { id: _id, path: path, contentType: file.type },
          },
          result = ref.put(file, metadata);
        let exists;
        for (
          progress &&
          result.on(
            "state_changed",
            (snapshot) => {
              let _progress =
                (snapshot.bytesTransferred / snapshot.totalBytes) * 95;
              progress.css({ width: _progress + "%" });
            },
            (error) => {
              err && console.log(error), progress.css({ width: 0 });
            },
            () => {
              progress.css({ width: 0 });
            }
          );
          !exists;

        )
          try {
            (await fetch(path).then((r) => r.ok)) && (exists = !0);
          } catch (err) {
            exists = !1;
          }
        return metadata;
      }),
      (this.parse = function (key, hint) {
        let data = _data[_id][key];
        if (void 0 === data) return null;
        if (Array.isArray(data)) {
          if (hint instanceof Vector2)
            return { value: new Vector2().fromArray(data) };
          if (hint instanceof Vector3)
            return { value: new Vector3().fromArray(data) };
          if (hint instanceof Vector4)
            return { value: new Vector4().fromArray(data) };
        } else if ("string" == typeof data && "#" === data.charAt(0))
          return { value: new Color(data) };
        return { value: data };
      });
  }, "static"),
  Class(function UILClipboard() {
    Inherit(this, Component);
    var _store = {};
    (this.copy = function (folders) {
      _store = {};
      for (let key in folders) {
        let folder = folders[key];
        _store[folder.label] = folder.value;
      }
    }),
      (this.paste = function (folders) {
        for (let key in folders) {
          let folder = folders[key];
          folder &&
            null != _store[folder.label] &&
            (key.includes("name") ||
              key.includes("shader") ||
              (folder.force(_store[folder.label], !0), folder.finish()));
        }
      }),
      this.get("store", (_) => _store);
  }, "static"),
  Class(
    function UILControl() {
      Inherit(this, Element);
      const _this = this;
      let $this,
        $label,
        $content,
        $view,
        _value,
        _previous,
        _label,
        _opts,
        _visible = !0,
        _onChange = () => {},
        _onFinishChange = () => {};
      function isEqual(a, b) {
        return Array.isArray(a) || Array.isArray(b)
          ? a + "" == b + ""
          : "object" == typeof a || "object" == typeof b
          ? JSON.stringify(a) === JSON.stringify(b)
          : a === b;
      }
      function clone(value) {
        return Array.isArray(value)
          ? [...value]
          : "object" == typeof value
          ? Object.assign({}, value)
          : value;
      }
      !(function initHTML() {
        ($this = _this.element),
          $this.size("100%", "auto"),
          $this.css({
            position: "relative",
            display: "inline-block",
            borderBottom: "1px solid #161616",
            padding: "2px 0",
            boxSizing: "border-box",
          }),
          $this.attr("data-type", "UILControl"),
          ($this.div._this = _this);
      })(),
        (function initLabel() {
          ($label = $this.create("label")),
            $label.size("100px", "auto").fontStyle("sans-serif", 12, "#9B9C9B"),
            $label.css({
              paddingLeft: 4,
              paddingTop: 2,
              boxSizing: "border-box",
              verticalAlign: "top",
              float: "left",
              wordBreak: "break-all",
            }),
            (_this.$label = $label);
        })(),
        (function initContent() {
          ($content = $this.create("content")),
            $content.size("calc(100% - 100px)", "auto").css({ float: "left" }),
            (_this.$content = $content);
        })(),
        (this.init = function (id, opts = {}) {
          (_this.id = id),
            (_opts = opts),
            (_value = clone(opts.value)),
            (_previous = clone(_value)),
            _this.setLabel(opts.label || id),
            $this.attr("data-id", id);
        }),
        (this.finish = function (history = !0) {
          _onFinishChange(_value),
            isEqual(_value, _previous) ||
              (history && UILHistory.set(_this, _previous),
              UILLocalStorage.set(_this.id, _value),
              (_previous = clone(_value)));
        }),
        (this.force = function (value) {
          (_this.value = clone(value)), _this.finish(!1);
        }),
        (this.debounce = function (callback, time = 250) {
          let interval;
          return (...args) => {
            clearTimeout(interval),
              (interval = setTimeout(() => {
                (interval = null), callback(...args);
              }, time));
          };
        }),
        (this.onChange = function (cb) {
          return (_onChange = cb), _this;
        }),
        (this.onFinishChange = function (cb) {
          return (_onFinishChange = cb), _this;
        }),
        this.get("value", () => _value),
        this.set("value", (value) => {
          isEqual(value, _value) ||
            ((_value = clone(value)),
            _this.update && _this.update(_value),
            _onChange(_value));
        }),
        this.get("view", () => $view),
        this.set("view", (view) => {
          $view && $view.destroy(), ($view = view), $content.add($view);
        }),
        (this.hide = function () {
          return (_visible = !1), $this.css({ display: "none" }), _this;
        }),
        (this.show = function () {
          return (_visible = !0), $this.css({ display: "inline-block" }), _this;
        }),
        (this.isVisible = function () {
          return _visible;
        }),
        (this.setLabel = function (label) {
          (_label = label), (_this.label = label);
          let title = label;
          if (_opts.description) {
            title = title + "\n" + _opts.description;
            let $span = $("icon").css({
              verticalAlign: "middle",
              display: "inline-block",
              paddingTop: 1,
            });
            $span.html(UILControl.infoIcon),
              $label.text(label + " "),
              $label.add($span);
          } else $label.text(label);
          $label.attr("title", title);
        }),
        (this.setDescription = function (desc) {
          $label.attr("title", desc);
        });
    },
    () => {
      UILControl.infoIcon =
        '<span><svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"/><path d="M9 9a3 3 0 016 1c0 2-3 3-3 3M12 17h0"/></svg></span>';
    }
  ),
  Class(function UILFolder(_id, _opts = { drag: !0 }) {
    Inherit(this, Element);
    const _this = this;
    let $this,
      $header,
      $container,
      $toggle,
      $drag,
      $title,
      _children = {},
      _open = !_opts.closed,
      _visible = !0,
      _order = [],
      _draggable = !1,
      _sortableChildren = !1,
      _headerDrag = !1;
    var _hasClipboard = !1;
    (_this.id = _id),
      (_this.label = `${_opts.label || _id}`),
      (_this.level = -1);
    const RECURSIVE_CLOSE = !0;
    function removeDragHandlers() {
      $this.div.removeEventListener("dragstart", dragStart, !1),
        $this.div.removeEventListener("dragover", dragOver, !1),
        $this.div.removeEventListener("drop", drop, !1);
    }
    function matchItem(str, item) {
      return (
        UILFuzzySearch.search(str, item.id.toLowerCase()) ||
        UILFuzzySearch.search(str, item.label.toLowerCase())
      );
    }
    function dragStart(e) {
      if (!UILFolder.DragLock) {
        if (!_headerDrag) return e.preventDefault(), void e.stopPropagation();
        (UILFolder.DragLock = _this.id),
          e.dataTransfer.setData("text/plain", _this.id),
          (e.dataTransfer.effectAllowed = "move"),
          $this.css({ opacity: 0.5 });
      }
    }
    function dragOver(e) {
      e.preventDefault(), (e.dataTransfer.dropEffect = "move");
    }
    function drop(e) {
      if (!UILFolder.DragLock) return;
      if (e.dataTransfer.items)
        for (var i = 0; i < e.dataTransfer.items.length; i++)
          if ("file" === e.dataTransfer.items[i].kind) return;
      e.preventDefault(), (_headerDrag = !1);
      let target = e.currentTarget._this,
        dragging = _this.parent.get(UILFolder.DragLock);
      (UILFolder.DragLock = null),
        target &&
          target.parent &&
          dragging &&
          (dragging.element.css({ opacity: 1 }),
          dragging.parent.get(target.id) &&
            (e.stopPropagation(),
            target.parent.container.insertBefore(
              dragging.element.div,
              target.element.div
            ),
            (_order = [...target.parent.container.childNodes].map(
              (el) => el._this.id
            )),
            _this.events.fire(UIL.REORDER, { order: [..._order] }),
            (function saveSort() {
              UILStorage.set(
                `UIL_${UIL.sortKey}_${_this.parent.id}_order`,
                JSON.stringify(_order)
              );
            })()));
    }
    function getUrlID() {
      return `${Global.PLAYGROUND || "Global"}_folder_${_id}`;
    }
    function saveFolderState() {
      sessionStorage.setItem(getUrlID(), JSON.stringify({ open: _open }));
    }
    function open(keepClosed = !1) {
      (_open = !0),
        $container.css({ display: "flex" }),
        $toggle && $toggle.text("▼"),
        RECURSIVE_CLOSE && 1 != keepClosed && forEachFolder((f) => f.close()),
        saveFolderState(),
        _this.onOpen && _this.onOpen();
    }
    function close() {
      (_open = !1),
        $container.css({ display: "none" }),
        $toggle && $toggle.text("▶"),
        saveFolderState();
    }
    function onToggle(e) {
      _open ? close() : open();
    }
    function onMouseDown(e) {
      (_headerDrag = !0), $header.div.addEventListener("mouseup", onMouseUp);
    }
    function onMouseUp(e) {
      (_headerDrag = !1), $header.div.removeEventListener("mouseup", onMouseUp);
    }
    function onKeydown(e) {
      13 === e.which && (_open ? close() : open());
    }
    function onKeyup(e) {
      _hasClipboard &&
        ("c" == e.key && e.metaKey
          ? (function onCopy() {
              UILClipboard.copy(_children);
            })()
          : "v" == e.key &&
            e.metaKey &&
            (function onPaste() {
              UILClipboard.paste(_children);
            })());
    }
    function onFocus() {
      $this.css({ border: "1px solid #37a1ef" }),
        $this.div.classList.add("active"),
        (_hasClipboard = !0);
    }
    function onBlur() {
      $this.css({ border: "none", border: "1px solid #161616" }),
        $this.div.classList.remove("active"),
        (_hasClipboard = !1);
    }
    function forEachFolder(cb) {
      return (
        Object.values(_children).forEach((el) => {
          el instanceof UILFolder && (cb(el), el.forEachFolder(cb));
        }),
        _this
      );
    }
    !(function init() {
      ($this = _this.element),
        $this.size("100%", "auto").bg(_opts.background || "#272727"),
        $this.css({
          position: "relative",
          border: "1px solid #161616",
          boxSizing: "border-box",
          maxHeight: _opts.maxHeight || "none",
        }),
        $this.attr("data-id", _id),
        $this.attr("data-type", "UILFolder"),
        ($this.div._this = _this);
    })(),
      (function style() {
        UIL.addCSS(
          UILFolder,
          "\n            .UILFolder *:focus { outline: none; }\n            .UILFolder input:focus { border-color:#37a1ef!important; }\n            .UILFolder button:focus { border-color:#37a1ef!important; }\n            .UILFolder .UILFolder .UILFolder .toggle {margin-left:8px; }\n            .UILFolder .UILFolder .UILFolder .UILFolder .toggle {margin-left:16px; }\n            .UILFolder .UILFolder .UILFolder .UILFolder .UILFolder .toggle {margin-left:24px; }\n            .UILFolder .UILFolder .UILFolder .UILFolder .UILFolder .UILFolder .toggle {margin-left:32px; }\n            .UILFolder .UILFolder .UILFolder .UILFolder .UILFolder .UILFolder .UILFolder .toggle {margin-left:40px; }\n        "
        );
      })(),
      (function initHeader() {
        _opts.hideTitle ||
          (($header = $this.create("title", "a")),
          $header.attr("tabindex", "0"),
          $header.size("100%", "auto").bg("#272727"),
          $header.css({
            display: "block",
            padding: "4px 4px",
            boxSizing: "border-box",
            fontWeight: "bold",
            userSelect: "none",
            borderBottom: "1px solid #161616",
          }),
          $header.fontStyle("sans-serif", 11, "#B1B1B1"),
          $header.div.addEventListener("keydown", onKeydown, !1),
          $header.div.addEventListener("click", onToggle, !1),
          $header.div.addEventListener("mousedown", onMouseDown),
          $header.div.addEventListener("focus", onFocus, !1),
          $header.div.addEventListener("blur", onBlur, !1),
          $header.div.addEventListener("keydown", onKeyup, !1),
          ($toggle = $header.create("toggle")),
          $toggle
            .text(_open ? "▼" : "▶")
            .css({
              fontSize: 8,
              display: "inline-block",
              verticalAlign: "middle",
            }),
          ($drag = $header.create("drag")),
          $drag
            .text("☰")
            .css({
              position: "absolute",
              right: 7,
              top: 3,
              display: "inline-block",
              pointerEvents: "none",
            }),
          $drag.hide(),
          ($title = $header.create("title")),
          $title
            .text(_this.label)
            .css({ display: "inline-block", marginLeft: 4 }));
      })(),
      (function initContainer() {
        ($container = $this.create("container")),
          $container
            .size("100%", "100%")
            .css({
              display: "flex",
              flexDirection: "column",
              position: "relative",
              overflowY: "auto",
            }),
          _open || $container.css({ display: "none" }),
          (_this.container = $container.div);
      })(),
      (function restoreFolderState() {
        let json = JSON.parse(sessionStorage.getItem(getUrlID()));
        json && (json.open ? open() : close());
      })(),
      (this.add = function (child) {
        return (
          child.draggable && child.draggable(_sortableChildren),
          (child.parent = _this),
          (_children[child.id] = child),
          $container.add(child),
          _this
        );
      }),
      (this.remove = function (x) {
        let id = "string" == typeof x ? x : x.id,
          child = _children[id];
        if (!child)
          for (let key in _children)
            if (key.includes(x)) {
              (child = _children[key]), delete _children[key];
              break;
            }
        if (child)
          return (
            child.eliminate && child.eliminate(),
            child.destroy(),
            _order && (_order = _order.filter((child) => child !== id)),
            delete _children[id],
            _this
          );
      }),
      (this.get = function (id) {
        return _children[id];
      }),
      (this.getAll = function () {
        return Object.values(_children);
      }),
      (this.getVisible = function () {
        return Object.values(_children).filter((x) => x.isVisible());
      }),
      (this.find = function (id) {
        return id === _id
          ? _this
          : Object.values(_children).reduce(
              (acc, item) =>
                item.id === id
                  ? acc.concat(item)
                  : item instanceof UILFolder
                  ? acc.concat(item.find(id))
                  : acc,
              []
            );
      }),
      (this.filter = function (str) {
        return (function filter(str, match = !1) {
          str = str.toLowerCase();
          let result = [],
            haystack = Object.values(_children);
          for (let el of haystack)
            if (el instanceof UILFolder) {
              let matches = el.filter(str, !0);
              matches.length
                ? (result.concat(matches), el.show(), el.open())
                : matchItem(str, el)
                ? (result.push(el), el.show(), el.showChildren(), el.close())
                : el.getVisible().length
                ? el.show()
                : el.hide();
            } else
              matchItem(str, el) ? (result.push(el), el.show()) : el.hide();
          return result;
        })(str);
      }),
      (this.filterSingle = function filterSingle(str) {
        str = str.toLowerCase();
        let haystack = Object.values(_children);
        for (let el of haystack)
          el instanceof UILFolder
            ? (el.filterSingle(str),
              str == el.label.toLowerCase() || str == el.id.toLowerCase()
                ? (el.show(), el.showChildren(), el.open(!0))
                : el.getVisible().length
                ? el.show()
                : el.hide())
            : matchItem(str, el)
            ? (el.show(), el.open && el.open(!0))
            : el.hide();
        return [];
      }),
      (this.open = function (keepClosed) {
        return open(keepClosed), _this;
      }),
      (this.close = function () {
        return close(), _this;
      }),
      (this.setLabel = function (label) {
        return (_this.label = `${label}`), $title.text(label), _this;
      }),
      (this.hide = function () {
        return (_visible = !1), $this.css({ display: "none" }), _this;
      }),
      (this.show = function () {
        return (_visible = !0), $this.css({ display: "block" }), _this;
      }),
      (this.showChildren = function () {
        return (
          Object.values(_children).forEach((el) =>
            el instanceof UILFolder ? el.showChildren() : el.show()
          ),
          _this.show(),
          _this
        );
      }),
      (this.isOpen = function () {
        return _open;
      }),
      (this.isVisible = function () {
        return _visible;
      }),
      (this.forEachFolder = function (cb) {
        return forEachFolder(cb);
      }),
      (this.forEachControl = function (cb) {
        return (
          Object.values(_children).forEach((el) => {
            el instanceof UILFolder ? el.forEachControl(cb) : cb(el);
          }),
          _this
        );
      }),
      (this.enableSorting = function (key) {
        (_sortableChildren = !0),
          (UIL.sortKey = key),
          Object.values(_children).forEach((el) => {
            el instanceof UILFolder && el.draggable(!0);
          });
        let order = (function getSort() {
          let sort = UILStorage.get(`UIL_${UIL.sortKey}_${_id}_order`);
          if (sort) return JSON.parse(sort);
        })();
        return (
          order &&
            ((_order = order),
            (function restoreSort() {
              _order.forEach((id) => {
                _children[id] && $container.add(_children[id]);
              });
            })()),
          _this
        );
      }),
      (this.draggable = function (enable) {
        (_draggable = enable),
          $this.attr("draggable", enable),
          enable
            ? (!(function addDragHandlers() {
                $this.div.addEventListener("dragstart", dragStart, !1),
                  $this.div.addEventListener("dragover", dragOver, !1),
                  $this.div.addEventListener("drop", drop, !1);
              })(),
              $drag && $drag.show())
            : (removeDragHandlers(), $drag && $drag.hide());
      }),
      (this.toClipboard = function () {
        UILClipboard.copy(_children);
      }),
      (this.fromClipboard = function () {
        UILClipboard.paste(_children);
      }),
      (this.eliminate = function () {
        _opts.hideTitle ||
          ($header.div.removeEventListener("keydown", onToggle, !1),
          $header.div.removeEventListener("click", onToggle, !1),
          $header.div.removeEventListener("mousedown", onMouseDown),
          $header.div.removeEventListener("focus", onFocus, !1),
          $header.div.removeEventListener("blur", onBlur, !1)),
          _draggable && removeDragHandlers();
      }),
      (this.forceSort = function (index) {
        _this.parent.container.insertBefore(
          _this.element.div,
          _this.parent.container.children[index]
        ),
          (_order = [..._this.parent.container.childNodes].map(
            (el) => el._this.id
          )),
          _this.events.fire(UIL.REORDER, { order: [..._order] });
      }),
      (this.openChildren = function () {
        Object.values(_children).forEach((el) =>
          el instanceof UILFolder ? el.open() : null
        );
      });
  }),
  Class(function UILPanel(_title, _opts = {}) {
    Inherit(this, Element);
    const _this = this;
    let $this,
      _folder,
      _toolbar,
      _hidden = !1;
    function onKeydown(e) {
      if (e.ctrlKey || e.metaKey) {
        if (72 == e.keyCode && e.shiftKey) {
          if (
            `${document.activeElement.type}`.includes([
              "textarea",
              "input",
              "number",
            ])
          )
            return;
          e.preventDefault(),
            _hidden
              ? (function show() {
                  $this.visible(), (_hidden = !1);
                })()
              : (function hide() {
                  $this.invisible(), (_hidden = !0);
                })();
        }
        37 == e.keyCode &&
          e.shiftKey &&
          (e.preventDefault(), $this.css({ left: 0, right: "auto" })),
          39 == e.keyCode &&
            e.shiftKey &&
            (e.preventDefault(), $this.css({ left: "auto", right: 0 })),
          67 == e.which &&
            e.shiftKey &&
            (e.preventDefault(), _folder.forEachFolder((f) => f.close())),
          79 == e.which &&
            e.shiftKey &&
            (e.preventDefault(), _folder.forEachFolder((f) => f.open()));
      }
    }
    function undim() {
      $this.css({ opacity: 1 });
    }
    function dim() {
      $this.css({ opacity: 0.6 });
    }
    "hide" in _opts || (_opts.hide = !0),
      (_this.id = _title),
      (function initHTML() {
        ($this = _this.element),
          $this
            .size(_opts.width || "300px", _opts.height || "auto")
            .bg("#161616")
            .mouseEnabled(!0),
          "left" === _opts.side
            ? $this.css({ left: 0 })
            : $this.css({ right: 0 }),
          $this.css({
            top: 0,
            maxHeight: _opts.maxHeight || "100%",
            position: "absolute",
            userSelect: "none",
            padding: 4,
            overflowY: "auto",
            borderRadius: 4,
          }),
          $this.hide(),
          ($this.div.className += " prevent_interaction3d");
      })(),
      (function initToolbar() {
        _toolbar = _this.toolbar = _this.initClass(UILPanelToolbar);
      })(),
      (function initGroup() {
        (_folder = _this.initClass(UILFolder, _title, {
          hideTitle: !0,
          drag: !1,
          background: "#161616",
        })),
          (_this.folder = _folder);
      })(),
      (function addHandlers() {
        document.addEventListener("keydown", onKeydown, !1),
          _opts.hide &&
            (dim(),
            $this.div.addEventListener("mouseover", undim, !1),
            $this.div.addEventListener("mouseleave", dim, !1));
      })(),
      (this.add = function (child) {
        return $this.show(), _folder.add(child), _this;
      }),
      (this.remove = function (x) {
        return _folder.remove(x.id), _this;
      }),
      (this.get = function (id) {
        return _folder.get(id);
      }),
      (this.find = function (id) {
        return _folder.find(id);
      }),
      (this.filter = function (str) {
        return _folder.filter(str);
      }),
      (this.enableSorting = function (key) {
        return _folder.enableSorting && _folder.enableSorting(key), _this;
      }),
      (this.eliminate = function () {
        _toolbar.eliminate(),
          $this.div.removeEventListener("mouseover", undim, !1),
          $this.div.removeEventListener("mouseleave", dim, !1),
          document.removeEventListener("keydown", onKeydown, !1);
      });
  }),
  Class(function UILWindow(_title, _opts = { hide: !1, drag: !0, resize: !0 }) {
    Inherit(this, Element);
    const _this = this;
    let $this,
      $header,
      $container,
      $toggle,
      $title,
      _folder,
      _hidden,
      _initialX,
      _initialY,
      _open = !_opts.closed,
      _x = _opts.left || 350,
      _y = _opts.top || 50,
      _xOffset = _x,
      _yOffset = _y,
      _dragging = !1;
    function hide() {
      $this && $this.invisible(),
        (_hidden = !0),
        _this.onClose && _this.onClose();
    }
    function show() {
      $this && $this.visible(), (_hidden = !1);
    }
    function onKeydown(e) {
      if (e.ctrlKey || e.metaKey) {
        if (72 == e.keyCode && e.shiftKey) {
          if (
            `${document.activeElement.type}`.includes([
              "textarea",
              "input",
              "number",
            ])
          )
            return;
          e.preventDefault(), _hidden ? show() : hide();
        }
        67 == e.which &&
          e.shiftKey &&
          (e.preventDefault(), _folder.forEachFolder((f) => f.close())),
          79 == e.which &&
            e.shiftKey &&
            (e.preventDefault(), _folder.forEachFolder((f) => f.open()));
      }
    }
    function onMouseDown(e) {
      e.preventDefault(),
        $header.css({ cursor: "move" }),
        (_initialX = e.clientX - _xOffset),
        (_initialY = e.clientY - _yOffset),
        (_dragging = !0),
        document.addEventListener("mousemove", onMouseMove, !1),
        document.addEventListener("mouseup", onMouseUp, !1);
    }
    function onMouseMove(e) {
      e.preventDefault(),
        (_x = e.clientX - _initialX),
        (_y = e.clientY - _initialY),
        (_xOffset = _x),
        (_yOffset = _y),
        $this.transform({ x: _x, y: _y });
    }
    function onMouseUp() {
      $header.css({ cursor: "" }),
        (_initialX = _x),
        (_initialY = _y),
        (_dragging = !1),
        document.removeEventListener("mousemove", onMouseMove, !1),
        document.removeEventListener("mouseup", onMouseUp, !1);
    }
    function onToggle(e) {
      ("click" !== e.type && 13 !== e.which) ||
        (_open
          ? (function close() {
              (_open = !1),
                $container.css({ display: "none" }),
                $toggle.text("▶");
            })()
          : (function open() {
              (_open = !0),
                $container.css({ display: "block" }),
                $toggle.text("▼");
            })());
    }
    function undim() {
      _dragging || $this.css({ opacity: 1 });
    }
    function dim() {
      _dragging || $this.css({ opacity: 0.3 });
    }
    (_this.id = _title),
      (function initHTML() {
        ($this = _this.element),
          $this.bg("#161616").transform({ x: _x, y: _y }).mouseEnabled(!0),
          $this.css({
            position: "absolute",
            userSelect: "none",
            overflowY: "auto",
            borderRadius: 4,
            maxHeight: _opts.maxHeight || "100%",
            border: "1px solid #2e2e2e",
          });
      })(),
      (function initHeader() {
        ($header = $this.create("header")),
          $header.size("100%", "auto").bg("#272727"),
          $header.css({
            display: "block",
            color: "#B1B1B1",
            padding: "4px 4px",
            boxSizing: "border-box",
            fontFamily: "sans-serif",
            fontSize: 11,
            fontWeight: "bold",
            userSelect: "none",
            minWidth: 200,
          }),
          ($toggle = $header.create("toggle")),
          $toggle
            .text(_open ? "▼" : "▶")
            .css({
              fontSize: 8,
              paddingLeft: 4,
              display: "inline-block",
              verticalAlign: "middle",
            }),
          $toggle.click(onToggle),
          ($title = $header.create("title")),
          $title
            .text(_opts.label || _title)
            .css({ display: "inline-block", marginLeft: 4 }),
          $title.click(onToggle);
        let $close = $header.create("close");
        $close
          .text("✕")
          .css({
            position: "absolute",
            right: 7,
            top: 5,
            display: "inline-block",
          }),
          $close.click(hide);
      })(),
      (function initContainer() {
        ($container = $this.create("container")),
          $container.size(_opts.width || "auto", _opts.height || "auto"),
          $container.css({
            position: "realtive",
            overflowY: "auto",
            padding: 4,
            boxSizing: "border-box",
            minWidth: _opts.minWidth || 0,
          }),
          _opts.resize &&
            $container.css({ resize: "both", minWidth: 200, minHeight: 60 }),
          _open || $container.css({ display: "none" });
      })(),
      (function initGroup() {
        (_folder = _this.initClass(
          UILFolder,
          _title,
          { hideTitle: !0, background: "#161616" },
          null
        )),
          (_this.folder = _folder),
          $container.add(_folder);
      })(),
      (function addHandlers() {
        document.addEventListener("keydown", onKeydown, !1),
          _opts.drag &&
            $header.div.addEventListener("mousedown", onMouseDown, !1),
          _opts.hide &&
            ($this.div.addEventListener("mouseover", undim, !1),
            $this.div.addEventListener("mouseleave", dim, !1));
      })(),
      (this.add = function (child) {
        return _folder.add(child), _this;
      }),
      (this.remove = function (x) {
        return _folder.remove(id), _this;
      }),
      (this.get = function (id) {
        return _folder.get(id);
      }),
      (this.find = function (id) {
        return _folder.find(id);
      }),
      (this.filter = function (str) {
        return _folder.filter(str);
      }),
      (this.show = function () {
        return show(), _this;
      }),
      (this.hide = function () {
        return hide(), _this;
      }),
      (this.isVisible = function () {
        return !_hidden;
      }),
      (this.enableSorting = function (key) {
        return _folder.enableSorting && _folder.enableSorting(key), _this;
      }),
      (this.eliminate = function () {
        _opts.drag &&
          $header.div.removeEventListener("mousedown", onMouseDown, !1),
          _opts.hide &&
            ($this.div.removeEventListener("mouseover", undim, !1),
            $this.div.removeEventListener("mouseleave", dim, !1)),
          document.removeEventListener("keydown", onKeydown, !1);
      });
  }),
  Class(function UILControlButton(_id, _opts = {}) {
    Inherit(this, UILControl);
    const _this = this;
    let $view,
      _buttons = [];
    !(function init() {
      _this.init(_id, _opts),
        _opts.hideLabel &&
          (_this.$label.css({ display: "none" }),
          _this.$content.css({ width: "100%" }));
    })(),
      (function initActions() {
        $view = $("inputs");
        let config = [].concat(_opts.actions);
        (_buttons = []
          .concat(_opts.actions)
          .map(({ title: title, callback: callback }) => {
            let btn = $view.create(`btn btn-${title}`, "button");
            return (
              btn.text(title).bg("#1d1d1d"),
              btn.css({
                width: `calc(100% / ${config.length || 1}`,
                border: "1px solid #2e2e2e",
                color: "#37a1ef",
                position: "relative",
              }),
              btn.interact((e) =>
                (function hover(btn, e) {
                  "over" === e.action
                    ? btn.css({ border: "1px solid #9b9c9b" })
                    : btn.css({ border: "1px solid #2e2e2e" });
                })(btn, e)
              ),
              btn.click((e) =>
                (function click(e, title, callback) {
                  (_this.value = title),
                    callback && callback(title, e),
                    _this.finish();
                })(e, title, callback)
              ),
              btn
            );
          })),
          (_this.view = $view);
      })(),
      (this.setTitle = function (text) {
        _buttons.forEach((btn) => {
          btn.text(text);
        });
      });
  }),
  Class(function UILControlCheckbox(_id, _opts = {}) {
    Inherit(this, UILControl);
    const _this = this;
    let $view, $label, $checkbox, $slider;
    function toggle() {
      $checkbox.attr("checked", _this.value),
        $slider.css({ right: _this.value ? 0 : "auto" }),
        $label.bg(_this.value ? "#37a1ef" : "#1d1d1d");
    }
    function click() {
      (_this.value = !_this.value), toggle(), _this.finish();
    }
    function focus() {
      $label.css({ border: "1px solid #37a1ef" });
    }
    function blur() {
      $label.css({ border: "1px solid #2e2e2e" });
    }
    !(function init() {
      (_opts.value = _opts.value || !1), _this.init(_id, _opts);
    })(),
      (function initView() {
        ($view = $("view")),
          ($label = $view.create("label", "label")),
          $label
            .size(30, 15)
            .css({
              position: "relative",
              display: "inline-block",
              borderRadius: 15,
              border: "1px solid #2e2e2e",
            })
            .bg(_this.value ? "#37a1ef" : "#1d1d1d"),
          ($checkbox = $label.create("checkbox", "input")),
          $checkbox.attr("type", "checkbox"),
          $checkbox.attr("checked", _this.value),
          $checkbox.css({ opacity: 0, width: "100%", position: "absolute" }),
          ($slider = $label.create("slider")),
          $slider
            .size(15, 15)
            .css({
              borderRadius: 15,
              position: "absolute",
              right: _this.value ? 0 : "auto",
              boxSizing: "border-box",
            })
            .bg("#ffffff"),
          (_this.view = $view);
      })(),
      (function addHandlers() {
        $checkbox.div.addEventListener("focus", focus, !1),
          $checkbox.div.addEventListener("blur", blur, !1),
          $checkbox.div.addEventListener("click", click, !1),
          $checkbox.div.addEventListener("keypress", click, !1);
      })(),
      (this.update = function () {
        toggle();
      }),
      (this.onDestroy = function () {
        $checkbox.div.removeEventListener("focus", focus, !1),
          $checkbox.div.removeEventListener("blur", blur, !1),
          $checkbox.div.removeEventListener("click", click, !1),
          $checkbox.div.removeEventListener("keypress", click, !1);
      });
  }),
  Class(function UILControlColor(_id, _opts = {}) {
    Inherit(this, UILControl);
    const _this = this;
    let $hex, $colorPicker, $hexInput, $colorInput;
    function syncColorValue(frame, hexUpdate = !1) {
      let needsUpdate = !0;
      hexUpdate
        ? $hexInput.div.value !== _this.value &&
          (_this.value = $hexInput.div.value)
        : $colorInput.div.value !== _this.value
        ? (_this.value = $colorInput.div.value)
        : (needsUpdate = !1),
        needsUpdate &&
          (($hexInput.div.value = _this.value),
          ($colorInput.div.value = _this.value),
          $colorPicker.bg(_this.value));
    }
    function onClick() {
      $colorInput.div.click(),
        $colorInput.div.focus(),
        _this.startRender(syncColorValue, 24);
    }
    function onTextFocus() {
      $hexInput.div.select();
    }
    function onColorBlur() {
      _this.stopRender(syncColorValue), finishChange();
    }
    function onChange(v) {
      syncColorValue(0, !0), finishChange();
    }
    function finishChange() {
      _this.finish();
    }
    !(function init() {
      (_opts.value = _opts.value || "#ffffff"), _this.init(_id, _opts);
    })(),
      (function initInput() {
        let $view = $("color");
        $view.css({ position: "relative", display: "flex" }),
          ($hex = $view.create("colorHex")),
          $hex.size("100%", "100%"),
          $hex.css({ boxSizing: "border-box", flex: "2", marginRight: 4 }),
          ($hexInput = $hex.create("hex", "input")),
          $hexInput
            .size("100%")
            .css({
              fontSize: 12,
              fontFamily: "sans-serif",
              padding: 1,
              color: "#37A1EF",
              border: "1px solid #2E2E2E",
            })
            .bg("#1D1D1D"),
          $hexInput.attr("value", _this.value),
          $hexInput.attr("maxlength", 7),
          ($colorPicker = $view.create("colorPicker")),
          $colorPicker.size("100%", "auto").bg(_this.value),
          $colorPicker.css({
            border: "1px solid #2E2E2E",
            position: "relative",
            flex: "3",
          }),
          ($colorInput = $colorPicker.create("colorInput", "input")),
          $colorInput.attr("type", "color"),
          $colorInput.attr("value", _this.value),
          $colorInput
            .size(0, 0)
            .css({ border: 0, top: 6, zIndex: -1, position: "absolute" }),
          (_this.view = $view);
      })(),
      (function addHandlers() {
        $colorPicker.interact(null, onClick),
          (finishChange = _this.debounce(finishChange, 250)),
          $hexInput.div.addEventListener("input", onChange, !1),
          $hexInput.div.addEventListener("focus", onTextFocus, !1),
          $hexInput.div.addEventListener("change", finishChange, !1),
          $colorInput.div.addEventListener("blur", onColorBlur, !1);
      })(),
      (this.force = function (value) {
        ($hexInput.div.value = value), syncColorValue(0, !0);
      }),
      (this.update = function () {
        $hexInput.attr("value", _this.value),
          $colorPicker.bg(_this.value),
          $colorInput.attr("value", _this.value),
          finishChange();
      }),
      (this.onDestroy = function () {
        $hexInput.div.removeEventListener("input", onChange, !1),
          $hexInput.div.removeEventListener("focus", onTextFocus, !1),
          $hexInput.div.removeEventListener("change", finishChange, !1),
          $colorInput.div.removeEventListener("blur", onColorBlur, !1);
      });
  }),
  Class(function UILControlFile(_id, _opts = { value: {} }) {
    Inherit(this, UILControl);
    const _this = this;
    let $view,
      $picker,
      $preview,
      $img,
      $input,
      $$copy,
      $progress,
      _value,
      $filepicker;
    function filePickerSelected(value) {
      window.UIL_REMOTE &&
        console.warn("UIL_REMOTE is not supported when using file picker!");
      const v = {
        prefix: void 0,
        src: `assets/geometry/${value}`,
        filename: value.split("/").last(),
        relative: "assets/geometry",
      };
      _this.force(v), (_this.value = v), _this.finish();
    }
    async function change(e) {
      let file = $picker.div.files[0];
      if (!file) return;
      let name = file.name;
      if (window.UIL_REMOTE) {
        const { customMetadata: customMetadata } =
          await UILStorage.uploadFileToRemoteBucket({
            file: file,
            progress: $progress,
          });
        name = customMetadata.path;
      }
      (_value.filename = name),
        (_value.relative = (function getRelative() {
          return _value.filename.includes("http")
            ? ""
            : _value.relative.includes(_value.prefix)
            ? _value.relative.replace(`${_value.prefix}`, "")
            : _value.relative;
        })()),
        (_value.src = (function getSrc() {
          return _value.filename.includes("http")
            ? _value.filename
            : `${_value.prefix ? _value.prefix + "/" : ""}${
                _value.relative ? _value.relative + "/" : ""
              }${_value.filename}`;
        })()),
        (await (function fileExists(url) {
          return (
            !!url.includes("http") ||
            fetch(Assets.getPath(url))
              .then((e) => 404 != e.status)
              .catch((e) =>
                console.warn("UILControlFile image url validation failed", e)
              )
          );
        })(_value.src))
          ? ((_this.value = Object.assign({}, _value)),
            $img.attr("title", _value.src),
            $$copy.text(_value.filename),
            _this.finish())
          : (($picker.div.value = ""),
            console.warn("UIL: Could not find file", _value),
            alert(
              `"${_value.src}" not found!\nMake sure "relative path" is correct.`
            ));
    }
    function focus() {
      $img.css({ border: "1px solid #37a1ef" });
    }
    function blur() {
      $img.css({ border: "1px dotted #2e2e2e" });
    }
    function inputChange() {
      (_value.relative = $input.div.value),
        _value.relative.includes(".") &&
          ((_this.value = Object.assign({}, _value)), _this.finish());
    }
    !(function init() {
      (_opts.value = Object.assign(
        {
          src: "",
          relative: _opts.relative || "",
          prefix: _opts.prefix,
          filename: "",
        },
        _opts.value
      )),
        (_value = Object.assign({}, _opts.value)),
        _this.init(_id, _opts);
    })(),
      (function initView() {
        ($view = $("view")),
          $view.css({ position: "relative", padding: 5 }),
          ($input = $view.create("path", "input")),
          $input.size("100%").bg("#1D1D1D"),
          $input.css({
            boxSizing: "border-box",
            border: "1px solid #2E2E2E",
            color: "#37A1EF",
            marginBottom: 5,
          }),
          _this.value.relative
            ? ($input.div.value = _this.value.relative)
            : $input.attr("placeholder", "Relative Path"),
          ($preview = $view.create("preview")),
          $preview.size("100%", 60),
          $preview.css({
            boxSizing: "border-box",
            position: "relative",
            display: "flex",
            alignItems: "center",
            justifyContent: "center",
            overflow: "hidden",
          }),
          ($img = $preview.create("img")),
          $img.size("100%"),
          $img.css({
            position: "absolute",
            top: 0,
            right: 0,
            bottom: 0,
            left: 0,
            backgroundSize: "cover",
            backgroundRepeat: "no-repeat",
            backgroundPosition: "center",
            border: "1px dotted #2e2e2e",
            boxSizing: "border-box",
          }),
          ($picker = $preview.create("picker", "input")),
          $picker.attr("type", "file"),
          $picker.css({
            opacity: 0,
            position: "absolute",
            top: 0,
            right: 0,
            bottom: 0,
            left: 0,
          }),
          ($progress = $preview.create("progress")),
          $progress.css({
            position: "absolute",
            bottom: 0,
            height: 10,
            left: 0,
            background: "#9B9C9B",
          }),
          ($$copy = $preview.create("copy")),
          $$copy.html("Drag file here<br><small>or Click to Select</small>"),
          $$copy
            .fontStyle("sans-serif", 11, "#9B9C9B")
            .css({ textAlign: "center" }),
          ($filepicker = $view.create("filepicker", "button")),
          $filepicker
            .text("Browse")
            .bg("#fff")
            .css({
              border: 0,
              width: 70,
              height: 15,
              textAlign: "center",
              borderRadius: 5,
              position: "relative",
              float: "left",
              paddingTop: 2,
            })
            .fontStyle("sans-serif", 11, "#000"),
          ($filepicker.div.onclick = () => {
            new UILExternalFilePicker(filePickerSelected, "geometries");
          }),
          (_this.view = $view),
          _value.src &&
            ($img.attr("title", _value.src), $$copy.text(_value.filename));
      })(),
      (function addHandlers() {
        $picker.div.addEventListener("change", change, !1),
          $picker.div.addEventListener("focus", focus, !1),
          $picker.div.addEventListener("blur", blur, !1),
          $input.div.addEventListener("change", inputChange, !1);
      })(),
      (this.force = function (value, isClipboard) {
        (_value = Object.assign({}, value)),
          !0 === isClipboard && (_this.value = _value),
          ($input.div.value = _value.relative),
          $img.attr("title", _value.src),
          $$copy.text(_value.filename);
      }),
      (this.onDestroy = function () {
        $picker.div.removeEventListener("change", change, !1),
          $picker.div.removeEventListener("focus", focus, !1),
          $picker.div.removeEventListener("blur", blur, !1),
          $input.div.removeEventListener("change", inputChange, !1);
      });
  }),
  Class(function UILControlImage(_id, _opts = { value: {} }) {
    Inherit(this, UILControl);
    const _this = this;
    let $view,
      $picker,
      $preview,
      $img,
      $input,
      $check,
      $compress,
      $delete,
      $progress,
      _value,
      $filepicker;
    function filePickerSelected(value) {
      window.UIL_REMOTE &&
        console.warn("UIL_REMOTE is not supported when using file picker!");
      const v = {
        compressed: !1,
        filename: value.split("/").last(),
        prefix: "assets/images",
        relative: "assets/images",
        src: `assets/images/${value}`,
      };
      _this.force(v, !0), _this.finish();
    }
    async function supportsKtx2() {
      if (void 0 === Dev.supportsKtx2)
        try {
          await Dev.execUILScript("compressktx2", {
            options: ["--help"],
            output: "",
            src: [],
          }),
            (Dev.supportsKtx2 = !0);
        } catch (e) {
          console.log(
            "%cKTX2 support not found in this project%c. 💁‍️ See https://www.notion.so/a91bbc09b19d4475bfc5bcb8d6048d70 for upgrade instructions",
            "background-color: #ffde7b",
            "background-color: unset"
          ),
            (Dev.supportsKtx2 = !1);
        }
      return Dev.supportsKtx2;
    }
    async function compressKtx2() {
      let result,
        path = _value.src.split("?")[0];
      if (_opts.compressOptions?.cube) {
        $compress.bg("#fdb460").html("Cubemap");
        let [output, src] = (function parseCubePaths(path) {
          let info = Utils3D.splitCubemapPath(path),
            src = Utils3D.getCubemapFacePaths(info);
          return [`${info.prefix}.ktx2`, src];
        })(path);
        result = await Dev.execUILScript("compressktx2", {
          options: ["--genmipmap", "--encode", "etc1s", "--cubemap"],
          output: output,
          src: src,
        });
      } else {
        let noext = path
            .split("/")
            .last()
            .replace(/\.[^.]+$/, ""),
          folder = path.replace(/\/[^/]*$/, "");
        result = await Dev.execUILScript("compressktx2", {
          options: ["--genmipmap", "--encode", "etc1s"],
          output: `${folder}/${noext}.ktx2`,
          src: [path],
        });
      }
      return "Error" !== result;
    }
    async function compressClick() {
      if (!_value.src || _this.flag("compressPending")) return;
      _this.flag("compressPending", !0), $compress.bg("#f4ee42").text("---");
      let success = !1;
      try {
        if (await supportsKtx2()) success = await compressKtx2();
        else {
          "Error" !==
            (await Dev.execUILScript("compressktx", {
              src: _value.src.split("?")[0],
            })) && (success = !0);
        }
      } catch (e) {
        console.error(e);
      }
      success
        ? $compress.bg("#46f441").html("Success")
        : $compress.bg("#f44141").html("Failed"),
        _this.flag("compressPending", !1);
    }
    async function checkChange() {
      let compressed = !!$check.div.checked;
      compressed && (await supportsKtx2()) && (compressed = "ktx2"),
        (_this.value.compressed = compressed),
        _this.finish(!1);
    }
    async function change(e) {
      let file = $picker.div.files[0];
      if (!file) return;
      let name = file.name;
      if (window.UIL_REMOTE) {
        const { customMetadata: customMetadata } =
          await UILStorage.uploadFileToRemoteBucket({
            file: file,
            progress: $progress,
          });
        name = customMetadata.path;
      }
      (_value.filename = name),
        (_value.relative = (function getRelative() {
          return _value.filename.includes("http")
            ? ""
            : _value.relative.includes(_value.prefix)
            ? _value.relative.replace(`${_value.prefix}`, "")
            : _value.relative;
        })()),
        (_value.src = (function getSrc() {
          return _value.filename.includes("http")
            ? _value.filename
            : `${_value.prefix ? _value.prefix + "/" : ""}${
                _value.relative ? _value.relative + "/" : ""
              }${_value.filename}`;
        })()),
        (_value.compressed = !!$check.div.checked),
        (await (function imageExists(url) {
          return (
            !!url.includes("http") ||
            ((url = Assets.getPath(url)),
            fetch(url)
              .then((e) => 404 != e.status)
              .catch((e) =>
                console.warn("UILControlImage image url validation failed", e)
              ))
          );
        })(_value.src))
          ? ((_this.value = Object.assign({}, _value)),
            ($picker.div.value = ""),
            $picker.attr("title", _value.src),
            $img.css({ backgroundImage: `url(${Assets.getPath(_value.src)})` }),
            $delete.show(),
            _this.finish())
          : (($picker.div.value = ""),
            console.warn("UIL: Could not find image", _value),
            alert(
              `"${_value.src}" not found!\nMake sure "relative path" is correct.`
            ));
    }
    function deleteImage() {
      (_value = {
        src: "",
        relative: "",
        prefix: "assets/images",
        filename: "",
      }),
        ($input.div.value = ""),
        ($picker.div.value = ""),
        $picker.attr("title", null),
        $img.css({ backgroundImage: "" }),
        $delete.hide(),
        (_this.value = Object.assign({}, _value)),
        _this.finish();
    }
    function focus() {
      $img.css({ border: "1px solid #37a1ef" });
    }
    function blur() {
      $img.css({ border: "1px dotted #2e2e2e" });
    }
    function inputChange() {
      _value.relative = $input.div.value;
    }
    !(function init() {
      (_opts.value = Object.assign(
        {
          src: "",
          relative: _opts.relative || "",
          prefix: _opts.prefix || "assets/images",
          filename: "",
        },
        _opts.value
      )),
        (_value = Object.assign({}, _opts.value)),
        _this.init(_id, _opts);
    })(),
      (function initView() {
        ($view = $("view")),
          $view.css({ position: "relative", padding: 5 }),
          ($input = $view.create("path", "input")),
          $input.size("100%").bg("#1D1D1D"),
          $input.css({
            boxSizing: "border-box",
            border: "1px solid #2E2E2E",
            color: "#37A1EF",
            marginBottom: 5,
          }),
          _this.value.relative
            ? ($input.div.value = _this.value.relative)
            : $input.attr("placeholder", "Relative Path"),
          ($compress = $view.create("compress")),
          $compress
            .text("Compress")
            .bg("#fff")
            .css({
              top: 3,
              width: 70,
              height: 15,
              textAlign: "center",
              borderRadius: 5,
              position: "relative",
              float: "left",
              paddingTop: 2,
            })
            .fontStyle("sans-serif", 11, "#000"),
          ($check = $view.create("#compressed", "input")),
          $check.attr("type", "checkbox"),
          $check.size(20, 20),
          $check.css({ boxSizing: "border-box", position: "relative" }),
          ($check.div.checked = !!_this.value.compressed);
        let $label = $view.create("compressed-label", "label");
        $label.attr("for", "compressed"),
          $label
            .text("Use Compressed")
            .fontStyle("sans-serif", 9, "#9B9C9B")
            .css({ top: -6, position: "relative" }),
          ($preview = $view.create("preview")),
          $preview.size("100%", 60),
          $preview.css({
            boxSizing: "border-box",
            position: "relative",
            display: "flex",
            alignItems: "center",
            justifyContent: "center",
            overflow: "hidden",
          }),
          ($img = $preview.create("img")),
          $img.size("100%"),
          $img.css({
            position: "absolute",
            top: 0,
            right: 0,
            bottom: 0,
            left: 0,
            backgroundSize: "cover",
            backgroundRepeat: "no-repeat",
            backgroundPosition: "center",
            border: "1px dotted #2e2e2e",
            boxSizing: "border-box",
          }),
          ($picker = $preview.create("picker", "input")),
          $picker.attr("type", "file"),
          $picker.attr("accept", "image/*"),
          $picker.css({
            opacity: 0,
            position: "absolute",
            top: 0,
            right: 0,
            bottom: 0,
            left: 0,
          }),
          ($progress = $preview.create("progress")),
          $progress.css({
            position: "absolute",
            bottom: 0,
            height: 10,
            left: 0,
            background: "#9B9C9B",
          }),
          ($delete = $preview.create("delete", "button")),
          $delete
            .size(18, 18)
            .css({
              border: "none",
              padding: 0,
              position: "absolute",
              top: 8,
              right: 8,
              borderRadius: "50%",
              background: "#1D1D1D",
              color: "#9B9C9B",
              textAlign: "center",
            })
            .html(
              '<svg width="10" height="10" viewBox="0 0 10 10" fill="none" stroke="currentColor" xmlns="http://www.w3.org/2000/svg"><path stroke-width="2" stroke-linecap="round" d="M2 2l6 6M2 8l6-6"/></svg>'
            ),
          $delete.hide();
        let copy = $preview.create("copy");
        copy.html("Drag image here<br><small>or Click to Select</small>"),
          copy
            .fontStyle("sans-serif", 11, "#9B9C9B")
            .css({ textAlign: "center" }),
          _this.value.src &&
            ($img.css({
              backgroundImage: `url('${Assets.getPath(_this.value.src)}')`,
            }),
            $picker.attr("title", _this.value.src),
            $delete.show()),
          ($filepicker = $view.create("filepicker", "button")),
          $filepicker
            .text("Browse")
            .bg("#fff")
            .css({
              border: 0,
              width: 70,
              height: 15,
              textAlign: "center",
              borderRadius: 5,
              position: "relative",
              float: "left",
              paddingTop: 2,
            })
            .fontStyle("sans-serif", 11, "#000"),
          ($filepicker.div.onclick = () => {
            new UILExternalFilePicker(filePickerSelected, "textures");
          }),
          (_this.view = $view);
      })(),
      (function addHandlers() {
        $picker.div.addEventListener("change", change, !1),
          $picker.div.addEventListener("focus", focus, !1),
          $picker.div.addEventListener("blur", blur, !1),
          $input.div.addEventListener("change", inputChange, !1),
          ($delete.div.onclick = deleteImage),
          ($compress.div.onclick = compressClick),
          ($check.div.onchange = checkChange);
      })(),
      (this.force = function (value, isClipboard) {
        (_value = Object.assign({}, value)),
          !0 === isClipboard && (_this.value = _value),
          ($input.div.value = _value.relative),
          ($picker.div.value = ""),
          $picker.attr("title", _value.src),
          $img.css({ backgroundImage: `url('${Assets.getPath(_value.src)}')` }),
          ($check.div.checked = _value.compressed);
      }),
      (this.onDestroy = function () {
        $picker.div.removeEventListener("change", change, !1),
          $picker.div.removeEventListener("focus", focus, !1),
          $picker.div.removeEventListener("blur", blur, !1),
          $input.div.removeEventListener("change", inputChange, !1);
      });
  }),
  Class(function UILControlNumber(_id, _opts = {}) {
    Inherit(this, UILControl);
    const _this = this;
    let _input;
    !(function init() {
      (_opts.value = _opts.value || 0), _this.init(_id, _opts);
    })(),
      (function initInput() {
        (_input = _this.initClass(
          UILInputNumber,
          Object.assign(_opts, { value: _this.value })
        )),
          _input.onInput((v) => (_this.value = v)),
          _input.onFinish((v) => _this.finish()),
          (_this.view = _input.input);
      })(),
      (this.update = function (value) {
        _input.value = _this.value || 0;
      }),
      (this.forceUpdate = function (value) {
        _input.forceUpdate(value);
      });
  }),
  Class(function UILControlRange(_id, _opts = {}) {
    Inherit(this, UILControl);
    const _this = this;
    let $view,
      $slider,
      _max = _opts.max || 100,
      _min = _opts.min || 0,
      _step = _opts.step || 1;
    function change() {
      _this.finish();
    }
    function input(e) {
      _this.value = Number($slider.div.value);
    }
    function focus() {
      $slider.css({ border: "1px solid #37a1ef" });
    }
    function blur() {
      $slider.css({ border: "1px solid #2e2e2e" });
    }
    !(function init() {
      (_opts.value = _opts.value || 0), _this.init(_id, _opts);
    })(),
      (function style() {
        UIL.addCSS(
          UILControlRange,
          "\n            .UILControlRange input { -webkit-appearance:none; appearance:none; }\n            .UILControlRange input::-webkit-slider-thumb { -webkit-appearance: none; }\n            .UILControlRange input::-webkit-slider-thumb { \n                -webkit-appearance:none; appearance:none;\n                width:15px; height:15px;\n                background:#FFF;\n                border-radius:15px;\n            }\n            .UILControlRange input::-moz-slider-thumb { \n                -webkit-appearance:none; appearance:none;\n                width:15px; height:15px;\n                background:#FFF;\n                border-radius:15px;\n            }\n        "
        );
      })(),
      (function initView() {
        ($view = $("view")),
          ($slider = $view.create("range", "input")),
          $slider.attr("type", "range"),
          $slider.attr("max", _max),
          $slider.attr("min", _min),
          $slider.attr("step", _step),
          ($slider.div.value = _this.value),
          $slider.css({
            width: "100%",
            margin: 0,
            padding: 0,
            background: "#1d1d1d",
            height: 4,
            borderRadius: 15,
            border: "1px solid #2e2e2e",
            boxSizing: "border-box",
          }),
          (_this.view = $view);
      })(),
      (function addHandlers() {
        $slider.div.addEventListener("change", change, !1),
          $slider.div.addEventListener("input", input, !1),
          $slider.div.addEventListener("focus", focus, !1),
          $slider.div.addEventListener("blur", blur, !1);
      })(),
      (this.force = function (value) {
        (_this.value = value), ($slider.div.value = value), _this.finish(!1);
      }),
      (this.onDestroy = function () {
        $slider.div.removeEventListener("change", change, !1),
          $slider.div.removeEventListener("input", input, !1),
          $slider.div.removeEventListener("focus", focus, !1),
          $slider.div.removeEventListener("blur", blur, !1);
      });
  }),
  Class(function UILControlSelect(_id, _opts = {}) {
    Inherit(this, UILControl);
    const _this = this;
    let $view, $select, _options;
    function change() {
      _this.finish();
    }
    function input() {
      let i = $select.div.selectedIndex;
      _this.value = _options[i].value;
    }
    function focus() {
      $select.css({ border: "1px solid #37a1ef" });
    }
    function blur() {
      $select.css({ border: "1px solid #2e2e2e" });
    }
    !(function init() {
      if (!_opts.options) throw "UILControlSelect is missing select options";
      (_opts.value = _opts.value || _opts.options[0].value),
        _this.init(_id, _opts);
    })(),
      (function style() {
        UIL.addCSS(
          UILControlSelect,
          "\n            .UILControlSelect select { -webkit-appearance:none; appearance:none; }\n        "
        );
      })(),
      (function initView() {
        ($view = $("view")),
          $view.css({ position: "relative" }),
          ($select = $view.create("dropdown", "select")),
          $select.css({
            width: "100%",
            margin: 0,
            padding: 0,
            background: "#1d1d1d",
            height: 15,
            border: "1px solid #2e2e2e",
            boxSizing: "border-box",
            color: "#37a1ef",
            borderRadius: 0,
            height: 17,
          }),
          $view
            .create("arrow")
            .text("▼")
            .css({
              color: "#37a1ef",
              fontSize: 6,
              position: "absolute",
              right: 8,
              top: 7,
              pointerEvents: "none",
            }),
          (_this.view = $view);
      })(),
      (function initOptions() {
        (_options = _opts.options.map(({ value: value, label: label }) => {
          let el = document.createElement("option");
          return (
            el.setAttribute("value", value),
            _this.value === value && el.setAttribute("selected", !0),
            (el.text = label || value),
            (el.value = value),
            $select.add(el),
            el
          );
        })),
          ($select.div.value = _this.value);
      })(),
      (function addHandlers() {
        $select.div.addEventListener("change", change, !1),
          $select.div.addEventListener("input", input, !1),
          $select.div.addEventListener("focus", focus, !1),
          $select.div.addEventListener("blur", blur, !1);
      })(),
      (this.force = function (value) {
        ($select.div.value = value), (_this.value = value);
      }),
      (this.onDestroy = function () {
        $select.div.removeEventListener("change", change, !1),
          $select.div.removeEventListener("input", input, !1),
          $select.div.removeEventListener("focus", focus, !1),
          $select.div.removeEventListener("blur", blur, !1);
      });
  }),
  Class(function UILControlText(_id, _opts = {}) {
    Inherit(this, UILControl);
    const _this = this;
    let $input, _timeout;
    function onChange(v) {
      clearTimeout(_timeout),
        (_timeout = setTimeout(onFinishChange, 400)),
        (_this.value = $input.div.value);
    }
    function onFinishChange() {
      null !== _timeout &&
        (clearTimeout(_timeout), (_timeout = null), _this.finish());
    }
    _this.init(_id, _opts),
      (function initInput() {
        ($input = $("input", "input")),
          $input.size("100%").bg("#1D1D1D"),
          $input.css({
            boxSizing: "border-box",
            border: "1px solid #2E2E2E",
            color: "#37A1EF",
          }),
          _this.value && ($input.div.value = _this.value || ""),
          (_this.view = $input);
      })(),
      (function addHandlers() {
        $input.div.addEventListener("input", onChange, !1),
          $input.div.addEventListener("change", onFinishChange, !1);
      })(),
      (this.update = function () {
        $input.div.value = _this.value || "";
      }),
      (this.onDestroy = function () {
        $input.div.removeEventListener("input", onChange, !1),
          $input.div.removeEventListener("change", onBlur, !1);
      });
  }),
  Class(function UILControlTextarea(_id, _opts = {}) {
    Inherit(this, UILControl);
    const _this = this;
    let $input, _timeout;
    function onChange(v) {
      clearTimeout(_timeout),
        (_timeout = setTimeout(onFinishChange, 400)),
        (_this.value = $input.div.value);
    }
    function onFinishChange() {
      null !== _timeout &&
        (clearTimeout(_timeout), (_timeout = null), _this.finish());
    }
    _this.init(_id, _opts),
      (function initInput() {
        ($input = $("input", "textarea")),
          $input.attr("maxlength", _opts.max || 1 / 0),
          $input.attr("minlength", _opts.min || -1 / 0),
          $input.attr("rows", _opts.rows || 2),
          $input.attr("readonly", _opts.readonly || !1),
          $input.size("100%").bg("#1D1D1D"),
          $input.css({
            boxSizing: "border-box",
            resize: _opts.resize || "vertical",
            minWidth: _opts.minWidth || 0,
            border: "1px solid #2E2E2E",
            color: "#37A1EF",
          }),
          (_opts.monospace || _opts.editor) &&
            $input.css({ fontFamily: "monospace" }),
          _this.value && ($input.div.value = _this.value || ""),
          (_this.view = $input);
      })(),
      _opts.editor &&
        (function enableTab() {
          $input.div.onkeydown = function (e) {
            if (9 === e.keyCode) {
              let val = this.value,
                start = this.selectionStart,
                end = this.selectionEnd;
              (this.value =
                val.substring(0, start) + "\t" + val.substring(end)),
                (this.selectionStart = this.selectionEnd = start + 1),
                e.preventDefault();
            }
          };
        })(),
      (function addHandlers() {
        $input.div.addEventListener("input", onChange, !1),
          $input.div.addEventListener("change", onFinishChange, !1);
      })(),
      (this.update = function () {
        $input.div.value = _this.value || "";
      }),
      (this.onDestroy = function () {
        $input.div.removeEventListener("input", onChange, !1),
          $input.div.removeEventListener("change", onBlur, !1);
      });
  }),
  Class(function UILControlVector(_id, _opts = {}) {
    Inherit(this, UILControl);
    const _this = this;
    let $view,
      _length,
      _inputs = [],
      _vector = [];
    function onInput(value, index, master) {
      master ? (_vector = _vector.map((v) => value)) : (_vector[index] = value),
        (_this.value = [..._vector]);
    }
    function onFinish(value, index, master) {
      _this.finish();
    }
    !(function init() {
      if (_opts.value) _length = _vector.length;
      else {
        if (!_opts.components)
          throw 'UILControlVector: Cannot detect vector type. Define "options.components" count or init with a initial value';
        _opts.value = new Array(_opts.components).fill(0);
      }
      (_length = _opts.value.length),
        _this.init(_id, _opts),
        (_vector = [..._this.value]);
    })(),
      (function initInputs() {
        $view = $("inputs");
        for (let i = 0; i < _length; i++) {
          let { steps: steps, ...opts } = _opts;
          if (Array.isArray(steps)) {
            let step = steps[i] || steps.last();
            step && (opts.step = step);
          }
          let input = _this.initClass(UILInputNumber, opts);
          (input.value = _this.value[i]),
            input.onInput((v, m) => onInput(v, i, m)),
            input.onFinish((v, m) => onFinish(v, i, m)),
            input.input.css({
              display: "inline-block",
              width: `calc(100% / ${_length})`,
            }),
            _inputs.push(input),
            $view.add(input.input);
        }
        _this.view = $view;
      })(),
      (this.force = function (value, history = !1) {
        (_vector = [...value]),
          (_this.value = [..._vector]),
          _inputs.forEach((input, index) => (input.value = _this.value[index])),
          _this.finish(history);
      }),
      (this.update = function () {
        _inputs.forEach((input, index) => (input.value = _this.value[index]));
      });
  }),
  Class(function UILInputNumber(_opts = {}) {
    Inherit(this, Component);
    const _this = this;
    let $input,
      _timeout,
      _distance,
      _onMouseDownValue,
      _editing = !1,
      _precision = _opts.precision || 3,
      _step = _opts.step || 1,
      _min = _opts.min || -1 / 0,
      _max = _opts.max || 1 / 0,
      _value = _opts.value || 0,
      _pointer = [0, 0],
      _prevPointer = [0, 0],
      _onInputCB = () => {},
      _onFinishCB = () => {};
    function setValue(value) {
      (value = parseFloat(value) || 0) < _min && (value = _min),
        value > _max && (value = _max),
        (_value = value),
        _onInputCB(value, _this.master);
    }
    function onBlur() {
      onFinishChange(),
        ($input.div.value = parseFloat(_value).toFixed(_precision));
    }
    function onKeyUp(e) {
      13 === e.keyCode && e.altKey && ((_this.master = !0), onInput());
    }
    function onInput(e) {
      (_timeout = setTimeout(onFinishChange, 400)),
        (_editing = !0),
        setValue(parseFloat($input.div.value));
    }
    function onFinishChange() {
      _editing &&
        ((_editing = !1),
        clearTimeout(_timeout),
        _onFinishCB(_value, _this.master),
        (_this.master = !1));
    }
    function onMouseDown(e) {
      (1 === e.button || (0 === e.button && e.metaKey) || e.ctrlKey) &&
        (e.preventDefault(),
        $input.css({ cursor: "col-resize" }),
        (_distance = 0),
        (_onMouseDownValue = _value),
        (_prevPointer = [e.screenX, e.screenY]),
        document.addEventListener("mousemove", onMouseMove, !1),
        document.addEventListener("mouseup", onMouseUp, !1));
    }
    function onMouseMove(e) {
      clearTimeout(_timeout), (_editing = !0);
      let currentValue = _value;
      (_pointer = [e.screenX, e.screenY]),
        (_distance +=
          _pointer[0] - _prevPointer[0] - (_pointer[1] - _prevPointer[1]));
      let value =
        _onMouseDownValue + (_distance / (e.shiftKey ? 5 : 50)) * _step;
      (value = Math.min(_max, Math.max(_min, value))),
        (_this.master = e.altKey),
        currentValue !== value &&
          (function setValueDrag(value) {
            (void 0 === value && value === $input.div.value) ||
              (setValue(value),
              ($input.div.value = _value.toFixed(_precision)));
          })(value),
        (_prevPointer = [e.screenX, e.screenY]);
    }
    function onMouseUp(e) {
      onFinishChange(),
        $input.css({ cursor: "" }),
        document.removeEventListener("mousemove", onMouseMove, !1),
        document.removeEventListener("mouseup", onMouseUp, !1);
    }
    !(function initInput() {
      ($input = $("input", "input")),
        $input.attr("type", "number"),
        $input.attr("step", _step),
        $input.size("100%").bg("#1D1D1D"),
        $input.css({
          boxSizing: "border-box",
          border: "1px solid #2E2E2E",
          color: "#37A1EF",
          boxShadow: "none",
        }),
        ($input.div.value = parseFloat(_value).toFixed(_precision)),
        (_this.input = $input);
    })(),
      (function addHandlers() {
        $input.div.addEventListener("mousedown", onMouseDown, !1),
          $input.div.addEventListener("keyup", onKeyUp, !1),
          $input.div.addEventListener("change", onFinishChange, !1),
          $input.div.addEventListener("blur", onBlur, !1),
          $input.div.addEventListener("input", onInput, !1);
      })(),
      this.set("value", (value) => {
        (_value = value),
          _editing ||
            ($input.div.value = parseFloat(value).toFixed(_precision));
      }),
      this.get("value", () => _value),
      (this.onInput = (cb) => (_onInputCB = cb)),
      (this.onFinish = (cb) => (_onFinishCB = cb)),
      (this.forceUpdate = function (value) {
        (_value = value),
          ($input.div.value = parseFloat(value).toFixed(_precision));
      }),
      (this.onDestroy = function () {
        $input.div.removeEventListener("mousedown", onMouseDown, !1),
          $input.div.removeEventListener("change", onFinishChange, !1),
          $input.div.removeEventListener("blur", onBlur, !1),
          $input.div.removeEventListener("input", onInput, !1);
      });
  }),
  Class(function UILExternalColor(_title, _value) {
    Inherit(this, Component);
    const _this = this;
    var _window;
    function onReload() {
      _this.onDestroy();
    }
    ((_window = window.open(
      location.protocol + "//localhost/hydra/editor/color/index.html",
      `hydra_color_${_title}`,
      "width=480,height=220,left=200,top=100,location=no"
    )).window.onload = (_) => {
      _window.window.initPicker(_title, _value, _this);
    }),
      window.addEventListener("beforeunload", onReload),
      (this.update = function (value) {
        _this.events.fire(Events.UPDATE, { value: value });
      }),
      (this.onDestroy = function () {
        window.removeEventListener("beforeunload", onReload),
          _window && _window.window && _window.window.close();
      });
  }),
  Class(function UILExternalEditor(_title, _height = 500, _width = 700) {
    Inherit(this, Component);
    const _this = this;
    var _window, _code, _language;
    (_window = window.open(
      location.protocol + "//localhost/hydra/editor/code/index.html",
      "_blank",
      `width=${_width},height=${_height},left=200,top=100`
    )),
      _this.events.sub(Events.UNLOAD, (_) => _window.close()),
      (_window.window.onload = (_) => {
        _window.window.initEditor(_title, _code, _language, _this);
      }),
      (this.setCode = function (code, language) {
        (_code = code), (_language = language);
      }),
      (this.saved = async function (code) {
        _this.onSave && _this.onSave(code), await defer(), UILStorage.write();
      });
  }),
  Class(function UILExternalFilePicker(callback, type = "textures") {
    Inherit(this, Component);
    const _this = this;
    var _window;
    async function init() {
      const assets = await get(
        Assets.getPath("assets/js/app/config/UILAssetsConfig.js")
      );
      let basePath, list;
      eval(assets),
        "textures" === type &&
          ((basePath = `${document.location.pathname}/assets/images`),
          (list = window.UIL_ASSETS_TEXTURES)),
        "geometries" === type &&
          ((basePath = `${document.location.pathname}/assets/geometry`),
          (list = window.UIL_ASSETS_GEOMETRIES)),
        (_window = window.open(
          `${location.protocol}//localhost/hydra/editor/filepicker/index.html`,
          "pick file",
          "width=800,height=700"
        )),
        _this.events.sub(Events.UNLOAD, (_) => _window.close()),
        (_window.window.onload = (_) => {
          _window.window.initPicker(_this, basePath, list);
        }),
        window.addEventListener("beforeunload", onReload);
    }
    function onReload() {
      _this.onDestroy();
    }
    !(async function () {
      await Dev.execUILScript("assetsconfig"), await init();
    })(),
      (this.refresh = function () {
        _window && _window.window && _window.window.close(), init();
      }),
      (this.update = function (value) {
        callback && callback(value);
      }),
      (this.onDestroy = function () {
        window.removeEventListener("beforeunload", onReload),
          _window && _window.window && _window.window.close();
      });
  }),
  Class(function UILExternalTimeline(
    _title,
    _height = 500,
    _width = 700,
    _config
  ) {
    Inherit(this, Component);
    const _this = this;
    var _window;
    (_window = window.open(
      location.protocol + "//localhost/hydra/editor/timeline/index.html",
      "_blank",
      `width=${_width},height=${_height},left=200,top=100`
    )),
      _this.events.sub(Events.UNLOAD, (_) => _window.close()),
      (_window.window.onload = (_) => {
        _window.window.initEditor(_title, _config);
      }),
      _window.window.addEventListener("message", (e) => {
        if (
          (e.data.bundle && _this.onMessage && _this.onMessage(e.data.bundle),
          e.data.save)
        ) {
          let path;
          _this.onSave && _this.onSave(),
            window.UIL_STATIC_PATH
              ? ((path = window.UIL_STATIC_PATH),
                (path = path.substring(0, path.lastIndexOf("/"))))
              : (path = "assets/data"),
            Dev.writeFile(
              `${path}/timeline-${_title}.json?compress`,
              e.data.save
            );
        }
        e.data.visualizePath && _this.onVisualizePath?.(e.data.visualizePath),
          void 0 !== e.data.position &&
            _this.onPositionChange &&
            _this.onPositionChange(e.data.position);
      }),
      _this.startRender((_) => {
        _window.closed && _this.destroy();
      }, 10),
      (this.saved = async function (code) {
        _this.onSave && _this.onSave(code), await defer(), UILStorage.write();
      }),
      (this.sendUpdate = function (layerName, value, key) {
        _window.window.sendUpdate(layerName, value, key);
      }),
      (this.close = function () {
        _window.close();
      });
  }),
  Class(function UILPanelToolbar() {
    Inherit(this, Element);
    const _this = this;
    let $this,
      $filter,
      _state = new Map();
    function restoreFolderState() {
      _this.parent.folder.forEachFolder((folder) => {
        _state.get(folder) ? folder.open() : folder.close();
      }),
        _state.clear();
    }
    function onInput(e) {
      if (!$filter.div.value.length)
        return restoreFolderState(), _this.parent.folder.showChildren();
      _this.parent.folder.filter($filter.div.value);
    }
    function onFocus() {
      !(function saveFolderState() {
        _this.parent.folder.forEachFolder((folder) => {
          _state.set(folder, folder.isOpen());
        });
      })(),
        $filter.css({ border: "1px solid #37a1ef" });
    }
    function onBlur() {
      $filter.css({ border: "1px solid #2e2e2e" });
    }
    function onKeyPressed(e) {
      if (27 === e.keyCode)
        return (
          ($filter.div.value = ""),
          restoreFolderState(),
          _this.parent.folder.showChildren()
        );
    }
    !(function initHTML() {
      ($this = _this.element),
        $this.size("100%", "auto").bg("#272727"),
        $this.css({ padding: 4, boxSizing: "border-box", marginBottom: 4 });
    })(),
      (function initFilter() {
        ($filter = $this.create("filter", "input")),
          $filter.div.addEventListener("input", onInput, !1),
          $filter.div.addEventListener("keydown", onKeyPressed, !1),
          $filter.div.addEventListener("focus", onFocus, !1),
          $filter.div.addEventListener("blur", onBlur, !1),
          $filter.size("100%", "auto").bg("#161616"),
          $filter.css({
            color: "#B1B1B1",
            border: "1px solid #2e2e2e",
            outline: "none",
            padding: 2,
            boxSizing: "border-box",
          });
      })(),
      (this.eliminate = function () {
        $filter.div.removeEventListener("input", onInput, !1),
          $filter.div.removeEventListener("keydown", onKeyPressed, !1),
          $filter.div.removeEventListener("focus", onFocus, !1),
          $filter.div.removeEventListener("blur", onBlur, !1);
      }),
      (this.filter = function (text) {
        ($filter.div.value = text), onInput();
      }),
      (this.filterSingle = function (text) {
        ($filter.div.value = text),
          _this.parent.folder.filterSingle($filter.div.value);
      }),
      (this.hideAll = function () {
        _this.flag("init") ||
          (_this.flag("init", !0), this.filterSingle("xxxxxx"));
      });
  }),
  Namespace("FX"),
  FX.Class(
    function UnrealBloom(_nuke, options, _unique) {
      Inherit(this, Component);
      var _triangleGeometry,
        _luminosityShader,
        _compositeShader,
        _mesh,
        _inputTexture,
        _this = this;
      "object" != typeof _nuke ||
        options ||
        (!_nuke.nuke && !_nuke.unique) ||
        ((options = _nuke.options),
        (_unique = _nuke.unique),
        (_nuke = _nuke.nuke)),
        "string" == typeof options
          ? ((_unique = _params), (options = {}), (_nuke = World.NUKE))
          : "string" == typeof _nuke
          ? ((_unique = _nuke), (options = {}), (_nuke = World.NUKE))
          : !_nuke || _nuke instanceof Nuke
          ? ((_nuke = _nuke || World.NUKE),
            (options = options || {}),
            (_unique = _unique || ""))
          : ((options = _nuke), (_nuke = World.NUKE));
      var _oldClearColor = new Color(),
        _oldClearAlpha = 1,
        _renderTargetsHorizontal = [],
        _renderTargetsVertical = [],
        _separableBlurShaders = [],
        _nMips = options.nMips || 5,
        _DPR = _nuke.dpr,
        _blurDirectionX = new Vector2(_DPR, 0),
        _blurDirectionY = new Vector2(0, _DPR),
        _kernelSizeArray = options.kernelSizeArray || [3, 5, 7, 9, 11],
        _bloomFactors = options.bloomFactors || [1, 0.8, 0.6, 0.4, 0.2],
        _useRTPool = !1 !== options.useRTPool;
      function render() {
        if (!_this.enabled || !1 === _this.visible) return;
        let renderer = _nuke.renderer;
        _oldClearColor.copy(renderer.getClearColor()),
          (_oldClearAlpha = renderer.getClearAlpha());
        let oldAutoClear = renderer.autoClear;
        (renderer.autoClear = !0), renderer.setClearColor(_this.clearColor, 0);
        let inputRenderTarget = _inputTexture || _nuke.rttBuffer.texture;
        _luminosityShader.uniforms.luminosityThreshold.value > 0.01 &&
          ((_luminosityShader.uniforms.tDiffuse.value = inputRenderTarget),
          (_mesh.shader = _luminosityShader),
          renderer.renderSingle(_mesh, _nuke.camera, _this.renderTargetBright),
          (inputRenderTarget = _this.renderTargetBright));
        for (let i = 0; i < _nMips; i++)
          (_mesh.shader = _separableBlurShaders[i]),
            (_separableBlurShaders[i].uniforms.colorTexture.value =
              inputRenderTarget),
            (_separableBlurShaders[i].uniforms.direction.value =
              _blurDirectionX),
            renderer.renderSingle(
              _mesh,
              _nuke.camera,
              _renderTargetsHorizontal[i]
            ),
            (_separableBlurShaders[i].uniforms.colorTexture.value =
              _renderTargetsHorizontal[i].texture),
            (_separableBlurShaders[i].uniforms.direction.value =
              _blurDirectionY),
            renderer.renderSingle(
              _mesh,
              _nuke.camera,
              _renderTargetsVertical[i]
            ),
            (inputRenderTarget = _renderTargetsVertical[i]);
        (_mesh.shader = _compositeShader),
          renderer.renderSingle(
            _mesh,
            _nuke.camera,
            _renderTargetsHorizontal[0]
          ),
          renderer.setClearColor(_oldClearColor, _oldClearAlpha),
          (renderer.autoClear = oldAutoClear);
      }
      function resizeHandler() {
        _this.resolution
          .set(_nuke.stage.width, _nuke.stage.height)
          .multiplyScalar(_DPR),
          (_blurDirectionX.x = _DPR),
          (_blurDirectionY.y = _DPR);
        let resx = Math.round(_this.resolution.x / 2),
          resy = Math.round(_this.resolution.y / 2);
        _this.renderTargetBright &&
          _this.renderTargetBright.setSize(resx, resy);
        for (var i = 0; i < _renderTargetsHorizontal.length; i++) {
          _renderTargetsHorizontal[i].setSize(resx, resy),
            _renderTargetsVertical[i].setSize(resx, resy);
          let shader = _separableBlurShaders[i];
          shader && (shader.uniforms.texSize.value = new Vector2(resx, resy)),
            (resx = Math.round(resx / 2)),
            (resy = Math.round(resy / 2));
        }
      }
      (this.uniforms = {
        tUnrealBloom: { value: null, ignoreUIL: !0 },
        unique: _unique,
      }),
        (this.resolution = new Vector2(
          _nuke.stage.width * _DPR,
          _nuke.stage.height * _DPR
        )),
        (this.clearColor = new Color(0, 0, 0)),
        (this.enabled = "boolean" != typeof options.enabled || options.enabled),
        (this.outputTexture = null),
        (function initRTs() {
          if (FX.UnrealBloom.hasRTs) return;
          let pars = {
              minFilter: Texture.LINEAR,
              magFilter: Texture.LINEAR,
              format: Texture.RGBAFormat,
            },
            resx = Math.round(_this.resolution.x / 2),
            resy = Math.round(_this.resolution.y / 2);
          (_this.renderTargetBright = new RenderTarget(resx, resy, pars)),
            (_this.renderTargetBright.texture.generateMipmaps = !1),
            FX.UnrealBloom.putRT(
              "renderTargetBright",
              _this.renderTargetBright
            );
          for (let i = 0; i < _nMips; i++) {
            let renderTargetHorizonal = new RenderTarget(resx, resy, pars);
            (renderTargetHorizonal.texture.generateMipmaps = !1),
              _renderTargetsHorizontal.push(renderTargetHorizonal),
              FX.UnrealBloom.putRT("mipHorizontal" + i, renderTargetHorizonal);
            let renderTargetVertical = new RenderTarget(resx, resy, pars);
            (renderTargetVertical.texture.generateMipmaps = !1),
              _renderTargetsVertical.push(renderTargetVertical),
              FX.UnrealBloom.putRT("mipVertical" + i, renderTargetVertical),
              (resx = Math.round(resx / 2)),
              (resy = Math.round(resy / 2));
          }
          (_this.outputTexture = _renderTargetsHorizontal[0].texture),
            (_this.uniforms.tUnrealBloom.value =
              _renderTargetsHorizontal[0].texture);
        })(),
        (function initScene() {
          (_triangleGeometry = World.QUAD),
            (_luminosityShader = _this.initClass(
              Shader,
              "UnrealBloomLuminosity",
              {
                tDiffuse: { value: null, ignoreUIL: !0 },
                luminosityThreshold: { value: 1 },
                smoothWidth: { value: 0.01, ignoreUIL: !0 },
                defaultColor: { value: new Color(0), ignoreUIL: !0 },
                defaultOpacity: { value: 0, ignoreUIL: !0 },
                unique: _unique,
              }
            )),
            ((_mesh = new Mesh(
              _triangleGeometry,
              _luminosityShader
            )).frustumCulled = !1);
        })(),
        (function initBlurShaders() {
          let resx = Math.round(_this.resolution.x / 2),
            resy = Math.round(_this.resolution.y / 2);
          for (let i = 0; i < _nMips; i++) {
            let shader = _this.initClass(
              Shader,
              "UnrealBloomGaussian",
              {
                unique: _unique,
                colorTexture: { value: null },
                texSize: { value: new Vector2(resx, resy) },
                direction: { value: new Vector2(0.5, 0.5) },
              },
              null,
              (glsl) =>
                `\n#define KERNEL_RADIUS ${_kernelSizeArray[i]}\n#define SIGMA ${_kernelSizeArray[i]}\n${glsl}`,
              `gaussian${i}`
            );
            _separableBlurShaders.push(shader),
              (resx = Math.round(resx / 2)),
              (resy = Math.round(resy / 2));
          }
        })(),
        (function initCompositeShader() {
          let uniforms = {
            bloomStrength: { value: 1 },
            bloomTintColor: { value: new Color("#ffffff") },
            bloomRadius: { value: 0 },
            unique: _unique,
          };
          for (let i = 0; i < _nMips; i++)
            uniforms[`blurTexture${i + 1}`] = {
              value: _useRTPool ? null : _renderTargetsVertical[i].texture,
              ignoreUIL: !0,
            };
          (_compositeShader = _this.initClass(
            Shader,
            "UnrealBloomComposite",
            uniforms,
            null,
            (glsl, type) => {
              if ("vs" === type) return glsl;
              let compositeUniforms = "",
                compositeMain = "";
              for (let i = 0; i < _nMips; i++)
                (compositeUniforms += `uniform sampler2D blurTexture${
                  i + 1
                };\n`),
                  (compositeMain += `lerpBloomFactor(${_bloomFactors[i].toFixed(
                    4
                  )}) * vec4(bloomTintColor, 1.0) * texture2D(blurTexture${
                    i + 1
                  }, vUv) ${i < _nMips - 1 ? "+ " : ""}`);
              return (glsl = glsl.replace(
                "uniform sampler2D blurTexture1;",
                compositeUniforms
              )).replace(
                "lerpBloomFactor(1.0) * vec4(bloomTintColor, 1.0) * texture2D(blurTexture1, vUv)",
                compositeMain
              );
            }
          )).needsUpdate = !0;
        })(),
        (function initPass() {
          _this.pass = _this.initClass(
            NukePass,
            "UnrealBloomPass",
            _this.uniforms
          );
        })(),
        (function addListeners() {
          _this.events.sub(Events.RESIZE, resizeHandler),
            _this.events.sub(_nuke, Nuke.BEFORE_PASSES, render),
            _this.startRender(() => {});
        })(),
        options.noUIL ||
          (ShaderUIL.add(_luminosityShader).setLabel("UnrealBloom Luminosity"),
          ShaderUIL.add(_compositeShader).setLabel("UnrealBloom Composite")),
        this.set("texture", (texture) => {
          _inputTexture = texture;
        }),
        this.get("luminosityShader", (_) => _luminosityShader),
        this.get("compositeShader", (_) => _compositeShader),
        this.set("dpr", (dpr) => {
          (_DPR = dpr), resizeHandler();
        }),
        (this.renderBloom = render),
        (this.renderMesh = _mesh),
        (this.onDestroy = function () {
          _renderTargetsHorizontal.forEach((r) => r.destroy()),
            _renderTargetsVertical.forEach((r) => r.destroy()),
            _this.renderTargetBright && _this.renderTargetBright.destroy();
        }),
        (this.getRTs = function () {
          const rt = FX.UnrealBloom.getRT;
          (_this.renderTargetBright = rt("renderTargetBright")),
            (_renderTargetsHorizontal = []),
            (_renderTargetsVertical = []);
          for (let i = 0; i < _nMips; i++)
            _renderTargetsHorizontal.push(rt("mipHorizontal" + i)),
              _renderTargetsVertical.push(rt("mipVertical" + i)),
              (_compositeShader.uniforms[`blurTexture${i + 1}`].value =
                _renderTargetsVertical[i].texture);
          (_this.outputTexture = _renderTargetsHorizontal[0].texture),
            (_this.uniforms.tUnrealBloom.value =
              _renderTargetsHorizontal[0].texture),
            resizeHandler();
        }),
        (this.putRTs = function () {
          (_this.renderTargetBright = null),
            (_renderTargetsHorizontal = []),
            (_renderTargetsVertical = []);
        }),
        (this.onInvisible = function () {
          _this.putRTs();
        }),
        (this.onVisible = function () {
          _this.getRTs();
        });
    },
    (_) => {
      var _pool = {};
      (FX.UnrealBloom.putRT = function (key, rt) {
        (FX.UnrealBloom.hasRTs = !0), (_pool[key] = rt);
      }),
        (FX.UnrealBloom.getRT = function (key) {
          return _pool[key];
        });
    }
  ),
  Class(function UnsupportedRedirect() {
    Inherit(this, Component);
    var _this = this,
      _tests = [];
    (this.BOTS = [
      "google",
      "apis-google",
      "mediapartners-google",
      "adsbot-google",
      "googlebot",
      "feedfetcher-google",
      "google-read-aloud",
      "storebot-google",
      "bingbot",
      "facebot",
      "facebookexternalhit",
      "slurp",
      "duckduckbot",
      "baiduspider",
      "yandexbot",
      "sogou",
      "exabot",
    ]),
      (this.chrome = 55),
      (this.firefox = 51),
      (this.safari = 8),
      (this.ie = 13),
      (this.requiresWebGL = !0),
      (this.url = "./fallback"),
      (this.test = function () {
        _this.unsupported() &&
          (function redirect() {
            window.location = _this.url;
          })();
      }),
      (this.unsupported = function () {
        return (
          !_this.BOTS.find((bot) => Device.detect(bot)) &&
          (!!_tests.find((test) => test()) ||
            !(
              !_this.requiresWebGL ||
              (Device.graphics.webgl && !GPU.BLOCKLIST)
            ) ||
            ("chrome" === Device.system.browser &&
              Device.system.browserVersion < _this.chrome) ||
            ("firefox" === Device.system.browser &&
              Device.system.browserVersion < _this.firefox) ||
            ("safari" === Device.system.browser &&
              Device.system.browserVersion < _this.safari) ||
            ("ie" === Device.system.browser &&
              Device.system.browserVersion < _this.ie) ||
            !!Utils.query("unsupported"))
        );
      }),
      (this.custom = function (...tests) {
        _tests.push(...tests);
      });
  }, "static"),
  Class(function VelocityTracker(_vector) {
    Inherit(this, Component);
    var _this = this,
      Vector = "number" == typeof _vector.z ? Vector3 : Vector2,
      _velocity = new Vector(),
      _last = new Vector();
    function loop(time, delta) {
      _velocity
        .subVectors(_vector, _last)
        .divideScalar((delta || Render.DELTA) / (1e3 / 60)),
        _last.copy(_vector);
    }
    (this.value = _velocity),
      (this.start = function () {
        _this.startRender(loop);
      }),
      (this.onDestroy = this.stop =
        function () {
          _this.stopRender(loop);
        }),
      (this.copy = function () {
        _last.copy(_vector);
      }),
      (this.update = loop);
  }),
  Class(
    function Video(_params) {
      Inherit(this, Component);
      const _this = this;
      let $video,
        _video,
        _loadingState,
        _handlers,
        _sharedVideo = !1,
        _ready = Promise.create(),
        _loaded = Promise.create(),
        _initialPlay = !0,
        _buffering = !0;
      function startPreload() {
        return (_loadingState = !0), _video.load(), _ready;
      }
      async function startPlayback() {
        if (
          !_this.playing &&
          ((_loadingState = !1),
          _video.readyState < 2 && (_video.load(), await _ready),
          !_this.playing)
        ) {
          _initialPlay &&
            ((_initialPlay = !1),
            _params.currentTime && (_video.currentTime = _params.currentTime)),
            (_this.playing = !0);
          try {
            return await _video.play();
          } catch (error) {
            throw ((_this.playing = !1), error);
          }
        }
      }
      function getSource(src = "") {
        return (
          src &&
            !src.includes(["webm", "mp4", "ogv", "blob", "?"]) &&
            (src += "." + Device.media.video),
          src
        );
      }
      function progress(e) {
        _this.events.fire(Video.PROGRESS, e);
      }
      function timeupdate(e) {
        _this.events.fire(Video.UPDATE, e);
      }
      function play(e) {
        if (_loadingState) return (_loadingState = !1);
        _this.events.fire(Video.PLAY, e);
      }
      function pause(e) {
        _this.events.fire(Video.PAUSE, e);
      }
      function playing(e) {
        _this.events.fire(Video.PLAYING, e);
      }
      function buffering(state) {
        _this.events.fire(Video.BUFFERING, { isBuffering: state });
      }
      function ended(e) {
        _this.events.fire(Video.ENDED, e);
      }
      function waiting(e) {
        _this.events.fire(Video.WAITING, e);
      }
      function canplay(e) {
        loadeddata(), _this.events.fire(Video.CANPLAY, e);
      }
      function loadedmetadata(e) {
        (_this.dimensions.width = _video.videoWidth),
          (_this.dimensions.height = _video.videoHeight),
          _this.events.fire(Video.LOADEDMETADATA, e);
      }
      function loadeddata(e) {
        _video.readyState >= 2 && _ready.resolve(),
          _video.readyState >= 4 && _loaded.resolve();
      }
      function error() {
        _this.playing && (_this.playing = !1),
          _this.events.fire(Video.ERROR, _video.error);
      }
      _params.toJSON &&
        (((_params = _params.toJSON()).autoplay = _params.autoPlay),
        "string" == typeof _params.events &&
          (_params.events = _params.events.split(","))),
        (function initParam() {
          let defaults = {
            muted: !0,
            loop: !1,
            autoplay: !1,
            inline: !0,
            controls: !1,
            currentTime: 0,
            playback: 1,
            preload: !1,
            width: 640,
            height: 360,
            events: [],
            disableRemotePlayback: !0,
          };
          _params = Object.assign(defaults, _params);
        })(),
        (function init() {
          return (
            _params.src instanceof HTMLVideoElement
              ? ((_video = _params.src), (_sharedVideo = !0))
              : ((_video = document.createElement("video")),
                _params.src && (_video.src = getSource(_params.src)),
                _video.setAttribute("crossorigin", "anonymous"),
                (_video.disableRemotePlayback = _params.disableRemotePlayback),
                (_video.autoplay = _params.autoplay),
                (_video.loop = _params.loop),
                (_video.controls = _params.controls),
                (_video.height = _params.height),
                (_video.width = _params.width),
                (_video.defaultMuted = _params.muted),
                (_video.defaultPlaybackRate = _params.playback),
                (_video.preload =
                  "string" == typeof _params.preload
                    ? _params.preload
                    : _params.preload
                    ? "auto"
                    : "none"),
                (_video.muted = _params.autoplay || _params.muted),
                _video.setAttribute("webkit-playsinline", _params.inline),
                _video.setAttribute("playsinline", _params.inline),
                _video.autoplay &&
                  _video.setAttribute("autoplay", _params.autoplay),
                _video.setAttribute("muted", _params.muted),
                _params.loop && _video.setAttribute("loop", _params.loop)),
            (_this.dimensions = {
              width: _params.width,
              height: _params.height,
            }),
            (_this.div = _video),
            ($video = $(_video)),
            _params.autoplay
              ? startPlayback()
              : _params.preload
              ? startPreload()
              : void 0
          );
        })(),
        (function addHandlers() {
          ["loadedmetadata", "loadeddata", "error"].forEach((ev) => {
            _params.events.includes(ev) || _params.events.push(ev);
          }),
            (_handlers = {
              play: play,
              pause: pause,
              ended: ended,
              playing: playing,
              progress: progress,
              waiting: waiting,
              timeupdate: timeupdate,
              loadedmetadata: loadedmetadata,
              loadeddata: loadeddata,
              canplay: canplay,
              error: error,
            }),
            _params.events.forEach((ev) =>
              _video.addEventListener(ev, _handlers[ev], !0)
            ),
            (_video.onwaiting = (e) => {
              (_buffering = !0), buffering(_buffering);
            }),
            (_video.onplaying = (e) => {
              (_buffering = !1), buffering(_buffering);
            });
        })(),
        this.set("loop", (bool) => (_video.loop = bool)),
        this.get("loop", () => _video.loop),
        this.set("src", (src) => {
          (src = getSource(src)) !== _video.src &&
            ((_ready = Promise.create()),
            (_loaded = Promise.create()),
            (_video.src = src),
            _this.playing
              ? ((_this.playing = !1), startPlayback())
              : _params.preload && startPreload());
        }),
        this.get("src", () => _video.currentSrc),
        this.set("volume", (v) => {
          v < 0.001 && (_video.muted = !0), (_video.volume = v);
        }),
        this.get("volume", () => _video.volume),
        this.set("muted", (bool) => (_video.muted = bool)),
        this.get("muted", () => _video.muted),
        this.set("controls", (bool) => (_video.controls = bool)),
        this.get("controls", () => _video.controls),
        this.get("duration", () => _video.duration),
        this.get("ended", () => _video.ended),
        this.get("playback", () => _video.playbackRate),
        this.get("time", () => _video.currentTime),
        this.get("error", () => _video.error),
        this.get("canRender", () => _video.readyState >= 2),
        this.get("canPlayThrough", () => _video.readyState >= 4),
        this.get("paused", () => _video.paused),
        this.get("buffering", () => _buffering),
        this.get("element", () => $video),
        this.get("object", () => $video),
        this.get("video", () => _video),
        this.get("bufferedSeconds", (_) =>
          _video.readyState < 2
            ? 0
            : _video.buffered.end(0) - _video.buffered.start(0)
        ),
        (this.load = async function () {
          return startPreload();
        }),
        (this.play = async function () {
          return startPlayback();
        }),
        (this.pause = function () {
          (_this.playing = !1), _video.pause();
        }),
        (this.stop = function () {
          (_this.playing = !1), _video.pause(), _this.seek(0);
        }),
        (this.seek = function (t) {
          if (_video.fastSeek) return _video.fastSeek(t);
          _video.currentTime = t;
        }),
        (this.seekExact = function (t) {
          _video.currentTime = t;
        }),
        (this.ready = function () {
          return _ready;
        }),
        (this.loaded = function () {
          return _loaded;
        }),
        (this.onDestroy = function () {
          _this.stop(),
            _sharedVideo || (_video.src = ""),
            (function removeListeners() {
              _params.events.forEach((ev) =>
                _video.removeEventListener(ev, _handlers[ev], !0)
              ),
                (_video.onwaiting = () => {}),
                (_video.onplaying = () => {});
            })(),
            (_video = null);
        }),
        (this.setSize = function (width, height) {
          (_video.width = width),
            (_video.height = height),
            (_this.dimensions.width = width),
            (_this.dimensions.height = height);
        });
    },
    () => {
      (Video.PLAY = "hydra_video_play"),
        (Video.CANPLAY = "hydra_video_can_play"),
        (Video.LOADEDMETADATA = "hydra_video_loaded_metadata"),
        (Video.PAUSE = "hydra_video_pause"),
        (Video.PROGRESS = "hydra_video_progress"),
        (Video.UPDATE = "hydra_video_update"),
        (Video.PLAYING = "hydra_video_playing"),
        (Video.BUFFERING = "hydra_video_buffering"),
        (Video.ENDED = "hydra_video_ended"),
        (Video.WAITING = "hydra_video_waiting"),
        (Video.ERROR = "hydra_video_error");
    }
  ),
  Class(
    function VideoTexture(_path, _props = {}) {
      Inherit(this, Component);
      const _this = this;
      let _video,
        _requestId,
        _hasRequestCallback = !1,
        _sharedVideo = !1;
      if (
        ((_this.canUpdate = !0),
        "object" == typeof _path && !(_path instanceof HTMLVideoElement))
      ) {
        let path = _path.path;
        (_props = _path), (_path = path), delete _props.path;
      }
      let {
        loop: loop,
        preload: preload,
        autoplay: autoplay,
        muted: muted,
        firstFrame: firstFrame,
        parseColor: parseColor,
        events: events = [],
      } = _props;
      function update() {
        _requestId = null;
        let updateTex = _video.canRender && _this.canUpdate;
        firstFrame && updateTex && (updateTex = _video.time > 0),
          updateTex &&
            (_this.videoTexture &&
              (_this.texture.destroy(),
              (_this.texture = _this.videoTexture),
              delete _this.videoTexture),
            _this.texture.image ||
              ((_this.texture.image = _video.video), _this.texture.upload()),
            _this.colorParser && _this.colorParser.update(_video.time),
            (_this.texture.loaded = _this.texture.needsUpdate = !0),
            (_this.uniform.value = _this.texture)),
          _hasRequestCallback &&
            (_requestId = _video.element.div.requestVideoFrameCallback(update));
      }
      function noop() {}
      function handleSharedVideoPlaying() {
        start();
      }
      function handleSharedVideoPause() {
        stop();
      }
      function start() {
        (_this.active = !0),
          _requestId &&
            (_video.element.div.cancelVideoFrameCallback(_requestId),
            (_requestId = null)),
          _hasRequestCallback
            ? _this.startRender(noop)
            : _this.startRender(update, 30),
          update();
      }
      function stop() {
        (_this.active = !1),
          _hasRequestCallback
            ? _requestId &&
              _video.element.div.cancelVideoFrameCallback(_requestId)
            : _this.stopRender(update);
      }
      void 0 === loop && (loop = !0),
        void 0 === preload && (preload = !0),
        void 0 === autoplay && (autoplay = !0),
        void 0 === muted && (muted = !0),
        void 0 === firstFrame && (firstFrame = !1),
        void 0 === parseColor && (parseColor = !1),
        void 0 === events && (events = []),
        "undefined" == typeof inline && (inline = !0),
        (_this.uniform = { value: null }),
        (function () {
          let src;
          if (
            (_props.start && defer((_) => _this.start()),
            _path instanceof HTMLVideoElement
              ? ((_sharedVideo = !0),
                (src = _path),
                (autoplay = !1),
                (preload = !1),
                (events = [...events, "pause"]))
              : (src = _path.includes("blob") ? _path : Assets.getPath(_path)),
            !_sharedVideo && _path.includes(["jpg", "png"]))
          ) {
            let noop = (_) => {};
            (_this.texture = Utils3D.getTexture(src)),
              (_this.video = { play: noop, pause: noop }),
              parseColor &&
                (_this.colorParser = _this.initClass(
                  VideoTextureColorParser,
                  src,
                  !0
                ));
          } else {
            let videoEvents = ["timeupdate", "playing", "ended"];
            events.forEach((ev) => {
              videoEvents.includes(ev) || videoEvents.push(ev);
            }),
              (_video = _this.initClass(Video, {
                src: src,
                loop: loop,
                preload: preload,
                autoplay: autoplay,
                muted: muted,
                events: videoEvents,
                inline: inline,
              })),
              (_this.texture = new Texture()),
              (_this.texture.format = Texture.RGBFormat),
              (_this.texture.minFilter = _this.texture.magFilter =
                Texture.LINEAR),
              (_this.texture.generateMipmaps = !1),
              (_this.texture.loaded = !1),
              (_this.video = _video),
              (_this.dimensions = _video.dimensions),
              (_this.texture.dimensions = _this.dimensions),
              _this.events.bubble(_video, Video.PLAYING),
              parseColor &&
                (_this.colorParser = _this.initClass(
                  VideoTextureColorParser,
                  src,
                  !1
                )),
              firstFrame &&
                ((_this.videoTexture = _this.texture),
                (_this.texture = Utils3D.getTexture(firstFrame)));
          }
          (_this.uniform.value = _this.texture),
            (_hasRequestCallback =
              "requestVideoFrameCallback" in HTMLVideoElement.prototype),
            "safari" === Device.system.browser && (_hasRequestCallback = !1),
            _sharedVideo &&
              (function initSharedVideo() {
                _this.events.sub(
                  _video,
                  Video.PLAYING,
                  handleSharedVideoPlaying
                ),
                  _this.events.sub(_video, Video.PAUSE, handleSharedVideoPause);
              })();
        })(),
        this.set("loop", (loop) => (_video.loop = loop)),
        this.set("muted", (muted) => (_video.muted = muted)),
        this.set("src", (src) => {
          _requestId &&
            (_video.element.div.cancelVideoFrameCallback(_requestId),
            (_requestId = null)),
            (_video.src = src.includes("blob") ? src : Assets.getPath(src)),
            _hasRequestCallback &&
              (_requestId =
                _video.element.div.requestVideoFrameCallback(update));
        }),
        (this.start = async function () {
          _sharedVideo || (_video && (start(), await _video.play()));
        }),
        (this.stop = function () {
          _sharedVideo || (_video && (stop(), _video.pause()));
        }),
        (this.seek = function (time) {
          _sharedVideo || (_video && _video.seek(time));
        }),
        (this.onInvisible = function () {
          _sharedVideo ||
            (_this.active && _video.pause(),
            VideoTexture.element().removeChild(_this.video.object, !0));
        }),
        (this.onVisible = function () {
          _sharedVideo ||
            (_this.active && _video.play(),
            VideoTexture.element().add(_this.video.object));
        }),
        (this.onDestroy = function () {
          _this.texture.destroy(),
            _sharedVideo ||
              VideoTexture.element().removeChild(_this.video.object, !0);
        });
    },
    (_) => {
      var $element;
      VideoTexture.element = function () {
        return (
          $element ||
            (($element = Stage.create("VideoTextures")).css({
              position: "absolute",
              pointerEvents: "none",
            }),
            $element.size(0, 0).setZ(-10),
            Stage.add($element)),
          $element
        );
      };
    }
  ),
  Class(function VideoTextureColorParser(_path, _static) {
    Inherit(this, Component);
    const _this = this;
    var _colorData,
      _color = new Color();
    (this.color = new Color()),
      (this.lerp = 1),
      (async function () {
        let path = _path.split(".")[0] + ".json";
        _colorData = await get(path);
      })(),
      (this.update = function (time) {
        if (_colorData)
          for (let key in _colorData)
            if (time <= key) {
              _color.set("#" + _colorData[key]),
                _this.color.lerp(_color, _this.lerp);
              break;
            }
      });
  }),
  Class(
    function SocketConnection(_server, _channel) {
      Inherit(this, Component);
      var _socket,
        _pingPong,
        _this = this,
        _fail = 0,
        _binary = {},
        _time = Render.TIME;
      const PING = "ping",
        PONG = "pong";
      function connect() {
        (_this.pending = !1),
          ((_socket = new WebSocket(_server, [
            "permessage-deflate",
          ])).binaryType = "arraybuffer"),
          (_socket.onopen = open),
          (_socket.onmessage = message),
          (_socket.onclose = close),
          (_socket.onerror = close);
      }
      function sendPing() {
        _socket && _socket.readyState == WebSocket.OPEN && _socket.send(PING);
      }
      function checkIfConnected() {
        _this.blocked ||
          _this.connected ||
          ((_this.blocked = !0), _this.events.fire(SocketConnection.BLOCKED));
      }
      function open(e) {
        (_fail = 0),
          (_this.connected = !0),
          _this.events.fire(SocketConnection.OPEN, { socket: _this }, !0),
          _channel && _this.send("register", { channel: _channel }),
          (_pingPong = setInterval(sendPing, 5e3));
      }
      function message(e) {
        if (e.data != PONG && e.data != PING)
          if ("string" == typeof e.data)
            try {
              let data = JSON.parse(e.data),
                evt = data._evt;
              evt
                ? (delete data._evt, _this.events.fire(evt, data, !0))
                : ((_binary.data = data),
                  _this.events.fire(SocketConnection.BINARY, _binary));
            } catch (er) {}
          else
            (_binary.data = e.data),
              _this.events.fire(SocketConnection.BINARY, _binary);
      }
      function close(e) {
        if (Render.TIME - _time < 50 && !_this.blocked)
          return (
            (_this.blocked = !0), _this.events.fire(SocketConnection.BLOCKED)
          );
        _this.pending ||
          _fail++ > 250 ||
          ((_this.connected = !1),
          (_this.pending = !0),
          _this.events.fire(SocketConnection.CLOSE, { socket: _this }, !0),
          (_this.timer = _this.delayedCall(connect, 250)),
          clearTimeout(_pingPong));
      }
      (this.connected = !1),
        (async function () {
          try {
            connect();
          } catch (e) {
            await defer(),
              _this.events.fire(SocketConnection.ERROR, { socket: _this }),
              (_this.timer = _this.delayedCall(connect, 250)),
              _this.delayedCall(checkIfConnected, 2e4);
          }
        })(),
        (this.send = function (evt, data = {}) {
          if (!_this.connected)
            return _this.delayedCall((_) => _this.send(evt, data), 100);
          (data._evt = evt),
            _socket &&
              _socket.readyState == WebSocket.OPEN &&
              _socket.send(null != data.length ? data : JSON.stringify(data));
        }),
        (this.sendBinary = function (data) {
          _socket &&
            _socket.readyState == WebSocket.OPEN &&
            _socket.bufferedAmount < 1024 &&
            _socket.send(
              "binary:" + (null != data.length ? data : JSON.stringify(data))
            );
        }),
        (this.close = function () {
          (_socket.onclose = null),
            (_socket.onerror = null),
            clearTimeout(_this.timer),
            _socket.close();
        });
    },
    (_) => {
      (SocketConnection.OPEN = "socket_connection_open"),
        (SocketConnection.CLOSE = "socket_connection_close"),
        (SocketConnection.ERROR = "socket_connection_error"),
        (SocketConnection.BINARY = "socket_connection_binary"),
        (SocketConnection.BLOCKED = "socket_connection_blocked");
    }
  ),
  Class(function BridgeUtils() {
    Inherit(this, Component);
  }),
  Class(function Draw(__options = {}) {
    Inherit(this, Component);
    const _this = this,
      _options = {
        scale: 0.2,
        ease: 0.2,
        filter: Texture.LINEAR,
        ...Object.fromEntries(
          Object.entries(__options).filter(([key, value]) => void 0 !== value)
        ),
      };
    let _rt,
      _scene,
      _mousePos = new Vector2(),
      _ease = _options.ease,
      _rtScale = Device.mobile ? 0.7 * _options.scale : _options.scale,
      _width = Stage.width * _rtScale,
      _height = Stage.height * _rtScale;
    function resize() {
      _scene &&
        ((_width = Stage.width * _rtScale),
        (_height = Stage.height * _rtScale),
        _rt.setSize(_width, _height),
        _scene.uniforms.uResolution.value.set(_width, _height));
    }
    function loop() {
      _scene &&
        ((_scene.uniforms.tSource.value = _rt.read),
        _scene.render(_rt.write),
        _rt.swap());
    }
    (_scene = _this.initClass(DrawScene, "DrawShader", "DrawShader", {
      tSource: { value: null },
      uResolution: { value: new Vector2(Stage.width, Stage.height) },
      uPosition: { value: new Vector2() },
      uTrail: { value: 0.94 },
      uMouseMove: RootScene.MOUSE_MOVE,
      uSharp: { value: 0 },
      uSize: { value: 1 },
      uVelocity: RootScene.VELOCITY,
    })),
      (_rt = _this.initClass(PingPongRT, _width, _height, _options.filter)),
      (_rt.disableDepth = !0),
      _this.startRender(loop),
      _this.onResize(resize),
      this.get("scene", () => _scene),
      this.get("rt", () => _rt.read),
      this.get("ease", () => _ease),
      this.set("ease", (value) => {
        _ease = value;
      }),
      this.get("trail", () => _scene.uniforms.uTrail.value),
      this.set("trail", (value) => {
        _scene.uniforms.uTrail.value = value;
      }),
      this.get("sharp", () => _scene.uniforms.uSharp.value),
      this.set("sharp", (value) => {
        _scene.uniforms.uSharp.value = value;
      }),
      this.get("size", () => _scene.uniforms.uSize.value),
      this.set("size", (value) => {
        _scene.uniforms.uSize.value = value;
      }),
      this.get("position", () => _scene.uniforms.uPosition.value),
      this.set("position", (value) => {
        _mousePos.copy(value),
          _scene.uniforms.uPosition.value.lerp(
            _mousePos.clone().multiplyScalar(_rtScale),
            _ease
          );
      });
  }),
  Class(function DrawScene(_vs, _fs, _uniforms) {
    Inherit(this, Component);
    const _this = this,
      _scene = new Scene();
    let shader;
    !(function () {
      (_uniforms.depthWrite = !1),
        (shader = _this.initClass(Shader, _vs, _fs, _uniforms));
      let mesh = new Mesh(World.QUAD, shader);
      (shader.depthWrite = !1),
        (mesh.noMatrices = !0),
        _scene.add(mesh),
        (_this.uniforms = shader.uniforms);
    })(),
      (this.render = function renderScene(rt) {
        (World.RENDERER.autoClear = !1),
          World.RENDERER.renderSingle(_scene.children[0], World.CAMERA, rt),
          (World.RENDERER.autoClear = !0);
      }),
      this.get("shader", () => shader);
  }),
  Class(
    function GLUIBaseBridge(__rootDiv, enable3D = !1, keepAlive = !1) {
      Inherit(this, GLUIElement);
      const _this = this;
      let _scrollPos = 0,
        _fixed = !1;
      function debounceResize(debounce = 400) {
        if (!_this.manualResize)
          return (
            _this.flag("isResized", !1), Utils.debounce(handleResize, debounce)
          );
      }
      async function handleResize() {
        await _this.handleResize?.(), _this.flag("isResized", !0);
      }
      (_this.wrapper = $gl()),
        keepAlive || ((_this.wrapper.alpha = 0), _this.wrapper.hide()),
        (_this.wrapper.name = __rootDiv.className),
        (async function () {
          _this.flag("ready", !1);
          let ready = Promise.create();
          await defer(),
            _this.onResize(() => debounceResize(), !1),
            ready.then(debounceResize),
            _this.init && (await _this.init()),
            Hydra.LOCAL &&
              Utils.query("hotreload") &&
              (function debugObserver() {
                const observer = new MutationObserver(_this.mutationHandler);
                __rootDiv.attr("GLUIBridgeRoot"),
                  observer.observe(__rootDiv.div, {
                    subtree: !0,
                    attributes: !0,
                  });
              })(),
            ready.resolve(),
            _this.flag("ready", !0),
            _this.flag("isResized", !0);
        })(),
        (_this.onDestroy = () => {}),
        (this.remove = function remove() {
          _this.element.remove();
        }),
        (this.createTween = function createTween(glui) {
          return (
            glui._tween || (glui._tween = glui.tween),
            (props, ...tweenProps) => {
              glui.tweenValues || (glui.tweenValues = {}),
                Object.keys(props).forEach((key) => {
                  glui.tweenValues[key] || (glui.tweenValues[key] = 0);
                });
              const modProps = Object.entries(props).reduce(
                (prev, [key, value]) => (
                  (glui.tweenValues[key] = value),
                  glui.initialValues[key]
                    ? { ...prev, [key]: value + glui.initialValues[key] }
                    : { ...prev, [key]: value }
                ),
                {}
              );
              return glui._tween(modProps, ...tweenProps);
            }
          );
        }),
        (this.createTransform = function createTransform(glui) {
          return (props) => {
            props
              ? Object.entries(props).forEach(([key, value]) => {
                  glui.initialValues[key]
                    ? (glui[key] = value + glui.initialValues[key])
                    : (glui[key] = value);
                })
              : Object.entries(glui.initialValues).forEach(([key, value]) => {
                  glui[key] = value + (glui?.tweenValues?.[key] || 0);
                });
          };
        }),
        (this.createPureTransform = function createPureTransform(glui) {
          return (props) => {
            Object.entries(props).forEach(([key, value]) => {
              glui[key] = value;
            });
          };
        }),
        (this.getBoundingClientRect = function getBoundingClientRect(el) {
          let {
              top: top,
              left: left,
              width: width,
              height: height,
            } = el.getBoundingClientRect(),
            transformArr =
              ((e = el),
              window
                .getComputedStyle(e)
                .transform.split(/\(|,|\)/)
                .slice(1, -1)
                .map((v) => parseFloat(v)));
          var e;
          if (6 === transformArr.length) {
            const t = transformArr;
            let det = t[0] * t[3] - t[1] * t[2];
            return {
              width: width / t[0],
              height: height / t[3],
              left:
                (left * t[3] - top * t[2] + t[2] * t[5] - t[4] * t[3]) / det,
              top:
                (-left * t[1] + top * t[0] + t[4] * t[1] - t[0] * t[5]) / det,
            };
          }
          return { top: top, left: left, width: width, height: height };
        }),
        (this.setColor = function setColor(color, colorValue) {
          const colorComp = colorValue
              ?.split("(")[1]
              ?.split(")")[0]
              ?.split(",")
              ?.map((c) => c / 255) || [0, 0, 0, 0],
            alpha = colorComp[3] >= 0 ? colorComp[3] : 1 / 255;
          return color.setRGB(...colorComp.slice(0, 3)), 255 * alpha;
        }),
        (this.isReady = function isReady() {
          return _this.wait("ready");
        }),
        (this.setInitialValues = function setInitialValues(
          element,
          boundingBox
        ) {
          if (!boundingBox) throw Error("Need to populate boundingBox");
          const { left: left, width: width, height: height } = boundingBox;
          let { top: top } = boundingBox;
          _this.fixed || (top += _scrollPos),
            (element.initialValues = {
              x: enable3D ? _this.get3dMultiplier(left) : left,
              y: enable3D ? _this.get3dMultiplier(Stage.height - top) : top,
              width: enable3D ? _this.get3dMultiplier(width) : width,
              height: enable3D ? _this.get3dMultiplier(height) : height,
            });
        }),
        (this.cssMatrixToObject = function cssMatrixToObject(matrix) {
          var values = matrix.match(
              /([-0-9.]+)[, ]+([-0-9.]+)[, ]+([-0-9.]+)[, ]+([-0-9.]+)[, ]+([-0-9.]+)[, ]+([-0-9.]+)/
            ),
            a = parseFloat(values[1]),
            b = parseFloat(values[2]),
            c = parseFloat(values[3]),
            d = parseFloat(values[4]);
          return {
            translate: [parseFloat(values[5]), parseFloat(values[6]), 0],
            rotate: [0, 0, Math.atan2(b, a) * (180 / Math.PI)],
            scale: [Math.sqrt(a * a + b * b), Math.sqrt(c * c + d * d), 1],
          };
        }),
        (this.getParentsUntil = function getParentsUntil(el, selector) {
          let parents = [],
            _el = el.parentNode;
          for (; _el && "function" == typeof _el.matches; ) {
            if ((parents.unshift(_el), _el.matches(selector))) return parents;
            _el = _el.parentNode;
          }
          return [];
        }),
        (this.setTransformOrigin = function setTransformOrigin(x, y) {
          (_this.wrapper.x = x),
            (_this.wrapper.y = y),
            _this.element.initialValues
              ? ((_this.element.x = -(x - _this.element.initialValues.x)),
                (_this.element.y = -(y - _this.element.initialValues.y)))
              : ((_this.element.x = -x), (_this.element.y = -y));
        }),
        (this.get3dMultiplier = (value) =>
          GLUIBaseBridge.get3dMultiplier(value, _this)),
        this.set("scrollPos", (val) => (_scrollPos = val)),
        this.get("scrollPos", () => _scrollPos),
        this.set("fixed", (val) => (_fixed = val)),
        this.get("fixed", () => _fixed);
    },
    (_) => {
      GLUIBaseBridge.get3dMultiplier = (value = 0, scope) =>
        ((12 * Math.tan((Math.PI / 180) * 15)) / Stage.height) * value;
    }
  ),
  Class(function GLUIShapeBridge(
    __gluiContainer,
    __element,
    { uniforms: __uniforms, ...__config }
  ) {
    const _element = __element?.div ? __element : $(__element);
    Inherit(
      this,
      GLUIBaseBridge,
      _element,
      __config.enable3D,
      __config.keepAlive
    );
    const _this = this;
    let _map,
      _color = new Color(),
      _borderColor = new Color();
    let _shader,
      _config = {
        batch: !0,
        firstRender: !0,
        takeTransform: !1,
        shaderName: "GLUIShapeBridgeShader",
        onBeforeBuildShader: (shader) => shader,
        uniforms: {
          tMap: { value: null },
          uTransition: { value: 1 },
          uResolution: { value: new Vector2() },
          uBorder: { value: new Vector2(1.5, 10) },
          uBorderAlpha: { value: 1 },
          uColor: { value: new Color() },
          uBorderColor: { value: new Color() },
          uAlphaValues: { value: new Vector3() },
          uMapResolution: { value: new Vector2(1, 1) },
          uType: { value: 0 },
          uVelocity: RootScene.VELOCITY,
          uMouseMove: RootScene.MOUSE_MOVE,
          ...__uniforms,
        },
        ...__config,
      };
    _this.init = async () => {
      (_shader =
        _config?.shader ||
        _this.initClass(
          Shader,
          _config.shaderName,
          _config.shaderName,
          _config.uniforms,
          _config.onBeforeBuildShader
        )),
        (_shader.neverRender = _config.neverRender),
        (_this.shader = _shader),
        await (async function mount() {
          (_this.element.$element = _element),
            await (async function create(element) {
              let map = await _config.map?.(),
                mapResolution = new Vector2(1, 1);
              map
                ? (_map = map)
                : element.getAttribute("src")
                ? ((map = Utils3D.getTexture(element.getAttribute("src"))),
                  (_map = map),
                  await _map.promise,
                  mapResolution.set(
                    map.dimensions.width,
                    map.dimensions.height
                  ))
                : (map = _color.getHexString());
              const style = getComputedStyle(element),
                boundingBox = getBoundingClientRect(element),
                {
                  width: width,
                  height: height,
                  left: left,
                  top: top,
                } = boundingBox;
              _this.setColor(_color, style["background-color"]),
                (_this.element = $gl(width, height, map, !1, _config.segments)),
                _this.setInitialValues(_this.element, boundingBox),
                (_this.element.tween = _this.createTween(_this.element)),
                (_this.element.transform = _this.createTransform(
                  _this.element
                )),
                (_this.element.boundingBox = boundingBox),
                (_this.width = boundingBox.width),
                (_this.height = boundingBox.height),
                _shader.set(
                  "uResolution",
                  new Vector2(_this.width, _this.height)
                ),
                mapResolution && _shader.set("uMapResolution", mapResolution);
              return (
                resetPosition(boundingBox),
                (_this.element.firstRender = _config.firstRender),
                _this.element.useShader(_shader),
                setStyle(_this.element, style),
                (_this.element.domElement = element),
                (_this.element.domBoundingBox = boundingBox),
                await _this.wait(() => _this.element.isDirty),
                _this.element
              );
            })(_element.div),
            _this.wrapper.add(_this.element),
            __gluiContainer && __gluiContainer.add(_this.wrapper);
          __config.enable3D &&
            (_this.element.enable3D(!0), _this.wrapper.enable3D(!0));
        })(),
        _this.flag("ready", !0);
    };
    function setStyle(
      $el = _this.element,
      style = getComputedStyle(_element.div)
    ) {
      const backgroundAlpha = _this.setColor(_color, style["background-color"]),
        borderAlpha = _this.setColor(_borderColor, style["border-color"]);
      if (
        (_this.setColor(_borderColor, style["border-color"]),
        "none" !== style["background-image"] &&
          !_map &&
          $el.shader.uniforms?.tMap &&
          ($el.shader.uniforms.tMap.value = Utils3D.getTexture(
            style["background-image"]
          )),
        !_config?.shader)
      ) {
        const height = parseFloat(style.height)
          ? 0.45 * parseFloat(style.height)
          : parseFloat(style["border-radius"]);
        $el.shader.uniforms?.uBorder &&
          (($el.shader.uniforms.uBorder.value.x =
            parseFloat(style["border-top-width"]) || 0),
          ($el.shader.uniforms.uBorder.value.y = Math.min(
            parseFloat(style["border-radius"]),
            height
          ))),
          $el.shader.uniforms?.uColor &&
            $el.shader.uniforms.uColor.value.set(_color.getHexString()),
          $el.shader.uniforms?.uBorderColor &&
            $el.shader.uniforms.uBorderColor.value.set(
              _borderColor.getHexString()
            ),
          $el.shader.uniforms?.uAlphaValues &&
            (($el.shader.uniforms.uAlphaValues.value.x = backgroundAlpha),
            ($el.shader.uniforms.uAlphaValues.value.y =
              _map || _config.useSolidColor ? 1 : 0),
            ($el.shader.uniforms.uAlphaValues.value.z =
              _map && !_config.useSolidColor ? 1 : 0)),
          $el.shader.uniforms?.uBorderAlpha &&
            ($el.shader.uniforms.uBorderAlpha.value = borderAlpha);
      }
    }
    function resetPosition(boundingBox) {
      _this.setInitialValues(
        _this.element,
        boundingBox || getBoundingClientRect(_element.div)
      );
      const { width: width, height: height } = _this.element.initialValues;
      _shader && _shader.uniforms?.uResolution.value.set(width, height),
        (_this.element.width = width),
        (_this.element.height = height);
      const style = getComputedStyle(_element.div);
      (_this.zIndex =
        "auto" === style["z-index"] ? 0 : parseInt(style["z-index"])),
        _this.element.setZ(
          __config.enable3D ? 1e3 - _this.zIndex : _this.zIndex
        ),
        __config.enable3D &&
          ((_this.wrapper.x = _this.get3dMultiplier((-1 * Stage.width) / 2)),
          (_this.wrapper.y = _this.get3dMultiplier((-1 * Stage.height) / 2)),
          (_this.wrapper.z = -1 * _this.zIndex)),
        _this.element.transform();
    }
    function getBoundingClientRect(element) {
      return _config.takeTransform
        ? element.getBoundingClientRect()
        : _this.getBoundingClientRect(element);
    }
    (this.mutationHandler = () => {
      setStyle(), resetPosition();
    }),
      (this.handleResize = function handleResize(boundingBox) {
        resetPosition(boundingBox), _this.afterResize?.();
      }),
      (this.resetPosition = resetPosition),
      (this.setStyle = setStyle),
      (this.setImage = function setImage(image) {
        _this.element.tMap.value = image;
      }),
      (this.setType = function setType(value) {
        _this.element.shader.uniforms.uType.value = value;
      }),
      this.get("shader", () => _shader);
  }),
  Class(function GLUITextBridge(__gluiContainer, __element, __config) {
    const _element = __element?.div ? __element : $(__element);
    Inherit(this, GLUIBaseBridge, _element, __config.enable3D);
    const _this = this;
    let _fontWeight,
      _shader,
      _batch,
      _prevBatch,
      _prevElement,
      _splitTextInstance,
      _color = new Color(),
      _config = {
        offsetSize: 1,
        offsetY: 0,
        offsetX: 0,
        batch: !0,
        firstRender: !0,
        revert: !0,
        noBalance: !0,
        fontFamily: null,
        chars: null,
        shaderName: "GLUITextBridgeShader",
        onBeforeBuildShader: (shader) => shader,
        uniforms: {},
        ...__config,
      },
      _gluiElements = [];
    _this.init = async () => {
      (_this.element.domElement = _element.div),
        (_this.element.$element = _element),
        (_this.element.domBoundingBox = _this.getBoundingClientRect(
          _element.div
        )),
        (_shader = _this.initClass(
          Shader,
          _config.shaderName,
          _config.shaderName,
          _config.uniforms,
          _config.onBeforeBuildShader
        )),
        (_this.shader = _shader),
        await handleResize();
    };
    function valueFromFnProp(key, object = _config) {
      return "function" == typeof object[key]
        ? object[key]({ fontWeight: _fontWeight })
        : object[key];
    }
    async function mount() {
      await defer(),
        _splitTextInstance
          ? _splitTextInstance.split()
          : (_splitTextInstance = _this.initClass(SplitText, _element, {
              type: "lines, words, chars",
              splitChars: !0,
              noAriaLabel: !1,
              noBalance: _config.noBalance,
            })),
        (_gluiElements.length = 0),
        (_gluiElements = []),
        _batch && ((_prevBatch = _batch), (_prevElement = _this.element)),
        (_this.element = $gl()),
        (_this.element.x = _prevElement?.x || 0),
        (_this.element.y = _prevElement?.y || 0),
        __config.enable3D && _this.element.enable3D(!0),
        (_batch = _config.batch ? _this.initClass(GLUIBatchText) : $gl()),
        _this.element.add(_batch),
        _splitTextInstance.chars.forEach((e, i) => {
          let gluiEl = (function create(element) {
            const style = getComputedStyle(element),
              color = style.color
                ? style.color.split("(")[1].split(")")[0]
                : "white";
            let fontFamily = `${style["font-family"]
              .split(",")[0]
              .replace(/"/g, "")}`;
            (_fontWeight = style["font-weight"] || 400),
              _config.fontFamily &&
                (fontFamily = valueFromFnProp("fontFamily"));
            const fontSizeNormalized =
                (style["font-size"] ? parseFloat(style["font-size"]) : 16) *
                valueFromFnProp("offsetSize"),
              colorRGB = _color.setRGB(...color.split(",").map((c) => c / 255));
            let textContent = element.textContent || "";
            switch (style["text-transform"]) {
              case "uppercase":
                textContent = element.textContent.toUpperCase();
                break;
              case "lowercase":
                textContent = element.textContent.toLowerCase();
                break;
              case "capitalize":
                textContent = element.textContent
                  .toLowerCase()
                  .split(" ")
                  .map((word) => word.charAt(0).toUpperCase() + word.slice(1))
                  .join(" ");
            }
            const $el = $glText(
              textContent,
              fontFamily,
              __config.enable3D
                ? _this.get3dMultiplier(fontSizeNormalized)
                : fontSizeNormalized,
              {
                color: colorRGB,
                align: "left",
                letterSpacing: 0,
                wordSpacing: 0,
                lineHeight: 0,
              }
            );
            __config.enable3D && $el.enable3D(!0);
            if (style?.transform && "none" !== style?.transform) {
              const { rotate: rotate } = _this.cssMatrixToObject(
                style.transform
              );
              _this.element.rotation = -rotate[2];
            }
            Utils.query("debug") && $el.setColor("#ff0000");
            return (
              ($el.firstRender = _config.firstRender),
              ($el.alpha = _this.wrapper.alpha),
              $el.useShader(_shader),
              $el
            );
          })((e instanceof HydraObject ? e : e.hydraObject).div);
          _gluiElements[i] = gluiEl;
        }),
        await Promise.all(_gluiElements.map((el) => el.text.ready())),
        await Promise.all(_gluiElements.map((el) => _batch.add(el))),
        (_this.element._text = __element.ariaLabel),
        (_this.element.group._text = __element.ariaLabel),
        _this.wrapper.add(_this.element),
        __gluiContainer && __gluiContainer.add(_this.wrapper),
        __config.enable3D &&
          (_this.wrapper.enable3D(!0),
          (_this.wrapper.x = _this.get3dMultiplier((-1 * Stage.width) / 2)),
          (_this.wrapper.y = _this.get3dMultiplier((-1 * Stage.height) / 2))),
        _prevBatch &&
          _prevElement &&
          (await _this.wait(200),
          _prevBatch instanceof GLUIBatchText
            ? _prevBatch?.destroy?.()
            : _prevBatch?.remove(),
          _prevElement.remove());
    }
    async function resetPosition() {
      await mount(),
        await Promise.all(
          _splitTextInstance.chars.map(async (el, i) => {
            const boundingBox = _this.getBoundingClientRect(el.div),
              gluiText = _gluiElements[i];
            await gluiText.text.ready();
            let customOffsetX = 0,
              customOffsetY = 0;
            if (_config?.chars?.[gluiText.text.string]) {
              const config = _config.chars[gluiText.text.string],
                offsetX = valueFromFnProp("offsetX", config),
                offsetY = valueFromFnProp("offsetY", config);
              offsetX && (customOffsetX = boundingBox.width * offsetX),
                offsetY && (customOffsetY = boundingBox.height * offsetY);
            }
            gluiText.boundingBox = boundingBox;
            const x =
              boundingBox.left +
              boundingBox.width * valueFromFnProp("offsetX") +
              customOffsetX;
            let { top: top } = boundingBox;
            _this.fixed || (top += _this.scrollPos);
            const y =
              top +
              boundingBox.height * valueFromFnProp("offsetY") +
              customOffsetY;
            (gluiText.x = __config.enable3D ? _this.get3dMultiplier(x) : x),
              (gluiText.y = __config.enable3D
                ? _this.get3dMultiplier(Stage.height - y)
                : y);
            const style = getComputedStyle(_element.div),
              z = "auto" === style["z-index"] ? 0 : parseInt(style["z-index"]);
            return _this.setZ(z), await defer(), gluiText.text.ready();
          })
        );
    }
    async function handleResize() {
      _this.flag("busy", !0),
        _splitTextInstance && _splitTextInstance.split(),
        await resetPosition(),
        await defer(),
        _splitTextInstance && _config.revert && _splitTextInstance.revert(),
        await _this.afterResize?.(),
        _this.flag("busy", !1);
    }
    (this.transform = function transform(props) {
      _this.flag("ready") &&
        Object.entries(props).forEach(([key, value]) => {
          _this.element[key] = value;
        });
    }),
      (this.mutationHandler = () => {
        _this.flag("busy") || handleResize();
      }),
      (this.resetPosition = resetPosition),
      (this.handleResize = handleResize),
      (this.setZ = function setZ(value) {
        _this.flag("zForced", !0),
          (_this.zIndex = value),
          __config.enable3D &&
            (_this.wrapper.z = -1 * _this.zIndex + _config.zOffset),
          _batch.setZ(__config.enable3D ? 1e3 - _this.zIndex : _this.zIndex),
          _this.element.setZ(
            __config.enable3D ? 1e3 - _this.zIndex : _this.zIndex
          );
      }),
      this.get("batch", () => _batch),
      this.get("gluiElements", () => _gluiElements);
  }),
  Class(
    function BMProfileShaderManager() {
      Inherit(this, Component);
      ShaderManager.setLerp(0.05),
        (ShaderManager.globals = BMProfileShaderManager.globalUniforms);
    },
    "singleton",
    (_) => {
      BMProfileShaderManager.globalUniforms = {};
    }
  ),
  Class(function PingPongRT(
    _width,
    _height,
    _filter = Texture.LINEAR,
    _format = Texture.RGBAFormat
  ) {
    Inherit(this, Component);
    const _this = this,
      type =
        Device.mobile || Renderer.type !== Renderer.WEBGL1
          ? Texture.HALF_FLOAT
          : Texture.FLOAT;
    let _fbo1 = new RenderTarget(_width, _height, {
        minFilter: _filter,
        magFilter: _filter,
        format: _format,
        type: type,
      }),
      _fbo2 = new RenderTarget(_width, _height, {
        minFilter: _filter,
        magFilter: _filter,
        format: _format,
        type: type,
      });
    (this.fbo = _fbo1),
      (this.uniform = { value: _fbo1 }),
      (_fbo1.disableDepth = !0),
      (_fbo2.disableDepth = !0),
      (_fbo1.generateMipmaps = !1),
      (_fbo2.generateMipmaps = !1),
      (this.setSize = function (width, height) {
        _fbo1.setSize(width, height), _fbo2.setSize(width, height);
      }),
      (this.swap = function () {
        let temp = _fbo1;
        (_fbo1 = _fbo2), (_fbo2 = temp), (_this.uniform.value = _fbo1);
      }),
      this.get("read", (_) => _fbo1),
      this.get("write", (_) => _fbo2);
  }),
  Class(
    function ViewUtil() {
      Inherit(this, Component);
      const _this = this;
      (this.findView = () => ViewUtil.findView(_this)),
        (this.findScene = () => ViewUtil.findScene(_this)),
        (this.isViewActive = () => ViewUtil.isViewActive(_this));
    },
    (_) => {
      (ViewUtil.findView = function (item) {
        let p = item.parent;
        for (; p; ) {
          if (p.isView) return p;
          p = p.parent;
        }
      }),
        (ViewUtil.findScene = function (item) {
          const view = ViewUtil.findView(item);
          return view?.scene;
        }),
        (ViewUtil.isViewActive = function (view) {
          const viewName = view.name.toLowerCase();
          return (
            viewName === Root.store.get("view") ||
            viewName === view?.parent?.store?.get("view")
          );
        });
    }
  ),
  Class(function BackgroundShader(_mesh, _shader, _group, _input) {
    Inherit(this, Component);
    _shader.addUniforms({
      uColor: { value: new Color().setStyle(StyleGuide.colors.brand) },
      uVelocity: RootScene.VELOCITY,
    });
  }),
  Class(function MSDFTextureShader(_mesh, _shader, _group, _input) {
    Inherit(this, Component);
    _shader.addUniforms({
      uColor: { value: new Color().setStyle(StyleGuide.colors.brand) },
      tMap: { value: null },
      uAlpha: { value: 1 },
    }),
      ShaderUIL.add(_shader);
  }),
  Class(function TestShader(_mesh, _shader, _group, _input) {
    Inherit(this, Component);
    _shader.addUniforms({});
  }),
  Class(function Tests() {
    (this.getDPR = function () {
      return GPU.OVERSIZED
        ? 0.8
        : GPU.lt(0)
        ? 1
        : GPU.lt(1)
        ? Math.min(Device.pixelRatio, 1.2)
        : GPU.lt(2)
        ? Math.min(Device.pixelRatio, 1.35)
        : GPU.lt(3)
        ? Math.min(Device.pixelRatio, 1.5)
        : GPU.mobileLT(0)
        ? 1
        : GPU.mobileLT(1)
        ? Math.min(Device.pixelRatio, 1.2)
        : GPU.mobileLT(2)
        ? Math.min(Device.pixelRatio, 1.35)
        : GPU.mobileLT(3)
        ? Math.min(Device.pixelRatio, 1.5)
        : GPU.mobileLT(4)
        ? Math.min(Device.pixelRatio, 2)
        : 1;
    }),
      (this.capFPS = function () {
        return GPU.lt(0) || GPU.mobileLT(2)
          ? 30.001
          : GPU.lt(3)
          ? Render.REFRESH_RATE > 60
            ? 60.001
            : null
          : Device.mobile && Render.REFRESH_RATE > 100
          ? 100.001
          : null;
      }),
      (this.renderFXAA = function () {
        return !1 === this.msaaSamples() && !GPU.lt(1) && !GPU.mobileLT(2);
      }),
      (this.lowEndMobile = function () {
        return GPU.mobileLT(3) || Utils.query("lowEndMobile");
      }),
      (this.enableWorldNukeMSAA = function () {
        return !0;
      }),
      (this.msaaSamples = function () {
        return (
          !(!Device.graphics.webgl.webgl2 || Utils.query("compat")) &&
          !Device.system.xr.vr &&
          !GPU.lt(2) &&
          !GPU.mobileLT(2) &&
          (GPU.lt(3) ? 2 : GPU.mobileLT(3) ? 1 : GPU.mobileLT(5) ? 2 : 4)
        );
      }),
      (this.useVFX = function () {
        return !!GPU.gt(3) || (Device.mobile, !1);
      }),
      (this.bloomEnabled = function () {
        return !0;
      }),
      (this.bloomMips = function () {
        return Device.mobile
          ? 3
          : GPU.gt(5)
          ? 5
          : GPU.gt(3)
          ? 4
          : GPU.gt(1)
          ? 3
          : 2;
      }),
      (this.renderRGBShift = function () {
        return !0;
      }),
      (this.useFluids = function () {
        return !GPU.lt(0) && !(GPU.mobileLT(3) && !Device.mobile.lowPowerMode);
      }),
      (this.getMaximumMVQuality = () =>
        Device.mobile?.lowPowerMode
          ? "low"
          : Device.mobile || GPU.lt(3)
          ? "medium"
          : "high"),
      (this.getMinimumMVQuality = () =>
        Device.mobile || GPU.lt(3) ? "low" : "medium"),
      (this.getMaxImgRes = () =>
        Device.mobile
          ? "400"
          : GPU.gt(4) && Stage.width > 900
          ? "1600"
          : "1024"),
      (this.useMVHover = () => !Device.mobile && !!GPU.gt(3)),
      (this.debugHitarea = () => Utils.query("debugHit"));
  }, "static"),
  Class(
    function Container() {
      Inherit(this, Element);
      const _this = this,
        $this = this.element;
      var _app,
        _hydraNextBus = window.hydraNextBus,
        _valtio = _hydraNextBus.utils;
      function resize() {
        if (_this.vh === window.innerHeight) return;
        _this.vh = window.innerHeight;
        const vh = 0.01 * window.innerHeight;
        document.documentElement.style.setProperty(
          "--vh",
          `${Math.round(vh, 2)}px`
        );
      }
      function handleSlugChange(slug) {}
      function handleRouteChangeStart({ url: url, shallow: shallow }) {}
      function handleRouteChangeComplete({ url: url, shallow: shallow }) {}
      Mobile.allowNativeScroll(),
        resize(),
        setBusState("transitioning", !0),
        setBusState("containerReady", !0),
        (_app = _this.initClass(App)),
        (function initHTML() {
          Stage.add($this), $this.css({ position: "static" });
        })(),
        (async function loadView() {
          let promise,
            loader = _this.initClass(
              AssetLoader,
              Assets.list().filter(
                _app.loaderData.assets.split(",").map((f) => f.trim())
              )
            );
          _this.events.sub(loader, Events.COMPLETE, () => {
            Container.readyProm.resolve();
          }),
            (Global.loader = loader),
            Global.loader.add(1),
            await Hydra.ready(),
            await Initializer3D.createWorld(),
            (function initView() {
              World.instance(),
                $this.add(World.ELEMENT),
                _this.initClass(window[_app.entryPointData]),
                _valtio.subscribeKey(
                  _hydraNextBus.hydra.state,
                  "slug",
                  handleSlugChange
                ),
                subBusState("routeChangeStart", handleRouteChangeStart),
                subBusState("routeChangeComplete", handleRouteChangeComplete);
            })(),
            Container.hydraReadyProm.resolve(),
            (Global.mvs = {});
          let featuredDevices = {
            "/contact": ["glove"],
            "/projects/gdk": ["dashboard"],
            "/projects/spotify-rapuk": ["boombox"],
            "/projects/dreamwave": ["keycard"],
            "/projects/chrome-pit-crew": ["gameboy"],
            "/projects/reliable-robotics": ["controller"],
            "/projects/dream-keeper": ["tablet"],
            "/projects/search-through-time": ["magnifying-glass"],
          };
          [
            "dashboard",
            "boombox",
            "keycard",
            "gameboy",
            "controller",
            "tablet",
            "magnifying-glass",
            "glove",
          ].forEach((mv) => {
            let featured =
              featuredDevices[window.location.pathname]?.includes(mv) ||
              "gameboy";
            (Global.mvs[mv] = _this.initClass(MotionVectorLayout, mv, {
              featured: featured,
            })),
              featured && (promise = Global.mvs[mv].wait("ready"));
          }),
            promise
              ? await promise.then(() => {
                  ButtermaxVFX.instance(), Global.loader.trigger(1);
                })
              : (ButtermaxVFX.instance(), Global.loader.trigger(1));
        })(),
        _this.onResize(resize);
    },
    "singleton",
    () => {
      (Container.environment = ""),
        (Container.readyProm = Promise.create()),
        (Container.hydraReadyProm = Promise.create()),
        (Container.hasInitialized = async () => {
          const prom = Promise.create();
          Utils.query("p") || (await Container.readyProm), prom.resolve();
        }),
        (Container.hydraReady = async () => {
          const prom = Promise.create();
          Utils.query("p") || (await Container.hydraReadyProm), prom.resolve();
        });
    }
  ),
  Class(function Playground() {
    Inherit(this, Component);
    const _this = this;
    let _view, _isRT;
    function initGLUIView(element) {
      GLUI.Stage.add(element);
    }
    !(async function () {
      await UILStorage.ready(),
        (Global.PLAYGROUND = Utils.query("p")),
        (function initThree() {
          World.instance(),
            Stage.add(World.ELEMENT),
            (function initDoubleClick() {
              _this.lastClick = performance.now();
              const speed = 180;
              Stage.bind("click", function () {
                performance.now() - _this.lastClick < speed &&
                  (function onDoubleClick() {
                    let camera = _isRT ? _view.nuke.camera : World.NUKE.camera,
                      scene = _isRT ? _view.scene : World.SCENE,
                      raycaster = Raycaster.find(camera),
                      objs = [];
                    scene.traverse((obj) => {
                      objs.push(obj);
                    });
                    let intersects = raycaster.checkHit(objs, Mouse),
                      found = !1;
                    intersects.forEach((element) => {
                      if (found) return;
                      const uilGraph = element?.object?.uilGraph;
                      uilGraph &&
                        ((found = !0),
                        uilGraph?.find?.(element?.object?.uilName)?.focus?.());
                    });
                  })(),
                  (_this.lastClick = performance.now());
              });
            })();
        })(),
        (function initView() {
          let request = Global.PLAYGROUND.split("/")[0],
            view = window[`Playground${request}`] || window[request] || null;
          if (!view) throw `No Playground class ${request} found.`;
          (_view = view.instance ? view.instance() : _this.initClass(view)),
            _view.element
              ? _view.element.mesh
                ? initGLUIView(_view.element)
                : Stage.add(_view.element)
              : _view.root &&
                _view.$gluiObject &&
                (function initUI3DView(ui3d) {
                  Device.mobile
                    ? initGLUIView(ui3d.root)
                    : (GLUI.Scene.add(ui3d.$gluiObject),
                      (function addUIToWorldScene(uiGroup) {
                        let group = new Group(),
                          v3 = new Vector3(),
                          distance = USING_XR ? 1.5 : 2;
                        return (
                          v3
                            .set(0, 0, -distance)
                            .applyQuaternion(World.CAMERA.quaternion),
                          group.position.copy(World.CAMERA.position).add(v3),
                          group.lookAt(World.CAMERA.position),
                          group.add(uiGroup),
                          World.SCENE.add(group),
                          group
                        );
                      })(ui3d.$gluiObject.anchor));
                })(_view);
          if (_view.rt && _view.scene && _view.nuke)
            if (request.includes("Figma")) {
              let dimensions = _view.dimensions,
                $obj = $gl(dimensions[0], dimensions[1], _view.rt.texture);
              ($obj.x = 40),
                ($obj.y = 40),
                "portrait" === Utils.query("orientation") &&
                  (($obj.scale = 0.5), ($obj.y = -300)),
                GLUI.Stage.add($obj);
            } else {
              let shader = _this.initClass(Shader, "ScreenQuad", {
                  tMap: { value: _view },
                }),
                mesh = new Mesh(World.QUAD, shader);
              (mesh.frustumCulled = !1), World.SCENE.add(mesh), (_isRT = !0);
            }
          else
            World.SCENE.add(
              _view.group || _view.mesh || _view.object3D || new Group()
            );
          (function initCameraHelper(nuke) {
            let orbitCamera = new PerspectiveCamera(
              30,
              Stage.width / Stage.height,
              0.1,
              1e3
            );
            orbitCamera.position.z = 6;
            let lastCamera,
              timer0,
              timer1,
              timer2,
              wasdCamera = orbitCamera.clone();
            _this.onResize((_) => {
              (orbitCamera.aspect = wasdCamera.aspect =
                Stage.width / Stage.height),
                orbitCamera.updateProjectionMatrix(),
                wasdCamera.updateProjectionMatrix();
            });
            let orbit = new DebugControls(orbitCamera, World.ELEMENT.div),
              wasd = new WASDControls(wasdCamera, World.ELEMENT.div);
            (orbit.enabled = !1),
              (wasd.enabled = !1),
              _this.startRender((_) => {
                orbit.update(), wasd.update();
              }),
              (_this.orbitControls = orbit),
              (_this.wasdControls = wasd);
            const clearTimers = (_) => {
                clearTimeout(timer0),
                  clearTimeout(timer1),
                  clearTimeout(timer2);
              },
              goToMain = (_) => {
                (orbit.enabled = !1),
                  (wasd.enabled = !1),
                  lastCamera && (nuke.camera = lastCamera),
                  AppState.set("playground_camera_active", !1),
                  clearTimers();
              },
              goToOrbit = (_) => {
                (orbit.enabled = !0),
                  (wasd.enabled = !1),
                  nuke.camera != wasdCamera &&
                    nuke.camera != orbitCamera &&
                    (lastCamera = nuke.camera),
                  (nuke.camera = orbitCamera),
                  AppState.set("playground_camera_active", nuke.camera),
                  (_this.activeControls = orbit),
                  clearTimers();
              },
              goToWASD = (_) => {
                (wasd.enabled = !0),
                  (orbit.enabled = !1),
                  nuke.camera != wasdCamera &&
                    nuke.camera != orbitCamera &&
                    (lastCamera = nuke.camera),
                  (nuke.camera = wasdCamera),
                  AppState.set("playground_camera_active", nuke.camera),
                  (_this.activeControls = wasd),
                  clearTimers();
              };
            Utils.query("orbit") &&
              (goToOrbit(),
              (timer0 = _this.delayedCall(goToOrbit, 500)),
              (timer1 = _this.delayedCall(goToOrbit, 1e3)),
              (timer2 = _this.delayedCall(goToOrbit, 3e3)));
            _this.events.sub(Keyboard.DOWN, (_) => {
              document.activeElement.tagName
                .toLowerCase()
                .includes(["textarea", "input"]) ||
                (Keyboard.pressing.includes("!") && goToMain(),
                Keyboard.pressing.includes("@") && goToOrbit(),
                Keyboard.pressing.includes("#") && goToWASD());
            });
          })(_view.nuke || World.NUKE),
            Dev.expose("view", _view);
        })(),
        defer(window.onresize);
    })();
  }, "singleton"),
  Class(function ButtermaxVFX() {
    Inherit(this, Component);
    const _this = this;
    var _nuke = World.NUKE;
    Tests.useVFX() &&
      (function initVFX() {
        let bloom = _this.initClass(FX.UnrealBloom, _nuke, {
            nMips: Tests.bloomMips(),
            enabled: !0,
            useRTPool: !0,
          }),
          composite = _this.initClass(
            NukePass,
            "ButtermaxVFX",
            Utils.mergeObject(
              {
                uRGBStrength: { value: 0.1 },
                uBloomStrength: { value: 0 },
                uExposure: { value: 1 },
                uPeakColor: { value: new Color("#000000") },
                uVelocity: RootScene.VELOCITY,
                uMouseMove: RootScene.MOUSE_MOVE,
                uRT: { value: null },
              },
              bloom.uniforms
            )
          );
        _nuke.add(composite),
          ShaderUIL.add(composite, null).setLabel("Shader"),
          (_this.shader = composite);
      })(),
      (this.bloomStrength = function (value = 1) {}),
      (_this.updatePeakColor = (color) => {
        Tests.useVFX() && _this.shader.set("uPeakColor", new Color(color));
      });
  }, "singleton"),
  Class(
    function RootScene() {
      Inherit(this, Object3D);
      const _this = this;
      let _curShader,
        _shader,
        _basicShader,
        _scrollShader,
        _fxSceneComp,
        _scrollY = 0;
      function loop() {
        let scrollY = getBusState("scrollY") || 0;
        if (void 0 !== scrollY) {
          _basicShader.uniforms.uBend.value = Math.lerp(
            Math.range(scrollY, 0, -Stage.height, 0, 1),
            _basicShader.uniforms.uBend.value,
            0.1
          );
          let dif = _scrollY - scrollY;
          (dif *= 0.35), Math.abs(dif) > 150 && (dif = 0);
          let velocity = 2 * Math.clamp(dif, -20, 20);
          (RootScene.VELOCITY.value = Math.lerp(
            velocity,
            RootScene.VELOCITY.value,
            0.1
          )),
            (_scrollY = scrollY);
        }
        RootScene.MOUSE_MOVE.value.lerp(Mouse.normal, 0.05);
      }
      World.SCENE.add(_this.group),
        (function initQuad() {
          (_shader = _this.initClass(Shader, "ScreenQuad", "SceneTransition", {
            uTransition: { value: 0 },
            uMousePosition: RootScene.MOUSE_MOVE,
            uMouseMove: RootScene.MOUSE_MOVE,
            uFirst: { value: 0 },
            uZoom: { value: 23 },
            uSize2: { value: -0.1 },
            uBlur: { value: 1 },
          })),
            (_basicShader = _this.initClass(
              Shader,
              "ScreenQuad",
              "BaseSceneShader",
              {
                uMouseMove: { value: new Vector2() },
                uBend: { value: 0 },
                uFirst: { value: 1 },
                uVelocity: RootScene.VELOCITY,
              }
            )),
            (_scrollShader = _this.initClass(
              Shader,
              "ScreenQuad",
              "ScrollSceneTransition",
              {
                uTransition: { value: 0 },
                uMousePosition: RootScene.MOUSE_MOVE,
                uMouseMove: RootScene.MOUSE_MOVE,
                uZoom: { value: 23 },
                uSize2: { value: -0.1 },
                uBlur: { value: 1 },
              }
            )),
            (_fxSceneComp = _this.initClass(FXSceneCompositor, _shader, {
              basicShader: _basicShader,
            })),
            _this.group.add(_fxSceneComp.group),
            _this.events.sub(Mouse.input, Interaction.START, () => {
              _shader.uniforms.uMousePosition.value.copy(Mouse.normal);
            }),
            _this.onResize(() => {
              (_shader.uniforms.uZoom.value =
                Device.mobile ||
                (Device.mobile.tablet && Stage.height > Stage.width)
                  ? 8
                  : 23),
                (_scrollShader.uniforms.uZoom.value =
                  Device.mobile ||
                  (Device.mobile.tablet && Stage.height > Stage.width)
                    ? 8
                    : 23);
            }),
            _this.startRender(loop);
        })(),
        this.get("shader", () => _shader),
        (this.navigate = async function (first = !1) {
          let duration = RootScene.TR_DURATION;
          for (key in (setBusState("transitioning", !0),
          (Global.notFirst = !1),
          first &&
            ((duration *= 1.25),
            (_curShader.uniforms.uMousePosition.value = new Vector2(0.5, 0.5)),
            _shader.set("uFirst", 1),
            _shader.tween("uFirst", 0, duration, "easeInQuint")),
          _curShader.set("uTransition", 0),
          _curShader.set("uBlur", 1),
          _curShader.set("uSize2", 0.35),
          _curShader.tween("uBlur", 1.3, duration, "easeOutCubic"),
          _curShader.tween("uSize2", -0.2, duration, "easeOutCubic"),
          Global.mvs)) {
            Global.mvs[key].visible = !1;
          }
          _this.delayedCall((_) => {
            setBusState("transitioning", !1);
          }, 0.5 * duration),
            _this.delayedCall(() => {
              _basicShader.set("uFirst", 0),
                Global.activeMV && (Global.activeMV.visible = !0);
            }, 16),
            first
              ? await _curShader
                  .tween("uTransition", 1, 1.2 * duration, "easeInOutCubic")
                  .promise()
              : await _curShader
                  .tween("uTransition", 1, duration, "easeInOutCubic")
                  .promise(),
            setBusState("scrollY", 0),
            (Global.FIRST_LOAD = !0);
        }),
        (this.setTo = function (v) {
          _curShader = Global.useScrollShader ? _scrollShader : _shader;
          let from = _basicShader.get("tFrom");
          _fxSceneComp.useShader(_curShader),
            _curShader.set("tFrom", from),
            _curShader.set("tTo", v),
            (Global.useScrollShader = !1);
        });
    },
    (_) => {
      (RootScene.TR_DURATION = 2600),
        (RootScene.VELOCITY = { value: 0 }),
        (RootScene.MOUSE_MOVE = { value: new Vector2() }),
        (RootScene.HOME = { value: 0 });
    }
  ),
  Class(
    function World() {
      Inherit(this, Component);
      const _this = this;
      let _renderer, _scene, _camera, _nuke, _controls;
      function resize() {
        _renderer.setSize(Stage.width, Stage.height),
          (_camera.aspect = Stage.width / Stage.height),
          _camera.updateProjectionMatrix();
      }
      function loop(t, delta) {
        _controls && _controls.enabled && _controls.update(),
          RenderManager.render();
      }
      (World.DPR = Tests.getDPR()),
        (function initWorld() {
          (World.PLANE = new PlaneGeometry(1, 1)),
            (World.WOBBLY_PLANE = new PlaneGeometry(16, 16)),
            (World.QUAD = Utils3D.getQuad()),
            (World.BOX = new BoxGeometry(1, 1, 1)),
            (World.SPHERE = new SphereGeometry(1, 16, 16)),
            (World.GLUI = new GLUIStage());
          let options = { powerPreference: "high-performance" };
          Tests.enableWorldNukeMSAA() &&
            ((options.samplesAmount = Tests.msaaSamples() || void 0),
            (options.multisample = !!options.samplesAmount)),
            RenderManager.initialize(RenderManager.NORMAL, options),
            (_renderer = RenderManager.gl),
            (_scene = RenderManager.scene),
            (_camera = RenderManager.camera.worldCamera),
            (_nuke = RenderManager.nuke),
            (World.SCENE = _scene),
            (World.RENDERER = _renderer),
            (World.ELEMENT = $(_renderer.domElement)),
            (World.CAMERA = _camera),
            ((World.NUKE = _nuke).dpr = RenderManager.DPR),
            Tests.renderFXAA() && _nuke.add(new FXAA());
        })(),
        RenderManager.type == RenderManager.NORMAL &&
          (Camera.instance(_camera), (Render.capFPS = Tests.capFPS())),
        (function initControls() {
          if (!window.DebugControls) return;
          const renderTypeNormal = RenderManager.type === RenderManager.NORMAL;
          if (!Utils.query("orbit")) {
            let camera = new BaseCamera();
            return camera.group.position.set(0, 0, 6), void camera.lock();
          }
          const Controls = Utils.query("wasd") ? WASDControls : DebugControls;
          (_controls = new Controls(_camera, World.ELEMENT.div)),
            renderTypeNormal
              ? (_controls.target = new Vector3(0, 0, 0))
              : (_controls.enabled = !1),
            (World.CONTROLS = _controls),
            (World.CAMERA.position.z = 6);
        })(),
        (function addHandlers() {
          _this.events.sub(Events.RESIZE, resize);
        })(),
        Utils.query("uilOnly") || Render.onDrawFrame(loop);
    },
    function () {
      var _instance;
      World.instance = function () {
        return _instance || (_instance = new World()), _instance;
      };
    }
  ),
  Class(function BaseScene({
    name: name = Utils.query("name") || "base",
    useVFX: useVFX = !1,
    VFX: VFX = "",
    clearColor: clearColor = "#101010",
  } = {}) {
    Inherit(this, FXScene);
    const _this = this;
    let _camera;
    (_this.ready = Promise.create()),
      (_this.gluiStage = World.GLUI),
      (_this.gluiStage3d = null),
      (async function () {
        _this.create(),
          (_this.layout = _this.initClass(SceneLayout, name)),
          (_camera = _this.initClass(GazeCamera)),
          (_camera.moveXY.y = 0.4),
          (_camera.moveXY.x = -1),
          _camera.position.set(0, 0, 6),
          (_camera.lookAt.z = 0.5),
          Global.PLAYGROUND || (await Initializer3D.uploadAll(_this.layout)),
          useVFX &&
            (_this.vfx = _this.initClass(window[VFX], {
              _nuke: _this.nuke,
              _name: name,
            })),
          _this.useCamera(_camera),
          (_this.nuke.postRender = () => {
            _this.gluiStage.renderToRT(_this.gluiStage.scene, _this.rt),
              _this.gluiStage3d &&
                _this.gluiStage3d.renderToRT2(
                  _this.gluiStage3d.scene,
                  _this.rt,
                  _this.nuke.camera
                );
          }),
          (_this.layers = await _this.layout.getAllLayers()),
          (_this.clearColor = new Color(clearColor)),
          await _this.onMounted?.(),
          _this.ready.resolve(),
          Dev.expose("gluiHide", _this.hide),
          Dev.expose("gluiShow", _this.show);
      })(),
      this.get("glui", () => _this.gluiStage),
      this.set("glui", (value) => (_this.gluiStage = value)),
      this.get("gluiScene", () => _this.gluiStage3d),
      this.set("gluiScene", (value) => (_this.gluiStage3d = value)),
      this.get("camera", () => _camera),
      (this.hide = function () {
        _this.onHide?.(),
          console.log(hide),
          _this.gluiStage && (_this.gluiStage.scene.visible = !1),
          _this.gluiStage3d && (_this.gluiStage3d.scene.visible = !1);
      }),
      (this.show = function () {
        _this.onShow?.(),
          _this.gluiStage && (_this.gluiStage.scene.visible = !0),
          _this.gluiStage3d && (_this.gluiStage3d.scene.visible = !0);
      });
  }),
  Class(function Enums() {
    Inherit(this, Component);
    this.PAGES = { LANDING: "landing", INDEX: "index" };
  }, "static"),
  Class(function TestScene() {
    Inherit(this, BaseScene, { name: "home" });
    const _this = this;
    _this.onMounted = () => {
      _this.ready.resolve();
    };
  }),
  Class(function MotionVectorLayout(
    __name = Utils.query("name"),
    __options = {}
  ) {
    Inherit(this, Object3D);
    const _this = this;
    let _checker, _colors, _shader, _useReel;
    var _gluiElement,
      _mouse = new Vector2(),
      _click = new Vector2(),
      _hit = new Vector2(0.5);
    let _maskImagesSet,
      _videoSet,
      _highQuality = !1,
      _motionVectorLayers = [],
      _textures = [];
    function loop() {
      _mouse.copy(Mouse.normal),
        (_mouse.x += 0.1 * Math.sin(0.001 * Render.TIME)),
        (_mouse.x = Math.smoothStep(0.1, 0.9, _mouse.x)),
        _shader.uniforms.uMouse.value.lerp(_mouse, 0.08),
        _shader.uniforms.uInside.value > 0 &&
          (_shader.uniforms.uInside.value -= 0.01 * Render.HZ_MULTIPLIER),
        _useReel &&
          (_shader.set("uRTMask", 1),
          _gluiElement?.element &&
            World.RENDERER.renderSingle(
              _gluiElement.element.mesh,
              Global.scene.camera.camera || World.CAMERA,
              _checker
            ),
          Utils.query("debugHit") &&
            ButtermaxVFX.instance().shader.set("uRT", _checker.texture),
          Math.abs(Mouse.tilt.x) < 0.5 && Math.abs(Mouse.tilt.y) < 0.5
            ? (_this.hovered ||
                (_hit.copy(Mouse.normal),
                (_hit.y = 1 - _hit.y),
                _click.copy(_hit),
                _shader.uniforms.uClickUv.value.copy(_hit),
                (_shader.uniforms.uSmall.value = 0),
                (_shader.uniforms.uClickTime.value = 0),
                (_shader.uniforms.uInside.value = 1)),
              (_this.hovered = !0))
            : (_this.hovered = !1),
          (Global.HIT_VALUE = _shader.uniforms.uClickTime),
          _shader.set("uRTMask", 0));
    }
    function getTexture(path, wait) {
      const texture = Utils3D.getTexture(path);
      return (
        (texture.anisotropy = World.RENDERER.getMaxAnisotropy()),
        texture.upload(),
        texture
      );
    }
    (_this.mvlayers = []),
      (_this.isHovering = !1),
      (async function () {
        (_this.layout = _this.initClass(SceneLayout, `mv_${__name}`)),
          (_this.visible = __options.featured);
        let layers = await _this.layout.getAllLayers();
        Object.keys(layers).forEach((key) => {
          void 0 !== layers[key]?.shader?.uniforms?.tMotion?.value &&
            (_motionVectorLayers.push(layers[key]),
            _this.mvlayers.push(layers[key]));
        }),
          _motionVectorLayers.forEach((layer, key) => {
            _shader = layer.shader;
          }),
          _shader.set("uClickTime", 0),
          (_checker = new RenderTarget(window.innerWidth, window.innerHeight)),
          _this.onResize(() => {
            _checker.setSize(window.innerWidth, window.innerHeight, !0);
          });
        let type = __options.featured
          ? Tests.getMaximumMVQuality()
          : Tests.getMinimumMVQuality();
        (_highQuality = __options.featured),
          await _this.setShaders(type),
          Global.PLAYGROUND
            ? ("testdevice" !== __name &&
                (Utils.query("showReel")
                  ? _this.useVideo()
                  : _this.useImageMask()),
              (_this.visible = !0))
            : __options.featured
            ? await Initializer3D.uploadAll(_this.layout)
            : await Initializer3D.uploadAllAsync(_this.layout),
          _this.useVideo(),
          _this.flag("ready", !0),
          _this.startRender(loop);
      })(),
      _this.set("draw", (draw) => {
        !Global.PLAYGROUND && draw && (_shader.uniforms.tDraw.value = draw.rt);
      }),
      (_this.setShaders = async (type, wait) => {
        let promises = [],
          minQuality = Tests.getMinimumMVQuality(),
          diffuse =
            type === minQuality && _textures[minQuality]?.diffuse
              ? _textures[minQuality]?.diffuse
              : getTexture(
                  `/assets/images/maps/${__name}_diffuse-${type}.png${
                    Utils.query("noktx") ? "" : ".ktx2"
                  }`
                );
        promises.push(diffuse.promise);
        let motion =
          type === minQuality && _textures[minQuality]?.motion
            ? _textures[minQuality]?.motion
            : getTexture(
                `/assets/images/maps/${__name}_mv-${type}.png${
                  Utils.query("noktx") ? "" : ".ktx2"
                }`
              );
        promises.push(motion.promise);
        let data =
          type === minQuality && _textures[minQuality]?.data
            ? _textures[minQuality]?.data
            : getTexture(
                `/assets/images/maps/${__name}_data-${type}.png${
                  Utils.query("noktx") ? "" : ".ktx2"
                }`
              );
        promises.push(data.promise);
        let glass,
          position =
            type === minQuality && _textures[minQuality]?.position
              ? _textures[minQuality]?.position
              : getTexture(
                  `/assets/images/maps/${__name}_position-${type}.png${
                    Utils.query("noktx") ? "" : ".ktx2"
                  }`
                );
        promises.push(position.promise),
          _shader.uniforms.uMaps.value.x > 0 &&
            ((glass =
              type === minQuality && _textures[minQuality]?.glass
                ? _textures[minQuality]?.glass
                : getTexture(
                    `/assets/images/maps/${__name}_glass-${type}.png${
                      Utils.query("noktx") ? "" : ".ktx2"
                    }`
                  )),
            promises.push(glass)),
          await Promise.all(promises).then(async () => {
            type !== Tests.getMaximumMVQuality() &&
              (_textures[Tests.getMinimumMVQuality] ||
                (_textures[Tests.getMinimumMVQuality] = {}),
              (_textures[Tests.getMinimumMVQuality] = {
                diffuse: diffuse,
                motion: motion,
                data: data,
                position: position,
                glass: glass,
              })),
              diffuse.upload(),
              motion.upload(),
              data.upload(),
              position.upload(),
              glass?.upload(),
              getBusState("transitioning") && (await _this.wait(950)),
              (_shader.uniforms.tDiffuse.value = diffuse),
              (_shader.uniforms.tMotion.value = motion),
              (_shader.uniforms.tData.value = data),
              (_shader.uniforms.tPosition.value = position),
              glass && (_shader.uniforms.tGlass.value = glass),
              _colors &&
                (_shader.uniforms.uLightColor.value = new Color(
                  _colors.secondary
                ));
          });
      }),
      (this.useVideo = async (useReel) => {
        if (_this.flag("ready") && 1 !== _shader.uniforms.uUseMask.value) {
          if (
            (Global.FIRST_LOAD &&
              (await _this.wait(100),
              await _this.wait(() => !getBusState("transitioning"))),
            (_shader.uniforms.uUseImagesMask.value = 0),
            (_shader.uniforms.uUseMask.value = 1),
            (_useReel = !0),
            Global.PLAYGROUND)
          ) {
            const tVideo = _this.initClass(VideoTexture, {
              path: "images/reel_desktop.mp4",
            });
            tVideo.start(),
              (Global.video = tVideo),
              $(tVideo.video.div).css({
                position: "fixed",
                top: 0,
                left: 0,
                backgroundSize: "cover",
              });
            let vt = null;
            await _this.wait(
              () => (
                (vt = Stage.div.querySelector(".VideoTextures")), null !== vt
              )
            ),
              $(vt).css({ zIndex: 0 }),
              await _this.wait(250),
              tVideo.stop();
          }
          _videoSet ||
            ((_videoSet = !0),
            Global.video?.texture &&
              (_shader.uniforms.tReel.value = Global.video?.texture),
            subBusState("video", async (t) => {
              Global.FIRST_LOAD &&
                (await _this.wait(() => !getBusState("transitioning"))),
                (_shader.uniforms.tReel.value = Global.video?.texture);
            }));
        }
      }),
      (this.useImageMask = () => {
        _this.flag("ready") &&
          ((_useReel = !1),
          (_shader.uniforms.uUseImagesMask.value = 1),
          (_shader.uniforms.uUseMask.value = 0),
          _maskImagesSet ||
            ((_maskImagesSet = !0),
            (_shader.uniforms.tImage1.value = getTexture(
              `/assets/images/maps/${__name}_mask-0.png${
                Utils.query("noktx") ? "" : ".ktx2"
              }`
            )),
            (_shader.uniforms.tImage2.value = getTexture(
              `/assets/images/maps/${__name}_mask-1.png${
                Utils.query("noktx") ? "" : ".ktx2"
              }`
            ))));
      }),
      this.get("shader", () => _shader),
      this.get("name", () => __name),
      this.get("highQuality", () => _highQuality),
      this.set("colors", (v) => (_colors = v)),
      this.set("gluiElement", (v) => (_gluiElement = v)),
      (this.addInteraction = async (inView) => {
        _this.flag("ready") &&
          (await _this.wait(() => void 0 !== Global.scene.camera),
          Interaction3D.find(Global.scene.camera || World.CAMERA).add(
            _gluiElement.element.mesh,
            (e) => {
              _this.isHovering = !!Tests.useMVHover() && "over" === e.action;
            },
            () => {},
            (e) => {
              _hit = e.hit.uv;
            }
          ));
      }),
      (this.loadHighRes = () => {
        if (!_this.flag("ready")) return;
        let type = Tests.getMaximumMVQuality();
        (_highQuality = !0), _this.setShaders(type, !0);
      }),
      (this.loadSwapToLowRes = () => {});
  }),
  Class(function MotionVectorShader(_mesh, _shader, _group, _input) {
    Inherit(this, Component);
    new Vector2();
    function getTexture(path) {
      const texture = Utils3D.getRepeatTexture(path);
      return (texture.minFilter = texture.magFilter = Texture.LINEAR), texture;
    }
    !(function () {
      const textureNoise = Utils3D.getRepeatTexture(
        "/assets/images/noise_rgb.png"
      );
      (textureNoise.anisotropy = World.RENDERER.getMaxAnisotropy()),
        _shader.addUniforms({
          tMap: { value: null, getTexture: getTexture, ignoreUIL: !0 },
          tDraw: { value: null, getTexture: getTexture, ignoreUIL: !0 },
          tMotion: { value: null, getTexture: getTexture, ignoreUIL: !0 },
          tPosition: { value: null, getTexture: getTexture, ignoreUIL: !0 },
          tDiffuse: { value: null, getTexture: getTexture, ignoreUIL: !0 },
          tData: { value: null, getTexture: getTexture, ignoreUIL: !0 },
          tReel: { value: null, getTexture: getTexture, ignoreUIL: !0 },
          tGlass: { value: null, getTexture: getTexture, ignoreUIL: !0 },
          tNoise: { value: textureNoise },
          uTransition: { value: 0 },
          uStrengthColor: { value: 0.35 },
          uStrengthNoise: { value: 1.01 },
          uStrengthSoftBody: { value: 0.01 },
          uSmall: { value: 0 },
          uStrengthDraw: { value: 0.01 },
          uStrength: { value: 1 },
          uTransitionSmooth: { value: 0.5 },
          uTransitionThreshold: { value: 0.2 },
          uColumns: { value: 4 },
          uRows: { value: 4 },
          uDisplacementStrength: { value: 0.7 },
          uTransitionColor: { value: new Color() },
          uColor: { value: new Color() },
          uMouse: { value: new Vector2(0, 0) },
          uLightColor: { value: new Color("#fed602") },
          uLightColorStr: { value: 0 },
          uMaps: { value: new Vector3() },
          uRandom: { value: Math.random(0, 1e3) },
          uDepthY: { value: -0.4 },
          uClickTime: { value: 1e6, ignoreUIL: !0 },
          uInside: { value: 0, ignoreUIL: !0 },
          uClickUv: { value: new Vector2(0.5, 0.5) },
          uPositionScale: { value: new Vector3(1, 1, 1) },
          uPositionOffset: { value: new Vector3() },
          uUseMask: { value: 0 },
          uLOD: { value: 5 },
          glass_uGridSize: { value: 8 },
          glass_uDisplacementStrength: { value: 0.01 },
          glass_uStrength: { value: 2.2 },
          tImage1: {
            value: null,
            getTexture: Utils3D.getTexture,
            ignoreUIL: !0,
          },
          tImage2: {
            value: null,
            getTexture: Utils3D.getTexture,
            ignoreUIL: !0,
          },
          uUseImagesMask: { value: 0 },
          uPositionScaleImage: { value: new Vector3(1, 1, 1) },
          uPositionOffsetImage: { value: new Vector3() },
          uRTMask: { value: 0, ignoreUIL: !0 },
          uVelocity: RootScene.VELOCITY,
        });
    })(),
      this.startRender((_) => {
        _shader.uniforms.uClickTime.value += Render.DELTA / 1200;
      });
  }),
  Class(function Spritesheet() {
    Inherit(this, FXScene);
    const _this = this;
    !(async function () {
      _this.create();
      let layout = _this.initClass(SpritesheetLayout);
      await layout.ready,
        _this.scene.add(layout.group),
        _this.setSize(512, 512, !0),
        (_this.ready = !0);
    })(),
      (_this.isReady = (_) => _this.wait("ready"));
  }),
  Class(function SpritesheetLayout(
    __name = Utils.query("name") || "reel",
    __draw,
    __options = {}
  ) {
    Inherit(this, Object3D);
    const _this = this;
    (_this.mvlayers = []),
      (async function () {
        _this.layout = _this.initClass(SceneLayout, `spritesheet_${__name}`);
        await _this.layout.getAllLayers();
      })(),
      this.get("shader", () => {});
  }),
  Class(function SpritesheetShader(_mesh, _shader, _group, _input) {
    Inherit(this, Component);
    function getTexture(path) {
      const texture = Utils3D.getTexture(path);
      return (texture.minFilter = texture.magFilter = Texture.LINEAR), texture;
    }
    !(function () {
      const texture = Utils3D.getTexture("/assets/spritesheet/reel.png.ktx2");
      _shader.addUniforms({ tMap: { value: texture, getTexture: getTexture } });
    })();
  }),
  Class(function VideoShaderScreen(_mesh, _shader, _group, _input) {
    Inherit(this, Component);
    _shader.addUniforms({
      tMap: { value: null },
      uBrightness: { value: 1 },
      uPow: { value: 1 },
      pixelCoverage: { value: new Vector2(70, 0.45) },
    }),
      Tests.useFluids() && MouseFluid.instance().applyTo(_shader);
  }),
  Class(function App() {
    const _this = this;
    Inherit(_this, Component),
      Inherit(_this, XComponent),
      (_this.fragName = "App"),
      (_this.contexts = "Component"),
      (this.isFragment = !0);
    var _promises = [];
    !(async function () {
      _this.element &&
        (_this.element.onMountedHook = (_) => _this.onMounted?.()),
        _this.parent?.layers && (_this.layers = _this.parent.layers),
        _this.layout?.getAllLayers &&
          (_this.layers = await _this.layout.getAllLayers());
      for (let key in _this)
        if (_this[key]?.then) {
          let store = _this[key];
          store.then((val) => (_this[key] = val)), _promises.push(store);
        }
      _promises.length && (await Promise.all(_promises)),
        (_this.loaderData = { fragment: "LoaderView", assets: "shaders, uil" }),
        (_this.entryPointData = "ViewController"),
        (_promises = null),
        _this.flag?.("__ready", !0),
        _this.onInit?.();
    })();
  }),
  Class(function ViewController(_params, ...restArgs) {
    const _this = this;
    Inherit(_this, Element),
      Inherit(_this, XComponent),
      (_this.fragName = "ViewController"),
      (_this.contexts = "Element"),
      (_this.params = _params),
      (_this.args = arguments),
      (this.isFragment = !0);
    var _promises = [];
    !(async function () {
      _this.element &&
        (_this.element.onMountedHook = (_) => _this.onMounted?.()),
        (_this.params = _params),
        (_this.args = arguments),
        _this.parent?.layers && (_this.layers = _this.parent.layers),
        _this.layout?.getAllLayers &&
          (_this.layers = await _this.layout.getAllLayers());
      for (let key in _this)
        if (_this[key]?.then) {
          let store = _this[key];
          store.then((val) => (_this[key] = val)), _promises.push(store);
        }
      _promises.length && (await Promise.all(_promises)),
        (_promises = null),
        _this.flag?.("__ready", !0),
        _this.onInit?.();
    })();
  }),
  Class(function Main() {
    !(function () {
      if (Utils.query("performance")) return Performance.displayResults();
      !(async function init() {
        window._PROJECT_NAME_ &&
          ((Dev.pathName = `/${window._PROJECT_NAME_}/HTML/`),
          (Dev.filesPath = Dev.pathName));
        if (
          (await AssetLoader.waitForLib("hydraNextBus"),
          (UnsupportedRedirect.requiresWebGL = !0),
          UnsupportedRedirect.unsupported())
        )
          return void window.location.replace(window._UNSUPPORTED_PAGE_);
        if ((GLUI.init(), Hydra.LOCAL && window.location.search.includes("p=")))
          return AssetLoader.loadAssets(
            Assets.list().filter(["uil", "shaders"])
          ).then(Playground.instance);
        Container.instance();
      })();
    })();
  });
window._MINIFIED_ = true;
window._BUILT_ = true;
